/**
 * Client
 **/

import * as runtime from "./runtime/library.js";
import $Types = runtime.Types; // general types
import $Public = runtime.Types.Public;
import $Utils = runtime.Types.Utils;
import $Extensions = runtime.Types.Extensions;
import $Result = runtime.Types.Result;

export type PrismaPromise<T> = $Public.PrismaPromise<T>;

/**
 * Model User
 *
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>;
/**
 * Model EmailVerificationToken
 *
 */
export type EmailVerificationToken =
  $Result.DefaultSelection<Prisma.$EmailVerificationTokenPayload>;
/**
 * Model Pupil
 *
 */
export type Pupil = $Result.DefaultSelection<Prisma.$PupilPayload>;
/**
 * Model Staff
 *
 */
export type Staff = $Result.DefaultSelection<Prisma.$StaffPayload>;
/**
 * Model Level
 *
 */
export type Level = $Result.DefaultSelection<Prisma.$LevelPayload>;
/**
 * Model Stream
 *
 */
export type Stream = $Result.DefaultSelection<Prisma.$StreamPayload>;
/**
 * Model Class
 *
 */
export type Class = $Result.DefaultSelection<Prisma.$ClassPayload>;
/**
 * Model AcademicYear
 *
 */
export type AcademicYear =
  $Result.DefaultSelection<Prisma.$AcademicYearPayload>;
/**
 * Model AcademicYearClass
 *
 */
export type AcademicYearClass =
  $Result.DefaultSelection<Prisma.$AcademicYearClassPayload>;
/**
 * Model Subject
 *
 */
export type Subject = $Result.DefaultSelection<Prisma.$SubjectPayload>;
/**
 * Model Grading
 *
 */
export type Grading = $Result.DefaultSelection<Prisma.$GradingPayload>;
/**
 * Model AcademicYearSubject
 *
 */
export type AcademicYearSubject =
  $Result.DefaultSelection<Prisma.$AcademicYearSubjectPayload>;
/**
 * Model classStream
 *
 */
export type classStream = $Result.DefaultSelection<Prisma.$classStreamPayload>;
/**
 * Model Term
 *
 */
export type Term = $Result.DefaultSelection<Prisma.$TermPayload>;
/**
 * Model ClassTerm
 *
 */
export type ClassTerm = $Result.DefaultSelection<Prisma.$ClassTermPayload>;
/**
 * Model Fees
 *
 */
export type Fees = $Result.DefaultSelection<Prisma.$FeesPayload>;
/**
 * Model FeesPayment
 *
 */
export type FeesPayment = $Result.DefaultSelection<Prisma.$FeesPaymentPayload>;
/**
 * Model Session
 *
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>;
/**
 * Model Asset
 *
 */
export type Asset = $Result.DefaultSelection<Prisma.$AssetPayload>;
/**
 * Model FoodStoreItem
 *
 */
export type FoodStoreItem =
  $Result.DefaultSelection<Prisma.$FoodStoreItemPayload>;
/**
 * Model IndividualFoodStoreItem
 *
 */
export type IndividualFoodStoreItem =
  $Result.DefaultSelection<Prisma.$IndividualFoodStoreItemPayload>;
/**
 * Model FoodConsumption
 *
 */
export type FoodConsumption =
  $Result.DefaultSelection<Prisma.$FoodConsumptionPayload>;
/**
 * Model Supplier
 *
 */
export type Supplier = $Result.DefaultSelection<Prisma.$SupplierPayload>;
/**
 * Model LibraryBook
 *
 */
export type LibraryBook = $Result.DefaultSelection<Prisma.$LibraryBookPayload>;
/**
 * Model IndividualBook
 *
 */
export type IndividualBook =
  $Result.DefaultSelection<Prisma.$IndividualBookPayload>;
/**
 * Model LibraryBookCategory
 *
 */
export type LibraryBookCategory =
  $Result.DefaultSelection<Prisma.$LibraryBookCategoryPayload>;
/**
 * Model Borrower
 *
 */
export type Borrower = $Result.DefaultSelection<Prisma.$BorrowerPayload>;
/**
 * Model LabItem
 *
 */
export type LabItem = $Result.DefaultSelection<Prisma.$LabItemPayload>;
/**
 * Model IndividualLabItem
 *
 */
export type IndividualLabItem =
  $Result.DefaultSelection<Prisma.$IndividualLabItemPayload>;
/**
 * Model ComputerLabItem
 *
 */
export type ComputerLabItem =
  $Result.DefaultSelection<Prisma.$ComputerLabItemPayload>;
/**
 * Model IndividualComputerLabItem
 *
 */
export type IndividualComputerLabItem =
  $Result.DefaultSelection<Prisma.$IndividualComputerLabItemPayload>;
/**
 * Model GeneralStoreItem
 *
 */
export type GeneralStoreItem =
  $Result.DefaultSelection<Prisma.$GeneralStoreItemPayload>;
/**
 * Model IndividualGeneralStoreItem
 *
 */
export type IndividualGeneralStoreItem =
  $Result.DefaultSelection<Prisma.$IndividualGeneralStoreItemPayload>;
/**
 * Model AssetDamage
 *
 */
export type AssetDamage = $Result.DefaultSelection<Prisma.$AssetDamagePayload>;
/**
 * Model AssetRepairPayment
 *
 */
export type AssetRepairPayment =
  $Result.DefaultSelection<Prisma.$AssetRepairPaymentPayload>;
/**
 * Model ExamScore
 *
 */
export type ExamScore = $Result.DefaultSelection<Prisma.$ExamScorePayload>;
/**
 * Model Exam
 *
 */
export type Exam = $Result.DefaultSelection<Prisma.$ExamPayload>;
/**
 * Model ExamSubject
 *
 */
export type ExamSubject = $Result.DefaultSelection<Prisma.$ExamSubjectPayload>;

/**
 * Enums
 */
export namespace $Enums {
  export const ExamType: {
    ASSESSMENT: "ASSESSMENT";
    TEST: "TEST";
    EXERCISE: "EXERCISE";
    MOCK: "MOCK";
    EXAM: "EXAM";
  };

  export type ExamType = (typeof ExamType)[keyof typeof ExamType];

  export const StaffType: {
    TEACHING_STAFF: "TEACHING_STAFF";
    NON_TEACHING_STAFF: "NON_TEACHING_STAFF";
  };

  export type StaffType = (typeof StaffType)[keyof typeof StaffType];

  export const FeesStatus: {
    COMPLETED: "COMPLETED";
    PENDING: "PENDING";
    NILL: "NILL";
  };

  export type FeesStatus = (typeof FeesStatus)[keyof typeof FeesStatus];

  export const Role: {
    SUPER_ADMIN: "SUPER_ADMIN";
    DIRECTOR: "DIRECTOR";
    BURSAR: "BURSAR";
    ASSET_CARETAKER: "ASSET_CARETAKER";
    GENERAL_STORE_ASSET_CARETAKER: "GENERAL_STORE_ASSET_CARETAKER";
    COMPUTER_LAB_ASSET_CARETAKER: "COMPUTER_LAB_ASSET_CARETAKER";
    LABORATORY_ASSET_CARETAKER: "LABORATORY_ASSET_CARETAKER";
    LIBRARY_ASSET_CARETAKER: "LIBRARY_ASSET_CARETAKER";
    FOOD_STORE_ASSET_CARETAKER: "FOOD_STORE_ASSET_CARETAKER";
    STAFF: "STAFF";
    CLASS_TEACHER: "CLASS_TEACHER";
    USER: "USER";
  };

  export type Role = (typeof Role)[keyof typeof Role];

  export const AssetCategory: {
    LIBRARY: "LIBRARY";
    COMPUTER_LAB: "COMPUTER_LAB";
    LABORATORY: "LABORATORY";
    GENERAL_STORE: "GENERAL_STORE";
    FOOD_STORE: "FOOD_STORE";
  };

  export type AssetCategory =
    (typeof AssetCategory)[keyof typeof AssetCategory];

  export const AssetCondition: {
    NEW: "NEW";
    GOOD: "GOOD";
    FAIR: "FAIR";
    POOR: "POOR";
    DAMAGED: "DAMAGED";
  };

  export type AssetCondition =
    (typeof AssetCondition)[keyof typeof AssetCondition];

  export const AssetStatus: {
    AVAILABLE: "AVAILABLE";
    ASSIGNED: "ASSIGNED";
    UNDER_MAINTENANCE: "UNDER_MAINTENANCE";
    DISPOSED: "DISPOSED";
  };

  export type AssetStatus = (typeof AssetStatus)[keyof typeof AssetStatus];

  export const AssetUnit: {
    KILOGRAM: "KILOGRAM";
    GRAMS: "GRAMS";
    PACKETS: "PACKETS";
    SAC: "SAC";
    LITER: "LITER";
    PIECE: "PIECE";
    PAIR: "PAIR";
    JERRICAN: "JERRICAN";
    CONTAINER: "CONTAINER";
    OTHERS: "OTHERS";
  };

  export type AssetUnit = (typeof AssetUnit)[keyof typeof AssetUnit];

  export const BorrowStatus: {
    ONGOING: "ONGOING";
    RETURNED: "RETURNED";
  };

  export type BorrowStatus = (typeof BorrowStatus)[keyof typeof BorrowStatus];

  export const BookStatus: {
    AVAILABLE: "AVAILABLE";
    BORROWED: "BORROWED";
    DAMAGED: "DAMAGED";
  };

  export type BookStatus = (typeof BookStatus)[keyof typeof BookStatus];

  export const AssetItemStatus: {
    AVAILABLE: "AVAILABLE";
    IN_USE: "IN_USE";
    EXPIRED: "EXPIRED";
  };

  export type AssetItemStatus =
    (typeof AssetItemStatus)[keyof typeof AssetItemStatus];
}

export type ExamType = $Enums.ExamType;

export const ExamType: typeof $Enums.ExamType;

export type StaffType = $Enums.StaffType;

export const StaffType: typeof $Enums.StaffType;

export type FeesStatus = $Enums.FeesStatus;

export const FeesStatus: typeof $Enums.FeesStatus;

export type Role = $Enums.Role;

export const Role: typeof $Enums.Role;

export type AssetCategory = $Enums.AssetCategory;

export const AssetCategory: typeof $Enums.AssetCategory;

export type AssetCondition = $Enums.AssetCondition;

export const AssetCondition: typeof $Enums.AssetCondition;

export type AssetStatus = $Enums.AssetStatus;

export const AssetStatus: typeof $Enums.AssetStatus;

export type AssetUnit = $Enums.AssetUnit;

export const AssetUnit: typeof $Enums.AssetUnit;

export type BorrowStatus = $Enums.BorrowStatus;

export const BorrowStatus: typeof $Enums.BorrowStatus;

export type BookStatus = $Enums.BookStatus;

export const BookStatus: typeof $Enums.BookStatus;

export type AssetItemStatus = $Enums.AssetItemStatus;

export const AssetItemStatus: typeof $Enums.AssetItemStatus;

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = "log" extends keyof ClientOptions
    ? ClientOptions["log"] extends Array<Prisma.LogLevel | Prisma.LogDefinition>
      ? Prisma.GetEvents<ClientOptions["log"]>
      : never
    : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>["other"] };

  /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(
    optionsArg?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>,
  );
  $on<V extends U>(
    eventType: V,
    callback: (
      event: V extends "query" ? Prisma.QueryEvent : Prisma.LogEvent,
    ) => void,
  ): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void;

  /**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(
    query: TemplateStringsArray | Prisma.Sql,
    ...values: any[]
  ): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(
    query: string,
    ...values: any[]
  ): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(
    query: TemplateStringsArray | Prisma.Sql,
    ...values: any[]
  ): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(
    query: string,
    ...values: any[]
  ): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(
    arg: [...P],
    options?: { isolationLevel?: Prisma.TransactionIsolationLevel },
  ): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>;

  $transaction<R>(
    fn: (
      prisma: Omit<PrismaClient, runtime.ITXClientDenyList>,
    ) => $Utils.JsPromise<R>,
    options?: {
      maxWait?: number;
      timeout?: number;
      isolationLevel?: Prisma.TransactionIsolationLevel;
    },
  ): $Utils.JsPromise<R>;

  $extends: $Extensions.ExtendsHook<
    "extends",
    Prisma.TypeMapCb<ClientOptions>,
    ExtArgs,
    $Utils.Call<
      Prisma.TypeMapCb<ClientOptions>,
      {
        extArgs: ExtArgs;
      }
    >
  >;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.emailVerificationToken`: Exposes CRUD operations for the **EmailVerificationToken** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more EmailVerificationTokens
   * const emailVerificationTokens = await prisma.emailVerificationToken.findMany()
   * ```
   */
  get emailVerificationToken(): Prisma.EmailVerificationTokenDelegate<
    ExtArgs,
    ClientOptions
  >;

  /**
   * `prisma.pupil`: Exposes CRUD operations for the **Pupil** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Pupils
   * const pupils = await prisma.pupil.findMany()
   * ```
   */
  get pupil(): Prisma.PupilDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.staff`: Exposes CRUD operations for the **Staff** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Staff
   * const staff = await prisma.staff.findMany()
   * ```
   */
  get staff(): Prisma.StaffDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.level`: Exposes CRUD operations for the **Level** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Levels
   * const levels = await prisma.level.findMany()
   * ```
   */
  get level(): Prisma.LevelDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.stream`: Exposes CRUD operations for the **Stream** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Streams
   * const streams = await prisma.stream.findMany()
   * ```
   */
  get stream(): Prisma.StreamDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.class`: Exposes CRUD operations for the **Class** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Classes
   * const classes = await prisma.class.findMany()
   * ```
   */
  get class(): Prisma.ClassDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.academicYear`: Exposes CRUD operations for the **AcademicYear** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more AcademicYears
   * const academicYears = await prisma.academicYear.findMany()
   * ```
   */
  get academicYear(): Prisma.AcademicYearDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.academicYearClass`: Exposes CRUD operations for the **AcademicYearClass** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more AcademicYearClasses
   * const academicYearClasses = await prisma.academicYearClass.findMany()
   * ```
   */
  get academicYearClass(): Prisma.AcademicYearClassDelegate<
    ExtArgs,
    ClientOptions
  >;

  /**
   * `prisma.subject`: Exposes CRUD operations for the **Subject** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Subjects
   * const subjects = await prisma.subject.findMany()
   * ```
   */
  get subject(): Prisma.SubjectDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.grading`: Exposes CRUD operations for the **Grading** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Gradings
   * const gradings = await prisma.grading.findMany()
   * ```
   */
  get grading(): Prisma.GradingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.academicYearSubject`: Exposes CRUD operations for the **AcademicYearSubject** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more AcademicYearSubjects
   * const academicYearSubjects = await prisma.academicYearSubject.findMany()
   * ```
   */
  get academicYearSubject(): Prisma.AcademicYearSubjectDelegate<
    ExtArgs,
    ClientOptions
  >;

  /**
   * `prisma.classStream`: Exposes CRUD operations for the **classStream** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more ClassStreams
   * const classStreams = await prisma.classStream.findMany()
   * ```
   */
  get classStream(): Prisma.classStreamDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.term`: Exposes CRUD operations for the **Term** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Terms
   * const terms = await prisma.term.findMany()
   * ```
   */
  get term(): Prisma.TermDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.classTerm`: Exposes CRUD operations for the **ClassTerm** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more ClassTerms
   * const classTerms = await prisma.classTerm.findMany()
   * ```
   */
  get classTerm(): Prisma.ClassTermDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fees`: Exposes CRUD operations for the **Fees** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Fees
   * const fees = await prisma.fees.findMany()
   * ```
   */
  get fees(): Prisma.FeesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.feesPayment`: Exposes CRUD operations for the **FeesPayment** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more FeesPayments
   * const feesPayments = await prisma.feesPayment.findMany()
   * ```
   */
  get feesPayment(): Prisma.FeesPaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Sessions
   * const sessions = await prisma.session.findMany()
   * ```
   */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.asset`: Exposes CRUD operations for the **Asset** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Assets
   * const assets = await prisma.asset.findMany()
   * ```
   */
  get asset(): Prisma.AssetDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.foodStoreItem`: Exposes CRUD operations for the **FoodStoreItem** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more FoodStoreItems
   * const foodStoreItems = await prisma.foodStoreItem.findMany()
   * ```
   */
  get foodStoreItem(): Prisma.FoodStoreItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.individualFoodStoreItem`: Exposes CRUD operations for the **IndividualFoodStoreItem** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more IndividualFoodStoreItems
   * const individualFoodStoreItems = await prisma.individualFoodStoreItem.findMany()
   * ```
   */
  get individualFoodStoreItem(): Prisma.IndividualFoodStoreItemDelegate<
    ExtArgs,
    ClientOptions
  >;

  /**
   * `prisma.foodConsumption`: Exposes CRUD operations for the **FoodConsumption** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more FoodConsumptions
   * const foodConsumptions = await prisma.foodConsumption.findMany()
   * ```
   */
  get foodConsumption(): Prisma.FoodConsumptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.supplier`: Exposes CRUD operations for the **Supplier** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Suppliers
   * const suppliers = await prisma.supplier.findMany()
   * ```
   */
  get supplier(): Prisma.SupplierDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.libraryBook`: Exposes CRUD operations for the **LibraryBook** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more LibraryBooks
   * const libraryBooks = await prisma.libraryBook.findMany()
   * ```
   */
  get libraryBook(): Prisma.LibraryBookDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.individualBook`: Exposes CRUD operations for the **IndividualBook** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more IndividualBooks
   * const individualBooks = await prisma.individualBook.findMany()
   * ```
   */
  get individualBook(): Prisma.IndividualBookDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.libraryBookCategory`: Exposes CRUD operations for the **LibraryBookCategory** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more LibraryBookCategories
   * const libraryBookCategories = await prisma.libraryBookCategory.findMany()
   * ```
   */
  get libraryBookCategory(): Prisma.LibraryBookCategoryDelegate<
    ExtArgs,
    ClientOptions
  >;

  /**
   * `prisma.borrower`: Exposes CRUD operations for the **Borrower** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Borrowers
   * const borrowers = await prisma.borrower.findMany()
   * ```
   */
  get borrower(): Prisma.BorrowerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.labItem`: Exposes CRUD operations for the **LabItem** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more LabItems
   * const labItems = await prisma.labItem.findMany()
   * ```
   */
  get labItem(): Prisma.LabItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.individualLabItem`: Exposes CRUD operations for the **IndividualLabItem** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more IndividualLabItems
   * const individualLabItems = await prisma.individualLabItem.findMany()
   * ```
   */
  get individualLabItem(): Prisma.IndividualLabItemDelegate<
    ExtArgs,
    ClientOptions
  >;

  /**
   * `prisma.computerLabItem`: Exposes CRUD operations for the **ComputerLabItem** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more ComputerLabItems
   * const computerLabItems = await prisma.computerLabItem.findMany()
   * ```
   */
  get computerLabItem(): Prisma.ComputerLabItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.individualComputerLabItem`: Exposes CRUD operations for the **IndividualComputerLabItem** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more IndividualComputerLabItems
   * const individualComputerLabItems = await prisma.individualComputerLabItem.findMany()
   * ```
   */
  get individualComputerLabItem(): Prisma.IndividualComputerLabItemDelegate<
    ExtArgs,
    ClientOptions
  >;

  /**
   * `prisma.generalStoreItem`: Exposes CRUD operations for the **GeneralStoreItem** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more GeneralStoreItems
   * const generalStoreItems = await prisma.generalStoreItem.findMany()
   * ```
   */
  get generalStoreItem(): Prisma.GeneralStoreItemDelegate<
    ExtArgs,
    ClientOptions
  >;

  /**
   * `prisma.individualGeneralStoreItem`: Exposes CRUD operations for the **IndividualGeneralStoreItem** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more IndividualGeneralStoreItems
   * const individualGeneralStoreItems = await prisma.individualGeneralStoreItem.findMany()
   * ```
   */
  get individualGeneralStoreItem(): Prisma.IndividualGeneralStoreItemDelegate<
    ExtArgs,
    ClientOptions
  >;

  /**
   * `prisma.assetDamage`: Exposes CRUD operations for the **AssetDamage** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more AssetDamages
   * const assetDamages = await prisma.assetDamage.findMany()
   * ```
   */
  get assetDamage(): Prisma.AssetDamageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.assetRepairPayment`: Exposes CRUD operations for the **AssetRepairPayment** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more AssetRepairPayments
   * const assetRepairPayments = await prisma.assetRepairPayment.findMany()
   * ```
   */
  get assetRepairPayment(): Prisma.AssetRepairPaymentDelegate<
    ExtArgs,
    ClientOptions
  >;

  /**
   * `prisma.examScore`: Exposes CRUD operations for the **ExamScore** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more ExamScores
   * const examScores = await prisma.examScore.findMany()
   * ```
   */
  get examScore(): Prisma.ExamScoreDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.exam`: Exposes CRUD operations for the **Exam** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Exams
   * const exams = await prisma.exam.findMany()
   * ```
   */
  get exam(): Prisma.ExamDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.examSubject`: Exposes CRUD operations for the **ExamSubject** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more ExamSubjects
   * const examSubjects = await prisma.examSubject.findMany()
   * ```
   */
  get examSubject(): Prisma.ExamSubjectDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF;

  export type PrismaPromise<T> = $Public.PrismaPromise<T>;

  /**
   * Validator
   */
  export import validator = runtime.Public.validator;

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError;
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError;
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError;
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError;
  export import PrismaClientValidationError = runtime.PrismaClientValidationError;

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag;
  export import empty = runtime.empty;
  export import join = runtime.join;
  export import raw = runtime.raw;
  export import Sql = runtime.Sql;

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal;

  export type DecimalJsLike = runtime.DecimalJsLike;

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics;
  export type Metric<T> = runtime.Metric<T>;
  export type MetricHistogram = runtime.MetricHistogram;
  export type MetricHistogramBucket = runtime.MetricHistogramBucket;

  /**
   * Extensions
   */
  export import Extension = $Extensions.UserArgs;
  export import getExtensionContext = runtime.Extensions.getExtensionContext;
  export import Args = $Public.Args;
  export import Payload = $Public.Payload;
  export import Result = $Public.Result;
  export import Exact = $Public.Exact;

  /**
   * Prisma Client JS version: 6.7.0
   * Query Engine version: 3cff47a7f5d65c3ea74883f1d736e41d68ce91ed
   */
  export type PrismaVersion = {
    client: string;
  };

  export const prismaVersion: PrismaVersion;

  /**
   * Utility Types
   */

  export import JsonObject = runtime.JsonObject;
  export import JsonArray = runtime.JsonArray;
  export import JsonValue = runtime.JsonValue;
  export import InputJsonObject = runtime.InputJsonObject;
  export import InputJsonArray = runtime.InputJsonArray;
  export import InputJsonValue = runtime.InputJsonValue;

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
     * Type of `Prisma.DbNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class DbNull {
      private DbNull: never;
      private constructor();
    }

    /**
     * Type of `Prisma.JsonNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class JsonNull {
      private JsonNull: never;
      private constructor();
    }

    /**
     * Type of `Prisma.AnyNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class AnyNull {
      private AnyNull: never;
      private constructor();
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull;

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull;

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull;

  type SelectAndInclude = {
    select: any;
    include: any;
  };

  type SelectAndOmit = {
    select: any;
    omit: any;
  };

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> =
    T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<
    T extends (...args: any) => $Utils.JsPromise<any>,
  > = PromiseType<ReturnType<T>>;

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
    [P in K]: T[P];
  };

  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K;
  }[keyof T];

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K;
  };

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>;

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  } & (T extends SelectAndInclude
    ? "Please either choose `select` or `include`."
    : T extends SelectAndOmit
      ? "Please either choose `select` or `omit`."
      : {});

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  } & K;

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> = T extends object
    ? U extends object
      ? (Without<T, U> & U) | (Without<U, T> & T)
      : U
    : T;

  /**
   * Is T a Record?
   */
  type IsObject<T extends any> =
    T extends Array<any>
      ? False
      : T extends Date
        ? False
        : T extends Uint8Array
          ? False
          : T extends BigInt
            ? False
            : T extends object
              ? True
              : False;

  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T;

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O>; // With K possibilities
    }[K];

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>;

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<
    __Either<O, K>
  >;

  type _Either<O extends object, K extends Key, strict extends Boolean> = {
    1: EitherStrict<O, K>;
    0: EitherLoose<O, K>;
  }[strict];

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1,
  > = O extends unknown ? _Either<O, K, strict> : never;

  export type Union = any;

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K];
  } & {};

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never;

  export type Overwrite<O extends object, O1 extends object> = {
    [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<
    Overwrite<
      U,
      {
        [K in keyof U]-?: At<U, K>;
      }
    >
  >;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O
    ? O[K]
    : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown
    ? AtStrict<O, K>
    : never;
  export type At<
    O extends object,
    K extends Key,
    strict extends Boolean = 1,
  > = {
    1: AtStrict<O, K>;
    0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function
    ? A
    : {
        [K in keyof A]: A[K];
      } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
      ?
          | (K extends keyof O ? { [P in K]: O[P] } & O : O)
          | ({ [P in keyof O as P extends K ? P : never]-?: O[P] } & O)
      : never
  >;

  type _Strict<U, _U = U> = U extends unknown
    ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>>
    : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False;

  // /**
  // 1
  // */
  export type True = 1;

  /**
  0
  */
  export type False = 0;

  export type Not<B extends Boolean> = {
    0: 1;
    1: 0;
  }[B];

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
      ? 1
      : 0;

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >;

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0;
      1: 1;
    };
    1: {
      0: 1;
      1: 1;
    };
  }[B1][B2];

  export type Keys<U extends Union> = U extends unknown ? keyof U : never;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object
    ? {
        [P in keyof T]: P extends keyof O ? O[P] : never;
      }
    : never;

  type FieldPaths<
    T,
    U = Omit<T, "_avg" | "_sum" | "_count" | "_min" | "_max">,
  > = IsObject<T> extends True ? U : T;

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<"OR", K>, Extends<"AND", K>>,
      Extends<"NOT", K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<
            UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never
          >
        : never
      : {} extends FieldPaths<T[K]>
        ? never
        : K;
  }[keyof T];

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never;
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>;
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T;

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<
    T,
    K extends Enumerable<keyof T> | keyof T,
  > = Prisma__Pick<T, MaybeTupleToUnion<K>>;

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}`
    ? never
    : T;

  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>;

  type FieldRefInputType<Model, FieldType> = Model extends never
    ? never
    : FieldRef<Model, FieldType>;

  export const ModelName: {
    User: "User";
    EmailVerificationToken: "EmailVerificationToken";
    Pupil: "Pupil";
    Staff: "Staff";
    Level: "Level";
    Stream: "Stream";
    Class: "Class";
    AcademicYear: "AcademicYear";
    AcademicYearClass: "AcademicYearClass";
    Subject: "Subject";
    Grading: "Grading";
    AcademicYearSubject: "AcademicYearSubject";
    classStream: "classStream";
    Term: "Term";
    ClassTerm: "ClassTerm";
    Fees: "Fees";
    FeesPayment: "FeesPayment";
    Session: "Session";
    Asset: "Asset";
    FoodStoreItem: "FoodStoreItem";
    IndividualFoodStoreItem: "IndividualFoodStoreItem";
    FoodConsumption: "FoodConsumption";
    Supplier: "Supplier";
    LibraryBook: "LibraryBook";
    IndividualBook: "IndividualBook";
    LibraryBookCategory: "LibraryBookCategory";
    Borrower: "Borrower";
    LabItem: "LabItem";
    IndividualLabItem: "IndividualLabItem";
    ComputerLabItem: "ComputerLabItem";
    IndividualComputerLabItem: "IndividualComputerLabItem";
    GeneralStoreItem: "GeneralStoreItem";
    IndividualGeneralStoreItem: "IndividualGeneralStoreItem";
    AssetDamage: "AssetDamage";
    AssetRepairPayment: "AssetRepairPayment";
    ExamScore: "ExamScore";
    Exam: "Exam";
    ExamSubject: "ExamSubject";
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName];

  export type Datasources = {
    db?: Datasource;
  };

  interface TypeMapCb<ClientOptions = {}>
    extends $Utils.Fn<
      { extArgs: $Extensions.InternalArgs },
      $Utils.Record<string, any>
    > {
    returns: Prisma.TypeMap<
      this["params"]["extArgs"],
      ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}
    >;
  }

  export type TypeMap<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > = {
    globalOmitOptions: {
      omit: GlobalOmitOptions;
    };
    meta: {
      modelProps:
        | "user"
        | "emailVerificationToken"
        | "pupil"
        | "staff"
        | "level"
        | "stream"
        | "class"
        | "academicYear"
        | "academicYearClass"
        | "subject"
        | "grading"
        | "academicYearSubject"
        | "classStream"
        | "term"
        | "classTerm"
        | "fees"
        | "feesPayment"
        | "session"
        | "asset"
        | "foodStoreItem"
        | "individualFoodStoreItem"
        | "foodConsumption"
        | "supplier"
        | "libraryBook"
        | "individualBook"
        | "libraryBookCategory"
        | "borrower"
        | "labItem"
        | "individualLabItem"
        | "computerLabItem"
        | "individualComputerLabItem"
        | "generalStoreItem"
        | "individualGeneralStoreItem"
        | "assetDamage"
        | "assetRepairPayment"
        | "examScore"
        | "exam"
        | "examSubject";
      txIsolationLevel: Prisma.TransactionIsolationLevel;
    };
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>;
        fields: Prisma.UserFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[];
          };
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[];
          };
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[];
          };
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateUser>;
          };
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>;
            result: $Utils.Optional<UserGroupByOutputType>[];
          };
          count: {
            args: Prisma.UserCountArgs<ExtArgs>;
            result: $Utils.Optional<UserCountAggregateOutputType> | number;
          };
        };
      };
      EmailVerificationToken: {
        payload: Prisma.$EmailVerificationTokenPayload<ExtArgs>;
        fields: Prisma.EmailVerificationTokenFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.EmailVerificationTokenFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationTokenPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.EmailVerificationTokenFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationTokenPayload>;
          };
          findFirst: {
            args: Prisma.EmailVerificationTokenFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationTokenPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.EmailVerificationTokenFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationTokenPayload>;
          };
          findMany: {
            args: Prisma.EmailVerificationTokenFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationTokenPayload>[];
          };
          create: {
            args: Prisma.EmailVerificationTokenCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationTokenPayload>;
          };
          createMany: {
            args: Prisma.EmailVerificationTokenCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.EmailVerificationTokenCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationTokenPayload>[];
          };
          delete: {
            args: Prisma.EmailVerificationTokenDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationTokenPayload>;
          };
          update: {
            args: Prisma.EmailVerificationTokenUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationTokenPayload>;
          };
          deleteMany: {
            args: Prisma.EmailVerificationTokenDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.EmailVerificationTokenUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.EmailVerificationTokenUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationTokenPayload>[];
          };
          upsert: {
            args: Prisma.EmailVerificationTokenUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationTokenPayload>;
          };
          aggregate: {
            args: Prisma.EmailVerificationTokenAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateEmailVerificationToken>;
          };
          groupBy: {
            args: Prisma.EmailVerificationTokenGroupByArgs<ExtArgs>;
            result: $Utils.Optional<EmailVerificationTokenGroupByOutputType>[];
          };
          count: {
            args: Prisma.EmailVerificationTokenCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<EmailVerificationTokenCountAggregateOutputType>
              | number;
          };
        };
      };
      Pupil: {
        payload: Prisma.$PupilPayload<ExtArgs>;
        fields: Prisma.PupilFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.PupilFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PupilPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.PupilFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PupilPayload>;
          };
          findFirst: {
            args: Prisma.PupilFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PupilPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.PupilFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PupilPayload>;
          };
          findMany: {
            args: Prisma.PupilFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PupilPayload>[];
          };
          create: {
            args: Prisma.PupilCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PupilPayload>;
          };
          createMany: {
            args: Prisma.PupilCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.PupilCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PupilPayload>[];
          };
          delete: {
            args: Prisma.PupilDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PupilPayload>;
          };
          update: {
            args: Prisma.PupilUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PupilPayload>;
          };
          deleteMany: {
            args: Prisma.PupilDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.PupilUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.PupilUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PupilPayload>[];
          };
          upsert: {
            args: Prisma.PupilUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PupilPayload>;
          };
          aggregate: {
            args: Prisma.PupilAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregatePupil>;
          };
          groupBy: {
            args: Prisma.PupilGroupByArgs<ExtArgs>;
            result: $Utils.Optional<PupilGroupByOutputType>[];
          };
          count: {
            args: Prisma.PupilCountArgs<ExtArgs>;
            result: $Utils.Optional<PupilCountAggregateOutputType> | number;
          };
        };
      };
      Staff: {
        payload: Prisma.$StaffPayload<ExtArgs>;
        fields: Prisma.StaffFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.StaffFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$StaffPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.StaffFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$StaffPayload>;
          };
          findFirst: {
            args: Prisma.StaffFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$StaffPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.StaffFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$StaffPayload>;
          };
          findMany: {
            args: Prisma.StaffFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$StaffPayload>[];
          };
          create: {
            args: Prisma.StaffCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$StaffPayload>;
          };
          createMany: {
            args: Prisma.StaffCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.StaffCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$StaffPayload>[];
          };
          delete: {
            args: Prisma.StaffDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$StaffPayload>;
          };
          update: {
            args: Prisma.StaffUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$StaffPayload>;
          };
          deleteMany: {
            args: Prisma.StaffDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.StaffUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.StaffUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$StaffPayload>[];
          };
          upsert: {
            args: Prisma.StaffUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$StaffPayload>;
          };
          aggregate: {
            args: Prisma.StaffAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateStaff>;
          };
          groupBy: {
            args: Prisma.StaffGroupByArgs<ExtArgs>;
            result: $Utils.Optional<StaffGroupByOutputType>[];
          };
          count: {
            args: Prisma.StaffCountArgs<ExtArgs>;
            result: $Utils.Optional<StaffCountAggregateOutputType> | number;
          };
        };
      };
      Level: {
        payload: Prisma.$LevelPayload<ExtArgs>;
        fields: Prisma.LevelFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.LevelFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LevelPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.LevelFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LevelPayload>;
          };
          findFirst: {
            args: Prisma.LevelFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LevelPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.LevelFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LevelPayload>;
          };
          findMany: {
            args: Prisma.LevelFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LevelPayload>[];
          };
          create: {
            args: Prisma.LevelCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LevelPayload>;
          };
          createMany: {
            args: Prisma.LevelCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.LevelCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LevelPayload>[];
          };
          delete: {
            args: Prisma.LevelDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LevelPayload>;
          };
          update: {
            args: Prisma.LevelUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LevelPayload>;
          };
          deleteMany: {
            args: Prisma.LevelDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.LevelUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.LevelUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LevelPayload>[];
          };
          upsert: {
            args: Prisma.LevelUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LevelPayload>;
          };
          aggregate: {
            args: Prisma.LevelAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateLevel>;
          };
          groupBy: {
            args: Prisma.LevelGroupByArgs<ExtArgs>;
            result: $Utils.Optional<LevelGroupByOutputType>[];
          };
          count: {
            args: Prisma.LevelCountArgs<ExtArgs>;
            result: $Utils.Optional<LevelCountAggregateOutputType> | number;
          };
        };
      };
      Stream: {
        payload: Prisma.$StreamPayload<ExtArgs>;
        fields: Prisma.StreamFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.StreamFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$StreamPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.StreamFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$StreamPayload>;
          };
          findFirst: {
            args: Prisma.StreamFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$StreamPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.StreamFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$StreamPayload>;
          };
          findMany: {
            args: Prisma.StreamFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$StreamPayload>[];
          };
          create: {
            args: Prisma.StreamCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$StreamPayload>;
          };
          createMany: {
            args: Prisma.StreamCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.StreamCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$StreamPayload>[];
          };
          delete: {
            args: Prisma.StreamDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$StreamPayload>;
          };
          update: {
            args: Prisma.StreamUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$StreamPayload>;
          };
          deleteMany: {
            args: Prisma.StreamDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.StreamUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.StreamUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$StreamPayload>[];
          };
          upsert: {
            args: Prisma.StreamUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$StreamPayload>;
          };
          aggregate: {
            args: Prisma.StreamAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateStream>;
          };
          groupBy: {
            args: Prisma.StreamGroupByArgs<ExtArgs>;
            result: $Utils.Optional<StreamGroupByOutputType>[];
          };
          count: {
            args: Prisma.StreamCountArgs<ExtArgs>;
            result: $Utils.Optional<StreamCountAggregateOutputType> | number;
          };
        };
      };
      Class: {
        payload: Prisma.$ClassPayload<ExtArgs>;
        fields: Prisma.ClassFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.ClassFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ClassPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.ClassFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>;
          };
          findFirst: {
            args: Prisma.ClassFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ClassPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.ClassFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>;
          };
          findMany: {
            args: Prisma.ClassFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>[];
          };
          create: {
            args: Prisma.ClassCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>;
          };
          createMany: {
            args: Prisma.ClassCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.ClassCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>[];
          };
          delete: {
            args: Prisma.ClassDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>;
          };
          update: {
            args: Prisma.ClassUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>;
          };
          deleteMany: {
            args: Prisma.ClassDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.ClassUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.ClassUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>[];
          };
          upsert: {
            args: Prisma.ClassUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>;
          };
          aggregate: {
            args: Prisma.ClassAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateClass>;
          };
          groupBy: {
            args: Prisma.ClassGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ClassGroupByOutputType>[];
          };
          count: {
            args: Prisma.ClassCountArgs<ExtArgs>;
            result: $Utils.Optional<ClassCountAggregateOutputType> | number;
          };
        };
      };
      AcademicYear: {
        payload: Prisma.$AcademicYearPayload<ExtArgs>;
        fields: Prisma.AcademicYearFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.AcademicYearFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AcademicYearPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.AcademicYearFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AcademicYearPayload>;
          };
          findFirst: {
            args: Prisma.AcademicYearFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AcademicYearPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.AcademicYearFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AcademicYearPayload>;
          };
          findMany: {
            args: Prisma.AcademicYearFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AcademicYearPayload>[];
          };
          create: {
            args: Prisma.AcademicYearCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AcademicYearPayload>;
          };
          createMany: {
            args: Prisma.AcademicYearCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.AcademicYearCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AcademicYearPayload>[];
          };
          delete: {
            args: Prisma.AcademicYearDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AcademicYearPayload>;
          };
          update: {
            args: Prisma.AcademicYearUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AcademicYearPayload>;
          };
          deleteMany: {
            args: Prisma.AcademicYearDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.AcademicYearUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.AcademicYearUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AcademicYearPayload>[];
          };
          upsert: {
            args: Prisma.AcademicYearUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AcademicYearPayload>;
          };
          aggregate: {
            args: Prisma.AcademicYearAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateAcademicYear>;
          };
          groupBy: {
            args: Prisma.AcademicYearGroupByArgs<ExtArgs>;
            result: $Utils.Optional<AcademicYearGroupByOutputType>[];
          };
          count: {
            args: Prisma.AcademicYearCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<AcademicYearCountAggregateOutputType>
              | number;
          };
        };
      };
      AcademicYearClass: {
        payload: Prisma.$AcademicYearClassPayload<ExtArgs>;
        fields: Prisma.AcademicYearClassFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.AcademicYearClassFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AcademicYearClassPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.AcademicYearClassFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AcademicYearClassPayload>;
          };
          findFirst: {
            args: Prisma.AcademicYearClassFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AcademicYearClassPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.AcademicYearClassFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AcademicYearClassPayload>;
          };
          findMany: {
            args: Prisma.AcademicYearClassFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AcademicYearClassPayload>[];
          };
          create: {
            args: Prisma.AcademicYearClassCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AcademicYearClassPayload>;
          };
          createMany: {
            args: Prisma.AcademicYearClassCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.AcademicYearClassCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AcademicYearClassPayload>[];
          };
          delete: {
            args: Prisma.AcademicYearClassDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AcademicYearClassPayload>;
          };
          update: {
            args: Prisma.AcademicYearClassUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AcademicYearClassPayload>;
          };
          deleteMany: {
            args: Prisma.AcademicYearClassDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.AcademicYearClassUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.AcademicYearClassUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AcademicYearClassPayload>[];
          };
          upsert: {
            args: Prisma.AcademicYearClassUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AcademicYearClassPayload>;
          };
          aggregate: {
            args: Prisma.AcademicYearClassAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateAcademicYearClass>;
          };
          groupBy: {
            args: Prisma.AcademicYearClassGroupByArgs<ExtArgs>;
            result: $Utils.Optional<AcademicYearClassGroupByOutputType>[];
          };
          count: {
            args: Prisma.AcademicYearClassCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<AcademicYearClassCountAggregateOutputType>
              | number;
          };
        };
      };
      Subject: {
        payload: Prisma.$SubjectPayload<ExtArgs>;
        fields: Prisma.SubjectFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.SubjectFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.SubjectFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>;
          };
          findFirst: {
            args: Prisma.SubjectFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.SubjectFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>;
          };
          findMany: {
            args: Prisma.SubjectFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>[];
          };
          create: {
            args: Prisma.SubjectCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>;
          };
          createMany: {
            args: Prisma.SubjectCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.SubjectCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>[];
          };
          delete: {
            args: Prisma.SubjectDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>;
          };
          update: {
            args: Prisma.SubjectUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>;
          };
          deleteMany: {
            args: Prisma.SubjectDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.SubjectUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.SubjectUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>[];
          };
          upsert: {
            args: Prisma.SubjectUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>;
          };
          aggregate: {
            args: Prisma.SubjectAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateSubject>;
          };
          groupBy: {
            args: Prisma.SubjectGroupByArgs<ExtArgs>;
            result: $Utils.Optional<SubjectGroupByOutputType>[];
          };
          count: {
            args: Prisma.SubjectCountArgs<ExtArgs>;
            result: $Utils.Optional<SubjectCountAggregateOutputType> | number;
          };
        };
      };
      Grading: {
        payload: Prisma.$GradingPayload<ExtArgs>;
        fields: Prisma.GradingFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.GradingFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$GradingPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.GradingFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$GradingPayload>;
          };
          findFirst: {
            args: Prisma.GradingFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$GradingPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.GradingFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$GradingPayload>;
          };
          findMany: {
            args: Prisma.GradingFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$GradingPayload>[];
          };
          create: {
            args: Prisma.GradingCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$GradingPayload>;
          };
          createMany: {
            args: Prisma.GradingCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.GradingCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$GradingPayload>[];
          };
          delete: {
            args: Prisma.GradingDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$GradingPayload>;
          };
          update: {
            args: Prisma.GradingUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$GradingPayload>;
          };
          deleteMany: {
            args: Prisma.GradingDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.GradingUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.GradingUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$GradingPayload>[];
          };
          upsert: {
            args: Prisma.GradingUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$GradingPayload>;
          };
          aggregate: {
            args: Prisma.GradingAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateGrading>;
          };
          groupBy: {
            args: Prisma.GradingGroupByArgs<ExtArgs>;
            result: $Utils.Optional<GradingGroupByOutputType>[];
          };
          count: {
            args: Prisma.GradingCountArgs<ExtArgs>;
            result: $Utils.Optional<GradingCountAggregateOutputType> | number;
          };
        };
      };
      AcademicYearSubject: {
        payload: Prisma.$AcademicYearSubjectPayload<ExtArgs>;
        fields: Prisma.AcademicYearSubjectFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.AcademicYearSubjectFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AcademicYearSubjectPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.AcademicYearSubjectFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AcademicYearSubjectPayload>;
          };
          findFirst: {
            args: Prisma.AcademicYearSubjectFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AcademicYearSubjectPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.AcademicYearSubjectFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AcademicYearSubjectPayload>;
          };
          findMany: {
            args: Prisma.AcademicYearSubjectFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AcademicYearSubjectPayload>[];
          };
          create: {
            args: Prisma.AcademicYearSubjectCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AcademicYearSubjectPayload>;
          };
          createMany: {
            args: Prisma.AcademicYearSubjectCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.AcademicYearSubjectCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AcademicYearSubjectPayload>[];
          };
          delete: {
            args: Prisma.AcademicYearSubjectDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AcademicYearSubjectPayload>;
          };
          update: {
            args: Prisma.AcademicYearSubjectUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AcademicYearSubjectPayload>;
          };
          deleteMany: {
            args: Prisma.AcademicYearSubjectDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.AcademicYearSubjectUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.AcademicYearSubjectUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AcademicYearSubjectPayload>[];
          };
          upsert: {
            args: Prisma.AcademicYearSubjectUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AcademicYearSubjectPayload>;
          };
          aggregate: {
            args: Prisma.AcademicYearSubjectAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateAcademicYearSubject>;
          };
          groupBy: {
            args: Prisma.AcademicYearSubjectGroupByArgs<ExtArgs>;
            result: $Utils.Optional<AcademicYearSubjectGroupByOutputType>[];
          };
          count: {
            args: Prisma.AcademicYearSubjectCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<AcademicYearSubjectCountAggregateOutputType>
              | number;
          };
        };
      };
      classStream: {
        payload: Prisma.$classStreamPayload<ExtArgs>;
        fields: Prisma.classStreamFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.classStreamFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$classStreamPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.classStreamFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$classStreamPayload>;
          };
          findFirst: {
            args: Prisma.classStreamFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$classStreamPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.classStreamFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$classStreamPayload>;
          };
          findMany: {
            args: Prisma.classStreamFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$classStreamPayload>[];
          };
          create: {
            args: Prisma.classStreamCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$classStreamPayload>;
          };
          createMany: {
            args: Prisma.classStreamCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.classStreamCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$classStreamPayload>[];
          };
          delete: {
            args: Prisma.classStreamDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$classStreamPayload>;
          };
          update: {
            args: Prisma.classStreamUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$classStreamPayload>;
          };
          deleteMany: {
            args: Prisma.classStreamDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.classStreamUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.classStreamUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$classStreamPayload>[];
          };
          upsert: {
            args: Prisma.classStreamUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$classStreamPayload>;
          };
          aggregate: {
            args: Prisma.ClassStreamAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateClassStream>;
          };
          groupBy: {
            args: Prisma.classStreamGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ClassStreamGroupByOutputType>[];
          };
          count: {
            args: Prisma.classStreamCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<ClassStreamCountAggregateOutputType>
              | number;
          };
        };
      };
      Term: {
        payload: Prisma.$TermPayload<ExtArgs>;
        fields: Prisma.TermFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.TermFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TermPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.TermFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TermPayload>;
          };
          findFirst: {
            args: Prisma.TermFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TermPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.TermFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TermPayload>;
          };
          findMany: {
            args: Prisma.TermFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TermPayload>[];
          };
          create: {
            args: Prisma.TermCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TermPayload>;
          };
          createMany: {
            args: Prisma.TermCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.TermCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TermPayload>[];
          };
          delete: {
            args: Prisma.TermDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TermPayload>;
          };
          update: {
            args: Prisma.TermUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TermPayload>;
          };
          deleteMany: {
            args: Prisma.TermDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.TermUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.TermUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TermPayload>[];
          };
          upsert: {
            args: Prisma.TermUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TermPayload>;
          };
          aggregate: {
            args: Prisma.TermAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateTerm>;
          };
          groupBy: {
            args: Prisma.TermGroupByArgs<ExtArgs>;
            result: $Utils.Optional<TermGroupByOutputType>[];
          };
          count: {
            args: Prisma.TermCountArgs<ExtArgs>;
            result: $Utils.Optional<TermCountAggregateOutputType> | number;
          };
        };
      };
      ClassTerm: {
        payload: Prisma.$ClassTermPayload<ExtArgs>;
        fields: Prisma.ClassTermFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.ClassTermFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ClassTermPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.ClassTermFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ClassTermPayload>;
          };
          findFirst: {
            args: Prisma.ClassTermFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ClassTermPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.ClassTermFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ClassTermPayload>;
          };
          findMany: {
            args: Prisma.ClassTermFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ClassTermPayload>[];
          };
          create: {
            args: Prisma.ClassTermCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ClassTermPayload>;
          };
          createMany: {
            args: Prisma.ClassTermCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.ClassTermCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ClassTermPayload>[];
          };
          delete: {
            args: Prisma.ClassTermDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ClassTermPayload>;
          };
          update: {
            args: Prisma.ClassTermUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ClassTermPayload>;
          };
          deleteMany: {
            args: Prisma.ClassTermDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.ClassTermUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.ClassTermUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ClassTermPayload>[];
          };
          upsert: {
            args: Prisma.ClassTermUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ClassTermPayload>;
          };
          aggregate: {
            args: Prisma.ClassTermAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateClassTerm>;
          };
          groupBy: {
            args: Prisma.ClassTermGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ClassTermGroupByOutputType>[];
          };
          count: {
            args: Prisma.ClassTermCountArgs<ExtArgs>;
            result: $Utils.Optional<ClassTermCountAggregateOutputType> | number;
          };
        };
      };
      Fees: {
        payload: Prisma.$FeesPayload<ExtArgs>;
        fields: Prisma.FeesFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.FeesFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FeesPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.FeesFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FeesPayload>;
          };
          findFirst: {
            args: Prisma.FeesFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FeesPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.FeesFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FeesPayload>;
          };
          findMany: {
            args: Prisma.FeesFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FeesPayload>[];
          };
          create: {
            args: Prisma.FeesCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FeesPayload>;
          };
          createMany: {
            args: Prisma.FeesCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.FeesCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FeesPayload>[];
          };
          delete: {
            args: Prisma.FeesDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FeesPayload>;
          };
          update: {
            args: Prisma.FeesUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FeesPayload>;
          };
          deleteMany: {
            args: Prisma.FeesDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.FeesUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.FeesUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FeesPayload>[];
          };
          upsert: {
            args: Prisma.FeesUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FeesPayload>;
          };
          aggregate: {
            args: Prisma.FeesAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateFees>;
          };
          groupBy: {
            args: Prisma.FeesGroupByArgs<ExtArgs>;
            result: $Utils.Optional<FeesGroupByOutputType>[];
          };
          count: {
            args: Prisma.FeesCountArgs<ExtArgs>;
            result: $Utils.Optional<FeesCountAggregateOutputType> | number;
          };
        };
      };
      FeesPayment: {
        payload: Prisma.$FeesPaymentPayload<ExtArgs>;
        fields: Prisma.FeesPaymentFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.FeesPaymentFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FeesPaymentPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.FeesPaymentFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FeesPaymentPayload>;
          };
          findFirst: {
            args: Prisma.FeesPaymentFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FeesPaymentPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.FeesPaymentFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FeesPaymentPayload>;
          };
          findMany: {
            args: Prisma.FeesPaymentFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FeesPaymentPayload>[];
          };
          create: {
            args: Prisma.FeesPaymentCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FeesPaymentPayload>;
          };
          createMany: {
            args: Prisma.FeesPaymentCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.FeesPaymentCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FeesPaymentPayload>[];
          };
          delete: {
            args: Prisma.FeesPaymentDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FeesPaymentPayload>;
          };
          update: {
            args: Prisma.FeesPaymentUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FeesPaymentPayload>;
          };
          deleteMany: {
            args: Prisma.FeesPaymentDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.FeesPaymentUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.FeesPaymentUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FeesPaymentPayload>[];
          };
          upsert: {
            args: Prisma.FeesPaymentUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FeesPaymentPayload>;
          };
          aggregate: {
            args: Prisma.FeesPaymentAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateFeesPayment>;
          };
          groupBy: {
            args: Prisma.FeesPaymentGroupByArgs<ExtArgs>;
            result: $Utils.Optional<FeesPaymentGroupByOutputType>[];
          };
          count: {
            args: Prisma.FeesPaymentCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<FeesPaymentCountAggregateOutputType>
              | number;
          };
        };
      };
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>;
        fields: Prisma.SessionFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>;
          };
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>;
          };
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[];
          };
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>;
          };
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[];
          };
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>;
          };
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>;
          };
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[];
          };
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>;
          };
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateSession>;
          };
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>;
            result: $Utils.Optional<SessionGroupByOutputType>[];
          };
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>;
            result: $Utils.Optional<SessionCountAggregateOutputType> | number;
          };
        };
      };
      Asset: {
        payload: Prisma.$AssetPayload<ExtArgs>;
        fields: Prisma.AssetFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.AssetFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AssetPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.AssetFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>;
          };
          findFirst: {
            args: Prisma.AssetFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AssetPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.AssetFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>;
          };
          findMany: {
            args: Prisma.AssetFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>[];
          };
          create: {
            args: Prisma.AssetCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>;
          };
          createMany: {
            args: Prisma.AssetCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.AssetCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>[];
          };
          delete: {
            args: Prisma.AssetDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>;
          };
          update: {
            args: Prisma.AssetUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>;
          };
          deleteMany: {
            args: Prisma.AssetDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.AssetUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.AssetUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>[];
          };
          upsert: {
            args: Prisma.AssetUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>;
          };
          aggregate: {
            args: Prisma.AssetAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateAsset>;
          };
          groupBy: {
            args: Prisma.AssetGroupByArgs<ExtArgs>;
            result: $Utils.Optional<AssetGroupByOutputType>[];
          };
          count: {
            args: Prisma.AssetCountArgs<ExtArgs>;
            result: $Utils.Optional<AssetCountAggregateOutputType> | number;
          };
        };
      };
      FoodStoreItem: {
        payload: Prisma.$FoodStoreItemPayload<ExtArgs>;
        fields: Prisma.FoodStoreItemFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.FoodStoreItemFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FoodStoreItemPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.FoodStoreItemFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FoodStoreItemPayload>;
          };
          findFirst: {
            args: Prisma.FoodStoreItemFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FoodStoreItemPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.FoodStoreItemFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FoodStoreItemPayload>;
          };
          findMany: {
            args: Prisma.FoodStoreItemFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FoodStoreItemPayload>[];
          };
          create: {
            args: Prisma.FoodStoreItemCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FoodStoreItemPayload>;
          };
          createMany: {
            args: Prisma.FoodStoreItemCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.FoodStoreItemCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FoodStoreItemPayload>[];
          };
          delete: {
            args: Prisma.FoodStoreItemDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FoodStoreItemPayload>;
          };
          update: {
            args: Prisma.FoodStoreItemUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FoodStoreItemPayload>;
          };
          deleteMany: {
            args: Prisma.FoodStoreItemDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.FoodStoreItemUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.FoodStoreItemUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FoodStoreItemPayload>[];
          };
          upsert: {
            args: Prisma.FoodStoreItemUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FoodStoreItemPayload>;
          };
          aggregate: {
            args: Prisma.FoodStoreItemAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateFoodStoreItem>;
          };
          groupBy: {
            args: Prisma.FoodStoreItemGroupByArgs<ExtArgs>;
            result: $Utils.Optional<FoodStoreItemGroupByOutputType>[];
          };
          count: {
            args: Prisma.FoodStoreItemCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<FoodStoreItemCountAggregateOutputType>
              | number;
          };
        };
      };
      IndividualFoodStoreItem: {
        payload: Prisma.$IndividualFoodStoreItemPayload<ExtArgs>;
        fields: Prisma.IndividualFoodStoreItemFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.IndividualFoodStoreItemFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$IndividualFoodStoreItemPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.IndividualFoodStoreItemFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$IndividualFoodStoreItemPayload>;
          };
          findFirst: {
            args: Prisma.IndividualFoodStoreItemFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$IndividualFoodStoreItemPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.IndividualFoodStoreItemFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$IndividualFoodStoreItemPayload>;
          };
          findMany: {
            args: Prisma.IndividualFoodStoreItemFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$IndividualFoodStoreItemPayload>[];
          };
          create: {
            args: Prisma.IndividualFoodStoreItemCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$IndividualFoodStoreItemPayload>;
          };
          createMany: {
            args: Prisma.IndividualFoodStoreItemCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.IndividualFoodStoreItemCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$IndividualFoodStoreItemPayload>[];
          };
          delete: {
            args: Prisma.IndividualFoodStoreItemDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$IndividualFoodStoreItemPayload>;
          };
          update: {
            args: Prisma.IndividualFoodStoreItemUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$IndividualFoodStoreItemPayload>;
          };
          deleteMany: {
            args: Prisma.IndividualFoodStoreItemDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.IndividualFoodStoreItemUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.IndividualFoodStoreItemUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$IndividualFoodStoreItemPayload>[];
          };
          upsert: {
            args: Prisma.IndividualFoodStoreItemUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$IndividualFoodStoreItemPayload>;
          };
          aggregate: {
            args: Prisma.IndividualFoodStoreItemAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateIndividualFoodStoreItem>;
          };
          groupBy: {
            args: Prisma.IndividualFoodStoreItemGroupByArgs<ExtArgs>;
            result: $Utils.Optional<IndividualFoodStoreItemGroupByOutputType>[];
          };
          count: {
            args: Prisma.IndividualFoodStoreItemCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<IndividualFoodStoreItemCountAggregateOutputType>
              | number;
          };
        };
      };
      FoodConsumption: {
        payload: Prisma.$FoodConsumptionPayload<ExtArgs>;
        fields: Prisma.FoodConsumptionFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.FoodConsumptionFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FoodConsumptionPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.FoodConsumptionFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FoodConsumptionPayload>;
          };
          findFirst: {
            args: Prisma.FoodConsumptionFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FoodConsumptionPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.FoodConsumptionFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FoodConsumptionPayload>;
          };
          findMany: {
            args: Prisma.FoodConsumptionFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FoodConsumptionPayload>[];
          };
          create: {
            args: Prisma.FoodConsumptionCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FoodConsumptionPayload>;
          };
          createMany: {
            args: Prisma.FoodConsumptionCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.FoodConsumptionCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FoodConsumptionPayload>[];
          };
          delete: {
            args: Prisma.FoodConsumptionDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FoodConsumptionPayload>;
          };
          update: {
            args: Prisma.FoodConsumptionUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FoodConsumptionPayload>;
          };
          deleteMany: {
            args: Prisma.FoodConsumptionDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.FoodConsumptionUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.FoodConsumptionUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FoodConsumptionPayload>[];
          };
          upsert: {
            args: Prisma.FoodConsumptionUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FoodConsumptionPayload>;
          };
          aggregate: {
            args: Prisma.FoodConsumptionAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateFoodConsumption>;
          };
          groupBy: {
            args: Prisma.FoodConsumptionGroupByArgs<ExtArgs>;
            result: $Utils.Optional<FoodConsumptionGroupByOutputType>[];
          };
          count: {
            args: Prisma.FoodConsumptionCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<FoodConsumptionCountAggregateOutputType>
              | number;
          };
        };
      };
      Supplier: {
        payload: Prisma.$SupplierPayload<ExtArgs>;
        fields: Prisma.SupplierFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.SupplierFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.SupplierFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>;
          };
          findFirst: {
            args: Prisma.SupplierFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.SupplierFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>;
          };
          findMany: {
            args: Prisma.SupplierFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>[];
          };
          create: {
            args: Prisma.SupplierCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>;
          };
          createMany: {
            args: Prisma.SupplierCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.SupplierCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>[];
          };
          delete: {
            args: Prisma.SupplierDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>;
          };
          update: {
            args: Prisma.SupplierUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>;
          };
          deleteMany: {
            args: Prisma.SupplierDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.SupplierUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.SupplierUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>[];
          };
          upsert: {
            args: Prisma.SupplierUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>;
          };
          aggregate: {
            args: Prisma.SupplierAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateSupplier>;
          };
          groupBy: {
            args: Prisma.SupplierGroupByArgs<ExtArgs>;
            result: $Utils.Optional<SupplierGroupByOutputType>[];
          };
          count: {
            args: Prisma.SupplierCountArgs<ExtArgs>;
            result: $Utils.Optional<SupplierCountAggregateOutputType> | number;
          };
        };
      };
      LibraryBook: {
        payload: Prisma.$LibraryBookPayload<ExtArgs>;
        fields: Prisma.LibraryBookFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.LibraryBookFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LibraryBookPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.LibraryBookFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LibraryBookPayload>;
          };
          findFirst: {
            args: Prisma.LibraryBookFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LibraryBookPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.LibraryBookFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LibraryBookPayload>;
          };
          findMany: {
            args: Prisma.LibraryBookFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LibraryBookPayload>[];
          };
          create: {
            args: Prisma.LibraryBookCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LibraryBookPayload>;
          };
          createMany: {
            args: Prisma.LibraryBookCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.LibraryBookCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LibraryBookPayload>[];
          };
          delete: {
            args: Prisma.LibraryBookDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LibraryBookPayload>;
          };
          update: {
            args: Prisma.LibraryBookUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LibraryBookPayload>;
          };
          deleteMany: {
            args: Prisma.LibraryBookDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.LibraryBookUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.LibraryBookUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LibraryBookPayload>[];
          };
          upsert: {
            args: Prisma.LibraryBookUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LibraryBookPayload>;
          };
          aggregate: {
            args: Prisma.LibraryBookAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateLibraryBook>;
          };
          groupBy: {
            args: Prisma.LibraryBookGroupByArgs<ExtArgs>;
            result: $Utils.Optional<LibraryBookGroupByOutputType>[];
          };
          count: {
            args: Prisma.LibraryBookCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<LibraryBookCountAggregateOutputType>
              | number;
          };
        };
      };
      IndividualBook: {
        payload: Prisma.$IndividualBookPayload<ExtArgs>;
        fields: Prisma.IndividualBookFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.IndividualBookFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$IndividualBookPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.IndividualBookFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$IndividualBookPayload>;
          };
          findFirst: {
            args: Prisma.IndividualBookFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$IndividualBookPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.IndividualBookFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$IndividualBookPayload>;
          };
          findMany: {
            args: Prisma.IndividualBookFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$IndividualBookPayload>[];
          };
          create: {
            args: Prisma.IndividualBookCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$IndividualBookPayload>;
          };
          createMany: {
            args: Prisma.IndividualBookCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.IndividualBookCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$IndividualBookPayload>[];
          };
          delete: {
            args: Prisma.IndividualBookDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$IndividualBookPayload>;
          };
          update: {
            args: Prisma.IndividualBookUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$IndividualBookPayload>;
          };
          deleteMany: {
            args: Prisma.IndividualBookDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.IndividualBookUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.IndividualBookUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$IndividualBookPayload>[];
          };
          upsert: {
            args: Prisma.IndividualBookUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$IndividualBookPayload>;
          };
          aggregate: {
            args: Prisma.IndividualBookAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateIndividualBook>;
          };
          groupBy: {
            args: Prisma.IndividualBookGroupByArgs<ExtArgs>;
            result: $Utils.Optional<IndividualBookGroupByOutputType>[];
          };
          count: {
            args: Prisma.IndividualBookCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<IndividualBookCountAggregateOutputType>
              | number;
          };
        };
      };
      LibraryBookCategory: {
        payload: Prisma.$LibraryBookCategoryPayload<ExtArgs>;
        fields: Prisma.LibraryBookCategoryFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.LibraryBookCategoryFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LibraryBookCategoryPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.LibraryBookCategoryFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LibraryBookCategoryPayload>;
          };
          findFirst: {
            args: Prisma.LibraryBookCategoryFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LibraryBookCategoryPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.LibraryBookCategoryFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LibraryBookCategoryPayload>;
          };
          findMany: {
            args: Prisma.LibraryBookCategoryFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LibraryBookCategoryPayload>[];
          };
          create: {
            args: Prisma.LibraryBookCategoryCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LibraryBookCategoryPayload>;
          };
          createMany: {
            args: Prisma.LibraryBookCategoryCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.LibraryBookCategoryCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LibraryBookCategoryPayload>[];
          };
          delete: {
            args: Prisma.LibraryBookCategoryDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LibraryBookCategoryPayload>;
          };
          update: {
            args: Prisma.LibraryBookCategoryUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LibraryBookCategoryPayload>;
          };
          deleteMany: {
            args: Prisma.LibraryBookCategoryDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.LibraryBookCategoryUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.LibraryBookCategoryUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LibraryBookCategoryPayload>[];
          };
          upsert: {
            args: Prisma.LibraryBookCategoryUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LibraryBookCategoryPayload>;
          };
          aggregate: {
            args: Prisma.LibraryBookCategoryAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateLibraryBookCategory>;
          };
          groupBy: {
            args: Prisma.LibraryBookCategoryGroupByArgs<ExtArgs>;
            result: $Utils.Optional<LibraryBookCategoryGroupByOutputType>[];
          };
          count: {
            args: Prisma.LibraryBookCategoryCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<LibraryBookCategoryCountAggregateOutputType>
              | number;
          };
        };
      };
      Borrower: {
        payload: Prisma.$BorrowerPayload<ExtArgs>;
        fields: Prisma.BorrowerFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.BorrowerFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$BorrowerPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.BorrowerFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$BorrowerPayload>;
          };
          findFirst: {
            args: Prisma.BorrowerFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$BorrowerPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.BorrowerFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$BorrowerPayload>;
          };
          findMany: {
            args: Prisma.BorrowerFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$BorrowerPayload>[];
          };
          create: {
            args: Prisma.BorrowerCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$BorrowerPayload>;
          };
          createMany: {
            args: Prisma.BorrowerCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.BorrowerCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$BorrowerPayload>[];
          };
          delete: {
            args: Prisma.BorrowerDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$BorrowerPayload>;
          };
          update: {
            args: Prisma.BorrowerUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$BorrowerPayload>;
          };
          deleteMany: {
            args: Prisma.BorrowerDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.BorrowerUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.BorrowerUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$BorrowerPayload>[];
          };
          upsert: {
            args: Prisma.BorrowerUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$BorrowerPayload>;
          };
          aggregate: {
            args: Prisma.BorrowerAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateBorrower>;
          };
          groupBy: {
            args: Prisma.BorrowerGroupByArgs<ExtArgs>;
            result: $Utils.Optional<BorrowerGroupByOutputType>[];
          };
          count: {
            args: Prisma.BorrowerCountArgs<ExtArgs>;
            result: $Utils.Optional<BorrowerCountAggregateOutputType> | number;
          };
        };
      };
      LabItem: {
        payload: Prisma.$LabItemPayload<ExtArgs>;
        fields: Prisma.LabItemFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.LabItemFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LabItemPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.LabItemFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LabItemPayload>;
          };
          findFirst: {
            args: Prisma.LabItemFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LabItemPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.LabItemFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LabItemPayload>;
          };
          findMany: {
            args: Prisma.LabItemFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LabItemPayload>[];
          };
          create: {
            args: Prisma.LabItemCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LabItemPayload>;
          };
          createMany: {
            args: Prisma.LabItemCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.LabItemCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LabItemPayload>[];
          };
          delete: {
            args: Prisma.LabItemDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LabItemPayload>;
          };
          update: {
            args: Prisma.LabItemUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LabItemPayload>;
          };
          deleteMany: {
            args: Prisma.LabItemDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.LabItemUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.LabItemUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LabItemPayload>[];
          };
          upsert: {
            args: Prisma.LabItemUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LabItemPayload>;
          };
          aggregate: {
            args: Prisma.LabItemAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateLabItem>;
          };
          groupBy: {
            args: Prisma.LabItemGroupByArgs<ExtArgs>;
            result: $Utils.Optional<LabItemGroupByOutputType>[];
          };
          count: {
            args: Prisma.LabItemCountArgs<ExtArgs>;
            result: $Utils.Optional<LabItemCountAggregateOutputType> | number;
          };
        };
      };
      IndividualLabItem: {
        payload: Prisma.$IndividualLabItemPayload<ExtArgs>;
        fields: Prisma.IndividualLabItemFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.IndividualLabItemFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$IndividualLabItemPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.IndividualLabItemFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$IndividualLabItemPayload>;
          };
          findFirst: {
            args: Prisma.IndividualLabItemFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$IndividualLabItemPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.IndividualLabItemFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$IndividualLabItemPayload>;
          };
          findMany: {
            args: Prisma.IndividualLabItemFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$IndividualLabItemPayload>[];
          };
          create: {
            args: Prisma.IndividualLabItemCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$IndividualLabItemPayload>;
          };
          createMany: {
            args: Prisma.IndividualLabItemCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.IndividualLabItemCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$IndividualLabItemPayload>[];
          };
          delete: {
            args: Prisma.IndividualLabItemDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$IndividualLabItemPayload>;
          };
          update: {
            args: Prisma.IndividualLabItemUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$IndividualLabItemPayload>;
          };
          deleteMany: {
            args: Prisma.IndividualLabItemDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.IndividualLabItemUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.IndividualLabItemUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$IndividualLabItemPayload>[];
          };
          upsert: {
            args: Prisma.IndividualLabItemUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$IndividualLabItemPayload>;
          };
          aggregate: {
            args: Prisma.IndividualLabItemAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateIndividualLabItem>;
          };
          groupBy: {
            args: Prisma.IndividualLabItemGroupByArgs<ExtArgs>;
            result: $Utils.Optional<IndividualLabItemGroupByOutputType>[];
          };
          count: {
            args: Prisma.IndividualLabItemCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<IndividualLabItemCountAggregateOutputType>
              | number;
          };
        };
      };
      ComputerLabItem: {
        payload: Prisma.$ComputerLabItemPayload<ExtArgs>;
        fields: Prisma.ComputerLabItemFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.ComputerLabItemFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ComputerLabItemPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.ComputerLabItemFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ComputerLabItemPayload>;
          };
          findFirst: {
            args: Prisma.ComputerLabItemFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ComputerLabItemPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.ComputerLabItemFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ComputerLabItemPayload>;
          };
          findMany: {
            args: Prisma.ComputerLabItemFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ComputerLabItemPayload>[];
          };
          create: {
            args: Prisma.ComputerLabItemCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ComputerLabItemPayload>;
          };
          createMany: {
            args: Prisma.ComputerLabItemCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.ComputerLabItemCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ComputerLabItemPayload>[];
          };
          delete: {
            args: Prisma.ComputerLabItemDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ComputerLabItemPayload>;
          };
          update: {
            args: Prisma.ComputerLabItemUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ComputerLabItemPayload>;
          };
          deleteMany: {
            args: Prisma.ComputerLabItemDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.ComputerLabItemUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.ComputerLabItemUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ComputerLabItemPayload>[];
          };
          upsert: {
            args: Prisma.ComputerLabItemUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ComputerLabItemPayload>;
          };
          aggregate: {
            args: Prisma.ComputerLabItemAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateComputerLabItem>;
          };
          groupBy: {
            args: Prisma.ComputerLabItemGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ComputerLabItemGroupByOutputType>[];
          };
          count: {
            args: Prisma.ComputerLabItemCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<ComputerLabItemCountAggregateOutputType>
              | number;
          };
        };
      };
      IndividualComputerLabItem: {
        payload: Prisma.$IndividualComputerLabItemPayload<ExtArgs>;
        fields: Prisma.IndividualComputerLabItemFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.IndividualComputerLabItemFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$IndividualComputerLabItemPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.IndividualComputerLabItemFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$IndividualComputerLabItemPayload>;
          };
          findFirst: {
            args: Prisma.IndividualComputerLabItemFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$IndividualComputerLabItemPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.IndividualComputerLabItemFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$IndividualComputerLabItemPayload>;
          };
          findMany: {
            args: Prisma.IndividualComputerLabItemFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$IndividualComputerLabItemPayload>[];
          };
          create: {
            args: Prisma.IndividualComputerLabItemCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$IndividualComputerLabItemPayload>;
          };
          createMany: {
            args: Prisma.IndividualComputerLabItemCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.IndividualComputerLabItemCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$IndividualComputerLabItemPayload>[];
          };
          delete: {
            args: Prisma.IndividualComputerLabItemDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$IndividualComputerLabItemPayload>;
          };
          update: {
            args: Prisma.IndividualComputerLabItemUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$IndividualComputerLabItemPayload>;
          };
          deleteMany: {
            args: Prisma.IndividualComputerLabItemDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.IndividualComputerLabItemUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.IndividualComputerLabItemUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$IndividualComputerLabItemPayload>[];
          };
          upsert: {
            args: Prisma.IndividualComputerLabItemUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$IndividualComputerLabItemPayload>;
          };
          aggregate: {
            args: Prisma.IndividualComputerLabItemAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateIndividualComputerLabItem>;
          };
          groupBy: {
            args: Prisma.IndividualComputerLabItemGroupByArgs<ExtArgs>;
            result: $Utils.Optional<IndividualComputerLabItemGroupByOutputType>[];
          };
          count: {
            args: Prisma.IndividualComputerLabItemCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<IndividualComputerLabItemCountAggregateOutputType>
              | number;
          };
        };
      };
      GeneralStoreItem: {
        payload: Prisma.$GeneralStoreItemPayload<ExtArgs>;
        fields: Prisma.GeneralStoreItemFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.GeneralStoreItemFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$GeneralStoreItemPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.GeneralStoreItemFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$GeneralStoreItemPayload>;
          };
          findFirst: {
            args: Prisma.GeneralStoreItemFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$GeneralStoreItemPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.GeneralStoreItemFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$GeneralStoreItemPayload>;
          };
          findMany: {
            args: Prisma.GeneralStoreItemFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$GeneralStoreItemPayload>[];
          };
          create: {
            args: Prisma.GeneralStoreItemCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$GeneralStoreItemPayload>;
          };
          createMany: {
            args: Prisma.GeneralStoreItemCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.GeneralStoreItemCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$GeneralStoreItemPayload>[];
          };
          delete: {
            args: Prisma.GeneralStoreItemDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$GeneralStoreItemPayload>;
          };
          update: {
            args: Prisma.GeneralStoreItemUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$GeneralStoreItemPayload>;
          };
          deleteMany: {
            args: Prisma.GeneralStoreItemDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.GeneralStoreItemUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.GeneralStoreItemUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$GeneralStoreItemPayload>[];
          };
          upsert: {
            args: Prisma.GeneralStoreItemUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$GeneralStoreItemPayload>;
          };
          aggregate: {
            args: Prisma.GeneralStoreItemAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateGeneralStoreItem>;
          };
          groupBy: {
            args: Prisma.GeneralStoreItemGroupByArgs<ExtArgs>;
            result: $Utils.Optional<GeneralStoreItemGroupByOutputType>[];
          };
          count: {
            args: Prisma.GeneralStoreItemCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<GeneralStoreItemCountAggregateOutputType>
              | number;
          };
        };
      };
      IndividualGeneralStoreItem: {
        payload: Prisma.$IndividualGeneralStoreItemPayload<ExtArgs>;
        fields: Prisma.IndividualGeneralStoreItemFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.IndividualGeneralStoreItemFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$IndividualGeneralStoreItemPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.IndividualGeneralStoreItemFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$IndividualGeneralStoreItemPayload>;
          };
          findFirst: {
            args: Prisma.IndividualGeneralStoreItemFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$IndividualGeneralStoreItemPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.IndividualGeneralStoreItemFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$IndividualGeneralStoreItemPayload>;
          };
          findMany: {
            args: Prisma.IndividualGeneralStoreItemFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$IndividualGeneralStoreItemPayload>[];
          };
          create: {
            args: Prisma.IndividualGeneralStoreItemCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$IndividualGeneralStoreItemPayload>;
          };
          createMany: {
            args: Prisma.IndividualGeneralStoreItemCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.IndividualGeneralStoreItemCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$IndividualGeneralStoreItemPayload>[];
          };
          delete: {
            args: Prisma.IndividualGeneralStoreItemDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$IndividualGeneralStoreItemPayload>;
          };
          update: {
            args: Prisma.IndividualGeneralStoreItemUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$IndividualGeneralStoreItemPayload>;
          };
          deleteMany: {
            args: Prisma.IndividualGeneralStoreItemDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.IndividualGeneralStoreItemUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.IndividualGeneralStoreItemUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$IndividualGeneralStoreItemPayload>[];
          };
          upsert: {
            args: Prisma.IndividualGeneralStoreItemUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$IndividualGeneralStoreItemPayload>;
          };
          aggregate: {
            args: Prisma.IndividualGeneralStoreItemAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateIndividualGeneralStoreItem>;
          };
          groupBy: {
            args: Prisma.IndividualGeneralStoreItemGroupByArgs<ExtArgs>;
            result: $Utils.Optional<IndividualGeneralStoreItemGroupByOutputType>[];
          };
          count: {
            args: Prisma.IndividualGeneralStoreItemCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<IndividualGeneralStoreItemCountAggregateOutputType>
              | number;
          };
        };
      };
      AssetDamage: {
        payload: Prisma.$AssetDamagePayload<ExtArgs>;
        fields: Prisma.AssetDamageFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.AssetDamageFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AssetDamagePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.AssetDamageFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AssetDamagePayload>;
          };
          findFirst: {
            args: Prisma.AssetDamageFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AssetDamagePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.AssetDamageFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AssetDamagePayload>;
          };
          findMany: {
            args: Prisma.AssetDamageFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AssetDamagePayload>[];
          };
          create: {
            args: Prisma.AssetDamageCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AssetDamagePayload>;
          };
          createMany: {
            args: Prisma.AssetDamageCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.AssetDamageCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AssetDamagePayload>[];
          };
          delete: {
            args: Prisma.AssetDamageDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AssetDamagePayload>;
          };
          update: {
            args: Prisma.AssetDamageUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AssetDamagePayload>;
          };
          deleteMany: {
            args: Prisma.AssetDamageDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.AssetDamageUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.AssetDamageUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AssetDamagePayload>[];
          };
          upsert: {
            args: Prisma.AssetDamageUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AssetDamagePayload>;
          };
          aggregate: {
            args: Prisma.AssetDamageAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateAssetDamage>;
          };
          groupBy: {
            args: Prisma.AssetDamageGroupByArgs<ExtArgs>;
            result: $Utils.Optional<AssetDamageGroupByOutputType>[];
          };
          count: {
            args: Prisma.AssetDamageCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<AssetDamageCountAggregateOutputType>
              | number;
          };
        };
      };
      AssetRepairPayment: {
        payload: Prisma.$AssetRepairPaymentPayload<ExtArgs>;
        fields: Prisma.AssetRepairPaymentFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.AssetRepairPaymentFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AssetRepairPaymentPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.AssetRepairPaymentFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AssetRepairPaymentPayload>;
          };
          findFirst: {
            args: Prisma.AssetRepairPaymentFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AssetRepairPaymentPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.AssetRepairPaymentFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AssetRepairPaymentPayload>;
          };
          findMany: {
            args: Prisma.AssetRepairPaymentFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AssetRepairPaymentPayload>[];
          };
          create: {
            args: Prisma.AssetRepairPaymentCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AssetRepairPaymentPayload>;
          };
          createMany: {
            args: Prisma.AssetRepairPaymentCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.AssetRepairPaymentCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AssetRepairPaymentPayload>[];
          };
          delete: {
            args: Prisma.AssetRepairPaymentDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AssetRepairPaymentPayload>;
          };
          update: {
            args: Prisma.AssetRepairPaymentUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AssetRepairPaymentPayload>;
          };
          deleteMany: {
            args: Prisma.AssetRepairPaymentDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.AssetRepairPaymentUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.AssetRepairPaymentUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AssetRepairPaymentPayload>[];
          };
          upsert: {
            args: Prisma.AssetRepairPaymentUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AssetRepairPaymentPayload>;
          };
          aggregate: {
            args: Prisma.AssetRepairPaymentAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateAssetRepairPayment>;
          };
          groupBy: {
            args: Prisma.AssetRepairPaymentGroupByArgs<ExtArgs>;
            result: $Utils.Optional<AssetRepairPaymentGroupByOutputType>[];
          };
          count: {
            args: Prisma.AssetRepairPaymentCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<AssetRepairPaymentCountAggregateOutputType>
              | number;
          };
        };
      };
      ExamScore: {
        payload: Prisma.$ExamScorePayload<ExtArgs>;
        fields: Prisma.ExamScoreFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.ExamScoreFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ExamScorePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.ExamScoreFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ExamScorePayload>;
          };
          findFirst: {
            args: Prisma.ExamScoreFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ExamScorePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.ExamScoreFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ExamScorePayload>;
          };
          findMany: {
            args: Prisma.ExamScoreFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ExamScorePayload>[];
          };
          create: {
            args: Prisma.ExamScoreCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ExamScorePayload>;
          };
          createMany: {
            args: Prisma.ExamScoreCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.ExamScoreCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ExamScorePayload>[];
          };
          delete: {
            args: Prisma.ExamScoreDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ExamScorePayload>;
          };
          update: {
            args: Prisma.ExamScoreUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ExamScorePayload>;
          };
          deleteMany: {
            args: Prisma.ExamScoreDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.ExamScoreUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.ExamScoreUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ExamScorePayload>[];
          };
          upsert: {
            args: Prisma.ExamScoreUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ExamScorePayload>;
          };
          aggregate: {
            args: Prisma.ExamScoreAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateExamScore>;
          };
          groupBy: {
            args: Prisma.ExamScoreGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ExamScoreGroupByOutputType>[];
          };
          count: {
            args: Prisma.ExamScoreCountArgs<ExtArgs>;
            result: $Utils.Optional<ExamScoreCountAggregateOutputType> | number;
          };
        };
      };
      Exam: {
        payload: Prisma.$ExamPayload<ExtArgs>;
        fields: Prisma.ExamFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.ExamFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ExamPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.ExamFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>;
          };
          findFirst: {
            args: Prisma.ExamFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ExamPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.ExamFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>;
          };
          findMany: {
            args: Prisma.ExamFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>[];
          };
          create: {
            args: Prisma.ExamCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>;
          };
          createMany: {
            args: Prisma.ExamCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.ExamCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>[];
          };
          delete: {
            args: Prisma.ExamDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>;
          };
          update: {
            args: Prisma.ExamUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>;
          };
          deleteMany: {
            args: Prisma.ExamDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.ExamUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.ExamUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>[];
          };
          upsert: {
            args: Prisma.ExamUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>;
          };
          aggregate: {
            args: Prisma.ExamAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateExam>;
          };
          groupBy: {
            args: Prisma.ExamGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ExamGroupByOutputType>[];
          };
          count: {
            args: Prisma.ExamCountArgs<ExtArgs>;
            result: $Utils.Optional<ExamCountAggregateOutputType> | number;
          };
        };
      };
      ExamSubject: {
        payload: Prisma.$ExamSubjectPayload<ExtArgs>;
        fields: Prisma.ExamSubjectFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.ExamSubjectFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ExamSubjectPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.ExamSubjectFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ExamSubjectPayload>;
          };
          findFirst: {
            args: Prisma.ExamSubjectFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ExamSubjectPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.ExamSubjectFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ExamSubjectPayload>;
          };
          findMany: {
            args: Prisma.ExamSubjectFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ExamSubjectPayload>[];
          };
          create: {
            args: Prisma.ExamSubjectCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ExamSubjectPayload>;
          };
          createMany: {
            args: Prisma.ExamSubjectCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.ExamSubjectCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ExamSubjectPayload>[];
          };
          delete: {
            args: Prisma.ExamSubjectDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ExamSubjectPayload>;
          };
          update: {
            args: Prisma.ExamSubjectUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ExamSubjectPayload>;
          };
          deleteMany: {
            args: Prisma.ExamSubjectDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.ExamSubjectUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.ExamSubjectUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ExamSubjectPayload>[];
          };
          upsert: {
            args: Prisma.ExamSubjectUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ExamSubjectPayload>;
          };
          aggregate: {
            args: Prisma.ExamSubjectAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateExamSubject>;
          };
          groupBy: {
            args: Prisma.ExamSubjectGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ExamSubjectGroupByOutputType>[];
          };
          count: {
            args: Prisma.ExamSubjectCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<ExamSubjectCountAggregateOutputType>
              | number;
          };
        };
      };
    };
  } & {
    other: {
      payload: any;
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]];
          result: any;
        };
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]];
          result: any;
        };
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]];
          result: any;
        };
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]];
          result: any;
        };
      };
    };
  };
  export const defineExtension: $Extensions.ExtendsHook<
    "define",
    Prisma.TypeMapCb,
    $Extensions.DefaultArgs
  >;
  export type DefaultPrismaClient = PrismaClient;
  export type ErrorFormat = "pretty" | "colorless" | "minimal";
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources;
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string;
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat;
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     *
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[];
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number;
      timeout?: number;
      isolationLevel?: Prisma.TransactionIsolationLevel;
    };
    /**
     * Global configuration for omitting model fields by default.
     *
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig;
  }
  export type GlobalOmitConfig = {
    user?: UserOmit;
    emailVerificationToken?: EmailVerificationTokenOmit;
    pupil?: PupilOmit;
    staff?: StaffOmit;
    level?: LevelOmit;
    stream?: StreamOmit;
    class?: ClassOmit;
    academicYear?: AcademicYearOmit;
    academicYearClass?: AcademicYearClassOmit;
    subject?: SubjectOmit;
    grading?: GradingOmit;
    academicYearSubject?: AcademicYearSubjectOmit;
    classStream?: classStreamOmit;
    term?: TermOmit;
    classTerm?: ClassTermOmit;
    fees?: FeesOmit;
    feesPayment?: FeesPaymentOmit;
    session?: SessionOmit;
    asset?: AssetOmit;
    foodStoreItem?: FoodStoreItemOmit;
    individualFoodStoreItem?: IndividualFoodStoreItemOmit;
    foodConsumption?: FoodConsumptionOmit;
    supplier?: SupplierOmit;
    libraryBook?: LibraryBookOmit;
    individualBook?: IndividualBookOmit;
    libraryBookCategory?: LibraryBookCategoryOmit;
    borrower?: BorrowerOmit;
    labItem?: LabItemOmit;
    individualLabItem?: IndividualLabItemOmit;
    computerLabItem?: ComputerLabItemOmit;
    individualComputerLabItem?: IndividualComputerLabItemOmit;
    generalStoreItem?: GeneralStoreItemOmit;
    individualGeneralStoreItem?: IndividualGeneralStoreItemOmit;
    assetDamage?: AssetDamageOmit;
    assetRepairPayment?: AssetRepairPaymentOmit;
    examScore?: ExamScoreOmit;
    exam?: ExamOmit;
    examSubject?: ExamSubjectOmit;
  };

  /* Types for Logging */
  export type LogLevel = "info" | "query" | "warn" | "error";
  export type LogDefinition = {
    level: LogLevel;
    emit: "stdout" | "event";
  };

  export type GetLogType<T extends LogLevel | LogDefinition> =
    T extends LogDefinition
      ? T["emit"] extends "event"
        ? T["level"]
        : never
      : never;
  export type GetEvents<T extends any> =
    T extends Array<LogLevel | LogDefinition>
      ?
          | GetLogType<T[0]>
          | GetLogType<T[1]>
          | GetLogType<T[2]>
          | GetLogType<T[3]>
      : never;

  export type QueryEvent = {
    timestamp: Date;
    query: string;
    params: string;
    duration: number;
    target: string;
  };

  export type LogEvent = {
    timestamp: Date;
    message: string;
    target: string;
  };
  /* End Types for Logging */

  export type PrismaAction =
    | "findUnique"
    | "findUniqueOrThrow"
    | "findMany"
    | "findFirst"
    | "findFirstOrThrow"
    | "create"
    | "createMany"
    | "createManyAndReturn"
    | "update"
    | "updateMany"
    | "updateManyAndReturn"
    | "upsert"
    | "delete"
    | "deleteMany"
    | "executeRaw"
    | "queryRaw"
    | "aggregate"
    | "count"
    | "runCommandRaw"
    | "findRaw"
    | "groupBy";

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName;
    action: PrismaAction;
    args: any;
    dataPath: string[];
    runInTransaction: boolean;
  };

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>;

  // tested in getLogLevel.test.ts
  export function getLogLevel(
    log: Array<LogLevel | LogDefinition>,
  ): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<
    Prisma.DefaultPrismaClient,
    runtime.ITXClientDenyList
  >;

  export type Datasource = {
    url?: string;
  };

  /**
   * Count Types
   */

  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    assetDamages: number;
    assetRepairPayments: number;
    borrowers: number;
    emailVerificationTokens: number;
    feesPayments: number;
    pupils: number;
    sessions: number;
    staffs: number;
  };

  export type UserCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    assetDamages?: boolean | UserCountOutputTypeCountAssetDamagesArgs;
    assetRepairPayments?:
      | boolean
      | UserCountOutputTypeCountAssetRepairPaymentsArgs;
    borrowers?: boolean | UserCountOutputTypeCountBorrowersArgs;
    emailVerificationTokens?:
      | boolean
      | UserCountOutputTypeCountEmailVerificationTokensArgs;
    feesPayments?: boolean | UserCountOutputTypeCountFeesPaymentsArgs;
    pupils?: boolean | UserCountOutputTypeCountPupilsArgs;
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs;
    staffs?: boolean | UserCountOutputTypeCountStaffsArgs;
  };

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAssetDamagesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AssetDamageWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAssetRepairPaymentsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AssetRepairPaymentWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBorrowersArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: BorrowerWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEmailVerificationTokensArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: EmailVerificationTokenWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFeesPaymentsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: FeesPaymentWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPupilsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: PupilWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: SessionWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountStaffsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: StaffWhereInput;
  };

  /**
   * Count Type PupilCountOutputType
   */

  export type PupilCountOutputType = {
    classStreams: number;
    examScores: number;
    fees: number;
  };

  export type PupilCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    classStreams?: boolean | PupilCountOutputTypeCountClassStreamsArgs;
    examScores?: boolean | PupilCountOutputTypeCountExamScoresArgs;
    fees?: boolean | PupilCountOutputTypeCountFeesArgs;
  };

  // Custom InputTypes
  /**
   * PupilCountOutputType without action
   */
  export type PupilCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PupilCountOutputType
     */
    select?: PupilCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * PupilCountOutputType without action
   */
  export type PupilCountOutputTypeCountClassStreamsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: classStreamWhereInput;
  };

  /**
   * PupilCountOutputType without action
   */
  export type PupilCountOutputTypeCountExamScoresArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ExamScoreWhereInput;
  };

  /**
   * PupilCountOutputType without action
   */
  export type PupilCountOutputTypeCountFeesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: FeesWhereInput;
  };

  /**
   * Count Type StaffCountOutputType
   */

  export type StaffCountOutputType = {
    academicYearSubjects: number;
    classStreams: number;
  };

  export type StaffCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    academicYearSubjects?:
      | boolean
      | StaffCountOutputTypeCountAcademicYearSubjectsArgs;
    classStreams?: boolean | StaffCountOutputTypeCountClassStreamsArgs;
  };

  // Custom InputTypes
  /**
   * StaffCountOutputType without action
   */
  export type StaffCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the StaffCountOutputType
     */
    select?: StaffCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * StaffCountOutputType without action
   */
  export type StaffCountOutputTypeCountAcademicYearSubjectsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AcademicYearSubjectWhereInput;
  };

  /**
   * StaffCountOutputType without action
   */
  export type StaffCountOutputTypeCountClassStreamsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: classStreamWhereInput;
  };

  /**
   * Count Type LevelCountOutputType
   */

  export type LevelCountOutputType = {
    classes: number;
    subjects: number;
  };

  export type LevelCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    classes?: boolean | LevelCountOutputTypeCountClassesArgs;
    subjects?: boolean | LevelCountOutputTypeCountSubjectsArgs;
  };

  // Custom InputTypes
  /**
   * LevelCountOutputType without action
   */
  export type LevelCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LevelCountOutputType
     */
    select?: LevelCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * LevelCountOutputType without action
   */
  export type LevelCountOutputTypeCountClassesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ClassWhereInput;
  };

  /**
   * LevelCountOutputType without action
   */
  export type LevelCountOutputTypeCountSubjectsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: SubjectWhereInput;
  };

  /**
   * Count Type StreamCountOutputType
   */

  export type StreamCountOutputType = {
    classStreams: number;
  };

  export type StreamCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    classStreams?: boolean | StreamCountOutputTypeCountClassStreamsArgs;
  };

  // Custom InputTypes
  /**
   * StreamCountOutputType without action
   */
  export type StreamCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the StreamCountOutputType
     */
    select?: StreamCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * StreamCountOutputType without action
   */
  export type StreamCountOutputTypeCountClassStreamsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: classStreamWhereInput;
  };

  /**
   * Count Type ClassCountOutputType
   */

  export type ClassCountOutputType = {
    academicYearClasses: number;
  };

  export type ClassCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    academicYearClasses?:
      | boolean
      | ClassCountOutputTypeCountAcademicYearClassesArgs;
  };

  // Custom InputTypes
  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ClassCountOutputType
     */
    select?: ClassCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeCountAcademicYearClassesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AcademicYearClassWhereInput;
  };

  /**
   * Count Type AcademicYearCountOutputType
   */

  export type AcademicYearCountOutputType = {
    academicYearClasses: number;
  };

  export type AcademicYearCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    academicYearClasses?:
      | boolean
      | AcademicYearCountOutputTypeCountAcademicYearClassesArgs;
  };

  // Custom InputTypes
  /**
   * AcademicYearCountOutputType without action
   */
  export type AcademicYearCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AcademicYearCountOutputType
     */
    select?: AcademicYearCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * AcademicYearCountOutputType without action
   */
  export type AcademicYearCountOutputTypeCountAcademicYearClassesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AcademicYearClassWhereInput;
  };

  /**
   * Count Type AcademicYearClassCountOutputType
   */

  export type AcademicYearClassCountOutputType = {
    academicYearSubjects: number;
    streams: number;
  };

  export type AcademicYearClassCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    academicYearSubjects?:
      | boolean
      | AcademicYearClassCountOutputTypeCountAcademicYearSubjectsArgs;
    streams?: boolean | AcademicYearClassCountOutputTypeCountStreamsArgs;
  };

  // Custom InputTypes
  /**
   * AcademicYearClassCountOutputType without action
   */
  export type AcademicYearClassCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AcademicYearClassCountOutputType
     */
    select?: AcademicYearClassCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * AcademicYearClassCountOutputType without action
   */
  export type AcademicYearClassCountOutputTypeCountAcademicYearSubjectsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AcademicYearSubjectWhereInput;
  };

  /**
   * AcademicYearClassCountOutputType without action
   */
  export type AcademicYearClassCountOutputTypeCountStreamsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: classStreamWhereInput;
  };

  /**
   * Count Type SubjectCountOutputType
   */

  export type SubjectCountOutputType = {
    grading: number;
    academicYearSubjects: number;
  };

  export type SubjectCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    grading?: boolean | SubjectCountOutputTypeCountGradingArgs;
    academicYearSubjects?:
      | boolean
      | SubjectCountOutputTypeCountAcademicYearSubjectsArgs;
  };

  // Custom InputTypes
  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SubjectCountOutputType
     */
    select?: SubjectCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeCountGradingArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: GradingWhereInput;
  };

  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeCountAcademicYearSubjectsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AcademicYearSubjectWhereInput;
  };

  /**
   * Count Type GradingCountOutputType
   */

  export type GradingCountOutputType = {
    subjects: number;
    academicYearSubjects: number;
  };

  export type GradingCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    subjects?: boolean | GradingCountOutputTypeCountSubjectsArgs;
    academicYearSubjects?:
      | boolean
      | GradingCountOutputTypeCountAcademicYearSubjectsArgs;
  };

  // Custom InputTypes
  /**
   * GradingCountOutputType without action
   */
  export type GradingCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the GradingCountOutputType
     */
    select?: GradingCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * GradingCountOutputType without action
   */
  export type GradingCountOutputTypeCountSubjectsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: SubjectWhereInput;
  };

  /**
   * GradingCountOutputType without action
   */
  export type GradingCountOutputTypeCountAcademicYearSubjectsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AcademicYearSubjectWhereInput;
  };

  /**
   * Count Type AcademicYearSubjectCountOutputType
   */

  export type AcademicYearSubjectCountOutputType = {
    customGrading: number;
    teachers: number;
    examSubjects: number;
  };

  export type AcademicYearSubjectCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    customGrading?:
      | boolean
      | AcademicYearSubjectCountOutputTypeCountCustomGradingArgs;
    teachers?: boolean | AcademicYearSubjectCountOutputTypeCountTeachersArgs;
    examSubjects?:
      | boolean
      | AcademicYearSubjectCountOutputTypeCountExamSubjectsArgs;
  };

  // Custom InputTypes
  /**
   * AcademicYearSubjectCountOutputType without action
   */
  export type AcademicYearSubjectCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AcademicYearSubjectCountOutputType
     */
    select?: AcademicYearSubjectCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * AcademicYearSubjectCountOutputType without action
   */
  export type AcademicYearSubjectCountOutputTypeCountCustomGradingArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: GradingWhereInput;
  };

  /**
   * AcademicYearSubjectCountOutputType without action
   */
  export type AcademicYearSubjectCountOutputTypeCountTeachersArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: StaffWhereInput;
  };

  /**
   * AcademicYearSubjectCountOutputType without action
   */
  export type AcademicYearSubjectCountOutputTypeCountExamSubjectsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ExamSubjectWhereInput;
  };

  /**
   * Count Type ClassStreamCountOutputType
   */

  export type ClassStreamCountOutputType = {
    pupils: number;
    terms: number;
  };

  export type ClassStreamCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    pupils?: boolean | ClassStreamCountOutputTypeCountPupilsArgs;
    terms?: boolean | ClassStreamCountOutputTypeCountTermsArgs;
  };

  // Custom InputTypes
  /**
   * ClassStreamCountOutputType without action
   */
  export type ClassStreamCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ClassStreamCountOutputType
     */
    select?: ClassStreamCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * ClassStreamCountOutputType without action
   */
  export type ClassStreamCountOutputTypeCountPupilsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: PupilWhereInput;
  };

  /**
   * ClassStreamCountOutputType without action
   */
  export type ClassStreamCountOutputTypeCountTermsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ClassTermWhereInput;
  };

  /**
   * Count Type TermCountOutputType
   */

  export type TermCountOutputType = {
    classTerms: number;
  };

  export type TermCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    classTerms?: boolean | TermCountOutputTypeCountClassTermsArgs;
  };

  // Custom InputTypes
  /**
   * TermCountOutputType without action
   */
  export type TermCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TermCountOutputType
     */
    select?: TermCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * TermCountOutputType without action
   */
  export type TermCountOutputTypeCountClassTermsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ClassTermWhereInput;
  };

  /**
   * Count Type ClassTermCountOutputType
   */

  export type ClassTermCountOutputType = {
    exams: number;
    fees: number;
  };

  export type ClassTermCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    exams?: boolean | ClassTermCountOutputTypeCountExamsArgs;
    fees?: boolean | ClassTermCountOutputTypeCountFeesArgs;
  };

  // Custom InputTypes
  /**
   * ClassTermCountOutputType without action
   */
  export type ClassTermCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ClassTermCountOutputType
     */
    select?: ClassTermCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * ClassTermCountOutputType without action
   */
  export type ClassTermCountOutputTypeCountExamsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ExamWhereInput;
  };

  /**
   * ClassTermCountOutputType without action
   */
  export type ClassTermCountOutputTypeCountFeesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: FeesWhereInput;
  };

  /**
   * Count Type FeesCountOutputType
   */

  export type FeesCountOutputType = {
    feesPayments: number;
  };

  export type FeesCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    feesPayments?: boolean | FeesCountOutputTypeCountFeesPaymentsArgs;
  };

  // Custom InputTypes
  /**
   * FeesCountOutputType without action
   */
  export type FeesCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FeesCountOutputType
     */
    select?: FeesCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * FeesCountOutputType without action
   */
  export type FeesCountOutputTypeCountFeesPaymentsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: FeesPaymentWhereInput;
  };

  /**
   * Count Type AssetCountOutputType
   */

  export type AssetCountOutputType = {
    computerLabItems: number;
    foodStoreItems: number;
    generalStoreItems: number;
    labItems: number;
    libraryBooks: number;
  };

  export type AssetCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    computerLabItems?: boolean | AssetCountOutputTypeCountComputerLabItemsArgs;
    foodStoreItems?: boolean | AssetCountOutputTypeCountFoodStoreItemsArgs;
    generalStoreItems?:
      | boolean
      | AssetCountOutputTypeCountGeneralStoreItemsArgs;
    labItems?: boolean | AssetCountOutputTypeCountLabItemsArgs;
    libraryBooks?: boolean | AssetCountOutputTypeCountLibraryBooksArgs;
  };

  // Custom InputTypes
  /**
   * AssetCountOutputType without action
   */
  export type AssetCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AssetCountOutputType
     */
    select?: AssetCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * AssetCountOutputType without action
   */
  export type AssetCountOutputTypeCountComputerLabItemsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ComputerLabItemWhereInput;
  };

  /**
   * AssetCountOutputType without action
   */
  export type AssetCountOutputTypeCountFoodStoreItemsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: FoodStoreItemWhereInput;
  };

  /**
   * AssetCountOutputType without action
   */
  export type AssetCountOutputTypeCountGeneralStoreItemsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: GeneralStoreItemWhereInput;
  };

  /**
   * AssetCountOutputType without action
   */
  export type AssetCountOutputTypeCountLabItemsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: LabItemWhereInput;
  };

  /**
   * AssetCountOutputType without action
   */
  export type AssetCountOutputTypeCountLibraryBooksArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: LibraryBookWhereInput;
  };

  /**
   * Count Type FoodStoreItemCountOutputType
   */

  export type FoodStoreItemCountOutputType = {
    consumptions: number;
    individualFoodStoreItems: number;
  };

  export type FoodStoreItemCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    consumptions?: boolean | FoodStoreItemCountOutputTypeCountConsumptionsArgs;
    individualFoodStoreItems?:
      | boolean
      | FoodStoreItemCountOutputTypeCountIndividualFoodStoreItemsArgs;
  };

  // Custom InputTypes
  /**
   * FoodStoreItemCountOutputType without action
   */
  export type FoodStoreItemCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FoodStoreItemCountOutputType
     */
    select?: FoodStoreItemCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * FoodStoreItemCountOutputType without action
   */
  export type FoodStoreItemCountOutputTypeCountConsumptionsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: FoodConsumptionWhereInput;
  };

  /**
   * FoodStoreItemCountOutputType without action
   */
  export type FoodStoreItemCountOutputTypeCountIndividualFoodStoreItemsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: IndividualFoodStoreItemWhereInput;
  };

  /**
   * Count Type IndividualFoodStoreItemCountOutputType
   */

  export type IndividualFoodStoreItemCountOutputType = {
    assetDamages: number;
  };

  export type IndividualFoodStoreItemCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    assetDamages?:
      | boolean
      | IndividualFoodStoreItemCountOutputTypeCountAssetDamagesArgs;
  };

  // Custom InputTypes
  /**
   * IndividualFoodStoreItemCountOutputType without action
   */
  export type IndividualFoodStoreItemCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IndividualFoodStoreItemCountOutputType
     */
    select?: IndividualFoodStoreItemCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * IndividualFoodStoreItemCountOutputType without action
   */
  export type IndividualFoodStoreItemCountOutputTypeCountAssetDamagesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AssetDamageWhereInput;
  };

  /**
   * Count Type SupplierCountOutputType
   */

  export type SupplierCountOutputType = {
    foodStoreItems: number;
  };

  export type SupplierCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    foodStoreItems?: boolean | SupplierCountOutputTypeCountFoodStoreItemsArgs;
  };

  // Custom InputTypes
  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SupplierCountOutputType
     */
    select?: SupplierCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeCountFoodStoreItemsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: FoodStoreItemWhereInput;
  };

  /**
   * Count Type LibraryBookCountOutputType
   */

  export type LibraryBookCountOutputType = {
    individualBooks: number;
  };

  export type LibraryBookCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    individualBooks?:
      | boolean
      | LibraryBookCountOutputTypeCountIndividualBooksArgs;
  };

  // Custom InputTypes
  /**
   * LibraryBookCountOutputType without action
   */
  export type LibraryBookCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LibraryBookCountOutputType
     */
    select?: LibraryBookCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * LibraryBookCountOutputType without action
   */
  export type LibraryBookCountOutputTypeCountIndividualBooksArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: IndividualBookWhereInput;
  };

  /**
   * Count Type IndividualBookCountOutputType
   */

  export type IndividualBookCountOutputType = {
    bookDamages: number;
    borrowers: number;
  };

  export type IndividualBookCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    bookDamages?: boolean | IndividualBookCountOutputTypeCountBookDamagesArgs;
    borrowers?: boolean | IndividualBookCountOutputTypeCountBorrowersArgs;
  };

  // Custom InputTypes
  /**
   * IndividualBookCountOutputType without action
   */
  export type IndividualBookCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IndividualBookCountOutputType
     */
    select?: IndividualBookCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * IndividualBookCountOutputType without action
   */
  export type IndividualBookCountOutputTypeCountBookDamagesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AssetDamageWhereInput;
  };

  /**
   * IndividualBookCountOutputType without action
   */
  export type IndividualBookCountOutputTypeCountBorrowersArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: BorrowerWhereInput;
  };

  /**
   * Count Type LibraryBookCategoryCountOutputType
   */

  export type LibraryBookCategoryCountOutputType = {
    libraryBooks: number;
  };

  export type LibraryBookCategoryCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    libraryBooks?:
      | boolean
      | LibraryBookCategoryCountOutputTypeCountLibraryBooksArgs;
  };

  // Custom InputTypes
  /**
   * LibraryBookCategoryCountOutputType without action
   */
  export type LibraryBookCategoryCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LibraryBookCategoryCountOutputType
     */
    select?: LibraryBookCategoryCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * LibraryBookCategoryCountOutputType without action
   */
  export type LibraryBookCategoryCountOutputTypeCountLibraryBooksArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: LibraryBookWhereInput;
  };

  /**
   * Count Type LabItemCountOutputType
   */

  export type LabItemCountOutputType = {
    individualLabItems: number;
  };

  export type LabItemCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    individualLabItems?:
      | boolean
      | LabItemCountOutputTypeCountIndividualLabItemsArgs;
  };

  // Custom InputTypes
  /**
   * LabItemCountOutputType without action
   */
  export type LabItemCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LabItemCountOutputType
     */
    select?: LabItemCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * LabItemCountOutputType without action
   */
  export type LabItemCountOutputTypeCountIndividualLabItemsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: IndividualLabItemWhereInput;
  };

  /**
   * Count Type IndividualLabItemCountOutputType
   */

  export type IndividualLabItemCountOutputType = {
    assetDamages: number;
  };

  export type IndividualLabItemCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    assetDamages?:
      | boolean
      | IndividualLabItemCountOutputTypeCountAssetDamagesArgs;
  };

  // Custom InputTypes
  /**
   * IndividualLabItemCountOutputType without action
   */
  export type IndividualLabItemCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IndividualLabItemCountOutputType
     */
    select?: IndividualLabItemCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * IndividualLabItemCountOutputType without action
   */
  export type IndividualLabItemCountOutputTypeCountAssetDamagesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AssetDamageWhereInput;
  };

  /**
   * Count Type ComputerLabItemCountOutputType
   */

  export type ComputerLabItemCountOutputType = {
    individualComputerLabItems: number;
  };

  export type ComputerLabItemCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    individualComputerLabItems?:
      | boolean
      | ComputerLabItemCountOutputTypeCountIndividualComputerLabItemsArgs;
  };

  // Custom InputTypes
  /**
   * ComputerLabItemCountOutputType without action
   */
  export type ComputerLabItemCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ComputerLabItemCountOutputType
     */
    select?: ComputerLabItemCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * ComputerLabItemCountOutputType without action
   */
  export type ComputerLabItemCountOutputTypeCountIndividualComputerLabItemsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: IndividualComputerLabItemWhereInput;
  };

  /**
   * Count Type IndividualComputerLabItemCountOutputType
   */

  export type IndividualComputerLabItemCountOutputType = {
    assetDamages: number;
  };

  export type IndividualComputerLabItemCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    assetDamages?:
      | boolean
      | IndividualComputerLabItemCountOutputTypeCountAssetDamagesArgs;
  };

  // Custom InputTypes
  /**
   * IndividualComputerLabItemCountOutputType without action
   */
  export type IndividualComputerLabItemCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IndividualComputerLabItemCountOutputType
     */
    select?: IndividualComputerLabItemCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * IndividualComputerLabItemCountOutputType without action
   */
  export type IndividualComputerLabItemCountOutputTypeCountAssetDamagesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AssetDamageWhereInput;
  };

  /**
   * Count Type GeneralStoreItemCountOutputType
   */

  export type GeneralStoreItemCountOutputType = {
    individualGeneralStoreItems: number;
  };

  export type GeneralStoreItemCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    individualGeneralStoreItems?:
      | boolean
      | GeneralStoreItemCountOutputTypeCountIndividualGeneralStoreItemsArgs;
  };

  // Custom InputTypes
  /**
   * GeneralStoreItemCountOutputType without action
   */
  export type GeneralStoreItemCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the GeneralStoreItemCountOutputType
     */
    select?: GeneralStoreItemCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * GeneralStoreItemCountOutputType without action
   */
  export type GeneralStoreItemCountOutputTypeCountIndividualGeneralStoreItemsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: IndividualGeneralStoreItemWhereInput;
  };

  /**
   * Count Type IndividualGeneralStoreItemCountOutputType
   */

  export type IndividualGeneralStoreItemCountOutputType = {
    assetDamages: number;
  };

  export type IndividualGeneralStoreItemCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    assetDamages?:
      | boolean
      | IndividualGeneralStoreItemCountOutputTypeCountAssetDamagesArgs;
  };

  // Custom InputTypes
  /**
   * IndividualGeneralStoreItemCountOutputType without action
   */
  export type IndividualGeneralStoreItemCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IndividualGeneralStoreItemCountOutputType
     */
    select?: IndividualGeneralStoreItemCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * IndividualGeneralStoreItemCountOutputType without action
   */
  export type IndividualGeneralStoreItemCountOutputTypeCountAssetDamagesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AssetDamageWhereInput;
  };

  /**
   * Count Type AssetDamageCountOutputType
   */

  export type AssetDamageCountOutputType = {
    assetRepairPayments: number;
  };

  export type AssetDamageCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    assetRepairPayments?:
      | boolean
      | AssetDamageCountOutputTypeCountAssetRepairPaymentsArgs;
  };

  // Custom InputTypes
  /**
   * AssetDamageCountOutputType without action
   */
  export type AssetDamageCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AssetDamageCountOutputType
     */
    select?: AssetDamageCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * AssetDamageCountOutputType without action
   */
  export type AssetDamageCountOutputTypeCountAssetRepairPaymentsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AssetRepairPaymentWhereInput;
  };

  /**
   * Count Type ExamCountOutputType
   */

  export type ExamCountOutputType = {
    examSubjects: number;
  };

  export type ExamCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    examSubjects?: boolean | ExamCountOutputTypeCountExamSubjectsArgs;
  };

  // Custom InputTypes
  /**
   * ExamCountOutputType without action
   */
  export type ExamCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ExamCountOutputType
     */
    select?: ExamCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * ExamCountOutputType without action
   */
  export type ExamCountOutputTypeCountExamSubjectsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ExamSubjectWhereInput;
  };

  /**
   * Count Type ExamSubjectCountOutputType
   */

  export type ExamSubjectCountOutputType = {
    examScores: number;
  };

  export type ExamSubjectCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    examScores?: boolean | ExamSubjectCountOutputTypeCountExamScoresArgs;
  };

  // Custom InputTypes
  /**
   * ExamSubjectCountOutputType without action
   */
  export type ExamSubjectCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ExamSubjectCountOutputType
     */
    select?: ExamSubjectCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * ExamSubjectCountOutputType without action
   */
  export type ExamSubjectCountOutputTypeCountExamScoresArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ExamScoreWhereInput;
  };

  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null;
    _min: UserMinAggregateOutputType | null;
    _max: UserMaxAggregateOutputType | null;
  };

  export type UserMinAggregateOutputType = {
    id: string | null;
    name: string | null;
    username: string | null;
    email: string | null;
    avatarUrl: string | null;
    role: $Enums.Role | null;
    createdAt: Date | null;
    telephone: string | null;
    passwordHash: string | null;
    googleId: string | null;
    bio: string | null;
    isWelcomed: boolean | null;
    isVerified: boolean | null;
    emailVerified: boolean | null;
  };

  export type UserMaxAggregateOutputType = {
    id: string | null;
    name: string | null;
    username: string | null;
    email: string | null;
    avatarUrl: string | null;
    role: $Enums.Role | null;
    createdAt: Date | null;
    telephone: string | null;
    passwordHash: string | null;
    googleId: string | null;
    bio: string | null;
    isWelcomed: boolean | null;
    isVerified: boolean | null;
    emailVerified: boolean | null;
  };

  export type UserCountAggregateOutputType = {
    id: number;
    name: number;
    username: number;
    email: number;
    avatarUrl: number;
    role: number;
    createdAt: number;
    telephone: number;
    passwordHash: number;
    googleId: number;
    bio: number;
    isWelcomed: number;
    isVerified: number;
    emailVerified: number;
    _all: number;
  };

  export type UserMinAggregateInputType = {
    id?: true;
    name?: true;
    username?: true;
    email?: true;
    avatarUrl?: true;
    role?: true;
    createdAt?: true;
    telephone?: true;
    passwordHash?: true;
    googleId?: true;
    bio?: true;
    isWelcomed?: true;
    isVerified?: true;
    emailVerified?: true;
  };

  export type UserMaxAggregateInputType = {
    id?: true;
    name?: true;
    username?: true;
    email?: true;
    avatarUrl?: true;
    role?: true;
    createdAt?: true;
    telephone?: true;
    passwordHash?: true;
    googleId?: true;
    bio?: true;
    isWelcomed?: true;
    isVerified?: true;
    emailVerified?: true;
  };

  export type UserCountAggregateInputType = {
    id?: true;
    name?: true;
    username?: true;
    email?: true;
    avatarUrl?: true;
    role?: true;
    createdAt?: true;
    telephone?: true;
    passwordHash?: true;
    googleId?: true;
    bio?: true;
    isWelcomed?: true;
    isVerified?: true;
    emailVerified?: true;
    _all?: true;
  };

  export type UserAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Users from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Users
     **/
    _count?: true | UserCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: UserMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: UserMaxAggregateInputType;
  };

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
    [P in keyof T & keyof AggregateUser]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>;
  };

  export type UserGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: UserWhereInput;
    orderBy?:
      | UserOrderByWithAggregationInput
      | UserOrderByWithAggregationInput[];
    by: UserScalarFieldEnum[] | UserScalarFieldEnum;
    having?: UserScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: UserCountAggregateInputType | true;
    _min?: UserMinAggregateInputType;
    _max?: UserMaxAggregateInputType;
  };

  export type UserGroupByOutputType = {
    id: string;
    name: string | null;
    username: string | null;
    email: string | null;
    avatarUrl: string | null;
    role: $Enums.Role | null;
    createdAt: Date;
    telephone: string | null;
    passwordHash: string | null;
    googleId: string | null;
    bio: string | null;
    isWelcomed: boolean;
    isVerified: boolean;
    emailVerified: boolean;
    _count: UserCountAggregateOutputType | null;
    _min: UserMinAggregateOutputType | null;
    _max: UserMaxAggregateOutputType | null;
  };

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T["by"]> & {
        [P in keyof T & keyof UserGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], UserGroupByOutputType[P]>
          : GetScalarType<T[P], UserGroupByOutputType[P]>;
      }
    >
  >;

  export type UserSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      username?: boolean;
      email?: boolean;
      avatarUrl?: boolean;
      role?: boolean;
      createdAt?: boolean;
      telephone?: boolean;
      passwordHash?: boolean;
      googleId?: boolean;
      bio?: boolean;
      isWelcomed?: boolean;
      isVerified?: boolean;
      emailVerified?: boolean;
      assetDamages?: boolean | User$assetDamagesArgs<ExtArgs>;
      assetRepairPayments?: boolean | User$assetRepairPaymentsArgs<ExtArgs>;
      borrowers?: boolean | User$borrowersArgs<ExtArgs>;
      emailVerificationTokens?:
        | boolean
        | User$emailVerificationTokensArgs<ExtArgs>;
      feesPayments?: boolean | User$feesPaymentsArgs<ExtArgs>;
      pupils?: boolean | User$pupilsArgs<ExtArgs>;
      sessions?: boolean | User$sessionsArgs<ExtArgs>;
      staffs?: boolean | User$staffsArgs<ExtArgs>;
      _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["user"]
  >;

  export type UserSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      username?: boolean;
      email?: boolean;
      avatarUrl?: boolean;
      role?: boolean;
      createdAt?: boolean;
      telephone?: boolean;
      passwordHash?: boolean;
      googleId?: boolean;
      bio?: boolean;
      isWelcomed?: boolean;
      isVerified?: boolean;
      emailVerified?: boolean;
    },
    ExtArgs["result"]["user"]
  >;

  export type UserSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      username?: boolean;
      email?: boolean;
      avatarUrl?: boolean;
      role?: boolean;
      createdAt?: boolean;
      telephone?: boolean;
      passwordHash?: boolean;
      googleId?: boolean;
      bio?: boolean;
      isWelcomed?: boolean;
      isVerified?: boolean;
      emailVerified?: boolean;
    },
    ExtArgs["result"]["user"]
  >;

  export type UserSelectScalar = {
    id?: boolean;
    name?: boolean;
    username?: boolean;
    email?: boolean;
    avatarUrl?: boolean;
    role?: boolean;
    createdAt?: boolean;
    telephone?: boolean;
    passwordHash?: boolean;
    googleId?: boolean;
    bio?: boolean;
    isWelcomed?: boolean;
    isVerified?: boolean;
    emailVerified?: boolean;
  };

  export type UserOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | "id"
    | "name"
    | "username"
    | "email"
    | "avatarUrl"
    | "role"
    | "createdAt"
    | "telephone"
    | "passwordHash"
    | "googleId"
    | "bio"
    | "isWelcomed"
    | "isVerified"
    | "emailVerified",
    ExtArgs["result"]["user"]
  >;
  export type UserInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    assetDamages?: boolean | User$assetDamagesArgs<ExtArgs>;
    assetRepairPayments?: boolean | User$assetRepairPaymentsArgs<ExtArgs>;
    borrowers?: boolean | User$borrowersArgs<ExtArgs>;
    emailVerificationTokens?:
      | boolean
      | User$emailVerificationTokensArgs<ExtArgs>;
    feesPayments?: boolean | User$feesPaymentsArgs<ExtArgs>;
    pupils?: boolean | User$pupilsArgs<ExtArgs>;
    sessions?: boolean | User$sessionsArgs<ExtArgs>;
    staffs?: boolean | User$staffsArgs<ExtArgs>;
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type UserIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};
  export type UserIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};

  export type $UserPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "User";
    objects: {
      assetDamages: Prisma.$AssetDamagePayload<ExtArgs>[];
      assetRepairPayments: Prisma.$AssetRepairPaymentPayload<ExtArgs>[];
      borrowers: Prisma.$BorrowerPayload<ExtArgs>[];
      emailVerificationTokens: Prisma.$EmailVerificationTokenPayload<ExtArgs>[];
      feesPayments: Prisma.$FeesPaymentPayload<ExtArgs>[];
      pupils: Prisma.$PupilPayload<ExtArgs>[];
      sessions: Prisma.$SessionPayload<ExtArgs>[];
      staffs: Prisma.$StaffPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        name: string | null;
        username: string | null;
        email: string | null;
        avatarUrl: string | null;
        role: $Enums.Role | null;
        createdAt: Date;
        telephone: string | null;
        passwordHash: string | null;
        googleId: string | null;
        bio: string | null;
        isWelcomed: boolean;
        isVerified: boolean;
        emailVerified: boolean;
      },
      ExtArgs["result"]["user"]
    >;
    composites: {};
  };

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> =
    $Result.GetResult<Prisma.$UserPayload, S>;

  type UserCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<UserFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
    select?: UserCountAggregateInputType | true;
  };

  export interface UserDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["User"];
      meta: { name: "User" };
    };
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(
      args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>,
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(
      args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(
      args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>,
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     *
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     *
     */
    findMany<T extends UserFindManyArgs>(
      args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     *
     */
    create<T extends UserCreateArgs>(
      args: SelectSubset<T, UserCreateArgs<ExtArgs>>,
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends UserCreateManyArgs>(
      args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(
      args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     *
     */
    delete<T extends UserDeleteArgs>(
      args: SelectSubset<T, UserDeleteArgs<ExtArgs>>,
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends UserUpdateArgs>(
      args: SelectSubset<T, UserUpdateArgs<ExtArgs>>,
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends UserDeleteManyArgs>(
      args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends UserUpdateManyArgs>(
      args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(
      args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(
      args: SelectSubset<T, UserUpsertArgs<ExtArgs>>,
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
     **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], UserCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends UserAggregateArgs>(
      args: Subset<T, UserAggregateArgs>,
    ): Prisma.PrismaPromise<GetUserAggregateType<T>>;

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs["orderBy"] }
        : { orderBy?: UserGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetUserGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the User model
     */
    readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    assetDamages<T extends User$assetDamagesArgs<ExtArgs> = {}>(
      args?: Subset<T, User$assetDamagesArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$AssetDamagePayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    assetRepairPayments<T extends User$assetRepairPaymentsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$assetRepairPaymentsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$AssetRepairPaymentPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    borrowers<T extends User$borrowersArgs<ExtArgs> = {}>(
      args?: Subset<T, User$borrowersArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$BorrowerPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    emailVerificationTokens<
      T extends User$emailVerificationTokensArgs<ExtArgs> = {},
    >(
      args?: Subset<T, User$emailVerificationTokensArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$EmailVerificationTokenPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    feesPayments<T extends User$feesPaymentsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$feesPaymentsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$FeesPaymentPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    pupils<T extends User$pupilsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$pupilsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$PupilPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$sessionsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$SessionPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    staffs<T extends User$staffsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$staffsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$StaffPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", "String">;
    readonly name: FieldRef<"User", "String">;
    readonly username: FieldRef<"User", "String">;
    readonly email: FieldRef<"User", "String">;
    readonly avatarUrl: FieldRef<"User", "String">;
    readonly role: FieldRef<"User", "Role">;
    readonly createdAt: FieldRef<"User", "DateTime">;
    readonly telephone: FieldRef<"User", "String">;
    readonly passwordHash: FieldRef<"User", "String">;
    readonly googleId: FieldRef<"User", "String">;
    readonly bio: FieldRef<"User", "String">;
    readonly isWelcomed: FieldRef<"User", "Boolean">;
    readonly isVerified: FieldRef<"User", "Boolean">;
    readonly emailVerified: FieldRef<"User", "Boolean">;
  }

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput;
  };

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput;
  };

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Users from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[];
  };

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Users from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[];
  };

  /**
   * User findMany
   */
  export type UserFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Users from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     */
    skip?: number;
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[];
  };

  /**
   * User create
   */
  export type UserCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * The data needed to create a User.
     */
    data?: XOR<UserCreateInput, UserUncheckedCreateInput>;
  };

  /**
   * User createMany
   */
  export type UserCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * User update
   */
  export type UserUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>;
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput;
  };

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>;
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput;
    /**
     * Limit how many Users to update.
     */
    limit?: number;
  };

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>;
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput;
    /**
     * Limit how many Users to update.
     */
    limit?: number;
  };

  /**
   * User upsert
   */
  export type UserUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput;
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>;
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>;
  };

  /**
   * User delete
   */
  export type UserDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput;
  };

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput;
    /**
     * Limit how many Users to delete.
     */
    limit?: number;
  };

  /**
   * User.assetDamages
   */
  export type User$assetDamagesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AssetDamage
     */
    select?: AssetDamageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AssetDamage
     */
    omit?: AssetDamageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetDamageInclude<ExtArgs> | null;
    where?: AssetDamageWhereInput;
    orderBy?:
      | AssetDamageOrderByWithRelationInput
      | AssetDamageOrderByWithRelationInput[];
    cursor?: AssetDamageWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: AssetDamageScalarFieldEnum | AssetDamageScalarFieldEnum[];
  };

  /**
   * User.assetRepairPayments
   */
  export type User$assetRepairPaymentsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AssetRepairPayment
     */
    select?: AssetRepairPaymentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AssetRepairPayment
     */
    omit?: AssetRepairPaymentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetRepairPaymentInclude<ExtArgs> | null;
    where?: AssetRepairPaymentWhereInput;
    orderBy?:
      | AssetRepairPaymentOrderByWithRelationInput
      | AssetRepairPaymentOrderByWithRelationInput[];
    cursor?: AssetRepairPaymentWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?:
      | AssetRepairPaymentScalarFieldEnum
      | AssetRepairPaymentScalarFieldEnum[];
  };

  /**
   * User.borrowers
   */
  export type User$borrowersArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Borrower
     */
    select?: BorrowerSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Borrower
     */
    omit?: BorrowerOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BorrowerInclude<ExtArgs> | null;
    where?: BorrowerWhereInput;
    orderBy?:
      | BorrowerOrderByWithRelationInput
      | BorrowerOrderByWithRelationInput[];
    cursor?: BorrowerWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: BorrowerScalarFieldEnum | BorrowerScalarFieldEnum[];
  };

  /**
   * User.emailVerificationTokens
   */
  export type User$emailVerificationTokensArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the EmailVerificationToken
     */
    select?: EmailVerificationTokenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the EmailVerificationToken
     */
    omit?: EmailVerificationTokenOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationTokenInclude<ExtArgs> | null;
    where?: EmailVerificationTokenWhereInput;
    orderBy?:
      | EmailVerificationTokenOrderByWithRelationInput
      | EmailVerificationTokenOrderByWithRelationInput[];
    cursor?: EmailVerificationTokenWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?:
      | EmailVerificationTokenScalarFieldEnum
      | EmailVerificationTokenScalarFieldEnum[];
  };

  /**
   * User.feesPayments
   */
  export type User$feesPaymentsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FeesPayment
     */
    select?: FeesPaymentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FeesPayment
     */
    omit?: FeesPaymentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeesPaymentInclude<ExtArgs> | null;
    where?: FeesPaymentWhereInput;
    orderBy?:
      | FeesPaymentOrderByWithRelationInput
      | FeesPaymentOrderByWithRelationInput[];
    cursor?: FeesPaymentWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: FeesPaymentScalarFieldEnum | FeesPaymentScalarFieldEnum[];
  };

  /**
   * User.pupils
   */
  export type User$pupilsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Pupil
     */
    select?: PupilSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Pupil
     */
    omit?: PupilOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PupilInclude<ExtArgs> | null;
    where?: PupilWhereInput;
    orderBy?: PupilOrderByWithRelationInput | PupilOrderByWithRelationInput[];
    cursor?: PupilWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: PupilScalarFieldEnum | PupilScalarFieldEnum[];
  };

  /**
   * User.sessions
   */
  export type User$sessionsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
    where?: SessionWhereInput;
    orderBy?:
      | SessionOrderByWithRelationInput
      | SessionOrderByWithRelationInput[];
    cursor?: SessionWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[];
  };

  /**
   * User.staffs
   */
  export type User$staffsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null;
    where?: StaffWhereInput;
    orderBy?: StaffOrderByWithRelationInput | StaffOrderByWithRelationInput[];
    cursor?: StaffWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: StaffScalarFieldEnum | StaffScalarFieldEnum[];
  };

  /**
   * User without action
   */
  export type UserDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
  };

  /**
   * Model EmailVerificationToken
   */

  export type AggregateEmailVerificationToken = {
    _count: EmailVerificationTokenCountAggregateOutputType | null;
    _avg: EmailVerificationTokenAvgAggregateOutputType | null;
    _sum: EmailVerificationTokenSumAggregateOutputType | null;
    _min: EmailVerificationTokenMinAggregateOutputType | null;
    _max: EmailVerificationTokenMaxAggregateOutputType | null;
  };

  export type EmailVerificationTokenAvgAggregateOutputType = {
    expires: number | null;
  };

  export type EmailVerificationTokenSumAggregateOutputType = {
    expires: bigint | null;
  };

  export type EmailVerificationTokenMinAggregateOutputType = {
    id: string | null;
    userId: string | null;
    expires: bigint | null;
  };

  export type EmailVerificationTokenMaxAggregateOutputType = {
    id: string | null;
    userId: string | null;
    expires: bigint | null;
  };

  export type EmailVerificationTokenCountAggregateOutputType = {
    id: number;
    userId: number;
    expires: number;
    _all: number;
  };

  export type EmailVerificationTokenAvgAggregateInputType = {
    expires?: true;
  };

  export type EmailVerificationTokenSumAggregateInputType = {
    expires?: true;
  };

  export type EmailVerificationTokenMinAggregateInputType = {
    id?: true;
    userId?: true;
    expires?: true;
  };

  export type EmailVerificationTokenMaxAggregateInputType = {
    id?: true;
    userId?: true;
    expires?: true;
  };

  export type EmailVerificationTokenCountAggregateInputType = {
    id?: true;
    userId?: true;
    expires?: true;
    _all?: true;
  };

  export type EmailVerificationTokenAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which EmailVerificationToken to aggregate.
     */
    where?: EmailVerificationTokenWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of EmailVerificationTokens to fetch.
     */
    orderBy?:
      | EmailVerificationTokenOrderByWithRelationInput
      | EmailVerificationTokenOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: EmailVerificationTokenWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` EmailVerificationTokens from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` EmailVerificationTokens.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned EmailVerificationTokens
     **/
    _count?: true | EmailVerificationTokenCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: EmailVerificationTokenAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: EmailVerificationTokenSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: EmailVerificationTokenMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: EmailVerificationTokenMaxAggregateInputType;
  };

  export type GetEmailVerificationTokenAggregateType<
    T extends EmailVerificationTokenAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateEmailVerificationToken]: P extends
      | "_count"
      | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailVerificationToken[P]>
      : GetScalarType<T[P], AggregateEmailVerificationToken[P]>;
  };

  export type EmailVerificationTokenGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: EmailVerificationTokenWhereInput;
    orderBy?:
      | EmailVerificationTokenOrderByWithAggregationInput
      | EmailVerificationTokenOrderByWithAggregationInput[];
    by:
      | EmailVerificationTokenScalarFieldEnum[]
      | EmailVerificationTokenScalarFieldEnum;
    having?: EmailVerificationTokenScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: EmailVerificationTokenCountAggregateInputType | true;
    _avg?: EmailVerificationTokenAvgAggregateInputType;
    _sum?: EmailVerificationTokenSumAggregateInputType;
    _min?: EmailVerificationTokenMinAggregateInputType;
    _max?: EmailVerificationTokenMaxAggregateInputType;
  };

  export type EmailVerificationTokenGroupByOutputType = {
    id: string;
    userId: string;
    expires: bigint;
    _count: EmailVerificationTokenCountAggregateOutputType | null;
    _avg: EmailVerificationTokenAvgAggregateOutputType | null;
    _sum: EmailVerificationTokenSumAggregateOutputType | null;
    _min: EmailVerificationTokenMinAggregateOutputType | null;
    _max: EmailVerificationTokenMaxAggregateOutputType | null;
  };

  type GetEmailVerificationTokenGroupByPayload<
    T extends EmailVerificationTokenGroupByArgs,
  > = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailVerificationTokenGroupByOutputType, T["by"]> & {
        [P in keyof T &
          keyof EmailVerificationTokenGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], EmailVerificationTokenGroupByOutputType[P]>
          : GetScalarType<T[P], EmailVerificationTokenGroupByOutputType[P]>;
      }
    >
  >;

  export type EmailVerificationTokenSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      expires?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["emailVerificationToken"]
  >;

  export type EmailVerificationTokenSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      expires?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["emailVerificationToken"]
  >;

  export type EmailVerificationTokenSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      expires?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["emailVerificationToken"]
  >;

  export type EmailVerificationTokenSelectScalar = {
    id?: boolean;
    userId?: boolean;
    expires?: boolean;
  };

  export type EmailVerificationTokenOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    "id" | "userId" | "expires",
    ExtArgs["result"]["emailVerificationToken"]
  >;
  export type EmailVerificationTokenInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type EmailVerificationTokenIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type EmailVerificationTokenIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $EmailVerificationTokenPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "EmailVerificationToken";
    objects: {
      user: Prisma.$UserPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        userId: string;
        expires: bigint;
      },
      ExtArgs["result"]["emailVerificationToken"]
    >;
    composites: {};
  };

  type EmailVerificationTokenGetPayload<
    S extends boolean | null | undefined | EmailVerificationTokenDefaultArgs,
  > = $Result.GetResult<Prisma.$EmailVerificationTokenPayload, S>;

  type EmailVerificationTokenCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    EmailVerificationTokenFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: EmailVerificationTokenCountAggregateInputType | true;
  };

  export interface EmailVerificationTokenDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["EmailVerificationToken"];
      meta: { name: "EmailVerificationToken" };
    };
    /**
     * Find zero or one EmailVerificationToken that matches the filter.
     * @param {EmailVerificationTokenFindUniqueArgs} args - Arguments to find a EmailVerificationToken
     * @example
     * // Get one EmailVerificationToken
     * const emailVerificationToken = await prisma.emailVerificationToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmailVerificationTokenFindUniqueArgs>(
      args: SelectSubset<T, EmailVerificationTokenFindUniqueArgs<ExtArgs>>,
    ): Prisma__EmailVerificationTokenClient<
      $Result.GetResult<
        Prisma.$EmailVerificationTokenPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one EmailVerificationToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmailVerificationTokenFindUniqueOrThrowArgs} args - Arguments to find a EmailVerificationToken
     * @example
     * // Get one EmailVerificationToken
     * const emailVerificationToken = await prisma.emailVerificationToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmailVerificationTokenFindUniqueOrThrowArgs>(
      args: SelectSubset<
        T,
        EmailVerificationTokenFindUniqueOrThrowArgs<ExtArgs>
      >,
    ): Prisma__EmailVerificationTokenClient<
      $Result.GetResult<
        Prisma.$EmailVerificationTokenPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first EmailVerificationToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailVerificationTokenFindFirstArgs} args - Arguments to find a EmailVerificationToken
     * @example
     * // Get one EmailVerificationToken
     * const emailVerificationToken = await prisma.emailVerificationToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmailVerificationTokenFindFirstArgs>(
      args?: SelectSubset<T, EmailVerificationTokenFindFirstArgs<ExtArgs>>,
    ): Prisma__EmailVerificationTokenClient<
      $Result.GetResult<
        Prisma.$EmailVerificationTokenPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first EmailVerificationToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailVerificationTokenFindFirstOrThrowArgs} args - Arguments to find a EmailVerificationToken
     * @example
     * // Get one EmailVerificationToken
     * const emailVerificationToken = await prisma.emailVerificationToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmailVerificationTokenFindFirstOrThrowArgs>(
      args?: SelectSubset<
        T,
        EmailVerificationTokenFindFirstOrThrowArgs<ExtArgs>
      >,
    ): Prisma__EmailVerificationTokenClient<
      $Result.GetResult<
        Prisma.$EmailVerificationTokenPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more EmailVerificationTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailVerificationTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailVerificationTokens
     * const emailVerificationTokens = await prisma.emailVerificationToken.findMany()
     *
     * // Get first 10 EmailVerificationTokens
     * const emailVerificationTokens = await prisma.emailVerificationToken.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const emailVerificationTokenWithIdOnly = await prisma.emailVerificationToken.findMany({ select: { id: true } })
     *
     */
    findMany<T extends EmailVerificationTokenFindManyArgs>(
      args?: SelectSubset<T, EmailVerificationTokenFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$EmailVerificationTokenPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a EmailVerificationToken.
     * @param {EmailVerificationTokenCreateArgs} args - Arguments to create a EmailVerificationToken.
     * @example
     * // Create one EmailVerificationToken
     * const EmailVerificationToken = await prisma.emailVerificationToken.create({
     *   data: {
     *     // ... data to create a EmailVerificationToken
     *   }
     * })
     *
     */
    create<T extends EmailVerificationTokenCreateArgs>(
      args: SelectSubset<T, EmailVerificationTokenCreateArgs<ExtArgs>>,
    ): Prisma__EmailVerificationTokenClient<
      $Result.GetResult<
        Prisma.$EmailVerificationTokenPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many EmailVerificationTokens.
     * @param {EmailVerificationTokenCreateManyArgs} args - Arguments to create many EmailVerificationTokens.
     * @example
     * // Create many EmailVerificationTokens
     * const emailVerificationToken = await prisma.emailVerificationToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends EmailVerificationTokenCreateManyArgs>(
      args?: SelectSubset<T, EmailVerificationTokenCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many EmailVerificationTokens and returns the data saved in the database.
     * @param {EmailVerificationTokenCreateManyAndReturnArgs} args - Arguments to create many EmailVerificationTokens.
     * @example
     * // Create many EmailVerificationTokens
     * const emailVerificationToken = await prisma.emailVerificationToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many EmailVerificationTokens and only return the `id`
     * const emailVerificationTokenWithIdOnly = await prisma.emailVerificationToken.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<
      T extends EmailVerificationTokenCreateManyAndReturnArgs,
    >(
      args?: SelectSubset<
        T,
        EmailVerificationTokenCreateManyAndReturnArgs<ExtArgs>
      >,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$EmailVerificationTokenPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a EmailVerificationToken.
     * @param {EmailVerificationTokenDeleteArgs} args - Arguments to delete one EmailVerificationToken.
     * @example
     * // Delete one EmailVerificationToken
     * const EmailVerificationToken = await prisma.emailVerificationToken.delete({
     *   where: {
     *     // ... filter to delete one EmailVerificationToken
     *   }
     * })
     *
     */
    delete<T extends EmailVerificationTokenDeleteArgs>(
      args: SelectSubset<T, EmailVerificationTokenDeleteArgs<ExtArgs>>,
    ): Prisma__EmailVerificationTokenClient<
      $Result.GetResult<
        Prisma.$EmailVerificationTokenPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one EmailVerificationToken.
     * @param {EmailVerificationTokenUpdateArgs} args - Arguments to update one EmailVerificationToken.
     * @example
     * // Update one EmailVerificationToken
     * const emailVerificationToken = await prisma.emailVerificationToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends EmailVerificationTokenUpdateArgs>(
      args: SelectSubset<T, EmailVerificationTokenUpdateArgs<ExtArgs>>,
    ): Prisma__EmailVerificationTokenClient<
      $Result.GetResult<
        Prisma.$EmailVerificationTokenPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more EmailVerificationTokens.
     * @param {EmailVerificationTokenDeleteManyArgs} args - Arguments to filter EmailVerificationTokens to delete.
     * @example
     * // Delete a few EmailVerificationTokens
     * const { count } = await prisma.emailVerificationToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends EmailVerificationTokenDeleteManyArgs>(
      args?: SelectSubset<T, EmailVerificationTokenDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more EmailVerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailVerificationTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailVerificationTokens
     * const emailVerificationToken = await prisma.emailVerificationToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends EmailVerificationTokenUpdateManyArgs>(
      args: SelectSubset<T, EmailVerificationTokenUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more EmailVerificationTokens and returns the data updated in the database.
     * @param {EmailVerificationTokenUpdateManyAndReturnArgs} args - Arguments to update many EmailVerificationTokens.
     * @example
     * // Update many EmailVerificationTokens
     * const emailVerificationToken = await prisma.emailVerificationToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more EmailVerificationTokens and only return the `id`
     * const emailVerificationTokenWithIdOnly = await prisma.emailVerificationToken.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<
      T extends EmailVerificationTokenUpdateManyAndReturnArgs,
    >(
      args: SelectSubset<
        T,
        EmailVerificationTokenUpdateManyAndReturnArgs<ExtArgs>
      >,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$EmailVerificationTokenPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one EmailVerificationToken.
     * @param {EmailVerificationTokenUpsertArgs} args - Arguments to update or create a EmailVerificationToken.
     * @example
     * // Update or create a EmailVerificationToken
     * const emailVerificationToken = await prisma.emailVerificationToken.upsert({
     *   create: {
     *     // ... data to create a EmailVerificationToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailVerificationToken we want to update
     *   }
     * })
     */
    upsert<T extends EmailVerificationTokenUpsertArgs>(
      args: SelectSubset<T, EmailVerificationTokenUpsertArgs<ExtArgs>>,
    ): Prisma__EmailVerificationTokenClient<
      $Result.GetResult<
        Prisma.$EmailVerificationTokenPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of EmailVerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailVerificationTokenCountArgs} args - Arguments to filter EmailVerificationTokens to count.
     * @example
     * // Count the number of EmailVerificationTokens
     * const count = await prisma.emailVerificationToken.count({
     *   where: {
     *     // ... the filter for the EmailVerificationTokens we want to count
     *   }
     * })
     **/
    count<T extends EmailVerificationTokenCountArgs>(
      args?: Subset<T, EmailVerificationTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<
              T["select"],
              EmailVerificationTokenCountAggregateOutputType
            >
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a EmailVerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailVerificationTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends EmailVerificationTokenAggregateArgs>(
      args: Subset<T, EmailVerificationTokenAggregateArgs>,
    ): Prisma.PrismaPromise<GetEmailVerificationTokenAggregateType<T>>;

    /**
     * Group by EmailVerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailVerificationTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends EmailVerificationTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailVerificationTokenGroupByArgs["orderBy"] }
        : { orderBy?: EmailVerificationTokenGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<
        T,
        EmailVerificationTokenGroupByArgs,
        OrderByArg
      > &
        InputErrors,
    ): {} extends InputErrors
      ? GetEmailVerificationTokenGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the EmailVerificationToken model
     */
    readonly fields: EmailVerificationTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailVerificationToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailVerificationTokenClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>,
    ): Prisma__UserClient<
      | $Result.GetResult<
          Prisma.$UserPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the EmailVerificationToken model
   */
  interface EmailVerificationTokenFieldRefs {
    readonly id: FieldRef<"EmailVerificationToken", "String">;
    readonly userId: FieldRef<"EmailVerificationToken", "String">;
    readonly expires: FieldRef<"EmailVerificationToken", "BigInt">;
  }

  // Custom InputTypes
  /**
   * EmailVerificationToken findUnique
   */
  export type EmailVerificationTokenFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the EmailVerificationToken
     */
    select?: EmailVerificationTokenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the EmailVerificationToken
     */
    omit?: EmailVerificationTokenOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationTokenInclude<ExtArgs> | null;
    /**
     * Filter, which EmailVerificationToken to fetch.
     */
    where: EmailVerificationTokenWhereUniqueInput;
  };

  /**
   * EmailVerificationToken findUniqueOrThrow
   */
  export type EmailVerificationTokenFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the EmailVerificationToken
     */
    select?: EmailVerificationTokenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the EmailVerificationToken
     */
    omit?: EmailVerificationTokenOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationTokenInclude<ExtArgs> | null;
    /**
     * Filter, which EmailVerificationToken to fetch.
     */
    where: EmailVerificationTokenWhereUniqueInput;
  };

  /**
   * EmailVerificationToken findFirst
   */
  export type EmailVerificationTokenFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the EmailVerificationToken
     */
    select?: EmailVerificationTokenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the EmailVerificationToken
     */
    omit?: EmailVerificationTokenOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationTokenInclude<ExtArgs> | null;
    /**
     * Filter, which EmailVerificationToken to fetch.
     */
    where?: EmailVerificationTokenWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of EmailVerificationTokens to fetch.
     */
    orderBy?:
      | EmailVerificationTokenOrderByWithRelationInput
      | EmailVerificationTokenOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for EmailVerificationTokens.
     */
    cursor?: EmailVerificationTokenWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` EmailVerificationTokens from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` EmailVerificationTokens.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of EmailVerificationTokens.
     */
    distinct?:
      | EmailVerificationTokenScalarFieldEnum
      | EmailVerificationTokenScalarFieldEnum[];
  };

  /**
   * EmailVerificationToken findFirstOrThrow
   */
  export type EmailVerificationTokenFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the EmailVerificationToken
     */
    select?: EmailVerificationTokenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the EmailVerificationToken
     */
    omit?: EmailVerificationTokenOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationTokenInclude<ExtArgs> | null;
    /**
     * Filter, which EmailVerificationToken to fetch.
     */
    where?: EmailVerificationTokenWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of EmailVerificationTokens to fetch.
     */
    orderBy?:
      | EmailVerificationTokenOrderByWithRelationInput
      | EmailVerificationTokenOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for EmailVerificationTokens.
     */
    cursor?: EmailVerificationTokenWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` EmailVerificationTokens from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` EmailVerificationTokens.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of EmailVerificationTokens.
     */
    distinct?:
      | EmailVerificationTokenScalarFieldEnum
      | EmailVerificationTokenScalarFieldEnum[];
  };

  /**
   * EmailVerificationToken findMany
   */
  export type EmailVerificationTokenFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the EmailVerificationToken
     */
    select?: EmailVerificationTokenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the EmailVerificationToken
     */
    omit?: EmailVerificationTokenOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationTokenInclude<ExtArgs> | null;
    /**
     * Filter, which EmailVerificationTokens to fetch.
     */
    where?: EmailVerificationTokenWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of EmailVerificationTokens to fetch.
     */
    orderBy?:
      | EmailVerificationTokenOrderByWithRelationInput
      | EmailVerificationTokenOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing EmailVerificationTokens.
     */
    cursor?: EmailVerificationTokenWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` EmailVerificationTokens from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` EmailVerificationTokens.
     */
    skip?: number;
    distinct?:
      | EmailVerificationTokenScalarFieldEnum
      | EmailVerificationTokenScalarFieldEnum[];
  };

  /**
   * EmailVerificationToken create
   */
  export type EmailVerificationTokenCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the EmailVerificationToken
     */
    select?: EmailVerificationTokenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the EmailVerificationToken
     */
    omit?: EmailVerificationTokenOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationTokenInclude<ExtArgs> | null;
    /**
     * The data needed to create a EmailVerificationToken.
     */
    data: XOR<
      EmailVerificationTokenCreateInput,
      EmailVerificationTokenUncheckedCreateInput
    >;
  };

  /**
   * EmailVerificationToken createMany
   */
  export type EmailVerificationTokenCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many EmailVerificationTokens.
     */
    data:
      | EmailVerificationTokenCreateManyInput
      | EmailVerificationTokenCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * EmailVerificationToken createManyAndReturn
   */
  export type EmailVerificationTokenCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the EmailVerificationToken
     */
    select?: EmailVerificationTokenSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the EmailVerificationToken
     */
    omit?: EmailVerificationTokenOmit<ExtArgs> | null;
    /**
     * The data used to create many EmailVerificationTokens.
     */
    data:
      | EmailVerificationTokenCreateManyInput
      | EmailVerificationTokenCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationTokenIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * EmailVerificationToken update
   */
  export type EmailVerificationTokenUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the EmailVerificationToken
     */
    select?: EmailVerificationTokenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the EmailVerificationToken
     */
    omit?: EmailVerificationTokenOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationTokenInclude<ExtArgs> | null;
    /**
     * The data needed to update a EmailVerificationToken.
     */
    data: XOR<
      EmailVerificationTokenUpdateInput,
      EmailVerificationTokenUncheckedUpdateInput
    >;
    /**
     * Choose, which EmailVerificationToken to update.
     */
    where: EmailVerificationTokenWhereUniqueInput;
  };

  /**
   * EmailVerificationToken updateMany
   */
  export type EmailVerificationTokenUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update EmailVerificationTokens.
     */
    data: XOR<
      EmailVerificationTokenUpdateManyMutationInput,
      EmailVerificationTokenUncheckedUpdateManyInput
    >;
    /**
     * Filter which EmailVerificationTokens to update
     */
    where?: EmailVerificationTokenWhereInput;
    /**
     * Limit how many EmailVerificationTokens to update.
     */
    limit?: number;
  };

  /**
   * EmailVerificationToken updateManyAndReturn
   */
  export type EmailVerificationTokenUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the EmailVerificationToken
     */
    select?: EmailVerificationTokenSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the EmailVerificationToken
     */
    omit?: EmailVerificationTokenOmit<ExtArgs> | null;
    /**
     * The data used to update EmailVerificationTokens.
     */
    data: XOR<
      EmailVerificationTokenUpdateManyMutationInput,
      EmailVerificationTokenUncheckedUpdateManyInput
    >;
    /**
     * Filter which EmailVerificationTokens to update
     */
    where?: EmailVerificationTokenWhereInput;
    /**
     * Limit how many EmailVerificationTokens to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationTokenIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * EmailVerificationToken upsert
   */
  export type EmailVerificationTokenUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the EmailVerificationToken
     */
    select?: EmailVerificationTokenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the EmailVerificationToken
     */
    omit?: EmailVerificationTokenOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationTokenInclude<ExtArgs> | null;
    /**
     * The filter to search for the EmailVerificationToken to update in case it exists.
     */
    where: EmailVerificationTokenWhereUniqueInput;
    /**
     * In case the EmailVerificationToken found by the `where` argument doesn't exist, create a new EmailVerificationToken with this data.
     */
    create: XOR<
      EmailVerificationTokenCreateInput,
      EmailVerificationTokenUncheckedCreateInput
    >;
    /**
     * In case the EmailVerificationToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<
      EmailVerificationTokenUpdateInput,
      EmailVerificationTokenUncheckedUpdateInput
    >;
  };

  /**
   * EmailVerificationToken delete
   */
  export type EmailVerificationTokenDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the EmailVerificationToken
     */
    select?: EmailVerificationTokenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the EmailVerificationToken
     */
    omit?: EmailVerificationTokenOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationTokenInclude<ExtArgs> | null;
    /**
     * Filter which EmailVerificationToken to delete.
     */
    where: EmailVerificationTokenWhereUniqueInput;
  };

  /**
   * EmailVerificationToken deleteMany
   */
  export type EmailVerificationTokenDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which EmailVerificationTokens to delete
     */
    where?: EmailVerificationTokenWhereInput;
    /**
     * Limit how many EmailVerificationTokens to delete.
     */
    limit?: number;
  };

  /**
   * EmailVerificationToken without action
   */
  export type EmailVerificationTokenDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the EmailVerificationToken
     */
    select?: EmailVerificationTokenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the EmailVerificationToken
     */
    omit?: EmailVerificationTokenOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationTokenInclude<ExtArgs> | null;
  };

  /**
   * Model Pupil
   */

  export type AggregatePupil = {
    _count: PupilCountAggregateOutputType | null;
    _min: PupilMinAggregateOutputType | null;
    _max: PupilMaxAggregateOutputType | null;
  };

  export type PupilMinAggregateOutputType = {
    id: string | null;
    userId: string | null;
    genericPassword: string | null;
  };

  export type PupilMaxAggregateOutputType = {
    id: string | null;
    userId: string | null;
    genericPassword: string | null;
  };

  export type PupilCountAggregateOutputType = {
    id: number;
    userId: number;
    genericPassword: number;
    _all: number;
  };

  export type PupilMinAggregateInputType = {
    id?: true;
    userId?: true;
    genericPassword?: true;
  };

  export type PupilMaxAggregateInputType = {
    id?: true;
    userId?: true;
    genericPassword?: true;
  };

  export type PupilCountAggregateInputType = {
    id?: true;
    userId?: true;
    genericPassword?: true;
    _all?: true;
  };

  export type PupilAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Pupil to aggregate.
     */
    where?: PupilWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Pupils to fetch.
     */
    orderBy?: PupilOrderByWithRelationInput | PupilOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: PupilWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Pupils from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Pupils.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Pupils
     **/
    _count?: true | PupilCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: PupilMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: PupilMaxAggregateInputType;
  };

  export type GetPupilAggregateType<T extends PupilAggregateArgs> = {
    [P in keyof T & keyof AggregatePupil]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePupil[P]>
      : GetScalarType<T[P], AggregatePupil[P]>;
  };

  export type PupilGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: PupilWhereInput;
    orderBy?:
      | PupilOrderByWithAggregationInput
      | PupilOrderByWithAggregationInput[];
    by: PupilScalarFieldEnum[] | PupilScalarFieldEnum;
    having?: PupilScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: PupilCountAggregateInputType | true;
    _min?: PupilMinAggregateInputType;
    _max?: PupilMaxAggregateInputType;
  };

  export type PupilGroupByOutputType = {
    id: string;
    userId: string | null;
    genericPassword: string;
    _count: PupilCountAggregateOutputType | null;
    _min: PupilMinAggregateOutputType | null;
    _max: PupilMaxAggregateOutputType | null;
  };

  type GetPupilGroupByPayload<T extends PupilGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<PupilGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof PupilGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PupilGroupByOutputType[P]>
            : GetScalarType<T[P], PupilGroupByOutputType[P]>;
        }
      >
    >;

  export type PupilSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      genericPassword?: boolean;
      classStreams?: boolean | Pupil$classStreamsArgs<ExtArgs>;
      examScores?: boolean | Pupil$examScoresArgs<ExtArgs>;
      fees?: boolean | Pupil$feesArgs<ExtArgs>;
      user?: boolean | Pupil$userArgs<ExtArgs>;
      _count?: boolean | PupilCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["pupil"]
  >;

  export type PupilSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      genericPassword?: boolean;
      user?: boolean | Pupil$userArgs<ExtArgs>;
    },
    ExtArgs["result"]["pupil"]
  >;

  export type PupilSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      genericPassword?: boolean;
      user?: boolean | Pupil$userArgs<ExtArgs>;
    },
    ExtArgs["result"]["pupil"]
  >;

  export type PupilSelectScalar = {
    id?: boolean;
    userId?: boolean;
    genericPassword?: boolean;
  };

  export type PupilOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    "id" | "userId" | "genericPassword",
    ExtArgs["result"]["pupil"]
  >;
  export type PupilInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    classStreams?: boolean | Pupil$classStreamsArgs<ExtArgs>;
    examScores?: boolean | Pupil$examScoresArgs<ExtArgs>;
    fees?: boolean | Pupil$feesArgs<ExtArgs>;
    user?: boolean | Pupil$userArgs<ExtArgs>;
    _count?: boolean | PupilCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type PupilIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | Pupil$userArgs<ExtArgs>;
  };
  export type PupilIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | Pupil$userArgs<ExtArgs>;
  };

  export type $PupilPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "Pupil";
    objects: {
      classStreams: Prisma.$classStreamPayload<ExtArgs>[];
      examScores: Prisma.$ExamScorePayload<ExtArgs>[];
      fees: Prisma.$FeesPayload<ExtArgs>[];
      user: Prisma.$UserPayload<ExtArgs> | null;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        userId: string | null;
        genericPassword: string;
      },
      ExtArgs["result"]["pupil"]
    >;
    composites: {};
  };

  type PupilGetPayload<
    S extends boolean | null | undefined | PupilDefaultArgs,
  > = $Result.GetResult<Prisma.$PupilPayload, S>;

  type PupilCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<PupilFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
    select?: PupilCountAggregateInputType | true;
  };

  export interface PupilDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["Pupil"];
      meta: { name: "Pupil" };
    };
    /**
     * Find zero or one Pupil that matches the filter.
     * @param {PupilFindUniqueArgs} args - Arguments to find a Pupil
     * @example
     * // Get one Pupil
     * const pupil = await prisma.pupil.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PupilFindUniqueArgs>(
      args: SelectSubset<T, PupilFindUniqueArgs<ExtArgs>>,
    ): Prisma__PupilClient<
      $Result.GetResult<
        Prisma.$PupilPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Pupil that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PupilFindUniqueOrThrowArgs} args - Arguments to find a Pupil
     * @example
     * // Get one Pupil
     * const pupil = await prisma.pupil.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PupilFindUniqueOrThrowArgs>(
      args: SelectSubset<T, PupilFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__PupilClient<
      $Result.GetResult<
        Prisma.$PupilPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Pupil that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PupilFindFirstArgs} args - Arguments to find a Pupil
     * @example
     * // Get one Pupil
     * const pupil = await prisma.pupil.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PupilFindFirstArgs>(
      args?: SelectSubset<T, PupilFindFirstArgs<ExtArgs>>,
    ): Prisma__PupilClient<
      $Result.GetResult<
        Prisma.$PupilPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Pupil that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PupilFindFirstOrThrowArgs} args - Arguments to find a Pupil
     * @example
     * // Get one Pupil
     * const pupil = await prisma.pupil.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PupilFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PupilFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__PupilClient<
      $Result.GetResult<
        Prisma.$PupilPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Pupils that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PupilFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pupils
     * const pupils = await prisma.pupil.findMany()
     *
     * // Get first 10 Pupils
     * const pupils = await prisma.pupil.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const pupilWithIdOnly = await prisma.pupil.findMany({ select: { id: true } })
     *
     */
    findMany<T extends PupilFindManyArgs>(
      args?: SelectSubset<T, PupilFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$PupilPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Pupil.
     * @param {PupilCreateArgs} args - Arguments to create a Pupil.
     * @example
     * // Create one Pupil
     * const Pupil = await prisma.pupil.create({
     *   data: {
     *     // ... data to create a Pupil
     *   }
     * })
     *
     */
    create<T extends PupilCreateArgs>(
      args: SelectSubset<T, PupilCreateArgs<ExtArgs>>,
    ): Prisma__PupilClient<
      $Result.GetResult<
        Prisma.$PupilPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Pupils.
     * @param {PupilCreateManyArgs} args - Arguments to create many Pupils.
     * @example
     * // Create many Pupils
     * const pupil = await prisma.pupil.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends PupilCreateManyArgs>(
      args?: SelectSubset<T, PupilCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Pupils and returns the data saved in the database.
     * @param {PupilCreateManyAndReturnArgs} args - Arguments to create many Pupils.
     * @example
     * // Create many Pupils
     * const pupil = await prisma.pupil.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Pupils and only return the `id`
     * const pupilWithIdOnly = await prisma.pupil.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends PupilCreateManyAndReturnArgs>(
      args?: SelectSubset<T, PupilCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$PupilPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Pupil.
     * @param {PupilDeleteArgs} args - Arguments to delete one Pupil.
     * @example
     * // Delete one Pupil
     * const Pupil = await prisma.pupil.delete({
     *   where: {
     *     // ... filter to delete one Pupil
     *   }
     * })
     *
     */
    delete<T extends PupilDeleteArgs>(
      args: SelectSubset<T, PupilDeleteArgs<ExtArgs>>,
    ): Prisma__PupilClient<
      $Result.GetResult<
        Prisma.$PupilPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Pupil.
     * @param {PupilUpdateArgs} args - Arguments to update one Pupil.
     * @example
     * // Update one Pupil
     * const pupil = await prisma.pupil.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends PupilUpdateArgs>(
      args: SelectSubset<T, PupilUpdateArgs<ExtArgs>>,
    ): Prisma__PupilClient<
      $Result.GetResult<
        Prisma.$PupilPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Pupils.
     * @param {PupilDeleteManyArgs} args - Arguments to filter Pupils to delete.
     * @example
     * // Delete a few Pupils
     * const { count } = await prisma.pupil.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends PupilDeleteManyArgs>(
      args?: SelectSubset<T, PupilDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Pupils.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PupilUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pupils
     * const pupil = await prisma.pupil.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends PupilUpdateManyArgs>(
      args: SelectSubset<T, PupilUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Pupils and returns the data updated in the database.
     * @param {PupilUpdateManyAndReturnArgs} args - Arguments to update many Pupils.
     * @example
     * // Update many Pupils
     * const pupil = await prisma.pupil.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Pupils and only return the `id`
     * const pupilWithIdOnly = await prisma.pupil.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends PupilUpdateManyAndReturnArgs>(
      args: SelectSubset<T, PupilUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$PupilPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Pupil.
     * @param {PupilUpsertArgs} args - Arguments to update or create a Pupil.
     * @example
     * // Update or create a Pupil
     * const pupil = await prisma.pupil.upsert({
     *   create: {
     *     // ... data to create a Pupil
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pupil we want to update
     *   }
     * })
     */
    upsert<T extends PupilUpsertArgs>(
      args: SelectSubset<T, PupilUpsertArgs<ExtArgs>>,
    ): Prisma__PupilClient<
      $Result.GetResult<
        Prisma.$PupilPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Pupils.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PupilCountArgs} args - Arguments to filter Pupils to count.
     * @example
     * // Count the number of Pupils
     * const count = await prisma.pupil.count({
     *   where: {
     *     // ... the filter for the Pupils we want to count
     *   }
     * })
     **/
    count<T extends PupilCountArgs>(
      args?: Subset<T, PupilCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], PupilCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Pupil.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PupilAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends PupilAggregateArgs>(
      args: Subset<T, PupilAggregateArgs>,
    ): Prisma.PrismaPromise<GetPupilAggregateType<T>>;

    /**
     * Group by Pupil.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PupilGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends PupilGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PupilGroupByArgs["orderBy"] }
        : { orderBy?: PupilGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, PupilGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetPupilGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Pupil model
     */
    readonly fields: PupilFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Pupil.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PupilClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    classStreams<T extends Pupil$classStreamsArgs<ExtArgs> = {}>(
      args?: Subset<T, Pupil$classStreamsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$classStreamPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    examScores<T extends Pupil$examScoresArgs<ExtArgs> = {}>(
      args?: Subset<T, Pupil$examScoresArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$ExamScorePayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    fees<T extends Pupil$feesArgs<ExtArgs> = {}>(
      args?: Subset<T, Pupil$feesArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$FeesPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    user<T extends Pupil$userArgs<ExtArgs> = {}>(
      args?: Subset<T, Pupil$userArgs<ExtArgs>>,
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Pupil model
   */
  interface PupilFieldRefs {
    readonly id: FieldRef<"Pupil", "String">;
    readonly userId: FieldRef<"Pupil", "String">;
    readonly genericPassword: FieldRef<"Pupil", "String">;
  }

  // Custom InputTypes
  /**
   * Pupil findUnique
   */
  export type PupilFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Pupil
     */
    select?: PupilSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Pupil
     */
    omit?: PupilOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PupilInclude<ExtArgs> | null;
    /**
     * Filter, which Pupil to fetch.
     */
    where: PupilWhereUniqueInput;
  };

  /**
   * Pupil findUniqueOrThrow
   */
  export type PupilFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Pupil
     */
    select?: PupilSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Pupil
     */
    omit?: PupilOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PupilInclude<ExtArgs> | null;
    /**
     * Filter, which Pupil to fetch.
     */
    where: PupilWhereUniqueInput;
  };

  /**
   * Pupil findFirst
   */
  export type PupilFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Pupil
     */
    select?: PupilSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Pupil
     */
    omit?: PupilOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PupilInclude<ExtArgs> | null;
    /**
     * Filter, which Pupil to fetch.
     */
    where?: PupilWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Pupils to fetch.
     */
    orderBy?: PupilOrderByWithRelationInput | PupilOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Pupils.
     */
    cursor?: PupilWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Pupils from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Pupils.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Pupils.
     */
    distinct?: PupilScalarFieldEnum | PupilScalarFieldEnum[];
  };

  /**
   * Pupil findFirstOrThrow
   */
  export type PupilFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Pupil
     */
    select?: PupilSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Pupil
     */
    omit?: PupilOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PupilInclude<ExtArgs> | null;
    /**
     * Filter, which Pupil to fetch.
     */
    where?: PupilWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Pupils to fetch.
     */
    orderBy?: PupilOrderByWithRelationInput | PupilOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Pupils.
     */
    cursor?: PupilWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Pupils from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Pupils.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Pupils.
     */
    distinct?: PupilScalarFieldEnum | PupilScalarFieldEnum[];
  };

  /**
   * Pupil findMany
   */
  export type PupilFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Pupil
     */
    select?: PupilSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Pupil
     */
    omit?: PupilOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PupilInclude<ExtArgs> | null;
    /**
     * Filter, which Pupils to fetch.
     */
    where?: PupilWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Pupils to fetch.
     */
    orderBy?: PupilOrderByWithRelationInput | PupilOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Pupils.
     */
    cursor?: PupilWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Pupils from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Pupils.
     */
    skip?: number;
    distinct?: PupilScalarFieldEnum | PupilScalarFieldEnum[];
  };

  /**
   * Pupil create
   */
  export type PupilCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Pupil
     */
    select?: PupilSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Pupil
     */
    omit?: PupilOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PupilInclude<ExtArgs> | null;
    /**
     * The data needed to create a Pupil.
     */
    data: XOR<PupilCreateInput, PupilUncheckedCreateInput>;
  };

  /**
   * Pupil createMany
   */
  export type PupilCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Pupils.
     */
    data: PupilCreateManyInput | PupilCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Pupil createManyAndReturn
   */
  export type PupilCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Pupil
     */
    select?: PupilSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Pupil
     */
    omit?: PupilOmit<ExtArgs> | null;
    /**
     * The data used to create many Pupils.
     */
    data: PupilCreateManyInput | PupilCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PupilIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Pupil update
   */
  export type PupilUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Pupil
     */
    select?: PupilSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Pupil
     */
    omit?: PupilOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PupilInclude<ExtArgs> | null;
    /**
     * The data needed to update a Pupil.
     */
    data: XOR<PupilUpdateInput, PupilUncheckedUpdateInput>;
    /**
     * Choose, which Pupil to update.
     */
    where: PupilWhereUniqueInput;
  };

  /**
   * Pupil updateMany
   */
  export type PupilUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Pupils.
     */
    data: XOR<PupilUpdateManyMutationInput, PupilUncheckedUpdateManyInput>;
    /**
     * Filter which Pupils to update
     */
    where?: PupilWhereInput;
    /**
     * Limit how many Pupils to update.
     */
    limit?: number;
  };

  /**
   * Pupil updateManyAndReturn
   */
  export type PupilUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Pupil
     */
    select?: PupilSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Pupil
     */
    omit?: PupilOmit<ExtArgs> | null;
    /**
     * The data used to update Pupils.
     */
    data: XOR<PupilUpdateManyMutationInput, PupilUncheckedUpdateManyInput>;
    /**
     * Filter which Pupils to update
     */
    where?: PupilWhereInput;
    /**
     * Limit how many Pupils to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PupilIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Pupil upsert
   */
  export type PupilUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Pupil
     */
    select?: PupilSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Pupil
     */
    omit?: PupilOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PupilInclude<ExtArgs> | null;
    /**
     * The filter to search for the Pupil to update in case it exists.
     */
    where: PupilWhereUniqueInput;
    /**
     * In case the Pupil found by the `where` argument doesn't exist, create a new Pupil with this data.
     */
    create: XOR<PupilCreateInput, PupilUncheckedCreateInput>;
    /**
     * In case the Pupil was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PupilUpdateInput, PupilUncheckedUpdateInput>;
  };

  /**
   * Pupil delete
   */
  export type PupilDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Pupil
     */
    select?: PupilSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Pupil
     */
    omit?: PupilOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PupilInclude<ExtArgs> | null;
    /**
     * Filter which Pupil to delete.
     */
    where: PupilWhereUniqueInput;
  };

  /**
   * Pupil deleteMany
   */
  export type PupilDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Pupils to delete
     */
    where?: PupilWhereInput;
    /**
     * Limit how many Pupils to delete.
     */
    limit?: number;
  };

  /**
   * Pupil.classStreams
   */
  export type Pupil$classStreamsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the classStream
     */
    select?: classStreamSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the classStream
     */
    omit?: classStreamOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: classStreamInclude<ExtArgs> | null;
    where?: classStreamWhereInput;
    orderBy?:
      | classStreamOrderByWithRelationInput
      | classStreamOrderByWithRelationInput[];
    cursor?: classStreamWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ClassStreamScalarFieldEnum | ClassStreamScalarFieldEnum[];
  };

  /**
   * Pupil.examScores
   */
  export type Pupil$examScoresArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ExamScore
     */
    select?: ExamScoreSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ExamScore
     */
    omit?: ExamScoreOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamScoreInclude<ExtArgs> | null;
    where?: ExamScoreWhereInput;
    orderBy?:
      | ExamScoreOrderByWithRelationInput
      | ExamScoreOrderByWithRelationInput[];
    cursor?: ExamScoreWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ExamScoreScalarFieldEnum | ExamScoreScalarFieldEnum[];
  };

  /**
   * Pupil.fees
   */
  export type Pupil$feesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Fees
     */
    select?: FeesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Fees
     */
    omit?: FeesOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeesInclude<ExtArgs> | null;
    where?: FeesWhereInput;
    orderBy?: FeesOrderByWithRelationInput | FeesOrderByWithRelationInput[];
    cursor?: FeesWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: FeesScalarFieldEnum | FeesScalarFieldEnum[];
  };

  /**
   * Pupil.user
   */
  export type Pupil$userArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    where?: UserWhereInput;
  };

  /**
   * Pupil without action
   */
  export type PupilDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Pupil
     */
    select?: PupilSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Pupil
     */
    omit?: PupilOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PupilInclude<ExtArgs> | null;
  };

  /**
   * Model Staff
   */

  export type AggregateStaff = {
    _count: StaffCountAggregateOutputType | null;
    _min: StaffMinAggregateOutputType | null;
    _max: StaffMaxAggregateOutputType | null;
  };

  export type StaffMinAggregateOutputType = {
    id: string | null;
    staffType: $Enums.StaffType | null;
    userId: string | null;
    genericPassword: string | null;
  };

  export type StaffMaxAggregateOutputType = {
    id: string | null;
    staffType: $Enums.StaffType | null;
    userId: string | null;
    genericPassword: string | null;
  };

  export type StaffCountAggregateOutputType = {
    id: number;
    staffType: number;
    userId: number;
    genericPassword: number;
    _all: number;
  };

  export type StaffMinAggregateInputType = {
    id?: true;
    staffType?: true;
    userId?: true;
    genericPassword?: true;
  };

  export type StaffMaxAggregateInputType = {
    id?: true;
    staffType?: true;
    userId?: true;
    genericPassword?: true;
  };

  export type StaffCountAggregateInputType = {
    id?: true;
    staffType?: true;
    userId?: true;
    genericPassword?: true;
    _all?: true;
  };

  export type StaffAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Staff to aggregate.
     */
    where?: StaffWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Staff to fetch.
     */
    orderBy?: StaffOrderByWithRelationInput | StaffOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: StaffWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Staff from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Staff.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Staff
     **/
    _count?: true | StaffCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: StaffMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: StaffMaxAggregateInputType;
  };

  export type GetStaffAggregateType<T extends StaffAggregateArgs> = {
    [P in keyof T & keyof AggregateStaff]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStaff[P]>
      : GetScalarType<T[P], AggregateStaff[P]>;
  };

  export type StaffGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: StaffWhereInput;
    orderBy?:
      | StaffOrderByWithAggregationInput
      | StaffOrderByWithAggregationInput[];
    by: StaffScalarFieldEnum[] | StaffScalarFieldEnum;
    having?: StaffScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: StaffCountAggregateInputType | true;
    _min?: StaffMinAggregateInputType;
    _max?: StaffMaxAggregateInputType;
  };

  export type StaffGroupByOutputType = {
    id: string;
    staffType: $Enums.StaffType;
    userId: string | null;
    genericPassword: string;
    _count: StaffCountAggregateOutputType | null;
    _min: StaffMinAggregateOutputType | null;
    _max: StaffMaxAggregateOutputType | null;
  };

  type GetStaffGroupByPayload<T extends StaffGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<StaffGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof StaffGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StaffGroupByOutputType[P]>
            : GetScalarType<T[P], StaffGroupByOutputType[P]>;
        }
      >
    >;

  export type StaffSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      staffType?: boolean;
      userId?: boolean;
      genericPassword?: boolean;
      academicYearSubjects?: boolean | Staff$academicYearSubjectsArgs<ExtArgs>;
      classStreams?: boolean | Staff$classStreamsArgs<ExtArgs>;
      user?: boolean | Staff$userArgs<ExtArgs>;
      _count?: boolean | StaffCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["staff"]
  >;

  export type StaffSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      staffType?: boolean;
      userId?: boolean;
      genericPassword?: boolean;
      user?: boolean | Staff$userArgs<ExtArgs>;
    },
    ExtArgs["result"]["staff"]
  >;

  export type StaffSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      staffType?: boolean;
      userId?: boolean;
      genericPassword?: boolean;
      user?: boolean | Staff$userArgs<ExtArgs>;
    },
    ExtArgs["result"]["staff"]
  >;

  export type StaffSelectScalar = {
    id?: boolean;
    staffType?: boolean;
    userId?: boolean;
    genericPassword?: boolean;
  };

  export type StaffOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    "id" | "staffType" | "userId" | "genericPassword",
    ExtArgs["result"]["staff"]
  >;
  export type StaffInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    academicYearSubjects?: boolean | Staff$academicYearSubjectsArgs<ExtArgs>;
    classStreams?: boolean | Staff$classStreamsArgs<ExtArgs>;
    user?: boolean | Staff$userArgs<ExtArgs>;
    _count?: boolean | StaffCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type StaffIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | Staff$userArgs<ExtArgs>;
  };
  export type StaffIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | Staff$userArgs<ExtArgs>;
  };

  export type $StaffPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "Staff";
    objects: {
      academicYearSubjects: Prisma.$AcademicYearSubjectPayload<ExtArgs>[];
      classStreams: Prisma.$classStreamPayload<ExtArgs>[];
      user: Prisma.$UserPayload<ExtArgs> | null;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        staffType: $Enums.StaffType;
        userId: string | null;
        genericPassword: string;
      },
      ExtArgs["result"]["staff"]
    >;
    composites: {};
  };

  type StaffGetPayload<
    S extends boolean | null | undefined | StaffDefaultArgs,
  > = $Result.GetResult<Prisma.$StaffPayload, S>;

  type StaffCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<StaffFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
    select?: StaffCountAggregateInputType | true;
  };

  export interface StaffDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["Staff"];
      meta: { name: "Staff" };
    };
    /**
     * Find zero or one Staff that matches the filter.
     * @param {StaffFindUniqueArgs} args - Arguments to find a Staff
     * @example
     * // Get one Staff
     * const staff = await prisma.staff.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StaffFindUniqueArgs>(
      args: SelectSubset<T, StaffFindUniqueArgs<ExtArgs>>,
    ): Prisma__StaffClient<
      $Result.GetResult<
        Prisma.$StaffPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Staff that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StaffFindUniqueOrThrowArgs} args - Arguments to find a Staff
     * @example
     * // Get one Staff
     * const staff = await prisma.staff.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StaffFindUniqueOrThrowArgs>(
      args: SelectSubset<T, StaffFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__StaffClient<
      $Result.GetResult<
        Prisma.$StaffPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Staff that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffFindFirstArgs} args - Arguments to find a Staff
     * @example
     * // Get one Staff
     * const staff = await prisma.staff.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StaffFindFirstArgs>(
      args?: SelectSubset<T, StaffFindFirstArgs<ExtArgs>>,
    ): Prisma__StaffClient<
      $Result.GetResult<
        Prisma.$StaffPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Staff that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffFindFirstOrThrowArgs} args - Arguments to find a Staff
     * @example
     * // Get one Staff
     * const staff = await prisma.staff.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StaffFindFirstOrThrowArgs>(
      args?: SelectSubset<T, StaffFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__StaffClient<
      $Result.GetResult<
        Prisma.$StaffPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Staff that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Staff
     * const staff = await prisma.staff.findMany()
     *
     * // Get first 10 Staff
     * const staff = await prisma.staff.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const staffWithIdOnly = await prisma.staff.findMany({ select: { id: true } })
     *
     */
    findMany<T extends StaffFindManyArgs>(
      args?: SelectSubset<T, StaffFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$StaffPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Staff.
     * @param {StaffCreateArgs} args - Arguments to create a Staff.
     * @example
     * // Create one Staff
     * const Staff = await prisma.staff.create({
     *   data: {
     *     // ... data to create a Staff
     *   }
     * })
     *
     */
    create<T extends StaffCreateArgs>(
      args: SelectSubset<T, StaffCreateArgs<ExtArgs>>,
    ): Prisma__StaffClient<
      $Result.GetResult<
        Prisma.$StaffPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Staff.
     * @param {StaffCreateManyArgs} args - Arguments to create many Staff.
     * @example
     * // Create many Staff
     * const staff = await prisma.staff.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends StaffCreateManyArgs>(
      args?: SelectSubset<T, StaffCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Staff and returns the data saved in the database.
     * @param {StaffCreateManyAndReturnArgs} args - Arguments to create many Staff.
     * @example
     * // Create many Staff
     * const staff = await prisma.staff.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Staff and only return the `id`
     * const staffWithIdOnly = await prisma.staff.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends StaffCreateManyAndReturnArgs>(
      args?: SelectSubset<T, StaffCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$StaffPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Staff.
     * @param {StaffDeleteArgs} args - Arguments to delete one Staff.
     * @example
     * // Delete one Staff
     * const Staff = await prisma.staff.delete({
     *   where: {
     *     // ... filter to delete one Staff
     *   }
     * })
     *
     */
    delete<T extends StaffDeleteArgs>(
      args: SelectSubset<T, StaffDeleteArgs<ExtArgs>>,
    ): Prisma__StaffClient<
      $Result.GetResult<
        Prisma.$StaffPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Staff.
     * @param {StaffUpdateArgs} args - Arguments to update one Staff.
     * @example
     * // Update one Staff
     * const staff = await prisma.staff.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends StaffUpdateArgs>(
      args: SelectSubset<T, StaffUpdateArgs<ExtArgs>>,
    ): Prisma__StaffClient<
      $Result.GetResult<
        Prisma.$StaffPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Staff.
     * @param {StaffDeleteManyArgs} args - Arguments to filter Staff to delete.
     * @example
     * // Delete a few Staff
     * const { count } = await prisma.staff.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends StaffDeleteManyArgs>(
      args?: SelectSubset<T, StaffDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Staff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Staff
     * const staff = await prisma.staff.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends StaffUpdateManyArgs>(
      args: SelectSubset<T, StaffUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Staff and returns the data updated in the database.
     * @param {StaffUpdateManyAndReturnArgs} args - Arguments to update many Staff.
     * @example
     * // Update many Staff
     * const staff = await prisma.staff.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Staff and only return the `id`
     * const staffWithIdOnly = await prisma.staff.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends StaffUpdateManyAndReturnArgs>(
      args: SelectSubset<T, StaffUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$StaffPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Staff.
     * @param {StaffUpsertArgs} args - Arguments to update or create a Staff.
     * @example
     * // Update or create a Staff
     * const staff = await prisma.staff.upsert({
     *   create: {
     *     // ... data to create a Staff
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Staff we want to update
     *   }
     * })
     */
    upsert<T extends StaffUpsertArgs>(
      args: SelectSubset<T, StaffUpsertArgs<ExtArgs>>,
    ): Prisma__StaffClient<
      $Result.GetResult<
        Prisma.$StaffPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Staff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffCountArgs} args - Arguments to filter Staff to count.
     * @example
     * // Count the number of Staff
     * const count = await prisma.staff.count({
     *   where: {
     *     // ... the filter for the Staff we want to count
     *   }
     * })
     **/
    count<T extends StaffCountArgs>(
      args?: Subset<T, StaffCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], StaffCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Staff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends StaffAggregateArgs>(
      args: Subset<T, StaffAggregateArgs>,
    ): Prisma.PrismaPromise<GetStaffAggregateType<T>>;

    /**
     * Group by Staff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends StaffGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StaffGroupByArgs["orderBy"] }
        : { orderBy?: StaffGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, StaffGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetStaffGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Staff model
     */
    readonly fields: StaffFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Staff.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StaffClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    academicYearSubjects<
      T extends Staff$academicYearSubjectsArgs<ExtArgs> = {},
    >(
      args?: Subset<T, Staff$academicYearSubjectsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$AcademicYearSubjectPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    classStreams<T extends Staff$classStreamsArgs<ExtArgs> = {}>(
      args?: Subset<T, Staff$classStreamsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$classStreamPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    user<T extends Staff$userArgs<ExtArgs> = {}>(
      args?: Subset<T, Staff$userArgs<ExtArgs>>,
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Staff model
   */
  interface StaffFieldRefs {
    readonly id: FieldRef<"Staff", "String">;
    readonly staffType: FieldRef<"Staff", "StaffType">;
    readonly userId: FieldRef<"Staff", "String">;
    readonly genericPassword: FieldRef<"Staff", "String">;
  }

  // Custom InputTypes
  /**
   * Staff findUnique
   */
  export type StaffFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null;
    /**
     * Filter, which Staff to fetch.
     */
    where: StaffWhereUniqueInput;
  };

  /**
   * Staff findUniqueOrThrow
   */
  export type StaffFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null;
    /**
     * Filter, which Staff to fetch.
     */
    where: StaffWhereUniqueInput;
  };

  /**
   * Staff findFirst
   */
  export type StaffFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null;
    /**
     * Filter, which Staff to fetch.
     */
    where?: StaffWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Staff to fetch.
     */
    orderBy?: StaffOrderByWithRelationInput | StaffOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Staff.
     */
    cursor?: StaffWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Staff from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Staff.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Staff.
     */
    distinct?: StaffScalarFieldEnum | StaffScalarFieldEnum[];
  };

  /**
   * Staff findFirstOrThrow
   */
  export type StaffFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null;
    /**
     * Filter, which Staff to fetch.
     */
    where?: StaffWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Staff to fetch.
     */
    orderBy?: StaffOrderByWithRelationInput | StaffOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Staff.
     */
    cursor?: StaffWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Staff from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Staff.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Staff.
     */
    distinct?: StaffScalarFieldEnum | StaffScalarFieldEnum[];
  };

  /**
   * Staff findMany
   */
  export type StaffFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null;
    /**
     * Filter, which Staff to fetch.
     */
    where?: StaffWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Staff to fetch.
     */
    orderBy?: StaffOrderByWithRelationInput | StaffOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Staff.
     */
    cursor?: StaffWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Staff from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Staff.
     */
    skip?: number;
    distinct?: StaffScalarFieldEnum | StaffScalarFieldEnum[];
  };

  /**
   * Staff create
   */
  export type StaffCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null;
    /**
     * The data needed to create a Staff.
     */
    data: XOR<StaffCreateInput, StaffUncheckedCreateInput>;
  };

  /**
   * Staff createMany
   */
  export type StaffCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Staff.
     */
    data: StaffCreateManyInput | StaffCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Staff createManyAndReturn
   */
  export type StaffCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null;
    /**
     * The data used to create many Staff.
     */
    data: StaffCreateManyInput | StaffCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Staff update
   */
  export type StaffUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null;
    /**
     * The data needed to update a Staff.
     */
    data: XOR<StaffUpdateInput, StaffUncheckedUpdateInput>;
    /**
     * Choose, which Staff to update.
     */
    where: StaffWhereUniqueInput;
  };

  /**
   * Staff updateMany
   */
  export type StaffUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Staff.
     */
    data: XOR<StaffUpdateManyMutationInput, StaffUncheckedUpdateManyInput>;
    /**
     * Filter which Staff to update
     */
    where?: StaffWhereInput;
    /**
     * Limit how many Staff to update.
     */
    limit?: number;
  };

  /**
   * Staff updateManyAndReturn
   */
  export type StaffUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null;
    /**
     * The data used to update Staff.
     */
    data: XOR<StaffUpdateManyMutationInput, StaffUncheckedUpdateManyInput>;
    /**
     * Filter which Staff to update
     */
    where?: StaffWhereInput;
    /**
     * Limit how many Staff to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Staff upsert
   */
  export type StaffUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null;
    /**
     * The filter to search for the Staff to update in case it exists.
     */
    where: StaffWhereUniqueInput;
    /**
     * In case the Staff found by the `where` argument doesn't exist, create a new Staff with this data.
     */
    create: XOR<StaffCreateInput, StaffUncheckedCreateInput>;
    /**
     * In case the Staff was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StaffUpdateInput, StaffUncheckedUpdateInput>;
  };

  /**
   * Staff delete
   */
  export type StaffDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null;
    /**
     * Filter which Staff to delete.
     */
    where: StaffWhereUniqueInput;
  };

  /**
   * Staff deleteMany
   */
  export type StaffDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Staff to delete
     */
    where?: StaffWhereInput;
    /**
     * Limit how many Staff to delete.
     */
    limit?: number;
  };

  /**
   * Staff.academicYearSubjects
   */
  export type Staff$academicYearSubjectsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AcademicYearSubject
     */
    select?: AcademicYearSubjectSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AcademicYearSubject
     */
    omit?: AcademicYearSubjectOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearSubjectInclude<ExtArgs> | null;
    where?: AcademicYearSubjectWhereInput;
    orderBy?:
      | AcademicYearSubjectOrderByWithRelationInput
      | AcademicYearSubjectOrderByWithRelationInput[];
    cursor?: AcademicYearSubjectWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?:
      | AcademicYearSubjectScalarFieldEnum
      | AcademicYearSubjectScalarFieldEnum[];
  };

  /**
   * Staff.classStreams
   */
  export type Staff$classStreamsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the classStream
     */
    select?: classStreamSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the classStream
     */
    omit?: classStreamOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: classStreamInclude<ExtArgs> | null;
    where?: classStreamWhereInput;
    orderBy?:
      | classStreamOrderByWithRelationInput
      | classStreamOrderByWithRelationInput[];
    cursor?: classStreamWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ClassStreamScalarFieldEnum | ClassStreamScalarFieldEnum[];
  };

  /**
   * Staff.user
   */
  export type Staff$userArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    where?: UserWhereInput;
  };

  /**
   * Staff without action
   */
  export type StaffDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null;
  };

  /**
   * Model Level
   */

  export type AggregateLevel = {
    _count: LevelCountAggregateOutputType | null;
    _min: LevelMinAggregateOutputType | null;
    _max: LevelMaxAggregateOutputType | null;
  };

  export type LevelMinAggregateOutputType = {
    id: string | null;
    name: string | null;
    slug: string | null;
  };

  export type LevelMaxAggregateOutputType = {
    id: string | null;
    name: string | null;
    slug: string | null;
  };

  export type LevelCountAggregateOutputType = {
    id: number;
    name: number;
    slug: number;
    _all: number;
  };

  export type LevelMinAggregateInputType = {
    id?: true;
    name?: true;
    slug?: true;
  };

  export type LevelMaxAggregateInputType = {
    id?: true;
    name?: true;
    slug?: true;
  };

  export type LevelCountAggregateInputType = {
    id?: true;
    name?: true;
    slug?: true;
    _all?: true;
  };

  export type LevelAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Level to aggregate.
     */
    where?: LevelWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Levels to fetch.
     */
    orderBy?: LevelOrderByWithRelationInput | LevelOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: LevelWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Levels from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Levels.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Levels
     **/
    _count?: true | LevelCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: LevelMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: LevelMaxAggregateInputType;
  };

  export type GetLevelAggregateType<T extends LevelAggregateArgs> = {
    [P in keyof T & keyof AggregateLevel]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLevel[P]>
      : GetScalarType<T[P], AggregateLevel[P]>;
  };

  export type LevelGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: LevelWhereInput;
    orderBy?:
      | LevelOrderByWithAggregationInput
      | LevelOrderByWithAggregationInput[];
    by: LevelScalarFieldEnum[] | LevelScalarFieldEnum;
    having?: LevelScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: LevelCountAggregateInputType | true;
    _min?: LevelMinAggregateInputType;
    _max?: LevelMaxAggregateInputType;
  };

  export type LevelGroupByOutputType = {
    id: string;
    name: string;
    slug: string;
    _count: LevelCountAggregateOutputType | null;
    _min: LevelMinAggregateOutputType | null;
    _max: LevelMaxAggregateOutputType | null;
  };

  type GetLevelGroupByPayload<T extends LevelGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<LevelGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof LevelGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LevelGroupByOutputType[P]>
            : GetScalarType<T[P], LevelGroupByOutputType[P]>;
        }
      >
    >;

  export type LevelSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      slug?: boolean;
      classes?: boolean | Level$classesArgs<ExtArgs>;
      subjects?: boolean | Level$subjectsArgs<ExtArgs>;
      _count?: boolean | LevelCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["level"]
  >;

  export type LevelSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      slug?: boolean;
    },
    ExtArgs["result"]["level"]
  >;

  export type LevelSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      slug?: boolean;
    },
    ExtArgs["result"]["level"]
  >;

  export type LevelSelectScalar = {
    id?: boolean;
    name?: boolean;
    slug?: boolean;
  };

  export type LevelOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<"id" | "name" | "slug", ExtArgs["result"]["level"]>;
  export type LevelInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    classes?: boolean | Level$classesArgs<ExtArgs>;
    subjects?: boolean | Level$subjectsArgs<ExtArgs>;
    _count?: boolean | LevelCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type LevelIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};
  export type LevelIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};

  export type $LevelPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "Level";
    objects: {
      classes: Prisma.$ClassPayload<ExtArgs>[];
      subjects: Prisma.$SubjectPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        name: string;
        slug: string;
      },
      ExtArgs["result"]["level"]
    >;
    composites: {};
  };

  type LevelGetPayload<
    S extends boolean | null | undefined | LevelDefaultArgs,
  > = $Result.GetResult<Prisma.$LevelPayload, S>;

  type LevelCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<LevelFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
    select?: LevelCountAggregateInputType | true;
  };

  export interface LevelDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["Level"];
      meta: { name: "Level" };
    };
    /**
     * Find zero or one Level that matches the filter.
     * @param {LevelFindUniqueArgs} args - Arguments to find a Level
     * @example
     * // Get one Level
     * const level = await prisma.level.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LevelFindUniqueArgs>(
      args: SelectSubset<T, LevelFindUniqueArgs<ExtArgs>>,
    ): Prisma__LevelClient<
      $Result.GetResult<
        Prisma.$LevelPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Level that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LevelFindUniqueOrThrowArgs} args - Arguments to find a Level
     * @example
     * // Get one Level
     * const level = await prisma.level.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LevelFindUniqueOrThrowArgs>(
      args: SelectSubset<T, LevelFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__LevelClient<
      $Result.GetResult<
        Prisma.$LevelPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Level that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevelFindFirstArgs} args - Arguments to find a Level
     * @example
     * // Get one Level
     * const level = await prisma.level.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LevelFindFirstArgs>(
      args?: SelectSubset<T, LevelFindFirstArgs<ExtArgs>>,
    ): Prisma__LevelClient<
      $Result.GetResult<
        Prisma.$LevelPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Level that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevelFindFirstOrThrowArgs} args - Arguments to find a Level
     * @example
     * // Get one Level
     * const level = await prisma.level.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LevelFindFirstOrThrowArgs>(
      args?: SelectSubset<T, LevelFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__LevelClient<
      $Result.GetResult<
        Prisma.$LevelPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Levels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Levels
     * const levels = await prisma.level.findMany()
     *
     * // Get first 10 Levels
     * const levels = await prisma.level.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const levelWithIdOnly = await prisma.level.findMany({ select: { id: true } })
     *
     */
    findMany<T extends LevelFindManyArgs>(
      args?: SelectSubset<T, LevelFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$LevelPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Level.
     * @param {LevelCreateArgs} args - Arguments to create a Level.
     * @example
     * // Create one Level
     * const Level = await prisma.level.create({
     *   data: {
     *     // ... data to create a Level
     *   }
     * })
     *
     */
    create<T extends LevelCreateArgs>(
      args: SelectSubset<T, LevelCreateArgs<ExtArgs>>,
    ): Prisma__LevelClient<
      $Result.GetResult<
        Prisma.$LevelPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Levels.
     * @param {LevelCreateManyArgs} args - Arguments to create many Levels.
     * @example
     * // Create many Levels
     * const level = await prisma.level.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends LevelCreateManyArgs>(
      args?: SelectSubset<T, LevelCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Levels and returns the data saved in the database.
     * @param {LevelCreateManyAndReturnArgs} args - Arguments to create many Levels.
     * @example
     * // Create many Levels
     * const level = await prisma.level.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Levels and only return the `id`
     * const levelWithIdOnly = await prisma.level.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends LevelCreateManyAndReturnArgs>(
      args?: SelectSubset<T, LevelCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$LevelPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Level.
     * @param {LevelDeleteArgs} args - Arguments to delete one Level.
     * @example
     * // Delete one Level
     * const Level = await prisma.level.delete({
     *   where: {
     *     // ... filter to delete one Level
     *   }
     * })
     *
     */
    delete<T extends LevelDeleteArgs>(
      args: SelectSubset<T, LevelDeleteArgs<ExtArgs>>,
    ): Prisma__LevelClient<
      $Result.GetResult<
        Prisma.$LevelPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Level.
     * @param {LevelUpdateArgs} args - Arguments to update one Level.
     * @example
     * // Update one Level
     * const level = await prisma.level.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends LevelUpdateArgs>(
      args: SelectSubset<T, LevelUpdateArgs<ExtArgs>>,
    ): Prisma__LevelClient<
      $Result.GetResult<
        Prisma.$LevelPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Levels.
     * @param {LevelDeleteManyArgs} args - Arguments to filter Levels to delete.
     * @example
     * // Delete a few Levels
     * const { count } = await prisma.level.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends LevelDeleteManyArgs>(
      args?: SelectSubset<T, LevelDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Levels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Levels
     * const level = await prisma.level.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends LevelUpdateManyArgs>(
      args: SelectSubset<T, LevelUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Levels and returns the data updated in the database.
     * @param {LevelUpdateManyAndReturnArgs} args - Arguments to update many Levels.
     * @example
     * // Update many Levels
     * const level = await prisma.level.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Levels and only return the `id`
     * const levelWithIdOnly = await prisma.level.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends LevelUpdateManyAndReturnArgs>(
      args: SelectSubset<T, LevelUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$LevelPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Level.
     * @param {LevelUpsertArgs} args - Arguments to update or create a Level.
     * @example
     * // Update or create a Level
     * const level = await prisma.level.upsert({
     *   create: {
     *     // ... data to create a Level
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Level we want to update
     *   }
     * })
     */
    upsert<T extends LevelUpsertArgs>(
      args: SelectSubset<T, LevelUpsertArgs<ExtArgs>>,
    ): Prisma__LevelClient<
      $Result.GetResult<
        Prisma.$LevelPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Levels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevelCountArgs} args - Arguments to filter Levels to count.
     * @example
     * // Count the number of Levels
     * const count = await prisma.level.count({
     *   where: {
     *     // ... the filter for the Levels we want to count
     *   }
     * })
     **/
    count<T extends LevelCountArgs>(
      args?: Subset<T, LevelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], LevelCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Level.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends LevelAggregateArgs>(
      args: Subset<T, LevelAggregateArgs>,
    ): Prisma.PrismaPromise<GetLevelAggregateType<T>>;

    /**
     * Group by Level.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends LevelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LevelGroupByArgs["orderBy"] }
        : { orderBy?: LevelGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, LevelGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetLevelGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Level model
     */
    readonly fields: LevelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Level.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LevelClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    classes<T extends Level$classesArgs<ExtArgs> = {}>(
      args?: Subset<T, Level$classesArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$ClassPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    subjects<T extends Level$subjectsArgs<ExtArgs> = {}>(
      args?: Subset<T, Level$subjectsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$SubjectPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Level model
   */
  interface LevelFieldRefs {
    readonly id: FieldRef<"Level", "String">;
    readonly name: FieldRef<"Level", "String">;
    readonly slug: FieldRef<"Level", "String">;
  }

  // Custom InputTypes
  /**
   * Level findUnique
   */
  export type LevelFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null;
    /**
     * Filter, which Level to fetch.
     */
    where: LevelWhereUniqueInput;
  };

  /**
   * Level findUniqueOrThrow
   */
  export type LevelFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null;
    /**
     * Filter, which Level to fetch.
     */
    where: LevelWhereUniqueInput;
  };

  /**
   * Level findFirst
   */
  export type LevelFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null;
    /**
     * Filter, which Level to fetch.
     */
    where?: LevelWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Levels to fetch.
     */
    orderBy?: LevelOrderByWithRelationInput | LevelOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Levels.
     */
    cursor?: LevelWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Levels from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Levels.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Levels.
     */
    distinct?: LevelScalarFieldEnum | LevelScalarFieldEnum[];
  };

  /**
   * Level findFirstOrThrow
   */
  export type LevelFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null;
    /**
     * Filter, which Level to fetch.
     */
    where?: LevelWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Levels to fetch.
     */
    orderBy?: LevelOrderByWithRelationInput | LevelOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Levels.
     */
    cursor?: LevelWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Levels from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Levels.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Levels.
     */
    distinct?: LevelScalarFieldEnum | LevelScalarFieldEnum[];
  };

  /**
   * Level findMany
   */
  export type LevelFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null;
    /**
     * Filter, which Levels to fetch.
     */
    where?: LevelWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Levels to fetch.
     */
    orderBy?: LevelOrderByWithRelationInput | LevelOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Levels.
     */
    cursor?: LevelWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Levels from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Levels.
     */
    skip?: number;
    distinct?: LevelScalarFieldEnum | LevelScalarFieldEnum[];
  };

  /**
   * Level create
   */
  export type LevelCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null;
    /**
     * The data needed to create a Level.
     */
    data: XOR<LevelCreateInput, LevelUncheckedCreateInput>;
  };

  /**
   * Level createMany
   */
  export type LevelCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Levels.
     */
    data: LevelCreateManyInput | LevelCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Level createManyAndReturn
   */
  export type LevelCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null;
    /**
     * The data used to create many Levels.
     */
    data: LevelCreateManyInput | LevelCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Level update
   */
  export type LevelUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null;
    /**
     * The data needed to update a Level.
     */
    data: XOR<LevelUpdateInput, LevelUncheckedUpdateInput>;
    /**
     * Choose, which Level to update.
     */
    where: LevelWhereUniqueInput;
  };

  /**
   * Level updateMany
   */
  export type LevelUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Levels.
     */
    data: XOR<LevelUpdateManyMutationInput, LevelUncheckedUpdateManyInput>;
    /**
     * Filter which Levels to update
     */
    where?: LevelWhereInput;
    /**
     * Limit how many Levels to update.
     */
    limit?: number;
  };

  /**
   * Level updateManyAndReturn
   */
  export type LevelUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null;
    /**
     * The data used to update Levels.
     */
    data: XOR<LevelUpdateManyMutationInput, LevelUncheckedUpdateManyInput>;
    /**
     * Filter which Levels to update
     */
    where?: LevelWhereInput;
    /**
     * Limit how many Levels to update.
     */
    limit?: number;
  };

  /**
   * Level upsert
   */
  export type LevelUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null;
    /**
     * The filter to search for the Level to update in case it exists.
     */
    where: LevelWhereUniqueInput;
    /**
     * In case the Level found by the `where` argument doesn't exist, create a new Level with this data.
     */
    create: XOR<LevelCreateInput, LevelUncheckedCreateInput>;
    /**
     * In case the Level was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LevelUpdateInput, LevelUncheckedUpdateInput>;
  };

  /**
   * Level delete
   */
  export type LevelDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null;
    /**
     * Filter which Level to delete.
     */
    where: LevelWhereUniqueInput;
  };

  /**
   * Level deleteMany
   */
  export type LevelDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Levels to delete
     */
    where?: LevelWhereInput;
    /**
     * Limit how many Levels to delete.
     */
    limit?: number;
  };

  /**
   * Level.classes
   */
  export type Level$classesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null;
    where?: ClassWhereInput;
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[];
    cursor?: ClassWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[];
  };

  /**
   * Level.subjects
   */
  export type Level$subjectsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null;
    where?: SubjectWhereInput;
    orderBy?:
      | SubjectOrderByWithRelationInput
      | SubjectOrderByWithRelationInput[];
    cursor?: SubjectWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: SubjectScalarFieldEnum | SubjectScalarFieldEnum[];
  };

  /**
   * Level without action
   */
  export type LevelDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null;
  };

  /**
   * Model Stream
   */

  export type AggregateStream = {
    _count: StreamCountAggregateOutputType | null;
    _min: StreamMinAggregateOutputType | null;
    _max: StreamMaxAggregateOutputType | null;
  };

  export type StreamMinAggregateOutputType = {
    id: string | null;
    name: string | null;
  };

  export type StreamMaxAggregateOutputType = {
    id: string | null;
    name: string | null;
  };

  export type StreamCountAggregateOutputType = {
    id: number;
    name: number;
    _all: number;
  };

  export type StreamMinAggregateInputType = {
    id?: true;
    name?: true;
  };

  export type StreamMaxAggregateInputType = {
    id?: true;
    name?: true;
  };

  export type StreamCountAggregateInputType = {
    id?: true;
    name?: true;
    _all?: true;
  };

  export type StreamAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Stream to aggregate.
     */
    where?: StreamWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Streams to fetch.
     */
    orderBy?: StreamOrderByWithRelationInput | StreamOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: StreamWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Streams from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Streams.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Streams
     **/
    _count?: true | StreamCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: StreamMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: StreamMaxAggregateInputType;
  };

  export type GetStreamAggregateType<T extends StreamAggregateArgs> = {
    [P in keyof T & keyof AggregateStream]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStream[P]>
      : GetScalarType<T[P], AggregateStream[P]>;
  };

  export type StreamGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: StreamWhereInput;
    orderBy?:
      | StreamOrderByWithAggregationInput
      | StreamOrderByWithAggregationInput[];
    by: StreamScalarFieldEnum[] | StreamScalarFieldEnum;
    having?: StreamScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: StreamCountAggregateInputType | true;
    _min?: StreamMinAggregateInputType;
    _max?: StreamMaxAggregateInputType;
  };

  export type StreamGroupByOutputType = {
    id: string;
    name: string;
    _count: StreamCountAggregateOutputType | null;
    _min: StreamMinAggregateOutputType | null;
    _max: StreamMaxAggregateOutputType | null;
  };

  type GetStreamGroupByPayload<T extends StreamGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<StreamGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof StreamGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StreamGroupByOutputType[P]>
            : GetScalarType<T[P], StreamGroupByOutputType[P]>;
        }
      >
    >;

  export type StreamSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      classStreams?: boolean | Stream$classStreamsArgs<ExtArgs>;
      _count?: boolean | StreamCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["stream"]
  >;

  export type StreamSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
    },
    ExtArgs["result"]["stream"]
  >;

  export type StreamSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
    },
    ExtArgs["result"]["stream"]
  >;

  export type StreamSelectScalar = {
    id?: boolean;
    name?: boolean;
  };

  export type StreamOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["stream"]>;
  export type StreamInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    classStreams?: boolean | Stream$classStreamsArgs<ExtArgs>;
    _count?: boolean | StreamCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type StreamIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};
  export type StreamIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};

  export type $StreamPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "Stream";
    objects: {
      classStreams: Prisma.$classStreamPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        name: string;
      },
      ExtArgs["result"]["stream"]
    >;
    composites: {};
  };

  type StreamGetPayload<
    S extends boolean | null | undefined | StreamDefaultArgs,
  > = $Result.GetResult<Prisma.$StreamPayload, S>;

  type StreamCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<StreamFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
    select?: StreamCountAggregateInputType | true;
  };

  export interface StreamDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["Stream"];
      meta: { name: "Stream" };
    };
    /**
     * Find zero or one Stream that matches the filter.
     * @param {StreamFindUniqueArgs} args - Arguments to find a Stream
     * @example
     * // Get one Stream
     * const stream = await prisma.stream.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StreamFindUniqueArgs>(
      args: SelectSubset<T, StreamFindUniqueArgs<ExtArgs>>,
    ): Prisma__StreamClient<
      $Result.GetResult<
        Prisma.$StreamPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Stream that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StreamFindUniqueOrThrowArgs} args - Arguments to find a Stream
     * @example
     * // Get one Stream
     * const stream = await prisma.stream.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StreamFindUniqueOrThrowArgs>(
      args: SelectSubset<T, StreamFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__StreamClient<
      $Result.GetResult<
        Prisma.$StreamPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Stream that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StreamFindFirstArgs} args - Arguments to find a Stream
     * @example
     * // Get one Stream
     * const stream = await prisma.stream.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StreamFindFirstArgs>(
      args?: SelectSubset<T, StreamFindFirstArgs<ExtArgs>>,
    ): Prisma__StreamClient<
      $Result.GetResult<
        Prisma.$StreamPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Stream that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StreamFindFirstOrThrowArgs} args - Arguments to find a Stream
     * @example
     * // Get one Stream
     * const stream = await prisma.stream.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StreamFindFirstOrThrowArgs>(
      args?: SelectSubset<T, StreamFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__StreamClient<
      $Result.GetResult<
        Prisma.$StreamPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Streams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StreamFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Streams
     * const streams = await prisma.stream.findMany()
     *
     * // Get first 10 Streams
     * const streams = await prisma.stream.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const streamWithIdOnly = await prisma.stream.findMany({ select: { id: true } })
     *
     */
    findMany<T extends StreamFindManyArgs>(
      args?: SelectSubset<T, StreamFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$StreamPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Stream.
     * @param {StreamCreateArgs} args - Arguments to create a Stream.
     * @example
     * // Create one Stream
     * const Stream = await prisma.stream.create({
     *   data: {
     *     // ... data to create a Stream
     *   }
     * })
     *
     */
    create<T extends StreamCreateArgs>(
      args: SelectSubset<T, StreamCreateArgs<ExtArgs>>,
    ): Prisma__StreamClient<
      $Result.GetResult<
        Prisma.$StreamPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Streams.
     * @param {StreamCreateManyArgs} args - Arguments to create many Streams.
     * @example
     * // Create many Streams
     * const stream = await prisma.stream.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends StreamCreateManyArgs>(
      args?: SelectSubset<T, StreamCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Streams and returns the data saved in the database.
     * @param {StreamCreateManyAndReturnArgs} args - Arguments to create many Streams.
     * @example
     * // Create many Streams
     * const stream = await prisma.stream.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Streams and only return the `id`
     * const streamWithIdOnly = await prisma.stream.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends StreamCreateManyAndReturnArgs>(
      args?: SelectSubset<T, StreamCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$StreamPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Stream.
     * @param {StreamDeleteArgs} args - Arguments to delete one Stream.
     * @example
     * // Delete one Stream
     * const Stream = await prisma.stream.delete({
     *   where: {
     *     // ... filter to delete one Stream
     *   }
     * })
     *
     */
    delete<T extends StreamDeleteArgs>(
      args: SelectSubset<T, StreamDeleteArgs<ExtArgs>>,
    ): Prisma__StreamClient<
      $Result.GetResult<
        Prisma.$StreamPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Stream.
     * @param {StreamUpdateArgs} args - Arguments to update one Stream.
     * @example
     * // Update one Stream
     * const stream = await prisma.stream.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends StreamUpdateArgs>(
      args: SelectSubset<T, StreamUpdateArgs<ExtArgs>>,
    ): Prisma__StreamClient<
      $Result.GetResult<
        Prisma.$StreamPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Streams.
     * @param {StreamDeleteManyArgs} args - Arguments to filter Streams to delete.
     * @example
     * // Delete a few Streams
     * const { count } = await prisma.stream.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends StreamDeleteManyArgs>(
      args?: SelectSubset<T, StreamDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Streams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StreamUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Streams
     * const stream = await prisma.stream.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends StreamUpdateManyArgs>(
      args: SelectSubset<T, StreamUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Streams and returns the data updated in the database.
     * @param {StreamUpdateManyAndReturnArgs} args - Arguments to update many Streams.
     * @example
     * // Update many Streams
     * const stream = await prisma.stream.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Streams and only return the `id`
     * const streamWithIdOnly = await prisma.stream.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends StreamUpdateManyAndReturnArgs>(
      args: SelectSubset<T, StreamUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$StreamPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Stream.
     * @param {StreamUpsertArgs} args - Arguments to update or create a Stream.
     * @example
     * // Update or create a Stream
     * const stream = await prisma.stream.upsert({
     *   create: {
     *     // ... data to create a Stream
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Stream we want to update
     *   }
     * })
     */
    upsert<T extends StreamUpsertArgs>(
      args: SelectSubset<T, StreamUpsertArgs<ExtArgs>>,
    ): Prisma__StreamClient<
      $Result.GetResult<
        Prisma.$StreamPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Streams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StreamCountArgs} args - Arguments to filter Streams to count.
     * @example
     * // Count the number of Streams
     * const count = await prisma.stream.count({
     *   where: {
     *     // ... the filter for the Streams we want to count
     *   }
     * })
     **/
    count<T extends StreamCountArgs>(
      args?: Subset<T, StreamCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], StreamCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Stream.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StreamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends StreamAggregateArgs>(
      args: Subset<T, StreamAggregateArgs>,
    ): Prisma.PrismaPromise<GetStreamAggregateType<T>>;

    /**
     * Group by Stream.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StreamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends StreamGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StreamGroupByArgs["orderBy"] }
        : { orderBy?: StreamGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, StreamGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetStreamGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Stream model
     */
    readonly fields: StreamFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Stream.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StreamClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    classStreams<T extends Stream$classStreamsArgs<ExtArgs> = {}>(
      args?: Subset<T, Stream$classStreamsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$classStreamPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Stream model
   */
  interface StreamFieldRefs {
    readonly id: FieldRef<"Stream", "String">;
    readonly name: FieldRef<"Stream", "String">;
  }

  // Custom InputTypes
  /**
   * Stream findUnique
   */
  export type StreamFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Stream
     */
    select?: StreamSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Stream
     */
    omit?: StreamOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreamInclude<ExtArgs> | null;
    /**
     * Filter, which Stream to fetch.
     */
    where: StreamWhereUniqueInput;
  };

  /**
   * Stream findUniqueOrThrow
   */
  export type StreamFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Stream
     */
    select?: StreamSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Stream
     */
    omit?: StreamOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreamInclude<ExtArgs> | null;
    /**
     * Filter, which Stream to fetch.
     */
    where: StreamWhereUniqueInput;
  };

  /**
   * Stream findFirst
   */
  export type StreamFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Stream
     */
    select?: StreamSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Stream
     */
    omit?: StreamOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreamInclude<ExtArgs> | null;
    /**
     * Filter, which Stream to fetch.
     */
    where?: StreamWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Streams to fetch.
     */
    orderBy?: StreamOrderByWithRelationInput | StreamOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Streams.
     */
    cursor?: StreamWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Streams from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Streams.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Streams.
     */
    distinct?: StreamScalarFieldEnum | StreamScalarFieldEnum[];
  };

  /**
   * Stream findFirstOrThrow
   */
  export type StreamFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Stream
     */
    select?: StreamSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Stream
     */
    omit?: StreamOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreamInclude<ExtArgs> | null;
    /**
     * Filter, which Stream to fetch.
     */
    where?: StreamWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Streams to fetch.
     */
    orderBy?: StreamOrderByWithRelationInput | StreamOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Streams.
     */
    cursor?: StreamWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Streams from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Streams.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Streams.
     */
    distinct?: StreamScalarFieldEnum | StreamScalarFieldEnum[];
  };

  /**
   * Stream findMany
   */
  export type StreamFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Stream
     */
    select?: StreamSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Stream
     */
    omit?: StreamOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreamInclude<ExtArgs> | null;
    /**
     * Filter, which Streams to fetch.
     */
    where?: StreamWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Streams to fetch.
     */
    orderBy?: StreamOrderByWithRelationInput | StreamOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Streams.
     */
    cursor?: StreamWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Streams from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Streams.
     */
    skip?: number;
    distinct?: StreamScalarFieldEnum | StreamScalarFieldEnum[];
  };

  /**
   * Stream create
   */
  export type StreamCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Stream
     */
    select?: StreamSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Stream
     */
    omit?: StreamOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreamInclude<ExtArgs> | null;
    /**
     * The data needed to create a Stream.
     */
    data: XOR<StreamCreateInput, StreamUncheckedCreateInput>;
  };

  /**
   * Stream createMany
   */
  export type StreamCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Streams.
     */
    data: StreamCreateManyInput | StreamCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Stream createManyAndReturn
   */
  export type StreamCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Stream
     */
    select?: StreamSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Stream
     */
    omit?: StreamOmit<ExtArgs> | null;
    /**
     * The data used to create many Streams.
     */
    data: StreamCreateManyInput | StreamCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Stream update
   */
  export type StreamUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Stream
     */
    select?: StreamSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Stream
     */
    omit?: StreamOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreamInclude<ExtArgs> | null;
    /**
     * The data needed to update a Stream.
     */
    data: XOR<StreamUpdateInput, StreamUncheckedUpdateInput>;
    /**
     * Choose, which Stream to update.
     */
    where: StreamWhereUniqueInput;
  };

  /**
   * Stream updateMany
   */
  export type StreamUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Streams.
     */
    data: XOR<StreamUpdateManyMutationInput, StreamUncheckedUpdateManyInput>;
    /**
     * Filter which Streams to update
     */
    where?: StreamWhereInput;
    /**
     * Limit how many Streams to update.
     */
    limit?: number;
  };

  /**
   * Stream updateManyAndReturn
   */
  export type StreamUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Stream
     */
    select?: StreamSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Stream
     */
    omit?: StreamOmit<ExtArgs> | null;
    /**
     * The data used to update Streams.
     */
    data: XOR<StreamUpdateManyMutationInput, StreamUncheckedUpdateManyInput>;
    /**
     * Filter which Streams to update
     */
    where?: StreamWhereInput;
    /**
     * Limit how many Streams to update.
     */
    limit?: number;
  };

  /**
   * Stream upsert
   */
  export type StreamUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Stream
     */
    select?: StreamSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Stream
     */
    omit?: StreamOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreamInclude<ExtArgs> | null;
    /**
     * The filter to search for the Stream to update in case it exists.
     */
    where: StreamWhereUniqueInput;
    /**
     * In case the Stream found by the `where` argument doesn't exist, create a new Stream with this data.
     */
    create: XOR<StreamCreateInput, StreamUncheckedCreateInput>;
    /**
     * In case the Stream was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StreamUpdateInput, StreamUncheckedUpdateInput>;
  };

  /**
   * Stream delete
   */
  export type StreamDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Stream
     */
    select?: StreamSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Stream
     */
    omit?: StreamOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreamInclude<ExtArgs> | null;
    /**
     * Filter which Stream to delete.
     */
    where: StreamWhereUniqueInput;
  };

  /**
   * Stream deleteMany
   */
  export type StreamDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Streams to delete
     */
    where?: StreamWhereInput;
    /**
     * Limit how many Streams to delete.
     */
    limit?: number;
  };

  /**
   * Stream.classStreams
   */
  export type Stream$classStreamsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the classStream
     */
    select?: classStreamSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the classStream
     */
    omit?: classStreamOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: classStreamInclude<ExtArgs> | null;
    where?: classStreamWhereInput;
    orderBy?:
      | classStreamOrderByWithRelationInput
      | classStreamOrderByWithRelationInput[];
    cursor?: classStreamWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ClassStreamScalarFieldEnum | ClassStreamScalarFieldEnum[];
  };

  /**
   * Stream without action
   */
  export type StreamDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Stream
     */
    select?: StreamSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Stream
     */
    omit?: StreamOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreamInclude<ExtArgs> | null;
  };

  /**
   * Model Class
   */

  export type AggregateClass = {
    _count: ClassCountAggregateOutputType | null;
    _min: ClassMinAggregateOutputType | null;
    _max: ClassMaxAggregateOutputType | null;
  };

  export type ClassMinAggregateOutputType = {
    id: string | null;
    name: string | null;
    levelId: string | null;
    createdAt: Date | null;
    slug: string | null;
  };

  export type ClassMaxAggregateOutputType = {
    id: string | null;
    name: string | null;
    levelId: string | null;
    createdAt: Date | null;
    slug: string | null;
  };

  export type ClassCountAggregateOutputType = {
    id: number;
    name: number;
    levelId: number;
    createdAt: number;
    slug: number;
    _all: number;
  };

  export type ClassMinAggregateInputType = {
    id?: true;
    name?: true;
    levelId?: true;
    createdAt?: true;
    slug?: true;
  };

  export type ClassMaxAggregateInputType = {
    id?: true;
    name?: true;
    levelId?: true;
    createdAt?: true;
    slug?: true;
  };

  export type ClassCountAggregateInputType = {
    id?: true;
    name?: true;
    levelId?: true;
    createdAt?: true;
    slug?: true;
    _all?: true;
  };

  export type ClassAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Class to aggregate.
     */
    where?: ClassWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ClassWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Classes.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Classes
     **/
    _count?: true | ClassCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ClassMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ClassMaxAggregateInputType;
  };

  export type GetClassAggregateType<T extends ClassAggregateArgs> = {
    [P in keyof T & keyof AggregateClass]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClass[P]>
      : GetScalarType<T[P], AggregateClass[P]>;
  };

  export type ClassGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ClassWhereInput;
    orderBy?:
      | ClassOrderByWithAggregationInput
      | ClassOrderByWithAggregationInput[];
    by: ClassScalarFieldEnum[] | ClassScalarFieldEnum;
    having?: ClassScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ClassCountAggregateInputType | true;
    _min?: ClassMinAggregateInputType;
    _max?: ClassMaxAggregateInputType;
  };

  export type ClassGroupByOutputType = {
    id: string;
    name: string;
    levelId: string | null;
    createdAt: Date;
    slug: string;
    _count: ClassCountAggregateOutputType | null;
    _min: ClassMinAggregateOutputType | null;
    _max: ClassMaxAggregateOutputType | null;
  };

  type GetClassGroupByPayload<T extends ClassGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<ClassGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof ClassGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClassGroupByOutputType[P]>
            : GetScalarType<T[P], ClassGroupByOutputType[P]>;
        }
      >
    >;

  export type ClassSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      levelId?: boolean;
      createdAt?: boolean;
      slug?: boolean;
      academicYearClasses?: boolean | Class$academicYearClassesArgs<ExtArgs>;
      level?: boolean | Class$levelArgs<ExtArgs>;
      _count?: boolean | ClassCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["class"]
  >;

  export type ClassSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      levelId?: boolean;
      createdAt?: boolean;
      slug?: boolean;
      level?: boolean | Class$levelArgs<ExtArgs>;
    },
    ExtArgs["result"]["class"]
  >;

  export type ClassSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      levelId?: boolean;
      createdAt?: boolean;
      slug?: boolean;
      level?: boolean | Class$levelArgs<ExtArgs>;
    },
    ExtArgs["result"]["class"]
  >;

  export type ClassSelectScalar = {
    id?: boolean;
    name?: boolean;
    levelId?: boolean;
    createdAt?: boolean;
    slug?: boolean;
  };

  export type ClassOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    "id" | "name" | "levelId" | "createdAt" | "slug",
    ExtArgs["result"]["class"]
  >;
  export type ClassInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    academicYearClasses?: boolean | Class$academicYearClassesArgs<ExtArgs>;
    level?: boolean | Class$levelArgs<ExtArgs>;
    _count?: boolean | ClassCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type ClassIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    level?: boolean | Class$levelArgs<ExtArgs>;
  };
  export type ClassIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    level?: boolean | Class$levelArgs<ExtArgs>;
  };

  export type $ClassPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "Class";
    objects: {
      academicYearClasses: Prisma.$AcademicYearClassPayload<ExtArgs>[];
      level: Prisma.$LevelPayload<ExtArgs> | null;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        name: string;
        levelId: string | null;
        createdAt: Date;
        slug: string;
      },
      ExtArgs["result"]["class"]
    >;
    composites: {};
  };

  type ClassGetPayload<
    S extends boolean | null | undefined | ClassDefaultArgs,
  > = $Result.GetResult<Prisma.$ClassPayload, S>;

  type ClassCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<ClassFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
    select?: ClassCountAggregateInputType | true;
  };

  export interface ClassDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["Class"];
      meta: { name: "Class" };
    };
    /**
     * Find zero or one Class that matches the filter.
     * @param {ClassFindUniqueArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClassFindUniqueArgs>(
      args: SelectSubset<T, ClassFindUniqueArgs<ExtArgs>>,
    ): Prisma__ClassClient<
      $Result.GetResult<
        Prisma.$ClassPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Class that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClassFindUniqueOrThrowArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClassFindUniqueOrThrowArgs>(
      args: SelectSubset<T, ClassFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__ClassClient<
      $Result.GetResult<
        Prisma.$ClassPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Class that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassFindFirstArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClassFindFirstArgs>(
      args?: SelectSubset<T, ClassFindFirstArgs<ExtArgs>>,
    ): Prisma__ClassClient<
      $Result.GetResult<
        Prisma.$ClassPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Class that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassFindFirstOrThrowArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClassFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ClassFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__ClassClient<
      $Result.GetResult<
        Prisma.$ClassPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Classes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Classes
     * const classes = await prisma.class.findMany()
     *
     * // Get first 10 Classes
     * const classes = await prisma.class.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const classWithIdOnly = await prisma.class.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ClassFindManyArgs>(
      args?: SelectSubset<T, ClassFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ClassPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Class.
     * @param {ClassCreateArgs} args - Arguments to create a Class.
     * @example
     * // Create one Class
     * const Class = await prisma.class.create({
     *   data: {
     *     // ... data to create a Class
     *   }
     * })
     *
     */
    create<T extends ClassCreateArgs>(
      args: SelectSubset<T, ClassCreateArgs<ExtArgs>>,
    ): Prisma__ClassClient<
      $Result.GetResult<
        Prisma.$ClassPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Classes.
     * @param {ClassCreateManyArgs} args - Arguments to create many Classes.
     * @example
     * // Create many Classes
     * const class = await prisma.class.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ClassCreateManyArgs>(
      args?: SelectSubset<T, ClassCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Classes and returns the data saved in the database.
     * @param {ClassCreateManyAndReturnArgs} args - Arguments to create many Classes.
     * @example
     * // Create many Classes
     * const class = await prisma.class.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Classes and only return the `id`
     * const classWithIdOnly = await prisma.class.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends ClassCreateManyAndReturnArgs>(
      args?: SelectSubset<T, ClassCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ClassPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Class.
     * @param {ClassDeleteArgs} args - Arguments to delete one Class.
     * @example
     * // Delete one Class
     * const Class = await prisma.class.delete({
     *   where: {
     *     // ... filter to delete one Class
     *   }
     * })
     *
     */
    delete<T extends ClassDeleteArgs>(
      args: SelectSubset<T, ClassDeleteArgs<ExtArgs>>,
    ): Prisma__ClassClient<
      $Result.GetResult<
        Prisma.$ClassPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Class.
     * @param {ClassUpdateArgs} args - Arguments to update one Class.
     * @example
     * // Update one Class
     * const class = await prisma.class.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ClassUpdateArgs>(
      args: SelectSubset<T, ClassUpdateArgs<ExtArgs>>,
    ): Prisma__ClassClient<
      $Result.GetResult<
        Prisma.$ClassPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Classes.
     * @param {ClassDeleteManyArgs} args - Arguments to filter Classes to delete.
     * @example
     * // Delete a few Classes
     * const { count } = await prisma.class.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ClassDeleteManyArgs>(
      args?: SelectSubset<T, ClassDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Classes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Classes
     * const class = await prisma.class.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ClassUpdateManyArgs>(
      args: SelectSubset<T, ClassUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Classes and returns the data updated in the database.
     * @param {ClassUpdateManyAndReturnArgs} args - Arguments to update many Classes.
     * @example
     * // Update many Classes
     * const class = await prisma.class.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Classes and only return the `id`
     * const classWithIdOnly = await prisma.class.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends ClassUpdateManyAndReturnArgs>(
      args: SelectSubset<T, ClassUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ClassPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Class.
     * @param {ClassUpsertArgs} args - Arguments to update or create a Class.
     * @example
     * // Update or create a Class
     * const class = await prisma.class.upsert({
     *   create: {
     *     // ... data to create a Class
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Class we want to update
     *   }
     * })
     */
    upsert<T extends ClassUpsertArgs>(
      args: SelectSubset<T, ClassUpsertArgs<ExtArgs>>,
    ): Prisma__ClassClient<
      $Result.GetResult<
        Prisma.$ClassPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Classes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassCountArgs} args - Arguments to filter Classes to count.
     * @example
     * // Count the number of Classes
     * const count = await prisma.class.count({
     *   where: {
     *     // ... the filter for the Classes we want to count
     *   }
     * })
     **/
    count<T extends ClassCountArgs>(
      args?: Subset<T, ClassCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], ClassCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Class.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ClassAggregateArgs>(
      args: Subset<T, ClassAggregateArgs>,
    ): Prisma.PrismaPromise<GetClassAggregateType<T>>;

    /**
     * Group by Class.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends ClassGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClassGroupByArgs["orderBy"] }
        : { orderBy?: ClassGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, ClassGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetClassGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Class model
     */
    readonly fields: ClassFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Class.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClassClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    academicYearClasses<T extends Class$academicYearClassesArgs<ExtArgs> = {}>(
      args?: Subset<T, Class$academicYearClassesArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$AcademicYearClassPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    level<T extends Class$levelArgs<ExtArgs> = {}>(
      args?: Subset<T, Class$levelArgs<ExtArgs>>,
    ): Prisma__LevelClient<
      $Result.GetResult<
        Prisma.$LevelPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Class model
   */
  interface ClassFieldRefs {
    readonly id: FieldRef<"Class", "String">;
    readonly name: FieldRef<"Class", "String">;
    readonly levelId: FieldRef<"Class", "String">;
    readonly createdAt: FieldRef<"Class", "DateTime">;
    readonly slug: FieldRef<"Class", "String">;
  }

  // Custom InputTypes
  /**
   * Class findUnique
   */
  export type ClassFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null;
    /**
     * Filter, which Class to fetch.
     */
    where: ClassWhereUniqueInput;
  };

  /**
   * Class findUniqueOrThrow
   */
  export type ClassFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null;
    /**
     * Filter, which Class to fetch.
     */
    where: ClassWhereUniqueInput;
  };

  /**
   * Class findFirst
   */
  export type ClassFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null;
    /**
     * Filter, which Class to fetch.
     */
    where?: ClassWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Classes.
     */
    cursor?: ClassWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Classes.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Classes.
     */
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[];
  };

  /**
   * Class findFirstOrThrow
   */
  export type ClassFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null;
    /**
     * Filter, which Class to fetch.
     */
    where?: ClassWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Classes.
     */
    cursor?: ClassWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Classes.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Classes.
     */
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[];
  };

  /**
   * Class findMany
   */
  export type ClassFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null;
    /**
     * Filter, which Classes to fetch.
     */
    where?: ClassWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Classes.
     */
    cursor?: ClassWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Classes.
     */
    skip?: number;
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[];
  };

  /**
   * Class create
   */
  export type ClassCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null;
    /**
     * The data needed to create a Class.
     */
    data: XOR<ClassCreateInput, ClassUncheckedCreateInput>;
  };

  /**
   * Class createMany
   */
  export type ClassCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Classes.
     */
    data: ClassCreateManyInput | ClassCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Class createManyAndReturn
   */
  export type ClassCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null;
    /**
     * The data used to create many Classes.
     */
    data: ClassCreateManyInput | ClassCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Class update
   */
  export type ClassUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null;
    /**
     * The data needed to update a Class.
     */
    data: XOR<ClassUpdateInput, ClassUncheckedUpdateInput>;
    /**
     * Choose, which Class to update.
     */
    where: ClassWhereUniqueInput;
  };

  /**
   * Class updateMany
   */
  export type ClassUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Classes.
     */
    data: XOR<ClassUpdateManyMutationInput, ClassUncheckedUpdateManyInput>;
    /**
     * Filter which Classes to update
     */
    where?: ClassWhereInput;
    /**
     * Limit how many Classes to update.
     */
    limit?: number;
  };

  /**
   * Class updateManyAndReturn
   */
  export type ClassUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null;
    /**
     * The data used to update Classes.
     */
    data: XOR<ClassUpdateManyMutationInput, ClassUncheckedUpdateManyInput>;
    /**
     * Filter which Classes to update
     */
    where?: ClassWhereInput;
    /**
     * Limit how many Classes to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Class upsert
   */
  export type ClassUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null;
    /**
     * The filter to search for the Class to update in case it exists.
     */
    where: ClassWhereUniqueInput;
    /**
     * In case the Class found by the `where` argument doesn't exist, create a new Class with this data.
     */
    create: XOR<ClassCreateInput, ClassUncheckedCreateInput>;
    /**
     * In case the Class was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClassUpdateInput, ClassUncheckedUpdateInput>;
  };

  /**
   * Class delete
   */
  export type ClassDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null;
    /**
     * Filter which Class to delete.
     */
    where: ClassWhereUniqueInput;
  };

  /**
   * Class deleteMany
   */
  export type ClassDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Classes to delete
     */
    where?: ClassWhereInput;
    /**
     * Limit how many Classes to delete.
     */
    limit?: number;
  };

  /**
   * Class.academicYearClasses
   */
  export type Class$academicYearClassesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AcademicYearClass
     */
    select?: AcademicYearClassSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AcademicYearClass
     */
    omit?: AcademicYearClassOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearClassInclude<ExtArgs> | null;
    where?: AcademicYearClassWhereInput;
    orderBy?:
      | AcademicYearClassOrderByWithRelationInput
      | AcademicYearClassOrderByWithRelationInput[];
    cursor?: AcademicYearClassWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?:
      | AcademicYearClassScalarFieldEnum
      | AcademicYearClassScalarFieldEnum[];
  };

  /**
   * Class.level
   */
  export type Class$levelArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null;
    where?: LevelWhereInput;
  };

  /**
   * Class without action
   */
  export type ClassDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null;
  };

  /**
   * Model AcademicYear
   */

  export type AggregateAcademicYear = {
    _count: AcademicYearCountAggregateOutputType | null;
    _min: AcademicYearMinAggregateOutputType | null;
    _max: AcademicYearMaxAggregateOutputType | null;
  };

  export type AcademicYearMinAggregateOutputType = {
    id: string | null;
    year: string | null;
    startAt: Date | null;
    endAt: Date | null;
  };

  export type AcademicYearMaxAggregateOutputType = {
    id: string | null;
    year: string | null;
    startAt: Date | null;
    endAt: Date | null;
  };

  export type AcademicYearCountAggregateOutputType = {
    id: number;
    year: number;
    startAt: number;
    endAt: number;
    _all: number;
  };

  export type AcademicYearMinAggregateInputType = {
    id?: true;
    year?: true;
    startAt?: true;
    endAt?: true;
  };

  export type AcademicYearMaxAggregateInputType = {
    id?: true;
    year?: true;
    startAt?: true;
    endAt?: true;
  };

  export type AcademicYearCountAggregateInputType = {
    id?: true;
    year?: true;
    startAt?: true;
    endAt?: true;
    _all?: true;
  };

  export type AcademicYearAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which AcademicYear to aggregate.
     */
    where?: AcademicYearWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AcademicYears to fetch.
     */
    orderBy?:
      | AcademicYearOrderByWithRelationInput
      | AcademicYearOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: AcademicYearWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AcademicYears from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AcademicYears.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned AcademicYears
     **/
    _count?: true | AcademicYearCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: AcademicYearMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: AcademicYearMaxAggregateInputType;
  };

  export type GetAcademicYearAggregateType<
    T extends AcademicYearAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateAcademicYear]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAcademicYear[P]>
      : GetScalarType<T[P], AggregateAcademicYear[P]>;
  };

  export type AcademicYearGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AcademicYearWhereInput;
    orderBy?:
      | AcademicYearOrderByWithAggregationInput
      | AcademicYearOrderByWithAggregationInput[];
    by: AcademicYearScalarFieldEnum[] | AcademicYearScalarFieldEnum;
    having?: AcademicYearScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: AcademicYearCountAggregateInputType | true;
    _min?: AcademicYearMinAggregateInputType;
    _max?: AcademicYearMaxAggregateInputType;
  };

  export type AcademicYearGroupByOutputType = {
    id: string;
    year: string;
    startAt: Date;
    endAt: Date;
    _count: AcademicYearCountAggregateOutputType | null;
    _min: AcademicYearMinAggregateOutputType | null;
    _max: AcademicYearMaxAggregateOutputType | null;
  };

  type GetAcademicYearGroupByPayload<T extends AcademicYearGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<AcademicYearGroupByOutputType, T["by"]> & {
          [P in keyof T &
            keyof AcademicYearGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AcademicYearGroupByOutputType[P]>
            : GetScalarType<T[P], AcademicYearGroupByOutputType[P]>;
        }
      >
    >;

  export type AcademicYearSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      year?: boolean;
      startAt?: boolean;
      endAt?: boolean;
      academicYearClasses?:
        | boolean
        | AcademicYear$academicYearClassesArgs<ExtArgs>;
      _count?: boolean | AcademicYearCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["academicYear"]
  >;

  export type AcademicYearSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      year?: boolean;
      startAt?: boolean;
      endAt?: boolean;
    },
    ExtArgs["result"]["academicYear"]
  >;

  export type AcademicYearSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      year?: boolean;
      startAt?: boolean;
      endAt?: boolean;
    },
    ExtArgs["result"]["academicYear"]
  >;

  export type AcademicYearSelectScalar = {
    id?: boolean;
    year?: boolean;
    startAt?: boolean;
    endAt?: boolean;
  };

  export type AcademicYearOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    "id" | "year" | "startAt" | "endAt",
    ExtArgs["result"]["academicYear"]
  >;
  export type AcademicYearInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    academicYearClasses?:
      | boolean
      | AcademicYear$academicYearClassesArgs<ExtArgs>;
    _count?: boolean | AcademicYearCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type AcademicYearIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};
  export type AcademicYearIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};

  export type $AcademicYearPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "AcademicYear";
    objects: {
      academicYearClasses: Prisma.$AcademicYearClassPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        year: string;
        startAt: Date;
        endAt: Date;
      },
      ExtArgs["result"]["academicYear"]
    >;
    composites: {};
  };

  type AcademicYearGetPayload<
    S extends boolean | null | undefined | AcademicYearDefaultArgs,
  > = $Result.GetResult<Prisma.$AcademicYearPayload, S>;

  type AcademicYearCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    AcademicYearFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: AcademicYearCountAggregateInputType | true;
  };

  export interface AcademicYearDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["AcademicYear"];
      meta: { name: "AcademicYear" };
    };
    /**
     * Find zero or one AcademicYear that matches the filter.
     * @param {AcademicYearFindUniqueArgs} args - Arguments to find a AcademicYear
     * @example
     * // Get one AcademicYear
     * const academicYear = await prisma.academicYear.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AcademicYearFindUniqueArgs>(
      args: SelectSubset<T, AcademicYearFindUniqueArgs<ExtArgs>>,
    ): Prisma__AcademicYearClient<
      $Result.GetResult<
        Prisma.$AcademicYearPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one AcademicYear that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AcademicYearFindUniqueOrThrowArgs} args - Arguments to find a AcademicYear
     * @example
     * // Get one AcademicYear
     * const academicYear = await prisma.academicYear.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AcademicYearFindUniqueOrThrowArgs>(
      args: SelectSubset<T, AcademicYearFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__AcademicYearClient<
      $Result.GetResult<
        Prisma.$AcademicYearPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first AcademicYear that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicYearFindFirstArgs} args - Arguments to find a AcademicYear
     * @example
     * // Get one AcademicYear
     * const academicYear = await prisma.academicYear.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AcademicYearFindFirstArgs>(
      args?: SelectSubset<T, AcademicYearFindFirstArgs<ExtArgs>>,
    ): Prisma__AcademicYearClient<
      $Result.GetResult<
        Prisma.$AcademicYearPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first AcademicYear that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicYearFindFirstOrThrowArgs} args - Arguments to find a AcademicYear
     * @example
     * // Get one AcademicYear
     * const academicYear = await prisma.academicYear.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AcademicYearFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AcademicYearFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__AcademicYearClient<
      $Result.GetResult<
        Prisma.$AcademicYearPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more AcademicYears that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicYearFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AcademicYears
     * const academicYears = await prisma.academicYear.findMany()
     *
     * // Get first 10 AcademicYears
     * const academicYears = await prisma.academicYear.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const academicYearWithIdOnly = await prisma.academicYear.findMany({ select: { id: true } })
     *
     */
    findMany<T extends AcademicYearFindManyArgs>(
      args?: SelectSubset<T, AcademicYearFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$AcademicYearPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a AcademicYear.
     * @param {AcademicYearCreateArgs} args - Arguments to create a AcademicYear.
     * @example
     * // Create one AcademicYear
     * const AcademicYear = await prisma.academicYear.create({
     *   data: {
     *     // ... data to create a AcademicYear
     *   }
     * })
     *
     */
    create<T extends AcademicYearCreateArgs>(
      args: SelectSubset<T, AcademicYearCreateArgs<ExtArgs>>,
    ): Prisma__AcademicYearClient<
      $Result.GetResult<
        Prisma.$AcademicYearPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many AcademicYears.
     * @param {AcademicYearCreateManyArgs} args - Arguments to create many AcademicYears.
     * @example
     * // Create many AcademicYears
     * const academicYear = await prisma.academicYear.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends AcademicYearCreateManyArgs>(
      args?: SelectSubset<T, AcademicYearCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many AcademicYears and returns the data saved in the database.
     * @param {AcademicYearCreateManyAndReturnArgs} args - Arguments to create many AcademicYears.
     * @example
     * // Create many AcademicYears
     * const academicYear = await prisma.academicYear.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many AcademicYears and only return the `id`
     * const academicYearWithIdOnly = await prisma.academicYear.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends AcademicYearCreateManyAndReturnArgs>(
      args?: SelectSubset<T, AcademicYearCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$AcademicYearPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a AcademicYear.
     * @param {AcademicYearDeleteArgs} args - Arguments to delete one AcademicYear.
     * @example
     * // Delete one AcademicYear
     * const AcademicYear = await prisma.academicYear.delete({
     *   where: {
     *     // ... filter to delete one AcademicYear
     *   }
     * })
     *
     */
    delete<T extends AcademicYearDeleteArgs>(
      args: SelectSubset<T, AcademicYearDeleteArgs<ExtArgs>>,
    ): Prisma__AcademicYearClient<
      $Result.GetResult<
        Prisma.$AcademicYearPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one AcademicYear.
     * @param {AcademicYearUpdateArgs} args - Arguments to update one AcademicYear.
     * @example
     * // Update one AcademicYear
     * const academicYear = await prisma.academicYear.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends AcademicYearUpdateArgs>(
      args: SelectSubset<T, AcademicYearUpdateArgs<ExtArgs>>,
    ): Prisma__AcademicYearClient<
      $Result.GetResult<
        Prisma.$AcademicYearPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more AcademicYears.
     * @param {AcademicYearDeleteManyArgs} args - Arguments to filter AcademicYears to delete.
     * @example
     * // Delete a few AcademicYears
     * const { count } = await prisma.academicYear.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends AcademicYearDeleteManyArgs>(
      args?: SelectSubset<T, AcademicYearDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more AcademicYears.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicYearUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AcademicYears
     * const academicYear = await prisma.academicYear.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends AcademicYearUpdateManyArgs>(
      args: SelectSubset<T, AcademicYearUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more AcademicYears and returns the data updated in the database.
     * @param {AcademicYearUpdateManyAndReturnArgs} args - Arguments to update many AcademicYears.
     * @example
     * // Update many AcademicYears
     * const academicYear = await prisma.academicYear.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more AcademicYears and only return the `id`
     * const academicYearWithIdOnly = await prisma.academicYear.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends AcademicYearUpdateManyAndReturnArgs>(
      args: SelectSubset<T, AcademicYearUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$AcademicYearPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one AcademicYear.
     * @param {AcademicYearUpsertArgs} args - Arguments to update or create a AcademicYear.
     * @example
     * // Update or create a AcademicYear
     * const academicYear = await prisma.academicYear.upsert({
     *   create: {
     *     // ... data to create a AcademicYear
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AcademicYear we want to update
     *   }
     * })
     */
    upsert<T extends AcademicYearUpsertArgs>(
      args: SelectSubset<T, AcademicYearUpsertArgs<ExtArgs>>,
    ): Prisma__AcademicYearClient<
      $Result.GetResult<
        Prisma.$AcademicYearPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of AcademicYears.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicYearCountArgs} args - Arguments to filter AcademicYears to count.
     * @example
     * // Count the number of AcademicYears
     * const count = await prisma.academicYear.count({
     *   where: {
     *     // ... the filter for the AcademicYears we want to count
     *   }
     * })
     **/
    count<T extends AcademicYearCountArgs>(
      args?: Subset<T, AcademicYearCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], AcademicYearCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a AcademicYear.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicYearAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends AcademicYearAggregateArgs>(
      args: Subset<T, AcademicYearAggregateArgs>,
    ): Prisma.PrismaPromise<GetAcademicYearAggregateType<T>>;

    /**
     * Group by AcademicYear.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicYearGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends AcademicYearGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AcademicYearGroupByArgs["orderBy"] }
        : { orderBy?: AcademicYearGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, AcademicYearGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetAcademicYearGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the AcademicYear model
     */
    readonly fields: AcademicYearFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AcademicYear.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AcademicYearClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    academicYearClasses<
      T extends AcademicYear$academicYearClassesArgs<ExtArgs> = {},
    >(
      args?: Subset<T, AcademicYear$academicYearClassesArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$AcademicYearClassPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the AcademicYear model
   */
  interface AcademicYearFieldRefs {
    readonly id: FieldRef<"AcademicYear", "String">;
    readonly year: FieldRef<"AcademicYear", "String">;
    readonly startAt: FieldRef<"AcademicYear", "DateTime">;
    readonly endAt: FieldRef<"AcademicYear", "DateTime">;
  }

  // Custom InputTypes
  /**
   * AcademicYear findUnique
   */
  export type AcademicYearFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AcademicYear
     */
    select?: AcademicYearSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AcademicYear
     */
    omit?: AcademicYearOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearInclude<ExtArgs> | null;
    /**
     * Filter, which AcademicYear to fetch.
     */
    where: AcademicYearWhereUniqueInput;
  };

  /**
   * AcademicYear findUniqueOrThrow
   */
  export type AcademicYearFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AcademicYear
     */
    select?: AcademicYearSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AcademicYear
     */
    omit?: AcademicYearOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearInclude<ExtArgs> | null;
    /**
     * Filter, which AcademicYear to fetch.
     */
    where: AcademicYearWhereUniqueInput;
  };

  /**
   * AcademicYear findFirst
   */
  export type AcademicYearFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AcademicYear
     */
    select?: AcademicYearSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AcademicYear
     */
    omit?: AcademicYearOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearInclude<ExtArgs> | null;
    /**
     * Filter, which AcademicYear to fetch.
     */
    where?: AcademicYearWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AcademicYears to fetch.
     */
    orderBy?:
      | AcademicYearOrderByWithRelationInput
      | AcademicYearOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for AcademicYears.
     */
    cursor?: AcademicYearWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AcademicYears from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AcademicYears.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of AcademicYears.
     */
    distinct?: AcademicYearScalarFieldEnum | AcademicYearScalarFieldEnum[];
  };

  /**
   * AcademicYear findFirstOrThrow
   */
  export type AcademicYearFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AcademicYear
     */
    select?: AcademicYearSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AcademicYear
     */
    omit?: AcademicYearOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearInclude<ExtArgs> | null;
    /**
     * Filter, which AcademicYear to fetch.
     */
    where?: AcademicYearWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AcademicYears to fetch.
     */
    orderBy?:
      | AcademicYearOrderByWithRelationInput
      | AcademicYearOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for AcademicYears.
     */
    cursor?: AcademicYearWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AcademicYears from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AcademicYears.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of AcademicYears.
     */
    distinct?: AcademicYearScalarFieldEnum | AcademicYearScalarFieldEnum[];
  };

  /**
   * AcademicYear findMany
   */
  export type AcademicYearFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AcademicYear
     */
    select?: AcademicYearSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AcademicYear
     */
    omit?: AcademicYearOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearInclude<ExtArgs> | null;
    /**
     * Filter, which AcademicYears to fetch.
     */
    where?: AcademicYearWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AcademicYears to fetch.
     */
    orderBy?:
      | AcademicYearOrderByWithRelationInput
      | AcademicYearOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing AcademicYears.
     */
    cursor?: AcademicYearWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AcademicYears from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AcademicYears.
     */
    skip?: number;
    distinct?: AcademicYearScalarFieldEnum | AcademicYearScalarFieldEnum[];
  };

  /**
   * AcademicYear create
   */
  export type AcademicYearCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AcademicYear
     */
    select?: AcademicYearSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AcademicYear
     */
    omit?: AcademicYearOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearInclude<ExtArgs> | null;
    /**
     * The data needed to create a AcademicYear.
     */
    data: XOR<AcademicYearCreateInput, AcademicYearUncheckedCreateInput>;
  };

  /**
   * AcademicYear createMany
   */
  export type AcademicYearCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many AcademicYears.
     */
    data: AcademicYearCreateManyInput | AcademicYearCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * AcademicYear createManyAndReturn
   */
  export type AcademicYearCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AcademicYear
     */
    select?: AcademicYearSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the AcademicYear
     */
    omit?: AcademicYearOmit<ExtArgs> | null;
    /**
     * The data used to create many AcademicYears.
     */
    data: AcademicYearCreateManyInput | AcademicYearCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * AcademicYear update
   */
  export type AcademicYearUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AcademicYear
     */
    select?: AcademicYearSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AcademicYear
     */
    omit?: AcademicYearOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearInclude<ExtArgs> | null;
    /**
     * The data needed to update a AcademicYear.
     */
    data: XOR<AcademicYearUpdateInput, AcademicYearUncheckedUpdateInput>;
    /**
     * Choose, which AcademicYear to update.
     */
    where: AcademicYearWhereUniqueInput;
  };

  /**
   * AcademicYear updateMany
   */
  export type AcademicYearUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update AcademicYears.
     */
    data: XOR<
      AcademicYearUpdateManyMutationInput,
      AcademicYearUncheckedUpdateManyInput
    >;
    /**
     * Filter which AcademicYears to update
     */
    where?: AcademicYearWhereInput;
    /**
     * Limit how many AcademicYears to update.
     */
    limit?: number;
  };

  /**
   * AcademicYear updateManyAndReturn
   */
  export type AcademicYearUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AcademicYear
     */
    select?: AcademicYearSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the AcademicYear
     */
    omit?: AcademicYearOmit<ExtArgs> | null;
    /**
     * The data used to update AcademicYears.
     */
    data: XOR<
      AcademicYearUpdateManyMutationInput,
      AcademicYearUncheckedUpdateManyInput
    >;
    /**
     * Filter which AcademicYears to update
     */
    where?: AcademicYearWhereInput;
    /**
     * Limit how many AcademicYears to update.
     */
    limit?: number;
  };

  /**
   * AcademicYear upsert
   */
  export type AcademicYearUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AcademicYear
     */
    select?: AcademicYearSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AcademicYear
     */
    omit?: AcademicYearOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearInclude<ExtArgs> | null;
    /**
     * The filter to search for the AcademicYear to update in case it exists.
     */
    where: AcademicYearWhereUniqueInput;
    /**
     * In case the AcademicYear found by the `where` argument doesn't exist, create a new AcademicYear with this data.
     */
    create: XOR<AcademicYearCreateInput, AcademicYearUncheckedCreateInput>;
    /**
     * In case the AcademicYear was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AcademicYearUpdateInput, AcademicYearUncheckedUpdateInput>;
  };

  /**
   * AcademicYear delete
   */
  export type AcademicYearDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AcademicYear
     */
    select?: AcademicYearSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AcademicYear
     */
    omit?: AcademicYearOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearInclude<ExtArgs> | null;
    /**
     * Filter which AcademicYear to delete.
     */
    where: AcademicYearWhereUniqueInput;
  };

  /**
   * AcademicYear deleteMany
   */
  export type AcademicYearDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which AcademicYears to delete
     */
    where?: AcademicYearWhereInput;
    /**
     * Limit how many AcademicYears to delete.
     */
    limit?: number;
  };

  /**
   * AcademicYear.academicYearClasses
   */
  export type AcademicYear$academicYearClassesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AcademicYearClass
     */
    select?: AcademicYearClassSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AcademicYearClass
     */
    omit?: AcademicYearClassOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearClassInclude<ExtArgs> | null;
    where?: AcademicYearClassWhereInput;
    orderBy?:
      | AcademicYearClassOrderByWithRelationInput
      | AcademicYearClassOrderByWithRelationInput[];
    cursor?: AcademicYearClassWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?:
      | AcademicYearClassScalarFieldEnum
      | AcademicYearClassScalarFieldEnum[];
  };

  /**
   * AcademicYear without action
   */
  export type AcademicYearDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AcademicYear
     */
    select?: AcademicYearSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AcademicYear
     */
    omit?: AcademicYearOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearInclude<ExtArgs> | null;
  };

  /**
   * Model AcademicYearClass
   */

  export type AggregateAcademicYearClass = {
    _count: AcademicYearClassCountAggregateOutputType | null;
    _min: AcademicYearClassMinAggregateOutputType | null;
    _max: AcademicYearClassMaxAggregateOutputType | null;
  };

  export type AcademicYearClassMinAggregateOutputType = {
    id: string | null;
    academicYearId: string | null;
    classId: string | null;
  };

  export type AcademicYearClassMaxAggregateOutputType = {
    id: string | null;
    academicYearId: string | null;
    classId: string | null;
  };

  export type AcademicYearClassCountAggregateOutputType = {
    id: number;
    academicYearId: number;
    classId: number;
    _all: number;
  };

  export type AcademicYearClassMinAggregateInputType = {
    id?: true;
    academicYearId?: true;
    classId?: true;
  };

  export type AcademicYearClassMaxAggregateInputType = {
    id?: true;
    academicYearId?: true;
    classId?: true;
  };

  export type AcademicYearClassCountAggregateInputType = {
    id?: true;
    academicYearId?: true;
    classId?: true;
    _all?: true;
  };

  export type AcademicYearClassAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which AcademicYearClass to aggregate.
     */
    where?: AcademicYearClassWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AcademicYearClasses to fetch.
     */
    orderBy?:
      | AcademicYearClassOrderByWithRelationInput
      | AcademicYearClassOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: AcademicYearClassWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AcademicYearClasses from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AcademicYearClasses.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned AcademicYearClasses
     **/
    _count?: true | AcademicYearClassCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: AcademicYearClassMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: AcademicYearClassMaxAggregateInputType;
  };

  export type GetAcademicYearClassAggregateType<
    T extends AcademicYearClassAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateAcademicYearClass]: P extends
      | "_count"
      | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAcademicYearClass[P]>
      : GetScalarType<T[P], AggregateAcademicYearClass[P]>;
  };

  export type AcademicYearClassGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AcademicYearClassWhereInput;
    orderBy?:
      | AcademicYearClassOrderByWithAggregationInput
      | AcademicYearClassOrderByWithAggregationInput[];
    by: AcademicYearClassScalarFieldEnum[] | AcademicYearClassScalarFieldEnum;
    having?: AcademicYearClassScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: AcademicYearClassCountAggregateInputType | true;
    _min?: AcademicYearClassMinAggregateInputType;
    _max?: AcademicYearClassMaxAggregateInputType;
  };

  export type AcademicYearClassGroupByOutputType = {
    id: string;
    academicYearId: string | null;
    classId: string | null;
    _count: AcademicYearClassCountAggregateOutputType | null;
    _min: AcademicYearClassMinAggregateOutputType | null;
    _max: AcademicYearClassMaxAggregateOutputType | null;
  };

  type GetAcademicYearClassGroupByPayload<
    T extends AcademicYearClassGroupByArgs,
  > = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AcademicYearClassGroupByOutputType, T["by"]> & {
        [P in keyof T &
          keyof AcademicYearClassGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], AcademicYearClassGroupByOutputType[P]>
          : GetScalarType<T[P], AcademicYearClassGroupByOutputType[P]>;
      }
    >
  >;

  export type AcademicYearClassSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      academicYearId?: boolean;
      classId?: boolean;
      academicYear?: boolean | AcademicYearClass$academicYearArgs<ExtArgs>;
      class?: boolean | AcademicYearClass$classArgs<ExtArgs>;
      academicYearSubjects?:
        | boolean
        | AcademicYearClass$academicYearSubjectsArgs<ExtArgs>;
      streams?: boolean | AcademicYearClass$streamsArgs<ExtArgs>;
      _count?: boolean | AcademicYearClassCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["academicYearClass"]
  >;

  export type AcademicYearClassSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      academicYearId?: boolean;
      classId?: boolean;
      academicYear?: boolean | AcademicYearClass$academicYearArgs<ExtArgs>;
      class?: boolean | AcademicYearClass$classArgs<ExtArgs>;
    },
    ExtArgs["result"]["academicYearClass"]
  >;

  export type AcademicYearClassSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      academicYearId?: boolean;
      classId?: boolean;
      academicYear?: boolean | AcademicYearClass$academicYearArgs<ExtArgs>;
      class?: boolean | AcademicYearClass$classArgs<ExtArgs>;
    },
    ExtArgs["result"]["academicYearClass"]
  >;

  export type AcademicYearClassSelectScalar = {
    id?: boolean;
    academicYearId?: boolean;
    classId?: boolean;
  };

  export type AcademicYearClassOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    "id" | "academicYearId" | "classId",
    ExtArgs["result"]["academicYearClass"]
  >;
  export type AcademicYearClassInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    academicYear?: boolean | AcademicYearClass$academicYearArgs<ExtArgs>;
    class?: boolean | AcademicYearClass$classArgs<ExtArgs>;
    academicYearSubjects?:
      | boolean
      | AcademicYearClass$academicYearSubjectsArgs<ExtArgs>;
    streams?: boolean | AcademicYearClass$streamsArgs<ExtArgs>;
    _count?: boolean | AcademicYearClassCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type AcademicYearClassIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    academicYear?: boolean | AcademicYearClass$academicYearArgs<ExtArgs>;
    class?: boolean | AcademicYearClass$classArgs<ExtArgs>;
  };
  export type AcademicYearClassIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    academicYear?: boolean | AcademicYearClass$academicYearArgs<ExtArgs>;
    class?: boolean | AcademicYearClass$classArgs<ExtArgs>;
  };

  export type $AcademicYearClassPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "AcademicYearClass";
    objects: {
      academicYear: Prisma.$AcademicYearPayload<ExtArgs> | null;
      class: Prisma.$ClassPayload<ExtArgs> | null;
      academicYearSubjects: Prisma.$AcademicYearSubjectPayload<ExtArgs>[];
      streams: Prisma.$classStreamPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        academicYearId: string | null;
        classId: string | null;
      },
      ExtArgs["result"]["academicYearClass"]
    >;
    composites: {};
  };

  type AcademicYearClassGetPayload<
    S extends boolean | null | undefined | AcademicYearClassDefaultArgs,
  > = $Result.GetResult<Prisma.$AcademicYearClassPayload, S>;

  type AcademicYearClassCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    AcademicYearClassFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: AcademicYearClassCountAggregateInputType | true;
  };

  export interface AcademicYearClassDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["AcademicYearClass"];
      meta: { name: "AcademicYearClass" };
    };
    /**
     * Find zero or one AcademicYearClass that matches the filter.
     * @param {AcademicYearClassFindUniqueArgs} args - Arguments to find a AcademicYearClass
     * @example
     * // Get one AcademicYearClass
     * const academicYearClass = await prisma.academicYearClass.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AcademicYearClassFindUniqueArgs>(
      args: SelectSubset<T, AcademicYearClassFindUniqueArgs<ExtArgs>>,
    ): Prisma__AcademicYearClassClient<
      $Result.GetResult<
        Prisma.$AcademicYearClassPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one AcademicYearClass that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AcademicYearClassFindUniqueOrThrowArgs} args - Arguments to find a AcademicYearClass
     * @example
     * // Get one AcademicYearClass
     * const academicYearClass = await prisma.academicYearClass.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AcademicYearClassFindUniqueOrThrowArgs>(
      args: SelectSubset<T, AcademicYearClassFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__AcademicYearClassClient<
      $Result.GetResult<
        Prisma.$AcademicYearClassPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first AcademicYearClass that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicYearClassFindFirstArgs} args - Arguments to find a AcademicYearClass
     * @example
     * // Get one AcademicYearClass
     * const academicYearClass = await prisma.academicYearClass.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AcademicYearClassFindFirstArgs>(
      args?: SelectSubset<T, AcademicYearClassFindFirstArgs<ExtArgs>>,
    ): Prisma__AcademicYearClassClient<
      $Result.GetResult<
        Prisma.$AcademicYearClassPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first AcademicYearClass that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicYearClassFindFirstOrThrowArgs} args - Arguments to find a AcademicYearClass
     * @example
     * // Get one AcademicYearClass
     * const academicYearClass = await prisma.academicYearClass.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AcademicYearClassFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AcademicYearClassFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__AcademicYearClassClient<
      $Result.GetResult<
        Prisma.$AcademicYearClassPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more AcademicYearClasses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicYearClassFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AcademicYearClasses
     * const academicYearClasses = await prisma.academicYearClass.findMany()
     *
     * // Get first 10 AcademicYearClasses
     * const academicYearClasses = await prisma.academicYearClass.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const academicYearClassWithIdOnly = await prisma.academicYearClass.findMany({ select: { id: true } })
     *
     */
    findMany<T extends AcademicYearClassFindManyArgs>(
      args?: SelectSubset<T, AcademicYearClassFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$AcademicYearClassPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a AcademicYearClass.
     * @param {AcademicYearClassCreateArgs} args - Arguments to create a AcademicYearClass.
     * @example
     * // Create one AcademicYearClass
     * const AcademicYearClass = await prisma.academicYearClass.create({
     *   data: {
     *     // ... data to create a AcademicYearClass
     *   }
     * })
     *
     */
    create<T extends AcademicYearClassCreateArgs>(
      args: SelectSubset<T, AcademicYearClassCreateArgs<ExtArgs>>,
    ): Prisma__AcademicYearClassClient<
      $Result.GetResult<
        Prisma.$AcademicYearClassPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many AcademicYearClasses.
     * @param {AcademicYearClassCreateManyArgs} args - Arguments to create many AcademicYearClasses.
     * @example
     * // Create many AcademicYearClasses
     * const academicYearClass = await prisma.academicYearClass.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends AcademicYearClassCreateManyArgs>(
      args?: SelectSubset<T, AcademicYearClassCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many AcademicYearClasses and returns the data saved in the database.
     * @param {AcademicYearClassCreateManyAndReturnArgs} args - Arguments to create many AcademicYearClasses.
     * @example
     * // Create many AcademicYearClasses
     * const academicYearClass = await prisma.academicYearClass.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many AcademicYearClasses and only return the `id`
     * const academicYearClassWithIdOnly = await prisma.academicYearClass.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends AcademicYearClassCreateManyAndReturnArgs>(
      args?: SelectSubset<T, AcademicYearClassCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$AcademicYearClassPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a AcademicYearClass.
     * @param {AcademicYearClassDeleteArgs} args - Arguments to delete one AcademicYearClass.
     * @example
     * // Delete one AcademicYearClass
     * const AcademicYearClass = await prisma.academicYearClass.delete({
     *   where: {
     *     // ... filter to delete one AcademicYearClass
     *   }
     * })
     *
     */
    delete<T extends AcademicYearClassDeleteArgs>(
      args: SelectSubset<T, AcademicYearClassDeleteArgs<ExtArgs>>,
    ): Prisma__AcademicYearClassClient<
      $Result.GetResult<
        Prisma.$AcademicYearClassPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one AcademicYearClass.
     * @param {AcademicYearClassUpdateArgs} args - Arguments to update one AcademicYearClass.
     * @example
     * // Update one AcademicYearClass
     * const academicYearClass = await prisma.academicYearClass.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends AcademicYearClassUpdateArgs>(
      args: SelectSubset<T, AcademicYearClassUpdateArgs<ExtArgs>>,
    ): Prisma__AcademicYearClassClient<
      $Result.GetResult<
        Prisma.$AcademicYearClassPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more AcademicYearClasses.
     * @param {AcademicYearClassDeleteManyArgs} args - Arguments to filter AcademicYearClasses to delete.
     * @example
     * // Delete a few AcademicYearClasses
     * const { count } = await prisma.academicYearClass.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends AcademicYearClassDeleteManyArgs>(
      args?: SelectSubset<T, AcademicYearClassDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more AcademicYearClasses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicYearClassUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AcademicYearClasses
     * const academicYearClass = await prisma.academicYearClass.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends AcademicYearClassUpdateManyArgs>(
      args: SelectSubset<T, AcademicYearClassUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more AcademicYearClasses and returns the data updated in the database.
     * @param {AcademicYearClassUpdateManyAndReturnArgs} args - Arguments to update many AcademicYearClasses.
     * @example
     * // Update many AcademicYearClasses
     * const academicYearClass = await prisma.academicYearClass.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more AcademicYearClasses and only return the `id`
     * const academicYearClassWithIdOnly = await prisma.academicYearClass.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends AcademicYearClassUpdateManyAndReturnArgs>(
      args: SelectSubset<T, AcademicYearClassUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$AcademicYearClassPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one AcademicYearClass.
     * @param {AcademicYearClassUpsertArgs} args - Arguments to update or create a AcademicYearClass.
     * @example
     * // Update or create a AcademicYearClass
     * const academicYearClass = await prisma.academicYearClass.upsert({
     *   create: {
     *     // ... data to create a AcademicYearClass
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AcademicYearClass we want to update
     *   }
     * })
     */
    upsert<T extends AcademicYearClassUpsertArgs>(
      args: SelectSubset<T, AcademicYearClassUpsertArgs<ExtArgs>>,
    ): Prisma__AcademicYearClassClient<
      $Result.GetResult<
        Prisma.$AcademicYearClassPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of AcademicYearClasses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicYearClassCountArgs} args - Arguments to filter AcademicYearClasses to count.
     * @example
     * // Count the number of AcademicYearClasses
     * const count = await prisma.academicYearClass.count({
     *   where: {
     *     // ... the filter for the AcademicYearClasses we want to count
     *   }
     * })
     **/
    count<T extends AcademicYearClassCountArgs>(
      args?: Subset<T, AcademicYearClassCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<
              T["select"],
              AcademicYearClassCountAggregateOutputType
            >
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a AcademicYearClass.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicYearClassAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends AcademicYearClassAggregateArgs>(
      args: Subset<T, AcademicYearClassAggregateArgs>,
    ): Prisma.PrismaPromise<GetAcademicYearClassAggregateType<T>>;

    /**
     * Group by AcademicYearClass.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicYearClassGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends AcademicYearClassGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AcademicYearClassGroupByArgs["orderBy"] }
        : { orderBy?: AcademicYearClassGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, AcademicYearClassGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetAcademicYearClassGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the AcademicYearClass model
     */
    readonly fields: AcademicYearClassFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AcademicYearClass.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AcademicYearClassClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    academicYear<T extends AcademicYearClass$academicYearArgs<ExtArgs> = {}>(
      args?: Subset<T, AcademicYearClass$academicYearArgs<ExtArgs>>,
    ): Prisma__AcademicYearClient<
      $Result.GetResult<
        Prisma.$AcademicYearPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    class<T extends AcademicYearClass$classArgs<ExtArgs> = {}>(
      args?: Subset<T, AcademicYearClass$classArgs<ExtArgs>>,
    ): Prisma__ClassClient<
      $Result.GetResult<
        Prisma.$ClassPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    academicYearSubjects<
      T extends AcademicYearClass$academicYearSubjectsArgs<ExtArgs> = {},
    >(
      args?: Subset<T, AcademicYearClass$academicYearSubjectsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$AcademicYearSubjectPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    streams<T extends AcademicYearClass$streamsArgs<ExtArgs> = {}>(
      args?: Subset<T, AcademicYearClass$streamsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$classStreamPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the AcademicYearClass model
   */
  interface AcademicYearClassFieldRefs {
    readonly id: FieldRef<"AcademicYearClass", "String">;
    readonly academicYearId: FieldRef<"AcademicYearClass", "String">;
    readonly classId: FieldRef<"AcademicYearClass", "String">;
  }

  // Custom InputTypes
  /**
   * AcademicYearClass findUnique
   */
  export type AcademicYearClassFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AcademicYearClass
     */
    select?: AcademicYearClassSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AcademicYearClass
     */
    omit?: AcademicYearClassOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearClassInclude<ExtArgs> | null;
    /**
     * Filter, which AcademicYearClass to fetch.
     */
    where: AcademicYearClassWhereUniqueInput;
  };

  /**
   * AcademicYearClass findUniqueOrThrow
   */
  export type AcademicYearClassFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AcademicYearClass
     */
    select?: AcademicYearClassSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AcademicYearClass
     */
    omit?: AcademicYearClassOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearClassInclude<ExtArgs> | null;
    /**
     * Filter, which AcademicYearClass to fetch.
     */
    where: AcademicYearClassWhereUniqueInput;
  };

  /**
   * AcademicYearClass findFirst
   */
  export type AcademicYearClassFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AcademicYearClass
     */
    select?: AcademicYearClassSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AcademicYearClass
     */
    omit?: AcademicYearClassOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearClassInclude<ExtArgs> | null;
    /**
     * Filter, which AcademicYearClass to fetch.
     */
    where?: AcademicYearClassWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AcademicYearClasses to fetch.
     */
    orderBy?:
      | AcademicYearClassOrderByWithRelationInput
      | AcademicYearClassOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for AcademicYearClasses.
     */
    cursor?: AcademicYearClassWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AcademicYearClasses from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AcademicYearClasses.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of AcademicYearClasses.
     */
    distinct?:
      | AcademicYearClassScalarFieldEnum
      | AcademicYearClassScalarFieldEnum[];
  };

  /**
   * AcademicYearClass findFirstOrThrow
   */
  export type AcademicYearClassFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AcademicYearClass
     */
    select?: AcademicYearClassSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AcademicYearClass
     */
    omit?: AcademicYearClassOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearClassInclude<ExtArgs> | null;
    /**
     * Filter, which AcademicYearClass to fetch.
     */
    where?: AcademicYearClassWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AcademicYearClasses to fetch.
     */
    orderBy?:
      | AcademicYearClassOrderByWithRelationInput
      | AcademicYearClassOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for AcademicYearClasses.
     */
    cursor?: AcademicYearClassWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AcademicYearClasses from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AcademicYearClasses.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of AcademicYearClasses.
     */
    distinct?:
      | AcademicYearClassScalarFieldEnum
      | AcademicYearClassScalarFieldEnum[];
  };

  /**
   * AcademicYearClass findMany
   */
  export type AcademicYearClassFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AcademicYearClass
     */
    select?: AcademicYearClassSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AcademicYearClass
     */
    omit?: AcademicYearClassOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearClassInclude<ExtArgs> | null;
    /**
     * Filter, which AcademicYearClasses to fetch.
     */
    where?: AcademicYearClassWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AcademicYearClasses to fetch.
     */
    orderBy?:
      | AcademicYearClassOrderByWithRelationInput
      | AcademicYearClassOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing AcademicYearClasses.
     */
    cursor?: AcademicYearClassWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AcademicYearClasses from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AcademicYearClasses.
     */
    skip?: number;
    distinct?:
      | AcademicYearClassScalarFieldEnum
      | AcademicYearClassScalarFieldEnum[];
  };

  /**
   * AcademicYearClass create
   */
  export type AcademicYearClassCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AcademicYearClass
     */
    select?: AcademicYearClassSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AcademicYearClass
     */
    omit?: AcademicYearClassOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearClassInclude<ExtArgs> | null;
    /**
     * The data needed to create a AcademicYearClass.
     */
    data?: XOR<
      AcademicYearClassCreateInput,
      AcademicYearClassUncheckedCreateInput
    >;
  };

  /**
   * AcademicYearClass createMany
   */
  export type AcademicYearClassCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many AcademicYearClasses.
     */
    data: AcademicYearClassCreateManyInput | AcademicYearClassCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * AcademicYearClass createManyAndReturn
   */
  export type AcademicYearClassCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AcademicYearClass
     */
    select?: AcademicYearClassSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the AcademicYearClass
     */
    omit?: AcademicYearClassOmit<ExtArgs> | null;
    /**
     * The data used to create many AcademicYearClasses.
     */
    data: AcademicYearClassCreateManyInput | AcademicYearClassCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearClassIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * AcademicYearClass update
   */
  export type AcademicYearClassUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AcademicYearClass
     */
    select?: AcademicYearClassSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AcademicYearClass
     */
    omit?: AcademicYearClassOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearClassInclude<ExtArgs> | null;
    /**
     * The data needed to update a AcademicYearClass.
     */
    data: XOR<
      AcademicYearClassUpdateInput,
      AcademicYearClassUncheckedUpdateInput
    >;
    /**
     * Choose, which AcademicYearClass to update.
     */
    where: AcademicYearClassWhereUniqueInput;
  };

  /**
   * AcademicYearClass updateMany
   */
  export type AcademicYearClassUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update AcademicYearClasses.
     */
    data: XOR<
      AcademicYearClassUpdateManyMutationInput,
      AcademicYearClassUncheckedUpdateManyInput
    >;
    /**
     * Filter which AcademicYearClasses to update
     */
    where?: AcademicYearClassWhereInput;
    /**
     * Limit how many AcademicYearClasses to update.
     */
    limit?: number;
  };

  /**
   * AcademicYearClass updateManyAndReturn
   */
  export type AcademicYearClassUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AcademicYearClass
     */
    select?: AcademicYearClassSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the AcademicYearClass
     */
    omit?: AcademicYearClassOmit<ExtArgs> | null;
    /**
     * The data used to update AcademicYearClasses.
     */
    data: XOR<
      AcademicYearClassUpdateManyMutationInput,
      AcademicYearClassUncheckedUpdateManyInput
    >;
    /**
     * Filter which AcademicYearClasses to update
     */
    where?: AcademicYearClassWhereInput;
    /**
     * Limit how many AcademicYearClasses to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearClassIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * AcademicYearClass upsert
   */
  export type AcademicYearClassUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AcademicYearClass
     */
    select?: AcademicYearClassSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AcademicYearClass
     */
    omit?: AcademicYearClassOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearClassInclude<ExtArgs> | null;
    /**
     * The filter to search for the AcademicYearClass to update in case it exists.
     */
    where: AcademicYearClassWhereUniqueInput;
    /**
     * In case the AcademicYearClass found by the `where` argument doesn't exist, create a new AcademicYearClass with this data.
     */
    create: XOR<
      AcademicYearClassCreateInput,
      AcademicYearClassUncheckedCreateInput
    >;
    /**
     * In case the AcademicYearClass was found with the provided `where` argument, update it with this data.
     */
    update: XOR<
      AcademicYearClassUpdateInput,
      AcademicYearClassUncheckedUpdateInput
    >;
  };

  /**
   * AcademicYearClass delete
   */
  export type AcademicYearClassDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AcademicYearClass
     */
    select?: AcademicYearClassSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AcademicYearClass
     */
    omit?: AcademicYearClassOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearClassInclude<ExtArgs> | null;
    /**
     * Filter which AcademicYearClass to delete.
     */
    where: AcademicYearClassWhereUniqueInput;
  };

  /**
   * AcademicYearClass deleteMany
   */
  export type AcademicYearClassDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which AcademicYearClasses to delete
     */
    where?: AcademicYearClassWhereInput;
    /**
     * Limit how many AcademicYearClasses to delete.
     */
    limit?: number;
  };

  /**
   * AcademicYearClass.academicYear
   */
  export type AcademicYearClass$academicYearArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AcademicYear
     */
    select?: AcademicYearSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AcademicYear
     */
    omit?: AcademicYearOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearInclude<ExtArgs> | null;
    where?: AcademicYearWhereInput;
  };

  /**
   * AcademicYearClass.class
   */
  export type AcademicYearClass$classArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null;
    where?: ClassWhereInput;
  };

  /**
   * AcademicYearClass.academicYearSubjects
   */
  export type AcademicYearClass$academicYearSubjectsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AcademicYearSubject
     */
    select?: AcademicYearSubjectSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AcademicYearSubject
     */
    omit?: AcademicYearSubjectOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearSubjectInclude<ExtArgs> | null;
    where?: AcademicYearSubjectWhereInput;
    orderBy?:
      | AcademicYearSubjectOrderByWithRelationInput
      | AcademicYearSubjectOrderByWithRelationInput[];
    cursor?: AcademicYearSubjectWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?:
      | AcademicYearSubjectScalarFieldEnum
      | AcademicYearSubjectScalarFieldEnum[];
  };

  /**
   * AcademicYearClass.streams
   */
  export type AcademicYearClass$streamsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the classStream
     */
    select?: classStreamSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the classStream
     */
    omit?: classStreamOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: classStreamInclude<ExtArgs> | null;
    where?: classStreamWhereInput;
    orderBy?:
      | classStreamOrderByWithRelationInput
      | classStreamOrderByWithRelationInput[];
    cursor?: classStreamWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ClassStreamScalarFieldEnum | ClassStreamScalarFieldEnum[];
  };

  /**
   * AcademicYearClass without action
   */
  export type AcademicYearClassDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AcademicYearClass
     */
    select?: AcademicYearClassSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AcademicYearClass
     */
    omit?: AcademicYearClassOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearClassInclude<ExtArgs> | null;
  };

  /**
   * Model Subject
   */

  export type AggregateSubject = {
    _count: SubjectCountAggregateOutputType | null;
    _min: SubjectMinAggregateOutputType | null;
    _max: SubjectMaxAggregateOutputType | null;
  };

  export type SubjectMinAggregateOutputType = {
    id: string | null;
    subjectName: string | null;
    slug: string | null;
    code: string | null;
    levelId: string | null;
  };

  export type SubjectMaxAggregateOutputType = {
    id: string | null;
    subjectName: string | null;
    slug: string | null;
    code: string | null;
    levelId: string | null;
  };

  export type SubjectCountAggregateOutputType = {
    id: number;
    subjectName: number;
    slug: number;
    code: number;
    levelId: number;
    _all: number;
  };

  export type SubjectMinAggregateInputType = {
    id?: true;
    subjectName?: true;
    slug?: true;
    code?: true;
    levelId?: true;
  };

  export type SubjectMaxAggregateInputType = {
    id?: true;
    subjectName?: true;
    slug?: true;
    code?: true;
    levelId?: true;
  };

  export type SubjectCountAggregateInputType = {
    id?: true;
    subjectName?: true;
    slug?: true;
    code?: true;
    levelId?: true;
    _all?: true;
  };

  export type SubjectAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Subject to aggregate.
     */
    where?: SubjectWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Subjects to fetch.
     */
    orderBy?:
      | SubjectOrderByWithRelationInput
      | SubjectOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: SubjectWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Subjects from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Subjects.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Subjects
     **/
    _count?: true | SubjectCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: SubjectMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: SubjectMaxAggregateInputType;
  };

  export type GetSubjectAggregateType<T extends SubjectAggregateArgs> = {
    [P in keyof T & keyof AggregateSubject]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubject[P]>
      : GetScalarType<T[P], AggregateSubject[P]>;
  };

  export type SubjectGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: SubjectWhereInput;
    orderBy?:
      | SubjectOrderByWithAggregationInput
      | SubjectOrderByWithAggregationInput[];
    by: SubjectScalarFieldEnum[] | SubjectScalarFieldEnum;
    having?: SubjectScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: SubjectCountAggregateInputType | true;
    _min?: SubjectMinAggregateInputType;
    _max?: SubjectMaxAggregateInputType;
  };

  export type SubjectGroupByOutputType = {
    id: string;
    subjectName: string;
    slug: string;
    code: string;
    levelId: string;
    _count: SubjectCountAggregateOutputType | null;
    _min: SubjectMinAggregateOutputType | null;
    _max: SubjectMaxAggregateOutputType | null;
  };

  type GetSubjectGroupByPayload<T extends SubjectGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<SubjectGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof SubjectGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubjectGroupByOutputType[P]>
            : GetScalarType<T[P], SubjectGroupByOutputType[P]>;
        }
      >
    >;

  export type SubjectSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      subjectName?: boolean;
      slug?: boolean;
      code?: boolean;
      levelId?: boolean;
      grading?: boolean | Subject$gradingArgs<ExtArgs>;
      academicYearSubjects?:
        | boolean
        | Subject$academicYearSubjectsArgs<ExtArgs>;
      level?: boolean | LevelDefaultArgs<ExtArgs>;
      _count?: boolean | SubjectCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["subject"]
  >;

  export type SubjectSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      subjectName?: boolean;
      slug?: boolean;
      code?: boolean;
      levelId?: boolean;
      level?: boolean | LevelDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["subject"]
  >;

  export type SubjectSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      subjectName?: boolean;
      slug?: boolean;
      code?: boolean;
      levelId?: boolean;
      level?: boolean | LevelDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["subject"]
  >;

  export type SubjectSelectScalar = {
    id?: boolean;
    subjectName?: boolean;
    slug?: boolean;
    code?: boolean;
    levelId?: boolean;
  };

  export type SubjectOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    "id" | "subjectName" | "slug" | "code" | "levelId",
    ExtArgs["result"]["subject"]
  >;
  export type SubjectInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    grading?: boolean | Subject$gradingArgs<ExtArgs>;
    academicYearSubjects?: boolean | Subject$academicYearSubjectsArgs<ExtArgs>;
    level?: boolean | LevelDefaultArgs<ExtArgs>;
    _count?: boolean | SubjectCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type SubjectIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    level?: boolean | LevelDefaultArgs<ExtArgs>;
  };
  export type SubjectIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    level?: boolean | LevelDefaultArgs<ExtArgs>;
  };

  export type $SubjectPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "Subject";
    objects: {
      grading: Prisma.$GradingPayload<ExtArgs>[];
      academicYearSubjects: Prisma.$AcademicYearSubjectPayload<ExtArgs>[];
      level: Prisma.$LevelPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        subjectName: string;
        slug: string;
        code: string;
        levelId: string;
      },
      ExtArgs["result"]["subject"]
    >;
    composites: {};
  };

  type SubjectGetPayload<
    S extends boolean | null | undefined | SubjectDefaultArgs,
  > = $Result.GetResult<Prisma.$SubjectPayload, S>;

  type SubjectCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<SubjectFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
    select?: SubjectCountAggregateInputType | true;
  };

  export interface SubjectDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["Subject"];
      meta: { name: "Subject" };
    };
    /**
     * Find zero or one Subject that matches the filter.
     * @param {SubjectFindUniqueArgs} args - Arguments to find a Subject
     * @example
     * // Get one Subject
     * const subject = await prisma.subject.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubjectFindUniqueArgs>(
      args: SelectSubset<T, SubjectFindUniqueArgs<ExtArgs>>,
    ): Prisma__SubjectClient<
      $Result.GetResult<
        Prisma.$SubjectPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Subject that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubjectFindUniqueOrThrowArgs} args - Arguments to find a Subject
     * @example
     * // Get one Subject
     * const subject = await prisma.subject.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubjectFindUniqueOrThrowArgs>(
      args: SelectSubset<T, SubjectFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__SubjectClient<
      $Result.GetResult<
        Prisma.$SubjectPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Subject that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectFindFirstArgs} args - Arguments to find a Subject
     * @example
     * // Get one Subject
     * const subject = await prisma.subject.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubjectFindFirstArgs>(
      args?: SelectSubset<T, SubjectFindFirstArgs<ExtArgs>>,
    ): Prisma__SubjectClient<
      $Result.GetResult<
        Prisma.$SubjectPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Subject that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectFindFirstOrThrowArgs} args - Arguments to find a Subject
     * @example
     * // Get one Subject
     * const subject = await prisma.subject.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubjectFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SubjectFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__SubjectClient<
      $Result.GetResult<
        Prisma.$SubjectPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Subjects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subjects
     * const subjects = await prisma.subject.findMany()
     *
     * // Get first 10 Subjects
     * const subjects = await prisma.subject.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const subjectWithIdOnly = await prisma.subject.findMany({ select: { id: true } })
     *
     */
    findMany<T extends SubjectFindManyArgs>(
      args?: SelectSubset<T, SubjectFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$SubjectPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Subject.
     * @param {SubjectCreateArgs} args - Arguments to create a Subject.
     * @example
     * // Create one Subject
     * const Subject = await prisma.subject.create({
     *   data: {
     *     // ... data to create a Subject
     *   }
     * })
     *
     */
    create<T extends SubjectCreateArgs>(
      args: SelectSubset<T, SubjectCreateArgs<ExtArgs>>,
    ): Prisma__SubjectClient<
      $Result.GetResult<
        Prisma.$SubjectPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Subjects.
     * @param {SubjectCreateManyArgs} args - Arguments to create many Subjects.
     * @example
     * // Create many Subjects
     * const subject = await prisma.subject.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends SubjectCreateManyArgs>(
      args?: SelectSubset<T, SubjectCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Subjects and returns the data saved in the database.
     * @param {SubjectCreateManyAndReturnArgs} args - Arguments to create many Subjects.
     * @example
     * // Create many Subjects
     * const subject = await prisma.subject.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Subjects and only return the `id`
     * const subjectWithIdOnly = await prisma.subject.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends SubjectCreateManyAndReturnArgs>(
      args?: SelectSubset<T, SubjectCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$SubjectPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Subject.
     * @param {SubjectDeleteArgs} args - Arguments to delete one Subject.
     * @example
     * // Delete one Subject
     * const Subject = await prisma.subject.delete({
     *   where: {
     *     // ... filter to delete one Subject
     *   }
     * })
     *
     */
    delete<T extends SubjectDeleteArgs>(
      args: SelectSubset<T, SubjectDeleteArgs<ExtArgs>>,
    ): Prisma__SubjectClient<
      $Result.GetResult<
        Prisma.$SubjectPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Subject.
     * @param {SubjectUpdateArgs} args - Arguments to update one Subject.
     * @example
     * // Update one Subject
     * const subject = await prisma.subject.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends SubjectUpdateArgs>(
      args: SelectSubset<T, SubjectUpdateArgs<ExtArgs>>,
    ): Prisma__SubjectClient<
      $Result.GetResult<
        Prisma.$SubjectPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Subjects.
     * @param {SubjectDeleteManyArgs} args - Arguments to filter Subjects to delete.
     * @example
     * // Delete a few Subjects
     * const { count } = await prisma.subject.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends SubjectDeleteManyArgs>(
      args?: SelectSubset<T, SubjectDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Subjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subjects
     * const subject = await prisma.subject.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends SubjectUpdateManyArgs>(
      args: SelectSubset<T, SubjectUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Subjects and returns the data updated in the database.
     * @param {SubjectUpdateManyAndReturnArgs} args - Arguments to update many Subjects.
     * @example
     * // Update many Subjects
     * const subject = await prisma.subject.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Subjects and only return the `id`
     * const subjectWithIdOnly = await prisma.subject.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends SubjectUpdateManyAndReturnArgs>(
      args: SelectSubset<T, SubjectUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$SubjectPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Subject.
     * @param {SubjectUpsertArgs} args - Arguments to update or create a Subject.
     * @example
     * // Update or create a Subject
     * const subject = await prisma.subject.upsert({
     *   create: {
     *     // ... data to create a Subject
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subject we want to update
     *   }
     * })
     */
    upsert<T extends SubjectUpsertArgs>(
      args: SelectSubset<T, SubjectUpsertArgs<ExtArgs>>,
    ): Prisma__SubjectClient<
      $Result.GetResult<
        Prisma.$SubjectPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Subjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectCountArgs} args - Arguments to filter Subjects to count.
     * @example
     * // Count the number of Subjects
     * const count = await prisma.subject.count({
     *   where: {
     *     // ... the filter for the Subjects we want to count
     *   }
     * })
     **/
    count<T extends SubjectCountArgs>(
      args?: Subset<T, SubjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], SubjectCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Subject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends SubjectAggregateArgs>(
      args: Subset<T, SubjectAggregateArgs>,
    ): Prisma.PrismaPromise<GetSubjectAggregateType<T>>;

    /**
     * Group by Subject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends SubjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubjectGroupByArgs["orderBy"] }
        : { orderBy?: SubjectGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, SubjectGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetSubjectGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Subject model
     */
    readonly fields: SubjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subject.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubjectClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    grading<T extends Subject$gradingArgs<ExtArgs> = {}>(
      args?: Subset<T, Subject$gradingArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$GradingPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    academicYearSubjects<
      T extends Subject$academicYearSubjectsArgs<ExtArgs> = {},
    >(
      args?: Subset<T, Subject$academicYearSubjectsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$AcademicYearSubjectPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    level<T extends LevelDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, LevelDefaultArgs<ExtArgs>>,
    ): Prisma__LevelClient<
      | $Result.GetResult<
          Prisma.$LevelPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Subject model
   */
  interface SubjectFieldRefs {
    readonly id: FieldRef<"Subject", "String">;
    readonly subjectName: FieldRef<"Subject", "String">;
    readonly slug: FieldRef<"Subject", "String">;
    readonly code: FieldRef<"Subject", "String">;
    readonly levelId: FieldRef<"Subject", "String">;
  }

  // Custom InputTypes
  /**
   * Subject findUnique
   */
  export type SubjectFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null;
    /**
     * Filter, which Subject to fetch.
     */
    where: SubjectWhereUniqueInput;
  };

  /**
   * Subject findUniqueOrThrow
   */
  export type SubjectFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null;
    /**
     * Filter, which Subject to fetch.
     */
    where: SubjectWhereUniqueInput;
  };

  /**
   * Subject findFirst
   */
  export type SubjectFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null;
    /**
     * Filter, which Subject to fetch.
     */
    where?: SubjectWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Subjects to fetch.
     */
    orderBy?:
      | SubjectOrderByWithRelationInput
      | SubjectOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Subjects.
     */
    cursor?: SubjectWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Subjects from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Subjects.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Subjects.
     */
    distinct?: SubjectScalarFieldEnum | SubjectScalarFieldEnum[];
  };

  /**
   * Subject findFirstOrThrow
   */
  export type SubjectFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null;
    /**
     * Filter, which Subject to fetch.
     */
    where?: SubjectWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Subjects to fetch.
     */
    orderBy?:
      | SubjectOrderByWithRelationInput
      | SubjectOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Subjects.
     */
    cursor?: SubjectWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Subjects from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Subjects.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Subjects.
     */
    distinct?: SubjectScalarFieldEnum | SubjectScalarFieldEnum[];
  };

  /**
   * Subject findMany
   */
  export type SubjectFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null;
    /**
     * Filter, which Subjects to fetch.
     */
    where?: SubjectWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Subjects to fetch.
     */
    orderBy?:
      | SubjectOrderByWithRelationInput
      | SubjectOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Subjects.
     */
    cursor?: SubjectWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Subjects from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Subjects.
     */
    skip?: number;
    distinct?: SubjectScalarFieldEnum | SubjectScalarFieldEnum[];
  };

  /**
   * Subject create
   */
  export type SubjectCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null;
    /**
     * The data needed to create a Subject.
     */
    data: XOR<SubjectCreateInput, SubjectUncheckedCreateInput>;
  };

  /**
   * Subject createMany
   */
  export type SubjectCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Subjects.
     */
    data: SubjectCreateManyInput | SubjectCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Subject createManyAndReturn
   */
  export type SubjectCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null;
    /**
     * The data used to create many Subjects.
     */
    data: SubjectCreateManyInput | SubjectCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Subject update
   */
  export type SubjectUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null;
    /**
     * The data needed to update a Subject.
     */
    data: XOR<SubjectUpdateInput, SubjectUncheckedUpdateInput>;
    /**
     * Choose, which Subject to update.
     */
    where: SubjectWhereUniqueInput;
  };

  /**
   * Subject updateMany
   */
  export type SubjectUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Subjects.
     */
    data: XOR<SubjectUpdateManyMutationInput, SubjectUncheckedUpdateManyInput>;
    /**
     * Filter which Subjects to update
     */
    where?: SubjectWhereInput;
    /**
     * Limit how many Subjects to update.
     */
    limit?: number;
  };

  /**
   * Subject updateManyAndReturn
   */
  export type SubjectUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null;
    /**
     * The data used to update Subjects.
     */
    data: XOR<SubjectUpdateManyMutationInput, SubjectUncheckedUpdateManyInput>;
    /**
     * Filter which Subjects to update
     */
    where?: SubjectWhereInput;
    /**
     * Limit how many Subjects to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Subject upsert
   */
  export type SubjectUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null;
    /**
     * The filter to search for the Subject to update in case it exists.
     */
    where: SubjectWhereUniqueInput;
    /**
     * In case the Subject found by the `where` argument doesn't exist, create a new Subject with this data.
     */
    create: XOR<SubjectCreateInput, SubjectUncheckedCreateInput>;
    /**
     * In case the Subject was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubjectUpdateInput, SubjectUncheckedUpdateInput>;
  };

  /**
   * Subject delete
   */
  export type SubjectDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null;
    /**
     * Filter which Subject to delete.
     */
    where: SubjectWhereUniqueInput;
  };

  /**
   * Subject deleteMany
   */
  export type SubjectDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Subjects to delete
     */
    where?: SubjectWhereInput;
    /**
     * Limit how many Subjects to delete.
     */
    limit?: number;
  };

  /**
   * Subject.grading
   */
  export type Subject$gradingArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Grading
     */
    select?: GradingSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Grading
     */
    omit?: GradingOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradingInclude<ExtArgs> | null;
    where?: GradingWhereInput;
    orderBy?:
      | GradingOrderByWithRelationInput
      | GradingOrderByWithRelationInput[];
    cursor?: GradingWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: GradingScalarFieldEnum | GradingScalarFieldEnum[];
  };

  /**
   * Subject.academicYearSubjects
   */
  export type Subject$academicYearSubjectsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AcademicYearSubject
     */
    select?: AcademicYearSubjectSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AcademicYearSubject
     */
    omit?: AcademicYearSubjectOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearSubjectInclude<ExtArgs> | null;
    where?: AcademicYearSubjectWhereInput;
    orderBy?:
      | AcademicYearSubjectOrderByWithRelationInput
      | AcademicYearSubjectOrderByWithRelationInput[];
    cursor?: AcademicYearSubjectWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?:
      | AcademicYearSubjectScalarFieldEnum
      | AcademicYearSubjectScalarFieldEnum[];
  };

  /**
   * Subject without action
   */
  export type SubjectDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null;
  };

  /**
   * Model Grading
   */

  export type AggregateGrading = {
    _count: GradingCountAggregateOutputType | null;
    _avg: GradingAvgAggregateOutputType | null;
    _sum: GradingSumAggregateOutputType | null;
    _min: GradingMinAggregateOutputType | null;
    _max: GradingMaxAggregateOutputType | null;
  };

  export type GradingAvgAggregateOutputType = {
    from: number | null;
    to: number | null;
  };

  export type GradingSumAggregateOutputType = {
    from: number | null;
    to: number | null;
  };

  export type GradingMinAggregateOutputType = {
    id: string | null;
    from: number | null;
    to: number | null;
    grade: string | null;
    remarks: string | null;
  };

  export type GradingMaxAggregateOutputType = {
    id: string | null;
    from: number | null;
    to: number | null;
    grade: string | null;
    remarks: string | null;
  };

  export type GradingCountAggregateOutputType = {
    id: number;
    from: number;
    to: number;
    grade: number;
    remarks: number;
    _all: number;
  };

  export type GradingAvgAggregateInputType = {
    from?: true;
    to?: true;
  };

  export type GradingSumAggregateInputType = {
    from?: true;
    to?: true;
  };

  export type GradingMinAggregateInputType = {
    id?: true;
    from?: true;
    to?: true;
    grade?: true;
    remarks?: true;
  };

  export type GradingMaxAggregateInputType = {
    id?: true;
    from?: true;
    to?: true;
    grade?: true;
    remarks?: true;
  };

  export type GradingCountAggregateInputType = {
    id?: true;
    from?: true;
    to?: true;
    grade?: true;
    remarks?: true;
    _all?: true;
  };

  export type GradingAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Grading to aggregate.
     */
    where?: GradingWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Gradings to fetch.
     */
    orderBy?:
      | GradingOrderByWithRelationInput
      | GradingOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: GradingWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Gradings from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Gradings.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Gradings
     **/
    _count?: true | GradingCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: GradingAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: GradingSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: GradingMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: GradingMaxAggregateInputType;
  };

  export type GetGradingAggregateType<T extends GradingAggregateArgs> = {
    [P in keyof T & keyof AggregateGrading]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGrading[P]>
      : GetScalarType<T[P], AggregateGrading[P]>;
  };

  export type GradingGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: GradingWhereInput;
    orderBy?:
      | GradingOrderByWithAggregationInput
      | GradingOrderByWithAggregationInput[];
    by: GradingScalarFieldEnum[] | GradingScalarFieldEnum;
    having?: GradingScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: GradingCountAggregateInputType | true;
    _avg?: GradingAvgAggregateInputType;
    _sum?: GradingSumAggregateInputType;
    _min?: GradingMinAggregateInputType;
    _max?: GradingMaxAggregateInputType;
  };

  export type GradingGroupByOutputType = {
    id: string;
    from: number;
    to: number;
    grade: string;
    remarks: string | null;
    _count: GradingCountAggregateOutputType | null;
    _avg: GradingAvgAggregateOutputType | null;
    _sum: GradingSumAggregateOutputType | null;
    _min: GradingMinAggregateOutputType | null;
    _max: GradingMaxAggregateOutputType | null;
  };

  type GetGradingGroupByPayload<T extends GradingGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<GradingGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof GradingGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GradingGroupByOutputType[P]>
            : GetScalarType<T[P], GradingGroupByOutputType[P]>;
        }
      >
    >;

  export type GradingSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      from?: boolean;
      to?: boolean;
      grade?: boolean;
      remarks?: boolean;
      subjects?: boolean | Grading$subjectsArgs<ExtArgs>;
      academicYearSubjects?:
        | boolean
        | Grading$academicYearSubjectsArgs<ExtArgs>;
      _count?: boolean | GradingCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["grading"]
  >;

  export type GradingSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      from?: boolean;
      to?: boolean;
      grade?: boolean;
      remarks?: boolean;
    },
    ExtArgs["result"]["grading"]
  >;

  export type GradingSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      from?: boolean;
      to?: boolean;
      grade?: boolean;
      remarks?: boolean;
    },
    ExtArgs["result"]["grading"]
  >;

  export type GradingSelectScalar = {
    id?: boolean;
    from?: boolean;
    to?: boolean;
    grade?: boolean;
    remarks?: boolean;
  };

  export type GradingOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    "id" | "from" | "to" | "grade" | "remarks",
    ExtArgs["result"]["grading"]
  >;
  export type GradingInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    subjects?: boolean | Grading$subjectsArgs<ExtArgs>;
    academicYearSubjects?: boolean | Grading$academicYearSubjectsArgs<ExtArgs>;
    _count?: boolean | GradingCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type GradingIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};
  export type GradingIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};

  export type $GradingPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "Grading";
    objects: {
      subjects: Prisma.$SubjectPayload<ExtArgs>[];
      academicYearSubjects: Prisma.$AcademicYearSubjectPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        from: number;
        to: number;
        grade: string;
        remarks: string | null;
      },
      ExtArgs["result"]["grading"]
    >;
    composites: {};
  };

  type GradingGetPayload<
    S extends boolean | null | undefined | GradingDefaultArgs,
  > = $Result.GetResult<Prisma.$GradingPayload, S>;

  type GradingCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<GradingFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
    select?: GradingCountAggregateInputType | true;
  };

  export interface GradingDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["Grading"];
      meta: { name: "Grading" };
    };
    /**
     * Find zero or one Grading that matches the filter.
     * @param {GradingFindUniqueArgs} args - Arguments to find a Grading
     * @example
     * // Get one Grading
     * const grading = await prisma.grading.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GradingFindUniqueArgs>(
      args: SelectSubset<T, GradingFindUniqueArgs<ExtArgs>>,
    ): Prisma__GradingClient<
      $Result.GetResult<
        Prisma.$GradingPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Grading that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GradingFindUniqueOrThrowArgs} args - Arguments to find a Grading
     * @example
     * // Get one Grading
     * const grading = await prisma.grading.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GradingFindUniqueOrThrowArgs>(
      args: SelectSubset<T, GradingFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__GradingClient<
      $Result.GetResult<
        Prisma.$GradingPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Grading that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradingFindFirstArgs} args - Arguments to find a Grading
     * @example
     * // Get one Grading
     * const grading = await prisma.grading.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GradingFindFirstArgs>(
      args?: SelectSubset<T, GradingFindFirstArgs<ExtArgs>>,
    ): Prisma__GradingClient<
      $Result.GetResult<
        Prisma.$GradingPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Grading that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradingFindFirstOrThrowArgs} args - Arguments to find a Grading
     * @example
     * // Get one Grading
     * const grading = await prisma.grading.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GradingFindFirstOrThrowArgs>(
      args?: SelectSubset<T, GradingFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__GradingClient<
      $Result.GetResult<
        Prisma.$GradingPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Gradings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Gradings
     * const gradings = await prisma.grading.findMany()
     *
     * // Get first 10 Gradings
     * const gradings = await prisma.grading.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const gradingWithIdOnly = await prisma.grading.findMany({ select: { id: true } })
     *
     */
    findMany<T extends GradingFindManyArgs>(
      args?: SelectSubset<T, GradingFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$GradingPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Grading.
     * @param {GradingCreateArgs} args - Arguments to create a Grading.
     * @example
     * // Create one Grading
     * const Grading = await prisma.grading.create({
     *   data: {
     *     // ... data to create a Grading
     *   }
     * })
     *
     */
    create<T extends GradingCreateArgs>(
      args: SelectSubset<T, GradingCreateArgs<ExtArgs>>,
    ): Prisma__GradingClient<
      $Result.GetResult<
        Prisma.$GradingPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Gradings.
     * @param {GradingCreateManyArgs} args - Arguments to create many Gradings.
     * @example
     * // Create many Gradings
     * const grading = await prisma.grading.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends GradingCreateManyArgs>(
      args?: SelectSubset<T, GradingCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Gradings and returns the data saved in the database.
     * @param {GradingCreateManyAndReturnArgs} args - Arguments to create many Gradings.
     * @example
     * // Create many Gradings
     * const grading = await prisma.grading.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Gradings and only return the `id`
     * const gradingWithIdOnly = await prisma.grading.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends GradingCreateManyAndReturnArgs>(
      args?: SelectSubset<T, GradingCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$GradingPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Grading.
     * @param {GradingDeleteArgs} args - Arguments to delete one Grading.
     * @example
     * // Delete one Grading
     * const Grading = await prisma.grading.delete({
     *   where: {
     *     // ... filter to delete one Grading
     *   }
     * })
     *
     */
    delete<T extends GradingDeleteArgs>(
      args: SelectSubset<T, GradingDeleteArgs<ExtArgs>>,
    ): Prisma__GradingClient<
      $Result.GetResult<
        Prisma.$GradingPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Grading.
     * @param {GradingUpdateArgs} args - Arguments to update one Grading.
     * @example
     * // Update one Grading
     * const grading = await prisma.grading.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends GradingUpdateArgs>(
      args: SelectSubset<T, GradingUpdateArgs<ExtArgs>>,
    ): Prisma__GradingClient<
      $Result.GetResult<
        Prisma.$GradingPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Gradings.
     * @param {GradingDeleteManyArgs} args - Arguments to filter Gradings to delete.
     * @example
     * // Delete a few Gradings
     * const { count } = await prisma.grading.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends GradingDeleteManyArgs>(
      args?: SelectSubset<T, GradingDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Gradings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Gradings
     * const grading = await prisma.grading.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends GradingUpdateManyArgs>(
      args: SelectSubset<T, GradingUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Gradings and returns the data updated in the database.
     * @param {GradingUpdateManyAndReturnArgs} args - Arguments to update many Gradings.
     * @example
     * // Update many Gradings
     * const grading = await prisma.grading.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Gradings and only return the `id`
     * const gradingWithIdOnly = await prisma.grading.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends GradingUpdateManyAndReturnArgs>(
      args: SelectSubset<T, GradingUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$GradingPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Grading.
     * @param {GradingUpsertArgs} args - Arguments to update or create a Grading.
     * @example
     * // Update or create a Grading
     * const grading = await prisma.grading.upsert({
     *   create: {
     *     // ... data to create a Grading
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Grading we want to update
     *   }
     * })
     */
    upsert<T extends GradingUpsertArgs>(
      args: SelectSubset<T, GradingUpsertArgs<ExtArgs>>,
    ): Prisma__GradingClient<
      $Result.GetResult<
        Prisma.$GradingPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Gradings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradingCountArgs} args - Arguments to filter Gradings to count.
     * @example
     * // Count the number of Gradings
     * const count = await prisma.grading.count({
     *   where: {
     *     // ... the filter for the Gradings we want to count
     *   }
     * })
     **/
    count<T extends GradingCountArgs>(
      args?: Subset<T, GradingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], GradingCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Grading.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends GradingAggregateArgs>(
      args: Subset<T, GradingAggregateArgs>,
    ): Prisma.PrismaPromise<GetGradingAggregateType<T>>;

    /**
     * Group by Grading.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends GradingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GradingGroupByArgs["orderBy"] }
        : { orderBy?: GradingGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, GradingGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetGradingGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Grading model
     */
    readonly fields: GradingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Grading.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GradingClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    subjects<T extends Grading$subjectsArgs<ExtArgs> = {}>(
      args?: Subset<T, Grading$subjectsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$SubjectPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    academicYearSubjects<
      T extends Grading$academicYearSubjectsArgs<ExtArgs> = {},
    >(
      args?: Subset<T, Grading$academicYearSubjectsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$AcademicYearSubjectPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Grading model
   */
  interface GradingFieldRefs {
    readonly id: FieldRef<"Grading", "String">;
    readonly from: FieldRef<"Grading", "Float">;
    readonly to: FieldRef<"Grading", "Float">;
    readonly grade: FieldRef<"Grading", "String">;
    readonly remarks: FieldRef<"Grading", "String">;
  }

  // Custom InputTypes
  /**
   * Grading findUnique
   */
  export type GradingFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Grading
     */
    select?: GradingSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Grading
     */
    omit?: GradingOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradingInclude<ExtArgs> | null;
    /**
     * Filter, which Grading to fetch.
     */
    where: GradingWhereUniqueInput;
  };

  /**
   * Grading findUniqueOrThrow
   */
  export type GradingFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Grading
     */
    select?: GradingSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Grading
     */
    omit?: GradingOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradingInclude<ExtArgs> | null;
    /**
     * Filter, which Grading to fetch.
     */
    where: GradingWhereUniqueInput;
  };

  /**
   * Grading findFirst
   */
  export type GradingFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Grading
     */
    select?: GradingSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Grading
     */
    omit?: GradingOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradingInclude<ExtArgs> | null;
    /**
     * Filter, which Grading to fetch.
     */
    where?: GradingWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Gradings to fetch.
     */
    orderBy?:
      | GradingOrderByWithRelationInput
      | GradingOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Gradings.
     */
    cursor?: GradingWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Gradings from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Gradings.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Gradings.
     */
    distinct?: GradingScalarFieldEnum | GradingScalarFieldEnum[];
  };

  /**
   * Grading findFirstOrThrow
   */
  export type GradingFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Grading
     */
    select?: GradingSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Grading
     */
    omit?: GradingOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradingInclude<ExtArgs> | null;
    /**
     * Filter, which Grading to fetch.
     */
    where?: GradingWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Gradings to fetch.
     */
    orderBy?:
      | GradingOrderByWithRelationInput
      | GradingOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Gradings.
     */
    cursor?: GradingWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Gradings from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Gradings.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Gradings.
     */
    distinct?: GradingScalarFieldEnum | GradingScalarFieldEnum[];
  };

  /**
   * Grading findMany
   */
  export type GradingFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Grading
     */
    select?: GradingSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Grading
     */
    omit?: GradingOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradingInclude<ExtArgs> | null;
    /**
     * Filter, which Gradings to fetch.
     */
    where?: GradingWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Gradings to fetch.
     */
    orderBy?:
      | GradingOrderByWithRelationInput
      | GradingOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Gradings.
     */
    cursor?: GradingWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Gradings from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Gradings.
     */
    skip?: number;
    distinct?: GradingScalarFieldEnum | GradingScalarFieldEnum[];
  };

  /**
   * Grading create
   */
  export type GradingCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Grading
     */
    select?: GradingSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Grading
     */
    omit?: GradingOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradingInclude<ExtArgs> | null;
    /**
     * The data needed to create a Grading.
     */
    data: XOR<GradingCreateInput, GradingUncheckedCreateInput>;
  };

  /**
   * Grading createMany
   */
  export type GradingCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Gradings.
     */
    data: GradingCreateManyInput | GradingCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Grading createManyAndReturn
   */
  export type GradingCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Grading
     */
    select?: GradingSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Grading
     */
    omit?: GradingOmit<ExtArgs> | null;
    /**
     * The data used to create many Gradings.
     */
    data: GradingCreateManyInput | GradingCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Grading update
   */
  export type GradingUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Grading
     */
    select?: GradingSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Grading
     */
    omit?: GradingOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradingInclude<ExtArgs> | null;
    /**
     * The data needed to update a Grading.
     */
    data: XOR<GradingUpdateInput, GradingUncheckedUpdateInput>;
    /**
     * Choose, which Grading to update.
     */
    where: GradingWhereUniqueInput;
  };

  /**
   * Grading updateMany
   */
  export type GradingUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Gradings.
     */
    data: XOR<GradingUpdateManyMutationInput, GradingUncheckedUpdateManyInput>;
    /**
     * Filter which Gradings to update
     */
    where?: GradingWhereInput;
    /**
     * Limit how many Gradings to update.
     */
    limit?: number;
  };

  /**
   * Grading updateManyAndReturn
   */
  export type GradingUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Grading
     */
    select?: GradingSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Grading
     */
    omit?: GradingOmit<ExtArgs> | null;
    /**
     * The data used to update Gradings.
     */
    data: XOR<GradingUpdateManyMutationInput, GradingUncheckedUpdateManyInput>;
    /**
     * Filter which Gradings to update
     */
    where?: GradingWhereInput;
    /**
     * Limit how many Gradings to update.
     */
    limit?: number;
  };

  /**
   * Grading upsert
   */
  export type GradingUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Grading
     */
    select?: GradingSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Grading
     */
    omit?: GradingOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradingInclude<ExtArgs> | null;
    /**
     * The filter to search for the Grading to update in case it exists.
     */
    where: GradingWhereUniqueInput;
    /**
     * In case the Grading found by the `where` argument doesn't exist, create a new Grading with this data.
     */
    create: XOR<GradingCreateInput, GradingUncheckedCreateInput>;
    /**
     * In case the Grading was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GradingUpdateInput, GradingUncheckedUpdateInput>;
  };

  /**
   * Grading delete
   */
  export type GradingDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Grading
     */
    select?: GradingSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Grading
     */
    omit?: GradingOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradingInclude<ExtArgs> | null;
    /**
     * Filter which Grading to delete.
     */
    where: GradingWhereUniqueInput;
  };

  /**
   * Grading deleteMany
   */
  export type GradingDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Gradings to delete
     */
    where?: GradingWhereInput;
    /**
     * Limit how many Gradings to delete.
     */
    limit?: number;
  };

  /**
   * Grading.subjects
   */
  export type Grading$subjectsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null;
    where?: SubjectWhereInput;
    orderBy?:
      | SubjectOrderByWithRelationInput
      | SubjectOrderByWithRelationInput[];
    cursor?: SubjectWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: SubjectScalarFieldEnum | SubjectScalarFieldEnum[];
  };

  /**
   * Grading.academicYearSubjects
   */
  export type Grading$academicYearSubjectsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AcademicYearSubject
     */
    select?: AcademicYearSubjectSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AcademicYearSubject
     */
    omit?: AcademicYearSubjectOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearSubjectInclude<ExtArgs> | null;
    where?: AcademicYearSubjectWhereInput;
    orderBy?:
      | AcademicYearSubjectOrderByWithRelationInput
      | AcademicYearSubjectOrderByWithRelationInput[];
    cursor?: AcademicYearSubjectWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?:
      | AcademicYearSubjectScalarFieldEnum
      | AcademicYearSubjectScalarFieldEnum[];
  };

  /**
   * Grading without action
   */
  export type GradingDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Grading
     */
    select?: GradingSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Grading
     */
    omit?: GradingOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradingInclude<ExtArgs> | null;
  };

  /**
   * Model AcademicYearSubject
   */

  export type AggregateAcademicYearSubject = {
    _count: AcademicYearSubjectCountAggregateOutputType | null;
    _min: AcademicYearSubjectMinAggregateOutputType | null;
    _max: AcademicYearSubjectMaxAggregateOutputType | null;
  };

  export type AcademicYearSubjectMinAggregateOutputType = {
    id: string | null;
    academicYearClassId: string | null;
    subjectId: string | null;
  };

  export type AcademicYearSubjectMaxAggregateOutputType = {
    id: string | null;
    academicYearClassId: string | null;
    subjectId: string | null;
  };

  export type AcademicYearSubjectCountAggregateOutputType = {
    id: number;
    academicYearClassId: number;
    subjectId: number;
    _all: number;
  };

  export type AcademicYearSubjectMinAggregateInputType = {
    id?: true;
    academicYearClassId?: true;
    subjectId?: true;
  };

  export type AcademicYearSubjectMaxAggregateInputType = {
    id?: true;
    academicYearClassId?: true;
    subjectId?: true;
  };

  export type AcademicYearSubjectCountAggregateInputType = {
    id?: true;
    academicYearClassId?: true;
    subjectId?: true;
    _all?: true;
  };

  export type AcademicYearSubjectAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which AcademicYearSubject to aggregate.
     */
    where?: AcademicYearSubjectWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AcademicYearSubjects to fetch.
     */
    orderBy?:
      | AcademicYearSubjectOrderByWithRelationInput
      | AcademicYearSubjectOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: AcademicYearSubjectWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AcademicYearSubjects from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AcademicYearSubjects.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned AcademicYearSubjects
     **/
    _count?: true | AcademicYearSubjectCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: AcademicYearSubjectMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: AcademicYearSubjectMaxAggregateInputType;
  };

  export type GetAcademicYearSubjectAggregateType<
    T extends AcademicYearSubjectAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateAcademicYearSubject]: P extends
      | "_count"
      | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAcademicYearSubject[P]>
      : GetScalarType<T[P], AggregateAcademicYearSubject[P]>;
  };

  export type AcademicYearSubjectGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AcademicYearSubjectWhereInput;
    orderBy?:
      | AcademicYearSubjectOrderByWithAggregationInput
      | AcademicYearSubjectOrderByWithAggregationInput[];
    by:
      | AcademicYearSubjectScalarFieldEnum[]
      | AcademicYearSubjectScalarFieldEnum;
    having?: AcademicYearSubjectScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: AcademicYearSubjectCountAggregateInputType | true;
    _min?: AcademicYearSubjectMinAggregateInputType;
    _max?: AcademicYearSubjectMaxAggregateInputType;
  };

  export type AcademicYearSubjectGroupByOutputType = {
    id: string;
    academicYearClassId: string;
    subjectId: string;
    _count: AcademicYearSubjectCountAggregateOutputType | null;
    _min: AcademicYearSubjectMinAggregateOutputType | null;
    _max: AcademicYearSubjectMaxAggregateOutputType | null;
  };

  type GetAcademicYearSubjectGroupByPayload<
    T extends AcademicYearSubjectGroupByArgs,
  > = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AcademicYearSubjectGroupByOutputType, T["by"]> & {
        [P in keyof T &
          keyof AcademicYearSubjectGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], AcademicYearSubjectGroupByOutputType[P]>
          : GetScalarType<T[P], AcademicYearSubjectGroupByOutputType[P]>;
      }
    >
  >;

  export type AcademicYearSubjectSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      academicYearClassId?: boolean;
      subjectId?: boolean;
      customGrading?: boolean | AcademicYearSubject$customGradingArgs<ExtArgs>;
      academicYearClass?: boolean | AcademicYearClassDefaultArgs<ExtArgs>;
      teachers?: boolean | AcademicYearSubject$teachersArgs<ExtArgs>;
      subject?: boolean | SubjectDefaultArgs<ExtArgs>;
      examSubjects?: boolean | AcademicYearSubject$examSubjectsArgs<ExtArgs>;
      _count?: boolean | AcademicYearSubjectCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["academicYearSubject"]
  >;

  export type AcademicYearSubjectSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      academicYearClassId?: boolean;
      subjectId?: boolean;
      academicYearClass?: boolean | AcademicYearClassDefaultArgs<ExtArgs>;
      subject?: boolean | SubjectDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["academicYearSubject"]
  >;

  export type AcademicYearSubjectSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      academicYearClassId?: boolean;
      subjectId?: boolean;
      academicYearClass?: boolean | AcademicYearClassDefaultArgs<ExtArgs>;
      subject?: boolean | SubjectDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["academicYearSubject"]
  >;

  export type AcademicYearSubjectSelectScalar = {
    id?: boolean;
    academicYearClassId?: boolean;
    subjectId?: boolean;
  };

  export type AcademicYearSubjectOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    "id" | "academicYearClassId" | "subjectId",
    ExtArgs["result"]["academicYearSubject"]
  >;
  export type AcademicYearSubjectInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    customGrading?: boolean | AcademicYearSubject$customGradingArgs<ExtArgs>;
    academicYearClass?: boolean | AcademicYearClassDefaultArgs<ExtArgs>;
    teachers?: boolean | AcademicYearSubject$teachersArgs<ExtArgs>;
    subject?: boolean | SubjectDefaultArgs<ExtArgs>;
    examSubjects?: boolean | AcademicYearSubject$examSubjectsArgs<ExtArgs>;
    _count?: boolean | AcademicYearSubjectCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type AcademicYearSubjectIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    academicYearClass?: boolean | AcademicYearClassDefaultArgs<ExtArgs>;
    subject?: boolean | SubjectDefaultArgs<ExtArgs>;
  };
  export type AcademicYearSubjectIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    academicYearClass?: boolean | AcademicYearClassDefaultArgs<ExtArgs>;
    subject?: boolean | SubjectDefaultArgs<ExtArgs>;
  };

  export type $AcademicYearSubjectPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "AcademicYearSubject";
    objects: {
      customGrading: Prisma.$GradingPayload<ExtArgs>[];
      academicYearClass: Prisma.$AcademicYearClassPayload<ExtArgs>;
      teachers: Prisma.$StaffPayload<ExtArgs>[];
      subject: Prisma.$SubjectPayload<ExtArgs>;
      examSubjects: Prisma.$ExamSubjectPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        academicYearClassId: string;
        subjectId: string;
      },
      ExtArgs["result"]["academicYearSubject"]
    >;
    composites: {};
  };

  type AcademicYearSubjectGetPayload<
    S extends boolean | null | undefined | AcademicYearSubjectDefaultArgs,
  > = $Result.GetResult<Prisma.$AcademicYearSubjectPayload, S>;

  type AcademicYearSubjectCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    AcademicYearSubjectFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: AcademicYearSubjectCountAggregateInputType | true;
  };

  export interface AcademicYearSubjectDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["AcademicYearSubject"];
      meta: { name: "AcademicYearSubject" };
    };
    /**
     * Find zero or one AcademicYearSubject that matches the filter.
     * @param {AcademicYearSubjectFindUniqueArgs} args - Arguments to find a AcademicYearSubject
     * @example
     * // Get one AcademicYearSubject
     * const academicYearSubject = await prisma.academicYearSubject.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AcademicYearSubjectFindUniqueArgs>(
      args: SelectSubset<T, AcademicYearSubjectFindUniqueArgs<ExtArgs>>,
    ): Prisma__AcademicYearSubjectClient<
      $Result.GetResult<
        Prisma.$AcademicYearSubjectPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one AcademicYearSubject that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AcademicYearSubjectFindUniqueOrThrowArgs} args - Arguments to find a AcademicYearSubject
     * @example
     * // Get one AcademicYearSubject
     * const academicYearSubject = await prisma.academicYearSubject.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AcademicYearSubjectFindUniqueOrThrowArgs>(
      args: SelectSubset<T, AcademicYearSubjectFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__AcademicYearSubjectClient<
      $Result.GetResult<
        Prisma.$AcademicYearSubjectPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first AcademicYearSubject that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicYearSubjectFindFirstArgs} args - Arguments to find a AcademicYearSubject
     * @example
     * // Get one AcademicYearSubject
     * const academicYearSubject = await prisma.academicYearSubject.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AcademicYearSubjectFindFirstArgs>(
      args?: SelectSubset<T, AcademicYearSubjectFindFirstArgs<ExtArgs>>,
    ): Prisma__AcademicYearSubjectClient<
      $Result.GetResult<
        Prisma.$AcademicYearSubjectPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first AcademicYearSubject that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicYearSubjectFindFirstOrThrowArgs} args - Arguments to find a AcademicYearSubject
     * @example
     * // Get one AcademicYearSubject
     * const academicYearSubject = await prisma.academicYearSubject.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AcademicYearSubjectFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AcademicYearSubjectFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__AcademicYearSubjectClient<
      $Result.GetResult<
        Prisma.$AcademicYearSubjectPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more AcademicYearSubjects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicYearSubjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AcademicYearSubjects
     * const academicYearSubjects = await prisma.academicYearSubject.findMany()
     *
     * // Get first 10 AcademicYearSubjects
     * const academicYearSubjects = await prisma.academicYearSubject.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const academicYearSubjectWithIdOnly = await prisma.academicYearSubject.findMany({ select: { id: true } })
     *
     */
    findMany<T extends AcademicYearSubjectFindManyArgs>(
      args?: SelectSubset<T, AcademicYearSubjectFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$AcademicYearSubjectPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a AcademicYearSubject.
     * @param {AcademicYearSubjectCreateArgs} args - Arguments to create a AcademicYearSubject.
     * @example
     * // Create one AcademicYearSubject
     * const AcademicYearSubject = await prisma.academicYearSubject.create({
     *   data: {
     *     // ... data to create a AcademicYearSubject
     *   }
     * })
     *
     */
    create<T extends AcademicYearSubjectCreateArgs>(
      args: SelectSubset<T, AcademicYearSubjectCreateArgs<ExtArgs>>,
    ): Prisma__AcademicYearSubjectClient<
      $Result.GetResult<
        Prisma.$AcademicYearSubjectPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many AcademicYearSubjects.
     * @param {AcademicYearSubjectCreateManyArgs} args - Arguments to create many AcademicYearSubjects.
     * @example
     * // Create many AcademicYearSubjects
     * const academicYearSubject = await prisma.academicYearSubject.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends AcademicYearSubjectCreateManyArgs>(
      args?: SelectSubset<T, AcademicYearSubjectCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many AcademicYearSubjects and returns the data saved in the database.
     * @param {AcademicYearSubjectCreateManyAndReturnArgs} args - Arguments to create many AcademicYearSubjects.
     * @example
     * // Create many AcademicYearSubjects
     * const academicYearSubject = await prisma.academicYearSubject.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many AcademicYearSubjects and only return the `id`
     * const academicYearSubjectWithIdOnly = await prisma.academicYearSubject.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends AcademicYearSubjectCreateManyAndReturnArgs>(
      args?: SelectSubset<
        T,
        AcademicYearSubjectCreateManyAndReturnArgs<ExtArgs>
      >,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$AcademicYearSubjectPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a AcademicYearSubject.
     * @param {AcademicYearSubjectDeleteArgs} args - Arguments to delete one AcademicYearSubject.
     * @example
     * // Delete one AcademicYearSubject
     * const AcademicYearSubject = await prisma.academicYearSubject.delete({
     *   where: {
     *     // ... filter to delete one AcademicYearSubject
     *   }
     * })
     *
     */
    delete<T extends AcademicYearSubjectDeleteArgs>(
      args: SelectSubset<T, AcademicYearSubjectDeleteArgs<ExtArgs>>,
    ): Prisma__AcademicYearSubjectClient<
      $Result.GetResult<
        Prisma.$AcademicYearSubjectPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one AcademicYearSubject.
     * @param {AcademicYearSubjectUpdateArgs} args - Arguments to update one AcademicYearSubject.
     * @example
     * // Update one AcademicYearSubject
     * const academicYearSubject = await prisma.academicYearSubject.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends AcademicYearSubjectUpdateArgs>(
      args: SelectSubset<T, AcademicYearSubjectUpdateArgs<ExtArgs>>,
    ): Prisma__AcademicYearSubjectClient<
      $Result.GetResult<
        Prisma.$AcademicYearSubjectPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more AcademicYearSubjects.
     * @param {AcademicYearSubjectDeleteManyArgs} args - Arguments to filter AcademicYearSubjects to delete.
     * @example
     * // Delete a few AcademicYearSubjects
     * const { count } = await prisma.academicYearSubject.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends AcademicYearSubjectDeleteManyArgs>(
      args?: SelectSubset<T, AcademicYearSubjectDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more AcademicYearSubjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicYearSubjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AcademicYearSubjects
     * const academicYearSubject = await prisma.academicYearSubject.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends AcademicYearSubjectUpdateManyArgs>(
      args: SelectSubset<T, AcademicYearSubjectUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more AcademicYearSubjects and returns the data updated in the database.
     * @param {AcademicYearSubjectUpdateManyAndReturnArgs} args - Arguments to update many AcademicYearSubjects.
     * @example
     * // Update many AcademicYearSubjects
     * const academicYearSubject = await prisma.academicYearSubject.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more AcademicYearSubjects and only return the `id`
     * const academicYearSubjectWithIdOnly = await prisma.academicYearSubject.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends AcademicYearSubjectUpdateManyAndReturnArgs>(
      args: SelectSubset<
        T,
        AcademicYearSubjectUpdateManyAndReturnArgs<ExtArgs>
      >,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$AcademicYearSubjectPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one AcademicYearSubject.
     * @param {AcademicYearSubjectUpsertArgs} args - Arguments to update or create a AcademicYearSubject.
     * @example
     * // Update or create a AcademicYearSubject
     * const academicYearSubject = await prisma.academicYearSubject.upsert({
     *   create: {
     *     // ... data to create a AcademicYearSubject
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AcademicYearSubject we want to update
     *   }
     * })
     */
    upsert<T extends AcademicYearSubjectUpsertArgs>(
      args: SelectSubset<T, AcademicYearSubjectUpsertArgs<ExtArgs>>,
    ): Prisma__AcademicYearSubjectClient<
      $Result.GetResult<
        Prisma.$AcademicYearSubjectPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of AcademicYearSubjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicYearSubjectCountArgs} args - Arguments to filter AcademicYearSubjects to count.
     * @example
     * // Count the number of AcademicYearSubjects
     * const count = await prisma.academicYearSubject.count({
     *   where: {
     *     // ... the filter for the AcademicYearSubjects we want to count
     *   }
     * })
     **/
    count<T extends AcademicYearSubjectCountArgs>(
      args?: Subset<T, AcademicYearSubjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<
              T["select"],
              AcademicYearSubjectCountAggregateOutputType
            >
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a AcademicYearSubject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicYearSubjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends AcademicYearSubjectAggregateArgs>(
      args: Subset<T, AcademicYearSubjectAggregateArgs>,
    ): Prisma.PrismaPromise<GetAcademicYearSubjectAggregateType<T>>;

    /**
     * Group by AcademicYearSubject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicYearSubjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends AcademicYearSubjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AcademicYearSubjectGroupByArgs["orderBy"] }
        : { orderBy?: AcademicYearSubjectGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, AcademicYearSubjectGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetAcademicYearSubjectGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the AcademicYearSubject model
     */
    readonly fields: AcademicYearSubjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AcademicYearSubject.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AcademicYearSubjectClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    customGrading<
      T extends AcademicYearSubject$customGradingArgs<ExtArgs> = {},
    >(
      args?: Subset<T, AcademicYearSubject$customGradingArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$GradingPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    academicYearClass<T extends AcademicYearClassDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, AcademicYearClassDefaultArgs<ExtArgs>>,
    ): Prisma__AcademicYearClassClient<
      | $Result.GetResult<
          Prisma.$AcademicYearClassPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    teachers<T extends AcademicYearSubject$teachersArgs<ExtArgs> = {}>(
      args?: Subset<T, AcademicYearSubject$teachersArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$StaffPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    subject<T extends SubjectDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, SubjectDefaultArgs<ExtArgs>>,
    ): Prisma__SubjectClient<
      | $Result.GetResult<
          Prisma.$SubjectPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    examSubjects<T extends AcademicYearSubject$examSubjectsArgs<ExtArgs> = {}>(
      args?: Subset<T, AcademicYearSubject$examSubjectsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$ExamSubjectPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the AcademicYearSubject model
   */
  interface AcademicYearSubjectFieldRefs {
    readonly id: FieldRef<"AcademicYearSubject", "String">;
    readonly academicYearClassId: FieldRef<"AcademicYearSubject", "String">;
    readonly subjectId: FieldRef<"AcademicYearSubject", "String">;
  }

  // Custom InputTypes
  /**
   * AcademicYearSubject findUnique
   */
  export type AcademicYearSubjectFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AcademicYearSubject
     */
    select?: AcademicYearSubjectSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AcademicYearSubject
     */
    omit?: AcademicYearSubjectOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearSubjectInclude<ExtArgs> | null;
    /**
     * Filter, which AcademicYearSubject to fetch.
     */
    where: AcademicYearSubjectWhereUniqueInput;
  };

  /**
   * AcademicYearSubject findUniqueOrThrow
   */
  export type AcademicYearSubjectFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AcademicYearSubject
     */
    select?: AcademicYearSubjectSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AcademicYearSubject
     */
    omit?: AcademicYearSubjectOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearSubjectInclude<ExtArgs> | null;
    /**
     * Filter, which AcademicYearSubject to fetch.
     */
    where: AcademicYearSubjectWhereUniqueInput;
  };

  /**
   * AcademicYearSubject findFirst
   */
  export type AcademicYearSubjectFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AcademicYearSubject
     */
    select?: AcademicYearSubjectSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AcademicYearSubject
     */
    omit?: AcademicYearSubjectOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearSubjectInclude<ExtArgs> | null;
    /**
     * Filter, which AcademicYearSubject to fetch.
     */
    where?: AcademicYearSubjectWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AcademicYearSubjects to fetch.
     */
    orderBy?:
      | AcademicYearSubjectOrderByWithRelationInput
      | AcademicYearSubjectOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for AcademicYearSubjects.
     */
    cursor?: AcademicYearSubjectWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AcademicYearSubjects from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AcademicYearSubjects.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of AcademicYearSubjects.
     */
    distinct?:
      | AcademicYearSubjectScalarFieldEnum
      | AcademicYearSubjectScalarFieldEnum[];
  };

  /**
   * AcademicYearSubject findFirstOrThrow
   */
  export type AcademicYearSubjectFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AcademicYearSubject
     */
    select?: AcademicYearSubjectSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AcademicYearSubject
     */
    omit?: AcademicYearSubjectOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearSubjectInclude<ExtArgs> | null;
    /**
     * Filter, which AcademicYearSubject to fetch.
     */
    where?: AcademicYearSubjectWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AcademicYearSubjects to fetch.
     */
    orderBy?:
      | AcademicYearSubjectOrderByWithRelationInput
      | AcademicYearSubjectOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for AcademicYearSubjects.
     */
    cursor?: AcademicYearSubjectWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AcademicYearSubjects from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AcademicYearSubjects.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of AcademicYearSubjects.
     */
    distinct?:
      | AcademicYearSubjectScalarFieldEnum
      | AcademicYearSubjectScalarFieldEnum[];
  };

  /**
   * AcademicYearSubject findMany
   */
  export type AcademicYearSubjectFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AcademicYearSubject
     */
    select?: AcademicYearSubjectSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AcademicYearSubject
     */
    omit?: AcademicYearSubjectOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearSubjectInclude<ExtArgs> | null;
    /**
     * Filter, which AcademicYearSubjects to fetch.
     */
    where?: AcademicYearSubjectWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AcademicYearSubjects to fetch.
     */
    orderBy?:
      | AcademicYearSubjectOrderByWithRelationInput
      | AcademicYearSubjectOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing AcademicYearSubjects.
     */
    cursor?: AcademicYearSubjectWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AcademicYearSubjects from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AcademicYearSubjects.
     */
    skip?: number;
    distinct?:
      | AcademicYearSubjectScalarFieldEnum
      | AcademicYearSubjectScalarFieldEnum[];
  };

  /**
   * AcademicYearSubject create
   */
  export type AcademicYearSubjectCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AcademicYearSubject
     */
    select?: AcademicYearSubjectSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AcademicYearSubject
     */
    omit?: AcademicYearSubjectOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearSubjectInclude<ExtArgs> | null;
    /**
     * The data needed to create a AcademicYearSubject.
     */
    data: XOR<
      AcademicYearSubjectCreateInput,
      AcademicYearSubjectUncheckedCreateInput
    >;
  };

  /**
   * AcademicYearSubject createMany
   */
  export type AcademicYearSubjectCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many AcademicYearSubjects.
     */
    data:
      | AcademicYearSubjectCreateManyInput
      | AcademicYearSubjectCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * AcademicYearSubject createManyAndReturn
   */
  export type AcademicYearSubjectCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AcademicYearSubject
     */
    select?: AcademicYearSubjectSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the AcademicYearSubject
     */
    omit?: AcademicYearSubjectOmit<ExtArgs> | null;
    /**
     * The data used to create many AcademicYearSubjects.
     */
    data:
      | AcademicYearSubjectCreateManyInput
      | AcademicYearSubjectCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearSubjectIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * AcademicYearSubject update
   */
  export type AcademicYearSubjectUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AcademicYearSubject
     */
    select?: AcademicYearSubjectSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AcademicYearSubject
     */
    omit?: AcademicYearSubjectOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearSubjectInclude<ExtArgs> | null;
    /**
     * The data needed to update a AcademicYearSubject.
     */
    data: XOR<
      AcademicYearSubjectUpdateInput,
      AcademicYearSubjectUncheckedUpdateInput
    >;
    /**
     * Choose, which AcademicYearSubject to update.
     */
    where: AcademicYearSubjectWhereUniqueInput;
  };

  /**
   * AcademicYearSubject updateMany
   */
  export type AcademicYearSubjectUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update AcademicYearSubjects.
     */
    data: XOR<
      AcademicYearSubjectUpdateManyMutationInput,
      AcademicYearSubjectUncheckedUpdateManyInput
    >;
    /**
     * Filter which AcademicYearSubjects to update
     */
    where?: AcademicYearSubjectWhereInput;
    /**
     * Limit how many AcademicYearSubjects to update.
     */
    limit?: number;
  };

  /**
   * AcademicYearSubject updateManyAndReturn
   */
  export type AcademicYearSubjectUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AcademicYearSubject
     */
    select?: AcademicYearSubjectSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the AcademicYearSubject
     */
    omit?: AcademicYearSubjectOmit<ExtArgs> | null;
    /**
     * The data used to update AcademicYearSubjects.
     */
    data: XOR<
      AcademicYearSubjectUpdateManyMutationInput,
      AcademicYearSubjectUncheckedUpdateManyInput
    >;
    /**
     * Filter which AcademicYearSubjects to update
     */
    where?: AcademicYearSubjectWhereInput;
    /**
     * Limit how many AcademicYearSubjects to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearSubjectIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * AcademicYearSubject upsert
   */
  export type AcademicYearSubjectUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AcademicYearSubject
     */
    select?: AcademicYearSubjectSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AcademicYearSubject
     */
    omit?: AcademicYearSubjectOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearSubjectInclude<ExtArgs> | null;
    /**
     * The filter to search for the AcademicYearSubject to update in case it exists.
     */
    where: AcademicYearSubjectWhereUniqueInput;
    /**
     * In case the AcademicYearSubject found by the `where` argument doesn't exist, create a new AcademicYearSubject with this data.
     */
    create: XOR<
      AcademicYearSubjectCreateInput,
      AcademicYearSubjectUncheckedCreateInput
    >;
    /**
     * In case the AcademicYearSubject was found with the provided `where` argument, update it with this data.
     */
    update: XOR<
      AcademicYearSubjectUpdateInput,
      AcademicYearSubjectUncheckedUpdateInput
    >;
  };

  /**
   * AcademicYearSubject delete
   */
  export type AcademicYearSubjectDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AcademicYearSubject
     */
    select?: AcademicYearSubjectSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AcademicYearSubject
     */
    omit?: AcademicYearSubjectOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearSubjectInclude<ExtArgs> | null;
    /**
     * Filter which AcademicYearSubject to delete.
     */
    where: AcademicYearSubjectWhereUniqueInput;
  };

  /**
   * AcademicYearSubject deleteMany
   */
  export type AcademicYearSubjectDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which AcademicYearSubjects to delete
     */
    where?: AcademicYearSubjectWhereInput;
    /**
     * Limit how many AcademicYearSubjects to delete.
     */
    limit?: number;
  };

  /**
   * AcademicYearSubject.customGrading
   */
  export type AcademicYearSubject$customGradingArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Grading
     */
    select?: GradingSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Grading
     */
    omit?: GradingOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradingInclude<ExtArgs> | null;
    where?: GradingWhereInput;
    orderBy?:
      | GradingOrderByWithRelationInput
      | GradingOrderByWithRelationInput[];
    cursor?: GradingWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: GradingScalarFieldEnum | GradingScalarFieldEnum[];
  };

  /**
   * AcademicYearSubject.teachers
   */
  export type AcademicYearSubject$teachersArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null;
    where?: StaffWhereInput;
    orderBy?: StaffOrderByWithRelationInput | StaffOrderByWithRelationInput[];
    cursor?: StaffWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: StaffScalarFieldEnum | StaffScalarFieldEnum[];
  };

  /**
   * AcademicYearSubject.examSubjects
   */
  export type AcademicYearSubject$examSubjectsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ExamSubject
     */
    select?: ExamSubjectSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ExamSubject
     */
    omit?: ExamSubjectOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamSubjectInclude<ExtArgs> | null;
    where?: ExamSubjectWhereInput;
    orderBy?:
      | ExamSubjectOrderByWithRelationInput
      | ExamSubjectOrderByWithRelationInput[];
    cursor?: ExamSubjectWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ExamSubjectScalarFieldEnum | ExamSubjectScalarFieldEnum[];
  };

  /**
   * AcademicYearSubject without action
   */
  export type AcademicYearSubjectDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AcademicYearSubject
     */
    select?: AcademicYearSubjectSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AcademicYearSubject
     */
    omit?: AcademicYearSubjectOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearSubjectInclude<ExtArgs> | null;
  };

  /**
   * Model classStream
   */

  export type AggregateClassStream = {
    _count: ClassStreamCountAggregateOutputType | null;
    _min: ClassStreamMinAggregateOutputType | null;
    _max: ClassStreamMaxAggregateOutputType | null;
  };

  export type ClassStreamMinAggregateOutputType = {
    id: string | null;
    staffId: string | null;
    classId: string | null;
    streamId: string | null;
  };

  export type ClassStreamMaxAggregateOutputType = {
    id: string | null;
    staffId: string | null;
    classId: string | null;
    streamId: string | null;
  };

  export type ClassStreamCountAggregateOutputType = {
    id: number;
    staffId: number;
    classId: number;
    streamId: number;
    _all: number;
  };

  export type ClassStreamMinAggregateInputType = {
    id?: true;
    staffId?: true;
    classId?: true;
    streamId?: true;
  };

  export type ClassStreamMaxAggregateInputType = {
    id?: true;
    staffId?: true;
    classId?: true;
    streamId?: true;
  };

  export type ClassStreamCountAggregateInputType = {
    id?: true;
    staffId?: true;
    classId?: true;
    streamId?: true;
    _all?: true;
  };

  export type ClassStreamAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which classStream to aggregate.
     */
    where?: classStreamWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of classStreams to fetch.
     */
    orderBy?:
      | classStreamOrderByWithRelationInput
      | classStreamOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: classStreamWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` classStreams from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` classStreams.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned classStreams
     **/
    _count?: true | ClassStreamCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ClassStreamMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ClassStreamMaxAggregateInputType;
  };

  export type GetClassStreamAggregateType<T extends ClassStreamAggregateArgs> =
    {
      [P in keyof T & keyof AggregateClassStream]: P extends "_count" | "count"
        ? T[P] extends true
          ? number
          : GetScalarType<T[P], AggregateClassStream[P]>
        : GetScalarType<T[P], AggregateClassStream[P]>;
    };

  export type classStreamGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: classStreamWhereInput;
    orderBy?:
      | classStreamOrderByWithAggregationInput
      | classStreamOrderByWithAggregationInput[];
    by: ClassStreamScalarFieldEnum[] | ClassStreamScalarFieldEnum;
    having?: classStreamScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ClassStreamCountAggregateInputType | true;
    _min?: ClassStreamMinAggregateInputType;
    _max?: ClassStreamMaxAggregateInputType;
  };

  export type ClassStreamGroupByOutputType = {
    id: string;
    staffId: string | null;
    classId: string | null;
    streamId: string | null;
    _count: ClassStreamCountAggregateOutputType | null;
    _min: ClassStreamMinAggregateOutputType | null;
    _max: ClassStreamMaxAggregateOutputType | null;
  };

  type GetClassStreamGroupByPayload<T extends classStreamGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<ClassStreamGroupByOutputType, T["by"]> & {
          [P in keyof T &
            keyof ClassStreamGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClassStreamGroupByOutputType[P]>
            : GetScalarType<T[P], ClassStreamGroupByOutputType[P]>;
        }
      >
    >;

  export type classStreamSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      staffId?: boolean;
      classId?: boolean;
      streamId?: boolean;
      pupils?: boolean | classStream$pupilsArgs<ExtArgs>;
      class?: boolean | classStream$classArgs<ExtArgs>;
      classTeacher?: boolean | classStream$classTeacherArgs<ExtArgs>;
      stream?: boolean | classStream$streamArgs<ExtArgs>;
      terms?: boolean | classStream$termsArgs<ExtArgs>;
      _count?: boolean | ClassStreamCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["classStream"]
  >;

  export type classStreamSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      staffId?: boolean;
      classId?: boolean;
      streamId?: boolean;
      class?: boolean | classStream$classArgs<ExtArgs>;
      classTeacher?: boolean | classStream$classTeacherArgs<ExtArgs>;
      stream?: boolean | classStream$streamArgs<ExtArgs>;
    },
    ExtArgs["result"]["classStream"]
  >;

  export type classStreamSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      staffId?: boolean;
      classId?: boolean;
      streamId?: boolean;
      class?: boolean | classStream$classArgs<ExtArgs>;
      classTeacher?: boolean | classStream$classTeacherArgs<ExtArgs>;
      stream?: boolean | classStream$streamArgs<ExtArgs>;
    },
    ExtArgs["result"]["classStream"]
  >;

  export type classStreamSelectScalar = {
    id?: boolean;
    staffId?: boolean;
    classId?: boolean;
    streamId?: boolean;
  };

  export type classStreamOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    "id" | "staffId" | "classId" | "streamId",
    ExtArgs["result"]["classStream"]
  >;
  export type classStreamInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    pupils?: boolean | classStream$pupilsArgs<ExtArgs>;
    class?: boolean | classStream$classArgs<ExtArgs>;
    classTeacher?: boolean | classStream$classTeacherArgs<ExtArgs>;
    stream?: boolean | classStream$streamArgs<ExtArgs>;
    terms?: boolean | classStream$termsArgs<ExtArgs>;
    _count?: boolean | ClassStreamCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type classStreamIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    class?: boolean | classStream$classArgs<ExtArgs>;
    classTeacher?: boolean | classStream$classTeacherArgs<ExtArgs>;
    stream?: boolean | classStream$streamArgs<ExtArgs>;
  };
  export type classStreamIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    class?: boolean | classStream$classArgs<ExtArgs>;
    classTeacher?: boolean | classStream$classTeacherArgs<ExtArgs>;
    stream?: boolean | classStream$streamArgs<ExtArgs>;
  };

  export type $classStreamPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "classStream";
    objects: {
      pupils: Prisma.$PupilPayload<ExtArgs>[];
      class: Prisma.$AcademicYearClassPayload<ExtArgs> | null;
      classTeacher: Prisma.$StaffPayload<ExtArgs> | null;
      stream: Prisma.$StreamPayload<ExtArgs> | null;
      terms: Prisma.$ClassTermPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        staffId: string | null;
        classId: string | null;
        streamId: string | null;
      },
      ExtArgs["result"]["classStream"]
    >;
    composites: {};
  };

  type classStreamGetPayload<
    S extends boolean | null | undefined | classStreamDefaultArgs,
  > = $Result.GetResult<Prisma.$classStreamPayload, S>;

  type classStreamCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    classStreamFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: ClassStreamCountAggregateInputType | true;
  };

  export interface classStreamDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["classStream"];
      meta: { name: "classStream" };
    };
    /**
     * Find zero or one ClassStream that matches the filter.
     * @param {classStreamFindUniqueArgs} args - Arguments to find a ClassStream
     * @example
     * // Get one ClassStream
     * const classStream = await prisma.classStream.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends classStreamFindUniqueArgs>(
      args: SelectSubset<T, classStreamFindUniqueArgs<ExtArgs>>,
    ): Prisma__classStreamClient<
      $Result.GetResult<
        Prisma.$classStreamPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one ClassStream that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {classStreamFindUniqueOrThrowArgs} args - Arguments to find a ClassStream
     * @example
     * // Get one ClassStream
     * const classStream = await prisma.classStream.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends classStreamFindUniqueOrThrowArgs>(
      args: SelectSubset<T, classStreamFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__classStreamClient<
      $Result.GetResult<
        Prisma.$classStreamPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first ClassStream that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {classStreamFindFirstArgs} args - Arguments to find a ClassStream
     * @example
     * // Get one ClassStream
     * const classStream = await prisma.classStream.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends classStreamFindFirstArgs>(
      args?: SelectSubset<T, classStreamFindFirstArgs<ExtArgs>>,
    ): Prisma__classStreamClient<
      $Result.GetResult<
        Prisma.$classStreamPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first ClassStream that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {classStreamFindFirstOrThrowArgs} args - Arguments to find a ClassStream
     * @example
     * // Get one ClassStream
     * const classStream = await prisma.classStream.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends classStreamFindFirstOrThrowArgs>(
      args?: SelectSubset<T, classStreamFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__classStreamClient<
      $Result.GetResult<
        Prisma.$classStreamPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more ClassStreams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {classStreamFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClassStreams
     * const classStreams = await prisma.classStream.findMany()
     *
     * // Get first 10 ClassStreams
     * const classStreams = await prisma.classStream.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const classStreamWithIdOnly = await prisma.classStream.findMany({ select: { id: true } })
     *
     */
    findMany<T extends classStreamFindManyArgs>(
      args?: SelectSubset<T, classStreamFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$classStreamPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a ClassStream.
     * @param {classStreamCreateArgs} args - Arguments to create a ClassStream.
     * @example
     * // Create one ClassStream
     * const ClassStream = await prisma.classStream.create({
     *   data: {
     *     // ... data to create a ClassStream
     *   }
     * })
     *
     */
    create<T extends classStreamCreateArgs>(
      args: SelectSubset<T, classStreamCreateArgs<ExtArgs>>,
    ): Prisma__classStreamClient<
      $Result.GetResult<
        Prisma.$classStreamPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many ClassStreams.
     * @param {classStreamCreateManyArgs} args - Arguments to create many ClassStreams.
     * @example
     * // Create many ClassStreams
     * const classStream = await prisma.classStream.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends classStreamCreateManyArgs>(
      args?: SelectSubset<T, classStreamCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many ClassStreams and returns the data saved in the database.
     * @param {classStreamCreateManyAndReturnArgs} args - Arguments to create many ClassStreams.
     * @example
     * // Create many ClassStreams
     * const classStream = await prisma.classStream.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many ClassStreams and only return the `id`
     * const classStreamWithIdOnly = await prisma.classStream.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends classStreamCreateManyAndReturnArgs>(
      args?: SelectSubset<T, classStreamCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$classStreamPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a ClassStream.
     * @param {classStreamDeleteArgs} args - Arguments to delete one ClassStream.
     * @example
     * // Delete one ClassStream
     * const ClassStream = await prisma.classStream.delete({
     *   where: {
     *     // ... filter to delete one ClassStream
     *   }
     * })
     *
     */
    delete<T extends classStreamDeleteArgs>(
      args: SelectSubset<T, classStreamDeleteArgs<ExtArgs>>,
    ): Prisma__classStreamClient<
      $Result.GetResult<
        Prisma.$classStreamPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one ClassStream.
     * @param {classStreamUpdateArgs} args - Arguments to update one ClassStream.
     * @example
     * // Update one ClassStream
     * const classStream = await prisma.classStream.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends classStreamUpdateArgs>(
      args: SelectSubset<T, classStreamUpdateArgs<ExtArgs>>,
    ): Prisma__classStreamClient<
      $Result.GetResult<
        Prisma.$classStreamPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more ClassStreams.
     * @param {classStreamDeleteManyArgs} args - Arguments to filter ClassStreams to delete.
     * @example
     * // Delete a few ClassStreams
     * const { count } = await prisma.classStream.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends classStreamDeleteManyArgs>(
      args?: SelectSubset<T, classStreamDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more ClassStreams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {classStreamUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClassStreams
     * const classStream = await prisma.classStream.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends classStreamUpdateManyArgs>(
      args: SelectSubset<T, classStreamUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more ClassStreams and returns the data updated in the database.
     * @param {classStreamUpdateManyAndReturnArgs} args - Arguments to update many ClassStreams.
     * @example
     * // Update many ClassStreams
     * const classStream = await prisma.classStream.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more ClassStreams and only return the `id`
     * const classStreamWithIdOnly = await prisma.classStream.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends classStreamUpdateManyAndReturnArgs>(
      args: SelectSubset<T, classStreamUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$classStreamPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one ClassStream.
     * @param {classStreamUpsertArgs} args - Arguments to update or create a ClassStream.
     * @example
     * // Update or create a ClassStream
     * const classStream = await prisma.classStream.upsert({
     *   create: {
     *     // ... data to create a ClassStream
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClassStream we want to update
     *   }
     * })
     */
    upsert<T extends classStreamUpsertArgs>(
      args: SelectSubset<T, classStreamUpsertArgs<ExtArgs>>,
    ): Prisma__classStreamClient<
      $Result.GetResult<
        Prisma.$classStreamPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of ClassStreams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {classStreamCountArgs} args - Arguments to filter ClassStreams to count.
     * @example
     * // Count the number of ClassStreams
     * const count = await prisma.classStream.count({
     *   where: {
     *     // ... the filter for the ClassStreams we want to count
     *   }
     * })
     **/
    count<T extends classStreamCountArgs>(
      args?: Subset<T, classStreamCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], ClassStreamCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a ClassStream.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassStreamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ClassStreamAggregateArgs>(
      args: Subset<T, ClassStreamAggregateArgs>,
    ): Prisma.PrismaPromise<GetClassStreamAggregateType<T>>;

    /**
     * Group by ClassStream.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {classStreamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends classStreamGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: classStreamGroupByArgs["orderBy"] }
        : { orderBy?: classStreamGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, classStreamGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetClassStreamGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the classStream model
     */
    readonly fields: classStreamFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for classStream.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__classStreamClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    pupils<T extends classStream$pupilsArgs<ExtArgs> = {}>(
      args?: Subset<T, classStream$pupilsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$PupilPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    class<T extends classStream$classArgs<ExtArgs> = {}>(
      args?: Subset<T, classStream$classArgs<ExtArgs>>,
    ): Prisma__AcademicYearClassClient<
      $Result.GetResult<
        Prisma.$AcademicYearClassPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    classTeacher<T extends classStream$classTeacherArgs<ExtArgs> = {}>(
      args?: Subset<T, classStream$classTeacherArgs<ExtArgs>>,
    ): Prisma__StaffClient<
      $Result.GetResult<
        Prisma.$StaffPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    stream<T extends classStream$streamArgs<ExtArgs> = {}>(
      args?: Subset<T, classStream$streamArgs<ExtArgs>>,
    ): Prisma__StreamClient<
      $Result.GetResult<
        Prisma.$StreamPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    terms<T extends classStream$termsArgs<ExtArgs> = {}>(
      args?: Subset<T, classStream$termsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$ClassTermPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the classStream model
   */
  interface classStreamFieldRefs {
    readonly id: FieldRef<"classStream", "String">;
    readonly staffId: FieldRef<"classStream", "String">;
    readonly classId: FieldRef<"classStream", "String">;
    readonly streamId: FieldRef<"classStream", "String">;
  }

  // Custom InputTypes
  /**
   * classStream findUnique
   */
  export type classStreamFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the classStream
     */
    select?: classStreamSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the classStream
     */
    omit?: classStreamOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: classStreamInclude<ExtArgs> | null;
    /**
     * Filter, which classStream to fetch.
     */
    where: classStreamWhereUniqueInput;
  };

  /**
   * classStream findUniqueOrThrow
   */
  export type classStreamFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the classStream
     */
    select?: classStreamSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the classStream
     */
    omit?: classStreamOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: classStreamInclude<ExtArgs> | null;
    /**
     * Filter, which classStream to fetch.
     */
    where: classStreamWhereUniqueInput;
  };

  /**
   * classStream findFirst
   */
  export type classStreamFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the classStream
     */
    select?: classStreamSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the classStream
     */
    omit?: classStreamOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: classStreamInclude<ExtArgs> | null;
    /**
     * Filter, which classStream to fetch.
     */
    where?: classStreamWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of classStreams to fetch.
     */
    orderBy?:
      | classStreamOrderByWithRelationInput
      | classStreamOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for classStreams.
     */
    cursor?: classStreamWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` classStreams from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` classStreams.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of classStreams.
     */
    distinct?: ClassStreamScalarFieldEnum | ClassStreamScalarFieldEnum[];
  };

  /**
   * classStream findFirstOrThrow
   */
  export type classStreamFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the classStream
     */
    select?: classStreamSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the classStream
     */
    omit?: classStreamOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: classStreamInclude<ExtArgs> | null;
    /**
     * Filter, which classStream to fetch.
     */
    where?: classStreamWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of classStreams to fetch.
     */
    orderBy?:
      | classStreamOrderByWithRelationInput
      | classStreamOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for classStreams.
     */
    cursor?: classStreamWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` classStreams from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` classStreams.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of classStreams.
     */
    distinct?: ClassStreamScalarFieldEnum | ClassStreamScalarFieldEnum[];
  };

  /**
   * classStream findMany
   */
  export type classStreamFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the classStream
     */
    select?: classStreamSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the classStream
     */
    omit?: classStreamOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: classStreamInclude<ExtArgs> | null;
    /**
     * Filter, which classStreams to fetch.
     */
    where?: classStreamWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of classStreams to fetch.
     */
    orderBy?:
      | classStreamOrderByWithRelationInput
      | classStreamOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing classStreams.
     */
    cursor?: classStreamWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` classStreams from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` classStreams.
     */
    skip?: number;
    distinct?: ClassStreamScalarFieldEnum | ClassStreamScalarFieldEnum[];
  };

  /**
   * classStream create
   */
  export type classStreamCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the classStream
     */
    select?: classStreamSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the classStream
     */
    omit?: classStreamOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: classStreamInclude<ExtArgs> | null;
    /**
     * The data needed to create a classStream.
     */
    data?: XOR<classStreamCreateInput, classStreamUncheckedCreateInput>;
  };

  /**
   * classStream createMany
   */
  export type classStreamCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many classStreams.
     */
    data: classStreamCreateManyInput | classStreamCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * classStream createManyAndReturn
   */
  export type classStreamCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the classStream
     */
    select?: classStreamSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the classStream
     */
    omit?: classStreamOmit<ExtArgs> | null;
    /**
     * The data used to create many classStreams.
     */
    data: classStreamCreateManyInput | classStreamCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: classStreamIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * classStream update
   */
  export type classStreamUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the classStream
     */
    select?: classStreamSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the classStream
     */
    omit?: classStreamOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: classStreamInclude<ExtArgs> | null;
    /**
     * The data needed to update a classStream.
     */
    data: XOR<classStreamUpdateInput, classStreamUncheckedUpdateInput>;
    /**
     * Choose, which classStream to update.
     */
    where: classStreamWhereUniqueInput;
  };

  /**
   * classStream updateMany
   */
  export type classStreamUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update classStreams.
     */
    data: XOR<
      classStreamUpdateManyMutationInput,
      classStreamUncheckedUpdateManyInput
    >;
    /**
     * Filter which classStreams to update
     */
    where?: classStreamWhereInput;
    /**
     * Limit how many classStreams to update.
     */
    limit?: number;
  };

  /**
   * classStream updateManyAndReturn
   */
  export type classStreamUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the classStream
     */
    select?: classStreamSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the classStream
     */
    omit?: classStreamOmit<ExtArgs> | null;
    /**
     * The data used to update classStreams.
     */
    data: XOR<
      classStreamUpdateManyMutationInput,
      classStreamUncheckedUpdateManyInput
    >;
    /**
     * Filter which classStreams to update
     */
    where?: classStreamWhereInput;
    /**
     * Limit how many classStreams to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: classStreamIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * classStream upsert
   */
  export type classStreamUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the classStream
     */
    select?: classStreamSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the classStream
     */
    omit?: classStreamOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: classStreamInclude<ExtArgs> | null;
    /**
     * The filter to search for the classStream to update in case it exists.
     */
    where: classStreamWhereUniqueInput;
    /**
     * In case the classStream found by the `where` argument doesn't exist, create a new classStream with this data.
     */
    create: XOR<classStreamCreateInput, classStreamUncheckedCreateInput>;
    /**
     * In case the classStream was found with the provided `where` argument, update it with this data.
     */
    update: XOR<classStreamUpdateInput, classStreamUncheckedUpdateInput>;
  };

  /**
   * classStream delete
   */
  export type classStreamDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the classStream
     */
    select?: classStreamSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the classStream
     */
    omit?: classStreamOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: classStreamInclude<ExtArgs> | null;
    /**
     * Filter which classStream to delete.
     */
    where: classStreamWhereUniqueInput;
  };

  /**
   * classStream deleteMany
   */
  export type classStreamDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which classStreams to delete
     */
    where?: classStreamWhereInput;
    /**
     * Limit how many classStreams to delete.
     */
    limit?: number;
  };

  /**
   * classStream.pupils
   */
  export type classStream$pupilsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Pupil
     */
    select?: PupilSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Pupil
     */
    omit?: PupilOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PupilInclude<ExtArgs> | null;
    where?: PupilWhereInput;
    orderBy?: PupilOrderByWithRelationInput | PupilOrderByWithRelationInput[];
    cursor?: PupilWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: PupilScalarFieldEnum | PupilScalarFieldEnum[];
  };

  /**
   * classStream.class
   */
  export type classStream$classArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AcademicYearClass
     */
    select?: AcademicYearClassSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AcademicYearClass
     */
    omit?: AcademicYearClassOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearClassInclude<ExtArgs> | null;
    where?: AcademicYearClassWhereInput;
  };

  /**
   * classStream.classTeacher
   */
  export type classStream$classTeacherArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null;
    where?: StaffWhereInput;
  };

  /**
   * classStream.stream
   */
  export type classStream$streamArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Stream
     */
    select?: StreamSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Stream
     */
    omit?: StreamOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreamInclude<ExtArgs> | null;
    where?: StreamWhereInput;
  };

  /**
   * classStream.terms
   */
  export type classStream$termsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ClassTerm
     */
    select?: ClassTermSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ClassTerm
     */
    omit?: ClassTermOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassTermInclude<ExtArgs> | null;
    where?: ClassTermWhereInput;
    orderBy?:
      | ClassTermOrderByWithRelationInput
      | ClassTermOrderByWithRelationInput[];
    cursor?: ClassTermWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ClassTermScalarFieldEnum | ClassTermScalarFieldEnum[];
  };

  /**
   * classStream without action
   */
  export type classStreamDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the classStream
     */
    select?: classStreamSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the classStream
     */
    omit?: classStreamOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: classStreamInclude<ExtArgs> | null;
  };

  /**
   * Model Term
   */

  export type AggregateTerm = {
    _count: TermCountAggregateOutputType | null;
    _min: TermMinAggregateOutputType | null;
    _max: TermMaxAggregateOutputType | null;
  };

  export type TermMinAggregateOutputType = {
    id: string | null;
    term: string | null;
    slug: string | null;
  };

  export type TermMaxAggregateOutputType = {
    id: string | null;
    term: string | null;
    slug: string | null;
  };

  export type TermCountAggregateOutputType = {
    id: number;
    term: number;
    slug: number;
    _all: number;
  };

  export type TermMinAggregateInputType = {
    id?: true;
    term?: true;
    slug?: true;
  };

  export type TermMaxAggregateInputType = {
    id?: true;
    term?: true;
    slug?: true;
  };

  export type TermCountAggregateInputType = {
    id?: true;
    term?: true;
    slug?: true;
    _all?: true;
  };

  export type TermAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Term to aggregate.
     */
    where?: TermWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Terms to fetch.
     */
    orderBy?: TermOrderByWithRelationInput | TermOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: TermWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Terms from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Terms.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Terms
     **/
    _count?: true | TermCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: TermMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: TermMaxAggregateInputType;
  };

  export type GetTermAggregateType<T extends TermAggregateArgs> = {
    [P in keyof T & keyof AggregateTerm]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTerm[P]>
      : GetScalarType<T[P], AggregateTerm[P]>;
  };

  export type TermGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: TermWhereInput;
    orderBy?:
      | TermOrderByWithAggregationInput
      | TermOrderByWithAggregationInput[];
    by: TermScalarFieldEnum[] | TermScalarFieldEnum;
    having?: TermScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: TermCountAggregateInputType | true;
    _min?: TermMinAggregateInputType;
    _max?: TermMaxAggregateInputType;
  };

  export type TermGroupByOutputType = {
    id: string;
    term: string;
    slug: string;
    _count: TermCountAggregateOutputType | null;
    _min: TermMinAggregateOutputType | null;
    _max: TermMaxAggregateOutputType | null;
  };

  type GetTermGroupByPayload<T extends TermGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TermGroupByOutputType, T["by"]> & {
        [P in keyof T & keyof TermGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], TermGroupByOutputType[P]>
          : GetScalarType<T[P], TermGroupByOutputType[P]>;
      }
    >
  >;

  export type TermSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      term?: boolean;
      slug?: boolean;
      classTerms?: boolean | Term$classTermsArgs<ExtArgs>;
      _count?: boolean | TermCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["term"]
  >;

  export type TermSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      term?: boolean;
      slug?: boolean;
    },
    ExtArgs["result"]["term"]
  >;

  export type TermSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      term?: boolean;
      slug?: boolean;
    },
    ExtArgs["result"]["term"]
  >;

  export type TermSelectScalar = {
    id?: boolean;
    term?: boolean;
    slug?: boolean;
  };

  export type TermOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<"id" | "term" | "slug", ExtArgs["result"]["term"]>;
  export type TermInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    classTerms?: boolean | Term$classTermsArgs<ExtArgs>;
    _count?: boolean | TermCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type TermIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};
  export type TermIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};

  export type $TermPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "Term";
    objects: {
      classTerms: Prisma.$ClassTermPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        term: string;
        slug: string;
      },
      ExtArgs["result"]["term"]
    >;
    composites: {};
  };

  type TermGetPayload<S extends boolean | null | undefined | TermDefaultArgs> =
    $Result.GetResult<Prisma.$TermPayload, S>;

  type TermCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<TermFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
    select?: TermCountAggregateInputType | true;
  };

  export interface TermDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["Term"];
      meta: { name: "Term" };
    };
    /**
     * Find zero or one Term that matches the filter.
     * @param {TermFindUniqueArgs} args - Arguments to find a Term
     * @example
     * // Get one Term
     * const term = await prisma.term.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TermFindUniqueArgs>(
      args: SelectSubset<T, TermFindUniqueArgs<ExtArgs>>,
    ): Prisma__TermClient<
      $Result.GetResult<
        Prisma.$TermPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Term that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TermFindUniqueOrThrowArgs} args - Arguments to find a Term
     * @example
     * // Get one Term
     * const term = await prisma.term.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TermFindUniqueOrThrowArgs>(
      args: SelectSubset<T, TermFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__TermClient<
      $Result.GetResult<
        Prisma.$TermPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Term that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermFindFirstArgs} args - Arguments to find a Term
     * @example
     * // Get one Term
     * const term = await prisma.term.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TermFindFirstArgs>(
      args?: SelectSubset<T, TermFindFirstArgs<ExtArgs>>,
    ): Prisma__TermClient<
      $Result.GetResult<
        Prisma.$TermPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Term that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermFindFirstOrThrowArgs} args - Arguments to find a Term
     * @example
     * // Get one Term
     * const term = await prisma.term.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TermFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TermFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__TermClient<
      $Result.GetResult<
        Prisma.$TermPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Terms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Terms
     * const terms = await prisma.term.findMany()
     *
     * // Get first 10 Terms
     * const terms = await prisma.term.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const termWithIdOnly = await prisma.term.findMany({ select: { id: true } })
     *
     */
    findMany<T extends TermFindManyArgs>(
      args?: SelectSubset<T, TermFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$TermPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Term.
     * @param {TermCreateArgs} args - Arguments to create a Term.
     * @example
     * // Create one Term
     * const Term = await prisma.term.create({
     *   data: {
     *     // ... data to create a Term
     *   }
     * })
     *
     */
    create<T extends TermCreateArgs>(
      args: SelectSubset<T, TermCreateArgs<ExtArgs>>,
    ): Prisma__TermClient<
      $Result.GetResult<
        Prisma.$TermPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Terms.
     * @param {TermCreateManyArgs} args - Arguments to create many Terms.
     * @example
     * // Create many Terms
     * const term = await prisma.term.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends TermCreateManyArgs>(
      args?: SelectSubset<T, TermCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Terms and returns the data saved in the database.
     * @param {TermCreateManyAndReturnArgs} args - Arguments to create many Terms.
     * @example
     * // Create many Terms
     * const term = await prisma.term.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Terms and only return the `id`
     * const termWithIdOnly = await prisma.term.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends TermCreateManyAndReturnArgs>(
      args?: SelectSubset<T, TermCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$TermPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Term.
     * @param {TermDeleteArgs} args - Arguments to delete one Term.
     * @example
     * // Delete one Term
     * const Term = await prisma.term.delete({
     *   where: {
     *     // ... filter to delete one Term
     *   }
     * })
     *
     */
    delete<T extends TermDeleteArgs>(
      args: SelectSubset<T, TermDeleteArgs<ExtArgs>>,
    ): Prisma__TermClient<
      $Result.GetResult<
        Prisma.$TermPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Term.
     * @param {TermUpdateArgs} args - Arguments to update one Term.
     * @example
     * // Update one Term
     * const term = await prisma.term.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends TermUpdateArgs>(
      args: SelectSubset<T, TermUpdateArgs<ExtArgs>>,
    ): Prisma__TermClient<
      $Result.GetResult<
        Prisma.$TermPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Terms.
     * @param {TermDeleteManyArgs} args - Arguments to filter Terms to delete.
     * @example
     * // Delete a few Terms
     * const { count } = await prisma.term.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends TermDeleteManyArgs>(
      args?: SelectSubset<T, TermDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Terms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Terms
     * const term = await prisma.term.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends TermUpdateManyArgs>(
      args: SelectSubset<T, TermUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Terms and returns the data updated in the database.
     * @param {TermUpdateManyAndReturnArgs} args - Arguments to update many Terms.
     * @example
     * // Update many Terms
     * const term = await prisma.term.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Terms and only return the `id`
     * const termWithIdOnly = await prisma.term.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends TermUpdateManyAndReturnArgs>(
      args: SelectSubset<T, TermUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$TermPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Term.
     * @param {TermUpsertArgs} args - Arguments to update or create a Term.
     * @example
     * // Update or create a Term
     * const term = await prisma.term.upsert({
     *   create: {
     *     // ... data to create a Term
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Term we want to update
     *   }
     * })
     */
    upsert<T extends TermUpsertArgs>(
      args: SelectSubset<T, TermUpsertArgs<ExtArgs>>,
    ): Prisma__TermClient<
      $Result.GetResult<
        Prisma.$TermPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Terms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermCountArgs} args - Arguments to filter Terms to count.
     * @example
     * // Count the number of Terms
     * const count = await prisma.term.count({
     *   where: {
     *     // ... the filter for the Terms we want to count
     *   }
     * })
     **/
    count<T extends TermCountArgs>(
      args?: Subset<T, TermCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], TermCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Term.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends TermAggregateArgs>(
      args: Subset<T, TermAggregateArgs>,
    ): Prisma.PrismaPromise<GetTermAggregateType<T>>;

    /**
     * Group by Term.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends TermGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TermGroupByArgs["orderBy"] }
        : { orderBy?: TermGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, TermGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetTermGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Term model
     */
    readonly fields: TermFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Term.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TermClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    classTerms<T extends Term$classTermsArgs<ExtArgs> = {}>(
      args?: Subset<T, Term$classTermsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$ClassTermPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Term model
   */
  interface TermFieldRefs {
    readonly id: FieldRef<"Term", "String">;
    readonly term: FieldRef<"Term", "String">;
    readonly slug: FieldRef<"Term", "String">;
  }

  // Custom InputTypes
  /**
   * Term findUnique
   */
  export type TermFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Term
     */
    select?: TermSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Term
     */
    omit?: TermOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermInclude<ExtArgs> | null;
    /**
     * Filter, which Term to fetch.
     */
    where: TermWhereUniqueInput;
  };

  /**
   * Term findUniqueOrThrow
   */
  export type TermFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Term
     */
    select?: TermSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Term
     */
    omit?: TermOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermInclude<ExtArgs> | null;
    /**
     * Filter, which Term to fetch.
     */
    where: TermWhereUniqueInput;
  };

  /**
   * Term findFirst
   */
  export type TermFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Term
     */
    select?: TermSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Term
     */
    omit?: TermOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermInclude<ExtArgs> | null;
    /**
     * Filter, which Term to fetch.
     */
    where?: TermWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Terms to fetch.
     */
    orderBy?: TermOrderByWithRelationInput | TermOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Terms.
     */
    cursor?: TermWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Terms from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Terms.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Terms.
     */
    distinct?: TermScalarFieldEnum | TermScalarFieldEnum[];
  };

  /**
   * Term findFirstOrThrow
   */
  export type TermFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Term
     */
    select?: TermSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Term
     */
    omit?: TermOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermInclude<ExtArgs> | null;
    /**
     * Filter, which Term to fetch.
     */
    where?: TermWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Terms to fetch.
     */
    orderBy?: TermOrderByWithRelationInput | TermOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Terms.
     */
    cursor?: TermWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Terms from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Terms.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Terms.
     */
    distinct?: TermScalarFieldEnum | TermScalarFieldEnum[];
  };

  /**
   * Term findMany
   */
  export type TermFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Term
     */
    select?: TermSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Term
     */
    omit?: TermOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermInclude<ExtArgs> | null;
    /**
     * Filter, which Terms to fetch.
     */
    where?: TermWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Terms to fetch.
     */
    orderBy?: TermOrderByWithRelationInput | TermOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Terms.
     */
    cursor?: TermWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Terms from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Terms.
     */
    skip?: number;
    distinct?: TermScalarFieldEnum | TermScalarFieldEnum[];
  };

  /**
   * Term create
   */
  export type TermCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Term
     */
    select?: TermSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Term
     */
    omit?: TermOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermInclude<ExtArgs> | null;
    /**
     * The data needed to create a Term.
     */
    data: XOR<TermCreateInput, TermUncheckedCreateInput>;
  };

  /**
   * Term createMany
   */
  export type TermCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Terms.
     */
    data: TermCreateManyInput | TermCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Term createManyAndReturn
   */
  export type TermCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Term
     */
    select?: TermSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Term
     */
    omit?: TermOmit<ExtArgs> | null;
    /**
     * The data used to create many Terms.
     */
    data: TermCreateManyInput | TermCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Term update
   */
  export type TermUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Term
     */
    select?: TermSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Term
     */
    omit?: TermOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermInclude<ExtArgs> | null;
    /**
     * The data needed to update a Term.
     */
    data: XOR<TermUpdateInput, TermUncheckedUpdateInput>;
    /**
     * Choose, which Term to update.
     */
    where: TermWhereUniqueInput;
  };

  /**
   * Term updateMany
   */
  export type TermUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Terms.
     */
    data: XOR<TermUpdateManyMutationInput, TermUncheckedUpdateManyInput>;
    /**
     * Filter which Terms to update
     */
    where?: TermWhereInput;
    /**
     * Limit how many Terms to update.
     */
    limit?: number;
  };

  /**
   * Term updateManyAndReturn
   */
  export type TermUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Term
     */
    select?: TermSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Term
     */
    omit?: TermOmit<ExtArgs> | null;
    /**
     * The data used to update Terms.
     */
    data: XOR<TermUpdateManyMutationInput, TermUncheckedUpdateManyInput>;
    /**
     * Filter which Terms to update
     */
    where?: TermWhereInput;
    /**
     * Limit how many Terms to update.
     */
    limit?: number;
  };

  /**
   * Term upsert
   */
  export type TermUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Term
     */
    select?: TermSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Term
     */
    omit?: TermOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermInclude<ExtArgs> | null;
    /**
     * The filter to search for the Term to update in case it exists.
     */
    where: TermWhereUniqueInput;
    /**
     * In case the Term found by the `where` argument doesn't exist, create a new Term with this data.
     */
    create: XOR<TermCreateInput, TermUncheckedCreateInput>;
    /**
     * In case the Term was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TermUpdateInput, TermUncheckedUpdateInput>;
  };

  /**
   * Term delete
   */
  export type TermDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Term
     */
    select?: TermSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Term
     */
    omit?: TermOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermInclude<ExtArgs> | null;
    /**
     * Filter which Term to delete.
     */
    where: TermWhereUniqueInput;
  };

  /**
   * Term deleteMany
   */
  export type TermDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Terms to delete
     */
    where?: TermWhereInput;
    /**
     * Limit how many Terms to delete.
     */
    limit?: number;
  };

  /**
   * Term.classTerms
   */
  export type Term$classTermsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ClassTerm
     */
    select?: ClassTermSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ClassTerm
     */
    omit?: ClassTermOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassTermInclude<ExtArgs> | null;
    where?: ClassTermWhereInput;
    orderBy?:
      | ClassTermOrderByWithRelationInput
      | ClassTermOrderByWithRelationInput[];
    cursor?: ClassTermWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ClassTermScalarFieldEnum | ClassTermScalarFieldEnum[];
  };

  /**
   * Term without action
   */
  export type TermDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Term
     */
    select?: TermSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Term
     */
    omit?: TermOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermInclude<ExtArgs> | null;
  };

  /**
   * Model ClassTerm
   */

  export type AggregateClassTerm = {
    _count: ClassTermCountAggregateOutputType | null;
    _avg: ClassTermAvgAggregateOutputType | null;
    _sum: ClassTermSumAggregateOutputType | null;
    _min: ClassTermMinAggregateOutputType | null;
    _max: ClassTermMaxAggregateOutputType | null;
  };

  export type ClassTermAvgAggregateOutputType = {
    feesAmount: number | null;
  };

  export type ClassTermSumAggregateOutputType = {
    feesAmount: number | null;
  };

  export type ClassTermMinAggregateOutputType = {
    id: string | null;
    startAt: Date | null;
    endAt: Date | null;
    termId: string | null;
    classStreamId: string | null;
    feesAmount: number | null;
  };

  export type ClassTermMaxAggregateOutputType = {
    id: string | null;
    startAt: Date | null;
    endAt: Date | null;
    termId: string | null;
    classStreamId: string | null;
    feesAmount: number | null;
  };

  export type ClassTermCountAggregateOutputType = {
    id: number;
    startAt: number;
    endAt: number;
    termId: number;
    classStreamId: number;
    feesAmount: number;
    _all: number;
  };

  export type ClassTermAvgAggregateInputType = {
    feesAmount?: true;
  };

  export type ClassTermSumAggregateInputType = {
    feesAmount?: true;
  };

  export type ClassTermMinAggregateInputType = {
    id?: true;
    startAt?: true;
    endAt?: true;
    termId?: true;
    classStreamId?: true;
    feesAmount?: true;
  };

  export type ClassTermMaxAggregateInputType = {
    id?: true;
    startAt?: true;
    endAt?: true;
    termId?: true;
    classStreamId?: true;
    feesAmount?: true;
  };

  export type ClassTermCountAggregateInputType = {
    id?: true;
    startAt?: true;
    endAt?: true;
    termId?: true;
    classStreamId?: true;
    feesAmount?: true;
    _all?: true;
  };

  export type ClassTermAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which ClassTerm to aggregate.
     */
    where?: ClassTermWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ClassTerms to fetch.
     */
    orderBy?:
      | ClassTermOrderByWithRelationInput
      | ClassTermOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ClassTermWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ClassTerms from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ClassTerms.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned ClassTerms
     **/
    _count?: true | ClassTermCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: ClassTermAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: ClassTermSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ClassTermMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ClassTermMaxAggregateInputType;
  };

  export type GetClassTermAggregateType<T extends ClassTermAggregateArgs> = {
    [P in keyof T & keyof AggregateClassTerm]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClassTerm[P]>
      : GetScalarType<T[P], AggregateClassTerm[P]>;
  };

  export type ClassTermGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ClassTermWhereInput;
    orderBy?:
      | ClassTermOrderByWithAggregationInput
      | ClassTermOrderByWithAggregationInput[];
    by: ClassTermScalarFieldEnum[] | ClassTermScalarFieldEnum;
    having?: ClassTermScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ClassTermCountAggregateInputType | true;
    _avg?: ClassTermAvgAggregateInputType;
    _sum?: ClassTermSumAggregateInputType;
    _min?: ClassTermMinAggregateInputType;
    _max?: ClassTermMaxAggregateInputType;
  };

  export type ClassTermGroupByOutputType = {
    id: string;
    startAt: Date;
    endAt: Date;
    termId: string | null;
    classStreamId: string | null;
    feesAmount: number | null;
    _count: ClassTermCountAggregateOutputType | null;
    _avg: ClassTermAvgAggregateOutputType | null;
    _sum: ClassTermSumAggregateOutputType | null;
    _min: ClassTermMinAggregateOutputType | null;
    _max: ClassTermMaxAggregateOutputType | null;
  };

  type GetClassTermGroupByPayload<T extends ClassTermGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<ClassTermGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof ClassTermGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClassTermGroupByOutputType[P]>
            : GetScalarType<T[P], ClassTermGroupByOutputType[P]>;
        }
      >
    >;

  export type ClassTermSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      startAt?: boolean;
      endAt?: boolean;
      termId?: boolean;
      classStreamId?: boolean;
      feesAmount?: boolean;
      classStream?: boolean | ClassTerm$classStreamArgs<ExtArgs>;
      term?: boolean | ClassTerm$termArgs<ExtArgs>;
      exams?: boolean | ClassTerm$examsArgs<ExtArgs>;
      fees?: boolean | ClassTerm$feesArgs<ExtArgs>;
      _count?: boolean | ClassTermCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["classTerm"]
  >;

  export type ClassTermSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      startAt?: boolean;
      endAt?: boolean;
      termId?: boolean;
      classStreamId?: boolean;
      feesAmount?: boolean;
      classStream?: boolean | ClassTerm$classStreamArgs<ExtArgs>;
      term?: boolean | ClassTerm$termArgs<ExtArgs>;
    },
    ExtArgs["result"]["classTerm"]
  >;

  export type ClassTermSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      startAt?: boolean;
      endAt?: boolean;
      termId?: boolean;
      classStreamId?: boolean;
      feesAmount?: boolean;
      classStream?: boolean | ClassTerm$classStreamArgs<ExtArgs>;
      term?: boolean | ClassTerm$termArgs<ExtArgs>;
    },
    ExtArgs["result"]["classTerm"]
  >;

  export type ClassTermSelectScalar = {
    id?: boolean;
    startAt?: boolean;
    endAt?: boolean;
    termId?: boolean;
    classStreamId?: boolean;
    feesAmount?: boolean;
  };

  export type ClassTermOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    "id" | "startAt" | "endAt" | "termId" | "classStreamId" | "feesAmount",
    ExtArgs["result"]["classTerm"]
  >;
  export type ClassTermInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    classStream?: boolean | ClassTerm$classStreamArgs<ExtArgs>;
    term?: boolean | ClassTerm$termArgs<ExtArgs>;
    exams?: boolean | ClassTerm$examsArgs<ExtArgs>;
    fees?: boolean | ClassTerm$feesArgs<ExtArgs>;
    _count?: boolean | ClassTermCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type ClassTermIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    classStream?: boolean | ClassTerm$classStreamArgs<ExtArgs>;
    term?: boolean | ClassTerm$termArgs<ExtArgs>;
  };
  export type ClassTermIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    classStream?: boolean | ClassTerm$classStreamArgs<ExtArgs>;
    term?: boolean | ClassTerm$termArgs<ExtArgs>;
  };

  export type $ClassTermPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "ClassTerm";
    objects: {
      classStream: Prisma.$classStreamPayload<ExtArgs> | null;
      term: Prisma.$TermPayload<ExtArgs> | null;
      exams: Prisma.$ExamPayload<ExtArgs>[];
      fees: Prisma.$FeesPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        startAt: Date;
        endAt: Date;
        termId: string | null;
        classStreamId: string | null;
        feesAmount: number | null;
      },
      ExtArgs["result"]["classTerm"]
    >;
    composites: {};
  };

  type ClassTermGetPayload<
    S extends boolean | null | undefined | ClassTermDefaultArgs,
  > = $Result.GetResult<Prisma.$ClassTermPayload, S>;

  type ClassTermCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    ClassTermFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: ClassTermCountAggregateInputType | true;
  };

  export interface ClassTermDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["ClassTerm"];
      meta: { name: "ClassTerm" };
    };
    /**
     * Find zero or one ClassTerm that matches the filter.
     * @param {ClassTermFindUniqueArgs} args - Arguments to find a ClassTerm
     * @example
     * // Get one ClassTerm
     * const classTerm = await prisma.classTerm.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClassTermFindUniqueArgs>(
      args: SelectSubset<T, ClassTermFindUniqueArgs<ExtArgs>>,
    ): Prisma__ClassTermClient<
      $Result.GetResult<
        Prisma.$ClassTermPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one ClassTerm that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClassTermFindUniqueOrThrowArgs} args - Arguments to find a ClassTerm
     * @example
     * // Get one ClassTerm
     * const classTerm = await prisma.classTerm.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClassTermFindUniqueOrThrowArgs>(
      args: SelectSubset<T, ClassTermFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__ClassTermClient<
      $Result.GetResult<
        Prisma.$ClassTermPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first ClassTerm that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassTermFindFirstArgs} args - Arguments to find a ClassTerm
     * @example
     * // Get one ClassTerm
     * const classTerm = await prisma.classTerm.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClassTermFindFirstArgs>(
      args?: SelectSubset<T, ClassTermFindFirstArgs<ExtArgs>>,
    ): Prisma__ClassTermClient<
      $Result.GetResult<
        Prisma.$ClassTermPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first ClassTerm that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassTermFindFirstOrThrowArgs} args - Arguments to find a ClassTerm
     * @example
     * // Get one ClassTerm
     * const classTerm = await prisma.classTerm.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClassTermFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ClassTermFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__ClassTermClient<
      $Result.GetResult<
        Prisma.$ClassTermPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more ClassTerms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassTermFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClassTerms
     * const classTerms = await prisma.classTerm.findMany()
     *
     * // Get first 10 ClassTerms
     * const classTerms = await prisma.classTerm.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const classTermWithIdOnly = await prisma.classTerm.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ClassTermFindManyArgs>(
      args?: SelectSubset<T, ClassTermFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ClassTermPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a ClassTerm.
     * @param {ClassTermCreateArgs} args - Arguments to create a ClassTerm.
     * @example
     * // Create one ClassTerm
     * const ClassTerm = await prisma.classTerm.create({
     *   data: {
     *     // ... data to create a ClassTerm
     *   }
     * })
     *
     */
    create<T extends ClassTermCreateArgs>(
      args: SelectSubset<T, ClassTermCreateArgs<ExtArgs>>,
    ): Prisma__ClassTermClient<
      $Result.GetResult<
        Prisma.$ClassTermPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many ClassTerms.
     * @param {ClassTermCreateManyArgs} args - Arguments to create many ClassTerms.
     * @example
     * // Create many ClassTerms
     * const classTerm = await prisma.classTerm.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ClassTermCreateManyArgs>(
      args?: SelectSubset<T, ClassTermCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many ClassTerms and returns the data saved in the database.
     * @param {ClassTermCreateManyAndReturnArgs} args - Arguments to create many ClassTerms.
     * @example
     * // Create many ClassTerms
     * const classTerm = await prisma.classTerm.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many ClassTerms and only return the `id`
     * const classTermWithIdOnly = await prisma.classTerm.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends ClassTermCreateManyAndReturnArgs>(
      args?: SelectSubset<T, ClassTermCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ClassTermPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a ClassTerm.
     * @param {ClassTermDeleteArgs} args - Arguments to delete one ClassTerm.
     * @example
     * // Delete one ClassTerm
     * const ClassTerm = await prisma.classTerm.delete({
     *   where: {
     *     // ... filter to delete one ClassTerm
     *   }
     * })
     *
     */
    delete<T extends ClassTermDeleteArgs>(
      args: SelectSubset<T, ClassTermDeleteArgs<ExtArgs>>,
    ): Prisma__ClassTermClient<
      $Result.GetResult<
        Prisma.$ClassTermPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one ClassTerm.
     * @param {ClassTermUpdateArgs} args - Arguments to update one ClassTerm.
     * @example
     * // Update one ClassTerm
     * const classTerm = await prisma.classTerm.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ClassTermUpdateArgs>(
      args: SelectSubset<T, ClassTermUpdateArgs<ExtArgs>>,
    ): Prisma__ClassTermClient<
      $Result.GetResult<
        Prisma.$ClassTermPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more ClassTerms.
     * @param {ClassTermDeleteManyArgs} args - Arguments to filter ClassTerms to delete.
     * @example
     * // Delete a few ClassTerms
     * const { count } = await prisma.classTerm.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ClassTermDeleteManyArgs>(
      args?: SelectSubset<T, ClassTermDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more ClassTerms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassTermUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClassTerms
     * const classTerm = await prisma.classTerm.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ClassTermUpdateManyArgs>(
      args: SelectSubset<T, ClassTermUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more ClassTerms and returns the data updated in the database.
     * @param {ClassTermUpdateManyAndReturnArgs} args - Arguments to update many ClassTerms.
     * @example
     * // Update many ClassTerms
     * const classTerm = await prisma.classTerm.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more ClassTerms and only return the `id`
     * const classTermWithIdOnly = await prisma.classTerm.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends ClassTermUpdateManyAndReturnArgs>(
      args: SelectSubset<T, ClassTermUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ClassTermPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one ClassTerm.
     * @param {ClassTermUpsertArgs} args - Arguments to update or create a ClassTerm.
     * @example
     * // Update or create a ClassTerm
     * const classTerm = await prisma.classTerm.upsert({
     *   create: {
     *     // ... data to create a ClassTerm
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClassTerm we want to update
     *   }
     * })
     */
    upsert<T extends ClassTermUpsertArgs>(
      args: SelectSubset<T, ClassTermUpsertArgs<ExtArgs>>,
    ): Prisma__ClassTermClient<
      $Result.GetResult<
        Prisma.$ClassTermPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of ClassTerms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassTermCountArgs} args - Arguments to filter ClassTerms to count.
     * @example
     * // Count the number of ClassTerms
     * const count = await prisma.classTerm.count({
     *   where: {
     *     // ... the filter for the ClassTerms we want to count
     *   }
     * })
     **/
    count<T extends ClassTermCountArgs>(
      args?: Subset<T, ClassTermCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], ClassTermCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a ClassTerm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassTermAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ClassTermAggregateArgs>(
      args: Subset<T, ClassTermAggregateArgs>,
    ): Prisma.PrismaPromise<GetClassTermAggregateType<T>>;

    /**
     * Group by ClassTerm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassTermGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends ClassTermGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClassTermGroupByArgs["orderBy"] }
        : { orderBy?: ClassTermGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, ClassTermGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetClassTermGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the ClassTerm model
     */
    readonly fields: ClassTermFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClassTerm.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClassTermClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    classStream<T extends ClassTerm$classStreamArgs<ExtArgs> = {}>(
      args?: Subset<T, ClassTerm$classStreamArgs<ExtArgs>>,
    ): Prisma__classStreamClient<
      $Result.GetResult<
        Prisma.$classStreamPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    term<T extends ClassTerm$termArgs<ExtArgs> = {}>(
      args?: Subset<T, ClassTerm$termArgs<ExtArgs>>,
    ): Prisma__TermClient<
      $Result.GetResult<
        Prisma.$TermPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    exams<T extends ClassTerm$examsArgs<ExtArgs> = {}>(
      args?: Subset<T, ClassTerm$examsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$ExamPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    fees<T extends ClassTerm$feesArgs<ExtArgs> = {}>(
      args?: Subset<T, ClassTerm$feesArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$FeesPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the ClassTerm model
   */
  interface ClassTermFieldRefs {
    readonly id: FieldRef<"ClassTerm", "String">;
    readonly startAt: FieldRef<"ClassTerm", "DateTime">;
    readonly endAt: FieldRef<"ClassTerm", "DateTime">;
    readonly termId: FieldRef<"ClassTerm", "String">;
    readonly classStreamId: FieldRef<"ClassTerm", "String">;
    readonly feesAmount: FieldRef<"ClassTerm", "Int">;
  }

  // Custom InputTypes
  /**
   * ClassTerm findUnique
   */
  export type ClassTermFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ClassTerm
     */
    select?: ClassTermSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ClassTerm
     */
    omit?: ClassTermOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassTermInclude<ExtArgs> | null;
    /**
     * Filter, which ClassTerm to fetch.
     */
    where: ClassTermWhereUniqueInput;
  };

  /**
   * ClassTerm findUniqueOrThrow
   */
  export type ClassTermFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ClassTerm
     */
    select?: ClassTermSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ClassTerm
     */
    omit?: ClassTermOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassTermInclude<ExtArgs> | null;
    /**
     * Filter, which ClassTerm to fetch.
     */
    where: ClassTermWhereUniqueInput;
  };

  /**
   * ClassTerm findFirst
   */
  export type ClassTermFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ClassTerm
     */
    select?: ClassTermSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ClassTerm
     */
    omit?: ClassTermOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassTermInclude<ExtArgs> | null;
    /**
     * Filter, which ClassTerm to fetch.
     */
    where?: ClassTermWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ClassTerms to fetch.
     */
    orderBy?:
      | ClassTermOrderByWithRelationInput
      | ClassTermOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ClassTerms.
     */
    cursor?: ClassTermWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ClassTerms from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ClassTerms.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ClassTerms.
     */
    distinct?: ClassTermScalarFieldEnum | ClassTermScalarFieldEnum[];
  };

  /**
   * ClassTerm findFirstOrThrow
   */
  export type ClassTermFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ClassTerm
     */
    select?: ClassTermSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ClassTerm
     */
    omit?: ClassTermOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassTermInclude<ExtArgs> | null;
    /**
     * Filter, which ClassTerm to fetch.
     */
    where?: ClassTermWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ClassTerms to fetch.
     */
    orderBy?:
      | ClassTermOrderByWithRelationInput
      | ClassTermOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ClassTerms.
     */
    cursor?: ClassTermWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ClassTerms from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ClassTerms.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ClassTerms.
     */
    distinct?: ClassTermScalarFieldEnum | ClassTermScalarFieldEnum[];
  };

  /**
   * ClassTerm findMany
   */
  export type ClassTermFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ClassTerm
     */
    select?: ClassTermSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ClassTerm
     */
    omit?: ClassTermOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassTermInclude<ExtArgs> | null;
    /**
     * Filter, which ClassTerms to fetch.
     */
    where?: ClassTermWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ClassTerms to fetch.
     */
    orderBy?:
      | ClassTermOrderByWithRelationInput
      | ClassTermOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing ClassTerms.
     */
    cursor?: ClassTermWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ClassTerms from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ClassTerms.
     */
    skip?: number;
    distinct?: ClassTermScalarFieldEnum | ClassTermScalarFieldEnum[];
  };

  /**
   * ClassTerm create
   */
  export type ClassTermCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ClassTerm
     */
    select?: ClassTermSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ClassTerm
     */
    omit?: ClassTermOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassTermInclude<ExtArgs> | null;
    /**
     * The data needed to create a ClassTerm.
     */
    data: XOR<ClassTermCreateInput, ClassTermUncheckedCreateInput>;
  };

  /**
   * ClassTerm createMany
   */
  export type ClassTermCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many ClassTerms.
     */
    data: ClassTermCreateManyInput | ClassTermCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * ClassTerm createManyAndReturn
   */
  export type ClassTermCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ClassTerm
     */
    select?: ClassTermSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the ClassTerm
     */
    omit?: ClassTermOmit<ExtArgs> | null;
    /**
     * The data used to create many ClassTerms.
     */
    data: ClassTermCreateManyInput | ClassTermCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassTermIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * ClassTerm update
   */
  export type ClassTermUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ClassTerm
     */
    select?: ClassTermSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ClassTerm
     */
    omit?: ClassTermOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassTermInclude<ExtArgs> | null;
    /**
     * The data needed to update a ClassTerm.
     */
    data: XOR<ClassTermUpdateInput, ClassTermUncheckedUpdateInput>;
    /**
     * Choose, which ClassTerm to update.
     */
    where: ClassTermWhereUniqueInput;
  };

  /**
   * ClassTerm updateMany
   */
  export type ClassTermUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update ClassTerms.
     */
    data: XOR<
      ClassTermUpdateManyMutationInput,
      ClassTermUncheckedUpdateManyInput
    >;
    /**
     * Filter which ClassTerms to update
     */
    where?: ClassTermWhereInput;
    /**
     * Limit how many ClassTerms to update.
     */
    limit?: number;
  };

  /**
   * ClassTerm updateManyAndReturn
   */
  export type ClassTermUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ClassTerm
     */
    select?: ClassTermSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the ClassTerm
     */
    omit?: ClassTermOmit<ExtArgs> | null;
    /**
     * The data used to update ClassTerms.
     */
    data: XOR<
      ClassTermUpdateManyMutationInput,
      ClassTermUncheckedUpdateManyInput
    >;
    /**
     * Filter which ClassTerms to update
     */
    where?: ClassTermWhereInput;
    /**
     * Limit how many ClassTerms to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassTermIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * ClassTerm upsert
   */
  export type ClassTermUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ClassTerm
     */
    select?: ClassTermSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ClassTerm
     */
    omit?: ClassTermOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassTermInclude<ExtArgs> | null;
    /**
     * The filter to search for the ClassTerm to update in case it exists.
     */
    where: ClassTermWhereUniqueInput;
    /**
     * In case the ClassTerm found by the `where` argument doesn't exist, create a new ClassTerm with this data.
     */
    create: XOR<ClassTermCreateInput, ClassTermUncheckedCreateInput>;
    /**
     * In case the ClassTerm was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClassTermUpdateInput, ClassTermUncheckedUpdateInput>;
  };

  /**
   * ClassTerm delete
   */
  export type ClassTermDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ClassTerm
     */
    select?: ClassTermSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ClassTerm
     */
    omit?: ClassTermOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassTermInclude<ExtArgs> | null;
    /**
     * Filter which ClassTerm to delete.
     */
    where: ClassTermWhereUniqueInput;
  };

  /**
   * ClassTerm deleteMany
   */
  export type ClassTermDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which ClassTerms to delete
     */
    where?: ClassTermWhereInput;
    /**
     * Limit how many ClassTerms to delete.
     */
    limit?: number;
  };

  /**
   * ClassTerm.classStream
   */
  export type ClassTerm$classStreamArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the classStream
     */
    select?: classStreamSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the classStream
     */
    omit?: classStreamOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: classStreamInclude<ExtArgs> | null;
    where?: classStreamWhereInput;
  };

  /**
   * ClassTerm.term
   */
  export type ClassTerm$termArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Term
     */
    select?: TermSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Term
     */
    omit?: TermOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermInclude<ExtArgs> | null;
    where?: TermWhereInput;
  };

  /**
   * ClassTerm.exams
   */
  export type ClassTerm$examsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null;
    where?: ExamWhereInput;
    orderBy?: ExamOrderByWithRelationInput | ExamOrderByWithRelationInput[];
    cursor?: ExamWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ExamScalarFieldEnum | ExamScalarFieldEnum[];
  };

  /**
   * ClassTerm.fees
   */
  export type ClassTerm$feesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Fees
     */
    select?: FeesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Fees
     */
    omit?: FeesOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeesInclude<ExtArgs> | null;
    where?: FeesWhereInput;
    orderBy?: FeesOrderByWithRelationInput | FeesOrderByWithRelationInput[];
    cursor?: FeesWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: FeesScalarFieldEnum | FeesScalarFieldEnum[];
  };

  /**
   * ClassTerm without action
   */
  export type ClassTermDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ClassTerm
     */
    select?: ClassTermSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ClassTerm
     */
    omit?: ClassTermOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassTermInclude<ExtArgs> | null;
  };

  /**
   * Model Fees
   */

  export type AggregateFees = {
    _count: FeesCountAggregateOutputType | null;
    _avg: FeesAvgAggregateOutputType | null;
    _sum: FeesSumAggregateOutputType | null;
    _min: FeesMinAggregateOutputType | null;
    _max: FeesMaxAggregateOutputType | null;
  };

  export type FeesAvgAggregateOutputType = {
    balance: number | null;
  };

  export type FeesSumAggregateOutputType = {
    balance: number | null;
  };

  export type FeesMinAggregateOutputType = {
    id: string | null;
    pupilId: string | null;
    balance: number | null;
    termId: string | null;
    status: $Enums.FeesStatus | null;
  };

  export type FeesMaxAggregateOutputType = {
    id: string | null;
    pupilId: string | null;
    balance: number | null;
    termId: string | null;
    status: $Enums.FeesStatus | null;
  };

  export type FeesCountAggregateOutputType = {
    id: number;
    pupilId: number;
    balance: number;
    termId: number;
    status: number;
    _all: number;
  };

  export type FeesAvgAggregateInputType = {
    balance?: true;
  };

  export type FeesSumAggregateInputType = {
    balance?: true;
  };

  export type FeesMinAggregateInputType = {
    id?: true;
    pupilId?: true;
    balance?: true;
    termId?: true;
    status?: true;
  };

  export type FeesMaxAggregateInputType = {
    id?: true;
    pupilId?: true;
    balance?: true;
    termId?: true;
    status?: true;
  };

  export type FeesCountAggregateInputType = {
    id?: true;
    pupilId?: true;
    balance?: true;
    termId?: true;
    status?: true;
    _all?: true;
  };

  export type FeesAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Fees to aggregate.
     */
    where?: FeesWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Fees to fetch.
     */
    orderBy?: FeesOrderByWithRelationInput | FeesOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: FeesWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Fees from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Fees.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Fees
     **/
    _count?: true | FeesCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: FeesAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: FeesSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: FeesMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: FeesMaxAggregateInputType;
  };

  export type GetFeesAggregateType<T extends FeesAggregateArgs> = {
    [P in keyof T & keyof AggregateFees]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFees[P]>
      : GetScalarType<T[P], AggregateFees[P]>;
  };

  export type FeesGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: FeesWhereInput;
    orderBy?:
      | FeesOrderByWithAggregationInput
      | FeesOrderByWithAggregationInput[];
    by: FeesScalarFieldEnum[] | FeesScalarFieldEnum;
    having?: FeesScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: FeesCountAggregateInputType | true;
    _avg?: FeesAvgAggregateInputType;
    _sum?: FeesSumAggregateInputType;
    _min?: FeesMinAggregateInputType;
    _max?: FeesMaxAggregateInputType;
  };

  export type FeesGroupByOutputType = {
    id: string;
    pupilId: string;
    balance: number;
    termId: string;
    status: $Enums.FeesStatus;
    _count: FeesCountAggregateOutputType | null;
    _avg: FeesAvgAggregateOutputType | null;
    _sum: FeesSumAggregateOutputType | null;
    _min: FeesMinAggregateOutputType | null;
    _max: FeesMaxAggregateOutputType | null;
  };

  type GetFeesGroupByPayload<T extends FeesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeesGroupByOutputType, T["by"]> & {
        [P in keyof T & keyof FeesGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], FeesGroupByOutputType[P]>
          : GetScalarType<T[P], FeesGroupByOutputType[P]>;
      }
    >
  >;

  export type FeesSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      pupilId?: boolean;
      balance?: boolean;
      termId?: boolean;
      status?: boolean;
      pupil?: boolean | PupilDefaultArgs<ExtArgs>;
      term?: boolean | ClassTermDefaultArgs<ExtArgs>;
      feesPayments?: boolean | Fees$feesPaymentsArgs<ExtArgs>;
      _count?: boolean | FeesCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["fees"]
  >;

  export type FeesSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      pupilId?: boolean;
      balance?: boolean;
      termId?: boolean;
      status?: boolean;
      pupil?: boolean | PupilDefaultArgs<ExtArgs>;
      term?: boolean | ClassTermDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["fees"]
  >;

  export type FeesSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      pupilId?: boolean;
      balance?: boolean;
      termId?: boolean;
      status?: boolean;
      pupil?: boolean | PupilDefaultArgs<ExtArgs>;
      term?: boolean | ClassTermDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["fees"]
  >;

  export type FeesSelectScalar = {
    id?: boolean;
    pupilId?: boolean;
    balance?: boolean;
    termId?: boolean;
    status?: boolean;
  };

  export type FeesOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    "id" | "pupilId" | "balance" | "termId" | "status",
    ExtArgs["result"]["fees"]
  >;
  export type FeesInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    pupil?: boolean | PupilDefaultArgs<ExtArgs>;
    term?: boolean | ClassTermDefaultArgs<ExtArgs>;
    feesPayments?: boolean | Fees$feesPaymentsArgs<ExtArgs>;
    _count?: boolean | FeesCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type FeesIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    pupil?: boolean | PupilDefaultArgs<ExtArgs>;
    term?: boolean | ClassTermDefaultArgs<ExtArgs>;
  };
  export type FeesIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    pupil?: boolean | PupilDefaultArgs<ExtArgs>;
    term?: boolean | ClassTermDefaultArgs<ExtArgs>;
  };

  export type $FeesPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "Fees";
    objects: {
      pupil: Prisma.$PupilPayload<ExtArgs>;
      term: Prisma.$ClassTermPayload<ExtArgs>;
      feesPayments: Prisma.$FeesPaymentPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        pupilId: string;
        balance: number;
        termId: string;
        status: $Enums.FeesStatus;
      },
      ExtArgs["result"]["fees"]
    >;
    composites: {};
  };

  type FeesGetPayload<S extends boolean | null | undefined | FeesDefaultArgs> =
    $Result.GetResult<Prisma.$FeesPayload, S>;

  type FeesCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<FeesFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
    select?: FeesCountAggregateInputType | true;
  };

  export interface FeesDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["Fees"];
      meta: { name: "Fees" };
    };
    /**
     * Find zero or one Fees that matches the filter.
     * @param {FeesFindUniqueArgs} args - Arguments to find a Fees
     * @example
     * // Get one Fees
     * const fees = await prisma.fees.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FeesFindUniqueArgs>(
      args: SelectSubset<T, FeesFindUniqueArgs<ExtArgs>>,
    ): Prisma__FeesClient<
      $Result.GetResult<
        Prisma.$FeesPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Fees that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FeesFindUniqueOrThrowArgs} args - Arguments to find a Fees
     * @example
     * // Get one Fees
     * const fees = await prisma.fees.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FeesFindUniqueOrThrowArgs>(
      args: SelectSubset<T, FeesFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__FeesClient<
      $Result.GetResult<
        Prisma.$FeesPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Fees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeesFindFirstArgs} args - Arguments to find a Fees
     * @example
     * // Get one Fees
     * const fees = await prisma.fees.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FeesFindFirstArgs>(
      args?: SelectSubset<T, FeesFindFirstArgs<ExtArgs>>,
    ): Prisma__FeesClient<
      $Result.GetResult<
        Prisma.$FeesPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Fees that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeesFindFirstOrThrowArgs} args - Arguments to find a Fees
     * @example
     * // Get one Fees
     * const fees = await prisma.fees.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FeesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, FeesFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__FeesClient<
      $Result.GetResult<
        Prisma.$FeesPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Fees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Fees
     * const fees = await prisma.fees.findMany()
     *
     * // Get first 10 Fees
     * const fees = await prisma.fees.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const feesWithIdOnly = await prisma.fees.findMany({ select: { id: true } })
     *
     */
    findMany<T extends FeesFindManyArgs>(
      args?: SelectSubset<T, FeesFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$FeesPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Fees.
     * @param {FeesCreateArgs} args - Arguments to create a Fees.
     * @example
     * // Create one Fees
     * const Fees = await prisma.fees.create({
     *   data: {
     *     // ... data to create a Fees
     *   }
     * })
     *
     */
    create<T extends FeesCreateArgs>(
      args: SelectSubset<T, FeesCreateArgs<ExtArgs>>,
    ): Prisma__FeesClient<
      $Result.GetResult<
        Prisma.$FeesPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Fees.
     * @param {FeesCreateManyArgs} args - Arguments to create many Fees.
     * @example
     * // Create many Fees
     * const fees = await prisma.fees.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends FeesCreateManyArgs>(
      args?: SelectSubset<T, FeesCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Fees and returns the data saved in the database.
     * @param {FeesCreateManyAndReturnArgs} args - Arguments to create many Fees.
     * @example
     * // Create many Fees
     * const fees = await prisma.fees.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Fees and only return the `id`
     * const feesWithIdOnly = await prisma.fees.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends FeesCreateManyAndReturnArgs>(
      args?: SelectSubset<T, FeesCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$FeesPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Fees.
     * @param {FeesDeleteArgs} args - Arguments to delete one Fees.
     * @example
     * // Delete one Fees
     * const Fees = await prisma.fees.delete({
     *   where: {
     *     // ... filter to delete one Fees
     *   }
     * })
     *
     */
    delete<T extends FeesDeleteArgs>(
      args: SelectSubset<T, FeesDeleteArgs<ExtArgs>>,
    ): Prisma__FeesClient<
      $Result.GetResult<
        Prisma.$FeesPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Fees.
     * @param {FeesUpdateArgs} args - Arguments to update one Fees.
     * @example
     * // Update one Fees
     * const fees = await prisma.fees.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends FeesUpdateArgs>(
      args: SelectSubset<T, FeesUpdateArgs<ExtArgs>>,
    ): Prisma__FeesClient<
      $Result.GetResult<
        Prisma.$FeesPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Fees.
     * @param {FeesDeleteManyArgs} args - Arguments to filter Fees to delete.
     * @example
     * // Delete a few Fees
     * const { count } = await prisma.fees.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends FeesDeleteManyArgs>(
      args?: SelectSubset<T, FeesDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Fees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Fees
     * const fees = await prisma.fees.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends FeesUpdateManyArgs>(
      args: SelectSubset<T, FeesUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Fees and returns the data updated in the database.
     * @param {FeesUpdateManyAndReturnArgs} args - Arguments to update many Fees.
     * @example
     * // Update many Fees
     * const fees = await prisma.fees.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Fees and only return the `id`
     * const feesWithIdOnly = await prisma.fees.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends FeesUpdateManyAndReturnArgs>(
      args: SelectSubset<T, FeesUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$FeesPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Fees.
     * @param {FeesUpsertArgs} args - Arguments to update or create a Fees.
     * @example
     * // Update or create a Fees
     * const fees = await prisma.fees.upsert({
     *   create: {
     *     // ... data to create a Fees
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Fees we want to update
     *   }
     * })
     */
    upsert<T extends FeesUpsertArgs>(
      args: SelectSubset<T, FeesUpsertArgs<ExtArgs>>,
    ): Prisma__FeesClient<
      $Result.GetResult<
        Prisma.$FeesPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Fees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeesCountArgs} args - Arguments to filter Fees to count.
     * @example
     * // Count the number of Fees
     * const count = await prisma.fees.count({
     *   where: {
     *     // ... the filter for the Fees we want to count
     *   }
     * })
     **/
    count<T extends FeesCountArgs>(
      args?: Subset<T, FeesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], FeesCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Fees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends FeesAggregateArgs>(
      args: Subset<T, FeesAggregateArgs>,
    ): Prisma.PrismaPromise<GetFeesAggregateType<T>>;

    /**
     * Group by Fees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends FeesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeesGroupByArgs["orderBy"] }
        : { orderBy?: FeesGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, FeesGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetFeesGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Fees model
     */
    readonly fields: FeesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Fees.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeesClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    pupil<T extends PupilDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, PupilDefaultArgs<ExtArgs>>,
    ): Prisma__PupilClient<
      | $Result.GetResult<
          Prisma.$PupilPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    term<T extends ClassTermDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, ClassTermDefaultArgs<ExtArgs>>,
    ): Prisma__ClassTermClient<
      | $Result.GetResult<
          Prisma.$ClassTermPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    feesPayments<T extends Fees$feesPaymentsArgs<ExtArgs> = {}>(
      args?: Subset<T, Fees$feesPaymentsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$FeesPaymentPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Fees model
   */
  interface FeesFieldRefs {
    readonly id: FieldRef<"Fees", "String">;
    readonly pupilId: FieldRef<"Fees", "String">;
    readonly balance: FieldRef<"Fees", "Int">;
    readonly termId: FieldRef<"Fees", "String">;
    readonly status: FieldRef<"Fees", "FeesStatus">;
  }

  // Custom InputTypes
  /**
   * Fees findUnique
   */
  export type FeesFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Fees
     */
    select?: FeesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Fees
     */
    omit?: FeesOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeesInclude<ExtArgs> | null;
    /**
     * Filter, which Fees to fetch.
     */
    where: FeesWhereUniqueInput;
  };

  /**
   * Fees findUniqueOrThrow
   */
  export type FeesFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Fees
     */
    select?: FeesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Fees
     */
    omit?: FeesOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeesInclude<ExtArgs> | null;
    /**
     * Filter, which Fees to fetch.
     */
    where: FeesWhereUniqueInput;
  };

  /**
   * Fees findFirst
   */
  export type FeesFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Fees
     */
    select?: FeesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Fees
     */
    omit?: FeesOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeesInclude<ExtArgs> | null;
    /**
     * Filter, which Fees to fetch.
     */
    where?: FeesWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Fees to fetch.
     */
    orderBy?: FeesOrderByWithRelationInput | FeesOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Fees.
     */
    cursor?: FeesWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Fees from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Fees.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Fees.
     */
    distinct?: FeesScalarFieldEnum | FeesScalarFieldEnum[];
  };

  /**
   * Fees findFirstOrThrow
   */
  export type FeesFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Fees
     */
    select?: FeesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Fees
     */
    omit?: FeesOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeesInclude<ExtArgs> | null;
    /**
     * Filter, which Fees to fetch.
     */
    where?: FeesWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Fees to fetch.
     */
    orderBy?: FeesOrderByWithRelationInput | FeesOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Fees.
     */
    cursor?: FeesWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Fees from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Fees.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Fees.
     */
    distinct?: FeesScalarFieldEnum | FeesScalarFieldEnum[];
  };

  /**
   * Fees findMany
   */
  export type FeesFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Fees
     */
    select?: FeesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Fees
     */
    omit?: FeesOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeesInclude<ExtArgs> | null;
    /**
     * Filter, which Fees to fetch.
     */
    where?: FeesWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Fees to fetch.
     */
    orderBy?: FeesOrderByWithRelationInput | FeesOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Fees.
     */
    cursor?: FeesWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Fees from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Fees.
     */
    skip?: number;
    distinct?: FeesScalarFieldEnum | FeesScalarFieldEnum[];
  };

  /**
   * Fees create
   */
  export type FeesCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Fees
     */
    select?: FeesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Fees
     */
    omit?: FeesOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeesInclude<ExtArgs> | null;
    /**
     * The data needed to create a Fees.
     */
    data: XOR<FeesCreateInput, FeesUncheckedCreateInput>;
  };

  /**
   * Fees createMany
   */
  export type FeesCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Fees.
     */
    data: FeesCreateManyInput | FeesCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Fees createManyAndReturn
   */
  export type FeesCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Fees
     */
    select?: FeesSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Fees
     */
    omit?: FeesOmit<ExtArgs> | null;
    /**
     * The data used to create many Fees.
     */
    data: FeesCreateManyInput | FeesCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeesIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Fees update
   */
  export type FeesUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Fees
     */
    select?: FeesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Fees
     */
    omit?: FeesOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeesInclude<ExtArgs> | null;
    /**
     * The data needed to update a Fees.
     */
    data: XOR<FeesUpdateInput, FeesUncheckedUpdateInput>;
    /**
     * Choose, which Fees to update.
     */
    where: FeesWhereUniqueInput;
  };

  /**
   * Fees updateMany
   */
  export type FeesUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Fees.
     */
    data: XOR<FeesUpdateManyMutationInput, FeesUncheckedUpdateManyInput>;
    /**
     * Filter which Fees to update
     */
    where?: FeesWhereInput;
    /**
     * Limit how many Fees to update.
     */
    limit?: number;
  };

  /**
   * Fees updateManyAndReturn
   */
  export type FeesUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Fees
     */
    select?: FeesSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Fees
     */
    omit?: FeesOmit<ExtArgs> | null;
    /**
     * The data used to update Fees.
     */
    data: XOR<FeesUpdateManyMutationInput, FeesUncheckedUpdateManyInput>;
    /**
     * Filter which Fees to update
     */
    where?: FeesWhereInput;
    /**
     * Limit how many Fees to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeesIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Fees upsert
   */
  export type FeesUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Fees
     */
    select?: FeesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Fees
     */
    omit?: FeesOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeesInclude<ExtArgs> | null;
    /**
     * The filter to search for the Fees to update in case it exists.
     */
    where: FeesWhereUniqueInput;
    /**
     * In case the Fees found by the `where` argument doesn't exist, create a new Fees with this data.
     */
    create: XOR<FeesCreateInput, FeesUncheckedCreateInput>;
    /**
     * In case the Fees was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeesUpdateInput, FeesUncheckedUpdateInput>;
  };

  /**
   * Fees delete
   */
  export type FeesDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Fees
     */
    select?: FeesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Fees
     */
    omit?: FeesOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeesInclude<ExtArgs> | null;
    /**
     * Filter which Fees to delete.
     */
    where: FeesWhereUniqueInput;
  };

  /**
   * Fees deleteMany
   */
  export type FeesDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Fees to delete
     */
    where?: FeesWhereInput;
    /**
     * Limit how many Fees to delete.
     */
    limit?: number;
  };

  /**
   * Fees.feesPayments
   */
  export type Fees$feesPaymentsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FeesPayment
     */
    select?: FeesPaymentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FeesPayment
     */
    omit?: FeesPaymentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeesPaymentInclude<ExtArgs> | null;
    where?: FeesPaymentWhereInput;
    orderBy?:
      | FeesPaymentOrderByWithRelationInput
      | FeesPaymentOrderByWithRelationInput[];
    cursor?: FeesPaymentWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: FeesPaymentScalarFieldEnum | FeesPaymentScalarFieldEnum[];
  };

  /**
   * Fees without action
   */
  export type FeesDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Fees
     */
    select?: FeesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Fees
     */
    omit?: FeesOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeesInclude<ExtArgs> | null;
  };

  /**
   * Model FeesPayment
   */

  export type AggregateFeesPayment = {
    _count: FeesPaymentCountAggregateOutputType | null;
    _avg: FeesPaymentAvgAggregateOutputType | null;
    _sum: FeesPaymentSumAggregateOutputType | null;
    _min: FeesPaymentMinAggregateOutputType | null;
    _max: FeesPaymentMaxAggregateOutputType | null;
  };

  export type FeesPaymentAvgAggregateOutputType = {
    amountPaid: number | null;
  };

  export type FeesPaymentSumAggregateOutputType = {
    amountPaid: number | null;
  };

  export type FeesPaymentMinAggregateOutputType = {
    id: string | null;
    amountPaid: number | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    feesId: string | null;
    userId: string | null;
  };

  export type FeesPaymentMaxAggregateOutputType = {
    id: string | null;
    amountPaid: number | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    feesId: string | null;
    userId: string | null;
  };

  export type FeesPaymentCountAggregateOutputType = {
    id: number;
    amountPaid: number;
    createdAt: number;
    updatedAt: number;
    feesId: number;
    userId: number;
    _all: number;
  };

  export type FeesPaymentAvgAggregateInputType = {
    amountPaid?: true;
  };

  export type FeesPaymentSumAggregateInputType = {
    amountPaid?: true;
  };

  export type FeesPaymentMinAggregateInputType = {
    id?: true;
    amountPaid?: true;
    createdAt?: true;
    updatedAt?: true;
    feesId?: true;
    userId?: true;
  };

  export type FeesPaymentMaxAggregateInputType = {
    id?: true;
    amountPaid?: true;
    createdAt?: true;
    updatedAt?: true;
    feesId?: true;
    userId?: true;
  };

  export type FeesPaymentCountAggregateInputType = {
    id?: true;
    amountPaid?: true;
    createdAt?: true;
    updatedAt?: true;
    feesId?: true;
    userId?: true;
    _all?: true;
  };

  export type FeesPaymentAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which FeesPayment to aggregate.
     */
    where?: FeesPaymentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FeesPayments to fetch.
     */
    orderBy?:
      | FeesPaymentOrderByWithRelationInput
      | FeesPaymentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: FeesPaymentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FeesPayments from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FeesPayments.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned FeesPayments
     **/
    _count?: true | FeesPaymentCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: FeesPaymentAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: FeesPaymentSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: FeesPaymentMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: FeesPaymentMaxAggregateInputType;
  };

  export type GetFeesPaymentAggregateType<T extends FeesPaymentAggregateArgs> =
    {
      [P in keyof T & keyof AggregateFeesPayment]: P extends "_count" | "count"
        ? T[P] extends true
          ? number
          : GetScalarType<T[P], AggregateFeesPayment[P]>
        : GetScalarType<T[P], AggregateFeesPayment[P]>;
    };

  export type FeesPaymentGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: FeesPaymentWhereInput;
    orderBy?:
      | FeesPaymentOrderByWithAggregationInput
      | FeesPaymentOrderByWithAggregationInput[];
    by: FeesPaymentScalarFieldEnum[] | FeesPaymentScalarFieldEnum;
    having?: FeesPaymentScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: FeesPaymentCountAggregateInputType | true;
    _avg?: FeesPaymentAvgAggregateInputType;
    _sum?: FeesPaymentSumAggregateInputType;
    _min?: FeesPaymentMinAggregateInputType;
    _max?: FeesPaymentMaxAggregateInputType;
  };

  export type FeesPaymentGroupByOutputType = {
    id: string;
    amountPaid: number;
    createdAt: Date;
    updatedAt: Date;
    feesId: string | null;
    userId: string;
    _count: FeesPaymentCountAggregateOutputType | null;
    _avg: FeesPaymentAvgAggregateOutputType | null;
    _sum: FeesPaymentSumAggregateOutputType | null;
    _min: FeesPaymentMinAggregateOutputType | null;
    _max: FeesPaymentMaxAggregateOutputType | null;
  };

  type GetFeesPaymentGroupByPayload<T extends FeesPaymentGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<FeesPaymentGroupByOutputType, T["by"]> & {
          [P in keyof T &
            keyof FeesPaymentGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeesPaymentGroupByOutputType[P]>
            : GetScalarType<T[P], FeesPaymentGroupByOutputType[P]>;
        }
      >
    >;

  export type FeesPaymentSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      amountPaid?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      feesId?: boolean;
      userId?: boolean;
      fees?: boolean | FeesPayment$feesArgs<ExtArgs>;
      paidBy?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["feesPayment"]
  >;

  export type FeesPaymentSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      amountPaid?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      feesId?: boolean;
      userId?: boolean;
      fees?: boolean | FeesPayment$feesArgs<ExtArgs>;
      paidBy?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["feesPayment"]
  >;

  export type FeesPaymentSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      amountPaid?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      feesId?: boolean;
      userId?: boolean;
      fees?: boolean | FeesPayment$feesArgs<ExtArgs>;
      paidBy?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["feesPayment"]
  >;

  export type FeesPaymentSelectScalar = {
    id?: boolean;
    amountPaid?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    feesId?: boolean;
    userId?: boolean;
  };

  export type FeesPaymentOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    "id" | "amountPaid" | "createdAt" | "updatedAt" | "feesId" | "userId",
    ExtArgs["result"]["feesPayment"]
  >;
  export type FeesPaymentInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    fees?: boolean | FeesPayment$feesArgs<ExtArgs>;
    paidBy?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type FeesPaymentIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    fees?: boolean | FeesPayment$feesArgs<ExtArgs>;
    paidBy?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type FeesPaymentIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    fees?: boolean | FeesPayment$feesArgs<ExtArgs>;
    paidBy?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $FeesPaymentPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "FeesPayment";
    objects: {
      fees: Prisma.$FeesPayload<ExtArgs> | null;
      paidBy: Prisma.$UserPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        amountPaid: number;
        createdAt: Date;
        updatedAt: Date;
        feesId: string | null;
        userId: string;
      },
      ExtArgs["result"]["feesPayment"]
    >;
    composites: {};
  };

  type FeesPaymentGetPayload<
    S extends boolean | null | undefined | FeesPaymentDefaultArgs,
  > = $Result.GetResult<Prisma.$FeesPaymentPayload, S>;

  type FeesPaymentCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    FeesPaymentFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: FeesPaymentCountAggregateInputType | true;
  };

  export interface FeesPaymentDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["FeesPayment"];
      meta: { name: "FeesPayment" };
    };
    /**
     * Find zero or one FeesPayment that matches the filter.
     * @param {FeesPaymentFindUniqueArgs} args - Arguments to find a FeesPayment
     * @example
     * // Get one FeesPayment
     * const feesPayment = await prisma.feesPayment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FeesPaymentFindUniqueArgs>(
      args: SelectSubset<T, FeesPaymentFindUniqueArgs<ExtArgs>>,
    ): Prisma__FeesPaymentClient<
      $Result.GetResult<
        Prisma.$FeesPaymentPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one FeesPayment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FeesPaymentFindUniqueOrThrowArgs} args - Arguments to find a FeesPayment
     * @example
     * // Get one FeesPayment
     * const feesPayment = await prisma.feesPayment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FeesPaymentFindUniqueOrThrowArgs>(
      args: SelectSubset<T, FeesPaymentFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__FeesPaymentClient<
      $Result.GetResult<
        Prisma.$FeesPaymentPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first FeesPayment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeesPaymentFindFirstArgs} args - Arguments to find a FeesPayment
     * @example
     * // Get one FeesPayment
     * const feesPayment = await prisma.feesPayment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FeesPaymentFindFirstArgs>(
      args?: SelectSubset<T, FeesPaymentFindFirstArgs<ExtArgs>>,
    ): Prisma__FeesPaymentClient<
      $Result.GetResult<
        Prisma.$FeesPaymentPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first FeesPayment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeesPaymentFindFirstOrThrowArgs} args - Arguments to find a FeesPayment
     * @example
     * // Get one FeesPayment
     * const feesPayment = await prisma.feesPayment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FeesPaymentFindFirstOrThrowArgs>(
      args?: SelectSubset<T, FeesPaymentFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__FeesPaymentClient<
      $Result.GetResult<
        Prisma.$FeesPaymentPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more FeesPayments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeesPaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FeesPayments
     * const feesPayments = await prisma.feesPayment.findMany()
     *
     * // Get first 10 FeesPayments
     * const feesPayments = await prisma.feesPayment.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const feesPaymentWithIdOnly = await prisma.feesPayment.findMany({ select: { id: true } })
     *
     */
    findMany<T extends FeesPaymentFindManyArgs>(
      args?: SelectSubset<T, FeesPaymentFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$FeesPaymentPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a FeesPayment.
     * @param {FeesPaymentCreateArgs} args - Arguments to create a FeesPayment.
     * @example
     * // Create one FeesPayment
     * const FeesPayment = await prisma.feesPayment.create({
     *   data: {
     *     // ... data to create a FeesPayment
     *   }
     * })
     *
     */
    create<T extends FeesPaymentCreateArgs>(
      args: SelectSubset<T, FeesPaymentCreateArgs<ExtArgs>>,
    ): Prisma__FeesPaymentClient<
      $Result.GetResult<
        Prisma.$FeesPaymentPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many FeesPayments.
     * @param {FeesPaymentCreateManyArgs} args - Arguments to create many FeesPayments.
     * @example
     * // Create many FeesPayments
     * const feesPayment = await prisma.feesPayment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends FeesPaymentCreateManyArgs>(
      args?: SelectSubset<T, FeesPaymentCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many FeesPayments and returns the data saved in the database.
     * @param {FeesPaymentCreateManyAndReturnArgs} args - Arguments to create many FeesPayments.
     * @example
     * // Create many FeesPayments
     * const feesPayment = await prisma.feesPayment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many FeesPayments and only return the `id`
     * const feesPaymentWithIdOnly = await prisma.feesPayment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends FeesPaymentCreateManyAndReturnArgs>(
      args?: SelectSubset<T, FeesPaymentCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$FeesPaymentPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a FeesPayment.
     * @param {FeesPaymentDeleteArgs} args - Arguments to delete one FeesPayment.
     * @example
     * // Delete one FeesPayment
     * const FeesPayment = await prisma.feesPayment.delete({
     *   where: {
     *     // ... filter to delete one FeesPayment
     *   }
     * })
     *
     */
    delete<T extends FeesPaymentDeleteArgs>(
      args: SelectSubset<T, FeesPaymentDeleteArgs<ExtArgs>>,
    ): Prisma__FeesPaymentClient<
      $Result.GetResult<
        Prisma.$FeesPaymentPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one FeesPayment.
     * @param {FeesPaymentUpdateArgs} args - Arguments to update one FeesPayment.
     * @example
     * // Update one FeesPayment
     * const feesPayment = await prisma.feesPayment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends FeesPaymentUpdateArgs>(
      args: SelectSubset<T, FeesPaymentUpdateArgs<ExtArgs>>,
    ): Prisma__FeesPaymentClient<
      $Result.GetResult<
        Prisma.$FeesPaymentPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more FeesPayments.
     * @param {FeesPaymentDeleteManyArgs} args - Arguments to filter FeesPayments to delete.
     * @example
     * // Delete a few FeesPayments
     * const { count } = await prisma.feesPayment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends FeesPaymentDeleteManyArgs>(
      args?: SelectSubset<T, FeesPaymentDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more FeesPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeesPaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FeesPayments
     * const feesPayment = await prisma.feesPayment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends FeesPaymentUpdateManyArgs>(
      args: SelectSubset<T, FeesPaymentUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more FeesPayments and returns the data updated in the database.
     * @param {FeesPaymentUpdateManyAndReturnArgs} args - Arguments to update many FeesPayments.
     * @example
     * // Update many FeesPayments
     * const feesPayment = await prisma.feesPayment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more FeesPayments and only return the `id`
     * const feesPaymentWithIdOnly = await prisma.feesPayment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends FeesPaymentUpdateManyAndReturnArgs>(
      args: SelectSubset<T, FeesPaymentUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$FeesPaymentPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one FeesPayment.
     * @param {FeesPaymentUpsertArgs} args - Arguments to update or create a FeesPayment.
     * @example
     * // Update or create a FeesPayment
     * const feesPayment = await prisma.feesPayment.upsert({
     *   create: {
     *     // ... data to create a FeesPayment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FeesPayment we want to update
     *   }
     * })
     */
    upsert<T extends FeesPaymentUpsertArgs>(
      args: SelectSubset<T, FeesPaymentUpsertArgs<ExtArgs>>,
    ): Prisma__FeesPaymentClient<
      $Result.GetResult<
        Prisma.$FeesPaymentPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of FeesPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeesPaymentCountArgs} args - Arguments to filter FeesPayments to count.
     * @example
     * // Count the number of FeesPayments
     * const count = await prisma.feesPayment.count({
     *   where: {
     *     // ... the filter for the FeesPayments we want to count
     *   }
     * })
     **/
    count<T extends FeesPaymentCountArgs>(
      args?: Subset<T, FeesPaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], FeesPaymentCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a FeesPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeesPaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends FeesPaymentAggregateArgs>(
      args: Subset<T, FeesPaymentAggregateArgs>,
    ): Prisma.PrismaPromise<GetFeesPaymentAggregateType<T>>;

    /**
     * Group by FeesPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeesPaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends FeesPaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeesPaymentGroupByArgs["orderBy"] }
        : { orderBy?: FeesPaymentGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, FeesPaymentGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetFeesPaymentGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the FeesPayment model
     */
    readonly fields: FeesPaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FeesPayment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeesPaymentClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    fees<T extends FeesPayment$feesArgs<ExtArgs> = {}>(
      args?: Subset<T, FeesPayment$feesArgs<ExtArgs>>,
    ): Prisma__FeesClient<
      $Result.GetResult<
        Prisma.$FeesPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    paidBy<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>,
    ): Prisma__UserClient<
      | $Result.GetResult<
          Prisma.$UserPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the FeesPayment model
   */
  interface FeesPaymentFieldRefs {
    readonly id: FieldRef<"FeesPayment", "String">;
    readonly amountPaid: FieldRef<"FeesPayment", "Int">;
    readonly createdAt: FieldRef<"FeesPayment", "DateTime">;
    readonly updatedAt: FieldRef<"FeesPayment", "DateTime">;
    readonly feesId: FieldRef<"FeesPayment", "String">;
    readonly userId: FieldRef<"FeesPayment", "String">;
  }

  // Custom InputTypes
  /**
   * FeesPayment findUnique
   */
  export type FeesPaymentFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FeesPayment
     */
    select?: FeesPaymentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FeesPayment
     */
    omit?: FeesPaymentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeesPaymentInclude<ExtArgs> | null;
    /**
     * Filter, which FeesPayment to fetch.
     */
    where: FeesPaymentWhereUniqueInput;
  };

  /**
   * FeesPayment findUniqueOrThrow
   */
  export type FeesPaymentFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FeesPayment
     */
    select?: FeesPaymentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FeesPayment
     */
    omit?: FeesPaymentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeesPaymentInclude<ExtArgs> | null;
    /**
     * Filter, which FeesPayment to fetch.
     */
    where: FeesPaymentWhereUniqueInput;
  };

  /**
   * FeesPayment findFirst
   */
  export type FeesPaymentFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FeesPayment
     */
    select?: FeesPaymentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FeesPayment
     */
    omit?: FeesPaymentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeesPaymentInclude<ExtArgs> | null;
    /**
     * Filter, which FeesPayment to fetch.
     */
    where?: FeesPaymentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FeesPayments to fetch.
     */
    orderBy?:
      | FeesPaymentOrderByWithRelationInput
      | FeesPaymentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for FeesPayments.
     */
    cursor?: FeesPaymentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FeesPayments from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FeesPayments.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of FeesPayments.
     */
    distinct?: FeesPaymentScalarFieldEnum | FeesPaymentScalarFieldEnum[];
  };

  /**
   * FeesPayment findFirstOrThrow
   */
  export type FeesPaymentFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FeesPayment
     */
    select?: FeesPaymentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FeesPayment
     */
    omit?: FeesPaymentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeesPaymentInclude<ExtArgs> | null;
    /**
     * Filter, which FeesPayment to fetch.
     */
    where?: FeesPaymentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FeesPayments to fetch.
     */
    orderBy?:
      | FeesPaymentOrderByWithRelationInput
      | FeesPaymentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for FeesPayments.
     */
    cursor?: FeesPaymentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FeesPayments from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FeesPayments.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of FeesPayments.
     */
    distinct?: FeesPaymentScalarFieldEnum | FeesPaymentScalarFieldEnum[];
  };

  /**
   * FeesPayment findMany
   */
  export type FeesPaymentFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FeesPayment
     */
    select?: FeesPaymentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FeesPayment
     */
    omit?: FeesPaymentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeesPaymentInclude<ExtArgs> | null;
    /**
     * Filter, which FeesPayments to fetch.
     */
    where?: FeesPaymentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FeesPayments to fetch.
     */
    orderBy?:
      | FeesPaymentOrderByWithRelationInput
      | FeesPaymentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing FeesPayments.
     */
    cursor?: FeesPaymentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FeesPayments from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FeesPayments.
     */
    skip?: number;
    distinct?: FeesPaymentScalarFieldEnum | FeesPaymentScalarFieldEnum[];
  };

  /**
   * FeesPayment create
   */
  export type FeesPaymentCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FeesPayment
     */
    select?: FeesPaymentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FeesPayment
     */
    omit?: FeesPaymentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeesPaymentInclude<ExtArgs> | null;
    /**
     * The data needed to create a FeesPayment.
     */
    data: XOR<FeesPaymentCreateInput, FeesPaymentUncheckedCreateInput>;
  };

  /**
   * FeesPayment createMany
   */
  export type FeesPaymentCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many FeesPayments.
     */
    data: FeesPaymentCreateManyInput | FeesPaymentCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * FeesPayment createManyAndReturn
   */
  export type FeesPaymentCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FeesPayment
     */
    select?: FeesPaymentSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the FeesPayment
     */
    omit?: FeesPaymentOmit<ExtArgs> | null;
    /**
     * The data used to create many FeesPayments.
     */
    data: FeesPaymentCreateManyInput | FeesPaymentCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeesPaymentIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * FeesPayment update
   */
  export type FeesPaymentUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FeesPayment
     */
    select?: FeesPaymentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FeesPayment
     */
    omit?: FeesPaymentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeesPaymentInclude<ExtArgs> | null;
    /**
     * The data needed to update a FeesPayment.
     */
    data: XOR<FeesPaymentUpdateInput, FeesPaymentUncheckedUpdateInput>;
    /**
     * Choose, which FeesPayment to update.
     */
    where: FeesPaymentWhereUniqueInput;
  };

  /**
   * FeesPayment updateMany
   */
  export type FeesPaymentUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update FeesPayments.
     */
    data: XOR<
      FeesPaymentUpdateManyMutationInput,
      FeesPaymentUncheckedUpdateManyInput
    >;
    /**
     * Filter which FeesPayments to update
     */
    where?: FeesPaymentWhereInput;
    /**
     * Limit how many FeesPayments to update.
     */
    limit?: number;
  };

  /**
   * FeesPayment updateManyAndReturn
   */
  export type FeesPaymentUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FeesPayment
     */
    select?: FeesPaymentSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the FeesPayment
     */
    omit?: FeesPaymentOmit<ExtArgs> | null;
    /**
     * The data used to update FeesPayments.
     */
    data: XOR<
      FeesPaymentUpdateManyMutationInput,
      FeesPaymentUncheckedUpdateManyInput
    >;
    /**
     * Filter which FeesPayments to update
     */
    where?: FeesPaymentWhereInput;
    /**
     * Limit how many FeesPayments to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeesPaymentIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * FeesPayment upsert
   */
  export type FeesPaymentUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FeesPayment
     */
    select?: FeesPaymentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FeesPayment
     */
    omit?: FeesPaymentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeesPaymentInclude<ExtArgs> | null;
    /**
     * The filter to search for the FeesPayment to update in case it exists.
     */
    where: FeesPaymentWhereUniqueInput;
    /**
     * In case the FeesPayment found by the `where` argument doesn't exist, create a new FeesPayment with this data.
     */
    create: XOR<FeesPaymentCreateInput, FeesPaymentUncheckedCreateInput>;
    /**
     * In case the FeesPayment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeesPaymentUpdateInput, FeesPaymentUncheckedUpdateInput>;
  };

  /**
   * FeesPayment delete
   */
  export type FeesPaymentDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FeesPayment
     */
    select?: FeesPaymentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FeesPayment
     */
    omit?: FeesPaymentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeesPaymentInclude<ExtArgs> | null;
    /**
     * Filter which FeesPayment to delete.
     */
    where: FeesPaymentWhereUniqueInput;
  };

  /**
   * FeesPayment deleteMany
   */
  export type FeesPaymentDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which FeesPayments to delete
     */
    where?: FeesPaymentWhereInput;
    /**
     * Limit how many FeesPayments to delete.
     */
    limit?: number;
  };

  /**
   * FeesPayment.fees
   */
  export type FeesPayment$feesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Fees
     */
    select?: FeesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Fees
     */
    omit?: FeesOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeesInclude<ExtArgs> | null;
    where?: FeesWhereInput;
  };

  /**
   * FeesPayment without action
   */
  export type FeesPaymentDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FeesPayment
     */
    select?: FeesPaymentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FeesPayment
     */
    omit?: FeesPaymentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeesPaymentInclude<ExtArgs> | null;
  };

  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null;
    _min: SessionMinAggregateOutputType | null;
    _max: SessionMaxAggregateOutputType | null;
  };

  export type SessionMinAggregateOutputType = {
    id: string | null;
    userId: string | null;
    expiresAt: Date | null;
    role: $Enums.Role | null;
  };

  export type SessionMaxAggregateOutputType = {
    id: string | null;
    userId: string | null;
    expiresAt: Date | null;
    role: $Enums.Role | null;
  };

  export type SessionCountAggregateOutputType = {
    id: number;
    userId: number;
    expiresAt: number;
    role: number;
    _all: number;
  };

  export type SessionMinAggregateInputType = {
    id?: true;
    userId?: true;
    expiresAt?: true;
    role?: true;
  };

  export type SessionMaxAggregateInputType = {
    id?: true;
    userId?: true;
    expiresAt?: true;
    role?: true;
  };

  export type SessionCountAggregateInputType = {
    id?: true;
    userId?: true;
    expiresAt?: true;
    role?: true;
    _all?: true;
  };

  export type SessionAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Sessions to fetch.
     */
    orderBy?:
      | SessionOrderByWithRelationInput
      | SessionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Sessions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Sessions
     **/
    _count?: true | SessionCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: SessionMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: SessionMaxAggregateInputType;
  };

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
    [P in keyof T & keyof AggregateSession]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>;
  };

  export type SessionGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: SessionWhereInput;
    orderBy?:
      | SessionOrderByWithAggregationInput
      | SessionOrderByWithAggregationInput[];
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum;
    having?: SessionScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: SessionCountAggregateInputType | true;
    _min?: SessionMinAggregateInputType;
    _max?: SessionMaxAggregateInputType;
  };

  export type SessionGroupByOutputType = {
    id: string;
    userId: string;
    expiresAt: Date;
    role: $Enums.Role;
    _count: SessionCountAggregateOutputType | null;
    _min: SessionMinAggregateOutputType | null;
    _max: SessionMaxAggregateOutputType | null;
  };

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<SessionGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof SessionGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>;
        }
      >
    >;

  export type SessionSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      expiresAt?: boolean;
      role?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["session"]
  >;

  export type SessionSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      expiresAt?: boolean;
      role?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["session"]
  >;

  export type SessionSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      expiresAt?: boolean;
      role?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["session"]
  >;

  export type SessionSelectScalar = {
    id?: boolean;
    userId?: boolean;
    expiresAt?: boolean;
    role?: boolean;
  };

  export type SessionOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    "id" | "userId" | "expiresAt" | "role",
    ExtArgs["result"]["session"]
  >;
  export type SessionInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type SessionIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type SessionIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $SessionPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "Session";
    objects: {
      user: Prisma.$UserPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        userId: string;
        expiresAt: Date;
        role: $Enums.Role;
      },
      ExtArgs["result"]["session"]
    >;
    composites: {};
  };

  type SessionGetPayload<
    S extends boolean | null | undefined | SessionDefaultArgs,
  > = $Result.GetResult<Prisma.$SessionPayload, S>;

  type SessionCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<SessionFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
    select?: SessionCountAggregateInputType | true;
  };

  export interface SessionDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["Session"];
      meta: { name: "Session" };
    };
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(
      args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>,
    ): Prisma__SessionClient<
      $Result.GetResult<
        Prisma.$SessionPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(
      args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__SessionClient<
      $Result.GetResult<
        Prisma.$SessionPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(
      args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>,
    ): Prisma__SessionClient<
      $Result.GetResult<
        Prisma.$SessionPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__SessionClient<
      $Result.GetResult<
        Prisma.$SessionPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     *
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     *
     */
    findMany<T extends SessionFindManyArgs>(
      args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$SessionPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     *
     */
    create<T extends SessionCreateArgs>(
      args: SelectSubset<T, SessionCreateArgs<ExtArgs>>,
    ): Prisma__SessionClient<
      $Result.GetResult<
        Prisma.$SessionPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends SessionCreateManyArgs>(
      args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(
      args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$SessionPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     *
     */
    delete<T extends SessionDeleteArgs>(
      args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>,
    ): Prisma__SessionClient<
      $Result.GetResult<
        Prisma.$SessionPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends SessionUpdateArgs>(
      args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>,
    ): Prisma__SessionClient<
      $Result.GetResult<
        Prisma.$SessionPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends SessionDeleteManyArgs>(
      args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends SessionUpdateManyArgs>(
      args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(
      args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$SessionPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(
      args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>,
    ): Prisma__SessionClient<
      $Result.GetResult<
        Prisma.$SessionPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
     **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], SessionCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends SessionAggregateArgs>(
      args: Subset<T, SessionAggregateArgs>,
    ): Prisma.PrismaPromise<GetSessionAggregateType<T>>;

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs["orderBy"] }
        : { orderBy?: SessionGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetSessionGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Session model
     */
    readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>,
    ): Prisma__UserClient<
      | $Result.GetResult<
          Prisma.$UserPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", "String">;
    readonly userId: FieldRef<"Session", "String">;
    readonly expiresAt: FieldRef<"Session", "DateTime">;
    readonly role: FieldRef<"Session", "Role">;
  }

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput;
  };

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput;
  };

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Sessions to fetch.
     */
    orderBy?:
      | SessionOrderByWithRelationInput
      | SessionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Sessions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[];
  };

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Sessions to fetch.
     */
    orderBy?:
      | SessionOrderByWithRelationInput
      | SessionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Sessions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[];
  };

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Sessions to fetch.
     */
    orderBy?:
      | SessionOrderByWithRelationInput
      | SessionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Sessions.
     */
    skip?: number;
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[];
  };

  /**
   * Session create
   */
  export type SessionCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>;
  };

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Session update
   */
  export type SessionUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>;
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput;
  };

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>;
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput;
    /**
     * Limit how many Sessions to update.
     */
    limit?: number;
  };

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>;
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput;
    /**
     * Limit how many Sessions to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput;
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>;
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>;
  };

  /**
   * Session delete
   */
  export type SessionDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput;
  };

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput;
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number;
  };

  /**
   * Session without action
   */
  export type SessionDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
  };

  /**
   * Model Asset
   */

  export type AggregateAsset = {
    _count: AssetCountAggregateOutputType | null;
    _min: AssetMinAggregateOutputType | null;
    _max: AssetMaxAggregateOutputType | null;
  };

  export type AssetMinAggregateOutputType = {
    id: string | null;
    name: string | null;
    description: string | null;
    category: $Enums.AssetCategory | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type AssetMaxAggregateOutputType = {
    id: string | null;
    name: string | null;
    description: string | null;
    category: $Enums.AssetCategory | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type AssetCountAggregateOutputType = {
    id: number;
    name: number;
    description: number;
    category: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type AssetMinAggregateInputType = {
    id?: true;
    name?: true;
    description?: true;
    category?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type AssetMaxAggregateInputType = {
    id?: true;
    name?: true;
    description?: true;
    category?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type AssetCountAggregateInputType = {
    id?: true;
    name?: true;
    description?: true;
    category?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type AssetAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Asset to aggregate.
     */
    where?: AssetWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Assets to fetch.
     */
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: AssetWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Assets from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Assets.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Assets
     **/
    _count?: true | AssetCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: AssetMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: AssetMaxAggregateInputType;
  };

  export type GetAssetAggregateType<T extends AssetAggregateArgs> = {
    [P in keyof T & keyof AggregateAsset]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAsset[P]>
      : GetScalarType<T[P], AggregateAsset[P]>;
  };

  export type AssetGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AssetWhereInput;
    orderBy?:
      | AssetOrderByWithAggregationInput
      | AssetOrderByWithAggregationInput[];
    by: AssetScalarFieldEnum[] | AssetScalarFieldEnum;
    having?: AssetScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: AssetCountAggregateInputType | true;
    _min?: AssetMinAggregateInputType;
    _max?: AssetMaxAggregateInputType;
  };

  export type AssetGroupByOutputType = {
    id: string;
    name: string;
    description: string | null;
    category: $Enums.AssetCategory;
    createdAt: Date;
    updatedAt: Date;
    _count: AssetCountAggregateOutputType | null;
    _min: AssetMinAggregateOutputType | null;
    _max: AssetMaxAggregateOutputType | null;
  };

  type GetAssetGroupByPayload<T extends AssetGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<AssetGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof AssetGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AssetGroupByOutputType[P]>
            : GetScalarType<T[P], AssetGroupByOutputType[P]>;
        }
      >
    >;

  export type AssetSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      description?: boolean;
      category?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      computerLabItems?: boolean | Asset$computerLabItemsArgs<ExtArgs>;
      foodStoreItems?: boolean | Asset$foodStoreItemsArgs<ExtArgs>;
      generalStoreItems?: boolean | Asset$generalStoreItemsArgs<ExtArgs>;
      labItems?: boolean | Asset$labItemsArgs<ExtArgs>;
      libraryBooks?: boolean | Asset$libraryBooksArgs<ExtArgs>;
      _count?: boolean | AssetCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["asset"]
  >;

  export type AssetSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      description?: boolean;
      category?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
    },
    ExtArgs["result"]["asset"]
  >;

  export type AssetSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      description?: boolean;
      category?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
    },
    ExtArgs["result"]["asset"]
  >;

  export type AssetSelectScalar = {
    id?: boolean;
    name?: boolean;
    description?: boolean;
    category?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type AssetOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    "id" | "name" | "description" | "category" | "createdAt" | "updatedAt",
    ExtArgs["result"]["asset"]
  >;
  export type AssetInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    computerLabItems?: boolean | Asset$computerLabItemsArgs<ExtArgs>;
    foodStoreItems?: boolean | Asset$foodStoreItemsArgs<ExtArgs>;
    generalStoreItems?: boolean | Asset$generalStoreItemsArgs<ExtArgs>;
    labItems?: boolean | Asset$labItemsArgs<ExtArgs>;
    libraryBooks?: boolean | Asset$libraryBooksArgs<ExtArgs>;
    _count?: boolean | AssetCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type AssetIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};
  export type AssetIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};

  export type $AssetPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "Asset";
    objects: {
      computerLabItems: Prisma.$ComputerLabItemPayload<ExtArgs>[];
      foodStoreItems: Prisma.$FoodStoreItemPayload<ExtArgs>[];
      generalStoreItems: Prisma.$GeneralStoreItemPayload<ExtArgs>[];
      labItems: Prisma.$LabItemPayload<ExtArgs>[];
      libraryBooks: Prisma.$LibraryBookPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        name: string;
        description: string | null;
        category: $Enums.AssetCategory;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs["result"]["asset"]
    >;
    composites: {};
  };

  type AssetGetPayload<
    S extends boolean | null | undefined | AssetDefaultArgs,
  > = $Result.GetResult<Prisma.$AssetPayload, S>;

  type AssetCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<AssetFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
    select?: AssetCountAggregateInputType | true;
  };

  export interface AssetDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["Asset"];
      meta: { name: "Asset" };
    };
    /**
     * Find zero or one Asset that matches the filter.
     * @param {AssetFindUniqueArgs} args - Arguments to find a Asset
     * @example
     * // Get one Asset
     * const asset = await prisma.asset.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AssetFindUniqueArgs>(
      args: SelectSubset<T, AssetFindUniqueArgs<ExtArgs>>,
    ): Prisma__AssetClient<
      $Result.GetResult<
        Prisma.$AssetPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Asset that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AssetFindUniqueOrThrowArgs} args - Arguments to find a Asset
     * @example
     * // Get one Asset
     * const asset = await prisma.asset.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AssetFindUniqueOrThrowArgs>(
      args: SelectSubset<T, AssetFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__AssetClient<
      $Result.GetResult<
        Prisma.$AssetPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Asset that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetFindFirstArgs} args - Arguments to find a Asset
     * @example
     * // Get one Asset
     * const asset = await prisma.asset.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AssetFindFirstArgs>(
      args?: SelectSubset<T, AssetFindFirstArgs<ExtArgs>>,
    ): Prisma__AssetClient<
      $Result.GetResult<
        Prisma.$AssetPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Asset that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetFindFirstOrThrowArgs} args - Arguments to find a Asset
     * @example
     * // Get one Asset
     * const asset = await prisma.asset.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AssetFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AssetFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__AssetClient<
      $Result.GetResult<
        Prisma.$AssetPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Assets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Assets
     * const assets = await prisma.asset.findMany()
     *
     * // Get first 10 Assets
     * const assets = await prisma.asset.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const assetWithIdOnly = await prisma.asset.findMany({ select: { id: true } })
     *
     */
    findMany<T extends AssetFindManyArgs>(
      args?: SelectSubset<T, AssetFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$AssetPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Asset.
     * @param {AssetCreateArgs} args - Arguments to create a Asset.
     * @example
     * // Create one Asset
     * const Asset = await prisma.asset.create({
     *   data: {
     *     // ... data to create a Asset
     *   }
     * })
     *
     */
    create<T extends AssetCreateArgs>(
      args: SelectSubset<T, AssetCreateArgs<ExtArgs>>,
    ): Prisma__AssetClient<
      $Result.GetResult<
        Prisma.$AssetPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Assets.
     * @param {AssetCreateManyArgs} args - Arguments to create many Assets.
     * @example
     * // Create many Assets
     * const asset = await prisma.asset.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends AssetCreateManyArgs>(
      args?: SelectSubset<T, AssetCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Assets and returns the data saved in the database.
     * @param {AssetCreateManyAndReturnArgs} args - Arguments to create many Assets.
     * @example
     * // Create many Assets
     * const asset = await prisma.asset.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Assets and only return the `id`
     * const assetWithIdOnly = await prisma.asset.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends AssetCreateManyAndReturnArgs>(
      args?: SelectSubset<T, AssetCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$AssetPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Asset.
     * @param {AssetDeleteArgs} args - Arguments to delete one Asset.
     * @example
     * // Delete one Asset
     * const Asset = await prisma.asset.delete({
     *   where: {
     *     // ... filter to delete one Asset
     *   }
     * })
     *
     */
    delete<T extends AssetDeleteArgs>(
      args: SelectSubset<T, AssetDeleteArgs<ExtArgs>>,
    ): Prisma__AssetClient<
      $Result.GetResult<
        Prisma.$AssetPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Asset.
     * @param {AssetUpdateArgs} args - Arguments to update one Asset.
     * @example
     * // Update one Asset
     * const asset = await prisma.asset.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends AssetUpdateArgs>(
      args: SelectSubset<T, AssetUpdateArgs<ExtArgs>>,
    ): Prisma__AssetClient<
      $Result.GetResult<
        Prisma.$AssetPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Assets.
     * @param {AssetDeleteManyArgs} args - Arguments to filter Assets to delete.
     * @example
     * // Delete a few Assets
     * const { count } = await prisma.asset.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends AssetDeleteManyArgs>(
      args?: SelectSubset<T, AssetDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Assets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Assets
     * const asset = await prisma.asset.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends AssetUpdateManyArgs>(
      args: SelectSubset<T, AssetUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Assets and returns the data updated in the database.
     * @param {AssetUpdateManyAndReturnArgs} args - Arguments to update many Assets.
     * @example
     * // Update many Assets
     * const asset = await prisma.asset.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Assets and only return the `id`
     * const assetWithIdOnly = await prisma.asset.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends AssetUpdateManyAndReturnArgs>(
      args: SelectSubset<T, AssetUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$AssetPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Asset.
     * @param {AssetUpsertArgs} args - Arguments to update or create a Asset.
     * @example
     * // Update or create a Asset
     * const asset = await prisma.asset.upsert({
     *   create: {
     *     // ... data to create a Asset
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Asset we want to update
     *   }
     * })
     */
    upsert<T extends AssetUpsertArgs>(
      args: SelectSubset<T, AssetUpsertArgs<ExtArgs>>,
    ): Prisma__AssetClient<
      $Result.GetResult<
        Prisma.$AssetPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Assets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetCountArgs} args - Arguments to filter Assets to count.
     * @example
     * // Count the number of Assets
     * const count = await prisma.asset.count({
     *   where: {
     *     // ... the filter for the Assets we want to count
     *   }
     * })
     **/
    count<T extends AssetCountArgs>(
      args?: Subset<T, AssetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], AssetCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Asset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends AssetAggregateArgs>(
      args: Subset<T, AssetAggregateArgs>,
    ): Prisma.PrismaPromise<GetAssetAggregateType<T>>;

    /**
     * Group by Asset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends AssetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AssetGroupByArgs["orderBy"] }
        : { orderBy?: AssetGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, AssetGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetAssetGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Asset model
     */
    readonly fields: AssetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Asset.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AssetClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    computerLabItems<T extends Asset$computerLabItemsArgs<ExtArgs> = {}>(
      args?: Subset<T, Asset$computerLabItemsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$ComputerLabItemPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    foodStoreItems<T extends Asset$foodStoreItemsArgs<ExtArgs> = {}>(
      args?: Subset<T, Asset$foodStoreItemsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$FoodStoreItemPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    generalStoreItems<T extends Asset$generalStoreItemsArgs<ExtArgs> = {}>(
      args?: Subset<T, Asset$generalStoreItemsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$GeneralStoreItemPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    labItems<T extends Asset$labItemsArgs<ExtArgs> = {}>(
      args?: Subset<T, Asset$labItemsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$LabItemPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    libraryBooks<T extends Asset$libraryBooksArgs<ExtArgs> = {}>(
      args?: Subset<T, Asset$libraryBooksArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$LibraryBookPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Asset model
   */
  interface AssetFieldRefs {
    readonly id: FieldRef<"Asset", "String">;
    readonly name: FieldRef<"Asset", "String">;
    readonly description: FieldRef<"Asset", "String">;
    readonly category: FieldRef<"Asset", "AssetCategory">;
    readonly createdAt: FieldRef<"Asset", "DateTime">;
    readonly updatedAt: FieldRef<"Asset", "DateTime">;
  }

  // Custom InputTypes
  /**
   * Asset findUnique
   */
  export type AssetFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null;
    /**
     * Filter, which Asset to fetch.
     */
    where: AssetWhereUniqueInput;
  };

  /**
   * Asset findUniqueOrThrow
   */
  export type AssetFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null;
    /**
     * Filter, which Asset to fetch.
     */
    where: AssetWhereUniqueInput;
  };

  /**
   * Asset findFirst
   */
  export type AssetFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null;
    /**
     * Filter, which Asset to fetch.
     */
    where?: AssetWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Assets to fetch.
     */
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Assets.
     */
    cursor?: AssetWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Assets from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Assets.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Assets.
     */
    distinct?: AssetScalarFieldEnum | AssetScalarFieldEnum[];
  };

  /**
   * Asset findFirstOrThrow
   */
  export type AssetFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null;
    /**
     * Filter, which Asset to fetch.
     */
    where?: AssetWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Assets to fetch.
     */
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Assets.
     */
    cursor?: AssetWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Assets from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Assets.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Assets.
     */
    distinct?: AssetScalarFieldEnum | AssetScalarFieldEnum[];
  };

  /**
   * Asset findMany
   */
  export type AssetFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null;
    /**
     * Filter, which Assets to fetch.
     */
    where?: AssetWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Assets to fetch.
     */
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Assets.
     */
    cursor?: AssetWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Assets from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Assets.
     */
    skip?: number;
    distinct?: AssetScalarFieldEnum | AssetScalarFieldEnum[];
  };

  /**
   * Asset create
   */
  export type AssetCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null;
    /**
     * The data needed to create a Asset.
     */
    data: XOR<AssetCreateInput, AssetUncheckedCreateInput>;
  };

  /**
   * Asset createMany
   */
  export type AssetCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Assets.
     */
    data: AssetCreateManyInput | AssetCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Asset createManyAndReturn
   */
  export type AssetCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null;
    /**
     * The data used to create many Assets.
     */
    data: AssetCreateManyInput | AssetCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Asset update
   */
  export type AssetUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null;
    /**
     * The data needed to update a Asset.
     */
    data: XOR<AssetUpdateInput, AssetUncheckedUpdateInput>;
    /**
     * Choose, which Asset to update.
     */
    where: AssetWhereUniqueInput;
  };

  /**
   * Asset updateMany
   */
  export type AssetUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Assets.
     */
    data: XOR<AssetUpdateManyMutationInput, AssetUncheckedUpdateManyInput>;
    /**
     * Filter which Assets to update
     */
    where?: AssetWhereInput;
    /**
     * Limit how many Assets to update.
     */
    limit?: number;
  };

  /**
   * Asset updateManyAndReturn
   */
  export type AssetUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null;
    /**
     * The data used to update Assets.
     */
    data: XOR<AssetUpdateManyMutationInput, AssetUncheckedUpdateManyInput>;
    /**
     * Filter which Assets to update
     */
    where?: AssetWhereInput;
    /**
     * Limit how many Assets to update.
     */
    limit?: number;
  };

  /**
   * Asset upsert
   */
  export type AssetUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null;
    /**
     * The filter to search for the Asset to update in case it exists.
     */
    where: AssetWhereUniqueInput;
    /**
     * In case the Asset found by the `where` argument doesn't exist, create a new Asset with this data.
     */
    create: XOR<AssetCreateInput, AssetUncheckedCreateInput>;
    /**
     * In case the Asset was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AssetUpdateInput, AssetUncheckedUpdateInput>;
  };

  /**
   * Asset delete
   */
  export type AssetDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null;
    /**
     * Filter which Asset to delete.
     */
    where: AssetWhereUniqueInput;
  };

  /**
   * Asset deleteMany
   */
  export type AssetDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Assets to delete
     */
    where?: AssetWhereInput;
    /**
     * Limit how many Assets to delete.
     */
    limit?: number;
  };

  /**
   * Asset.computerLabItems
   */
  export type Asset$computerLabItemsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ComputerLabItem
     */
    select?: ComputerLabItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ComputerLabItem
     */
    omit?: ComputerLabItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComputerLabItemInclude<ExtArgs> | null;
    where?: ComputerLabItemWhereInput;
    orderBy?:
      | ComputerLabItemOrderByWithRelationInput
      | ComputerLabItemOrderByWithRelationInput[];
    cursor?: ComputerLabItemWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?:
      | ComputerLabItemScalarFieldEnum
      | ComputerLabItemScalarFieldEnum[];
  };

  /**
   * Asset.foodStoreItems
   */
  export type Asset$foodStoreItemsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FoodStoreItem
     */
    select?: FoodStoreItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FoodStoreItem
     */
    omit?: FoodStoreItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodStoreItemInclude<ExtArgs> | null;
    where?: FoodStoreItemWhereInput;
    orderBy?:
      | FoodStoreItemOrderByWithRelationInput
      | FoodStoreItemOrderByWithRelationInput[];
    cursor?: FoodStoreItemWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: FoodStoreItemScalarFieldEnum | FoodStoreItemScalarFieldEnum[];
  };

  /**
   * Asset.generalStoreItems
   */
  export type Asset$generalStoreItemsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the GeneralStoreItem
     */
    select?: GeneralStoreItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the GeneralStoreItem
     */
    omit?: GeneralStoreItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneralStoreItemInclude<ExtArgs> | null;
    where?: GeneralStoreItemWhereInput;
    orderBy?:
      | GeneralStoreItemOrderByWithRelationInput
      | GeneralStoreItemOrderByWithRelationInput[];
    cursor?: GeneralStoreItemWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?:
      | GeneralStoreItemScalarFieldEnum
      | GeneralStoreItemScalarFieldEnum[];
  };

  /**
   * Asset.labItems
   */
  export type Asset$labItemsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LabItem
     */
    select?: LabItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the LabItem
     */
    omit?: LabItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabItemInclude<ExtArgs> | null;
    where?: LabItemWhereInput;
    orderBy?:
      | LabItemOrderByWithRelationInput
      | LabItemOrderByWithRelationInput[];
    cursor?: LabItemWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: LabItemScalarFieldEnum | LabItemScalarFieldEnum[];
  };

  /**
   * Asset.libraryBooks
   */
  export type Asset$libraryBooksArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LibraryBook
     */
    select?: LibraryBookSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the LibraryBook
     */
    omit?: LibraryBookOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryBookInclude<ExtArgs> | null;
    where?: LibraryBookWhereInput;
    orderBy?:
      | LibraryBookOrderByWithRelationInput
      | LibraryBookOrderByWithRelationInput[];
    cursor?: LibraryBookWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: LibraryBookScalarFieldEnum | LibraryBookScalarFieldEnum[];
  };

  /**
   * Asset without action
   */
  export type AssetDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null;
  };

  /**
   * Model FoodStoreItem
   */

  export type AggregateFoodStoreItem = {
    _count: FoodStoreItemCountAggregateOutputType | null;
    _avg: FoodStoreItemAvgAggregateOutputType | null;
    _sum: FoodStoreItemSumAggregateOutputType | null;
    _min: FoodStoreItemMinAggregateOutputType | null;
    _max: FoodStoreItemMaxAggregateOutputType | null;
  };

  export type FoodStoreItemAvgAggregateOutputType = {
    quantity: number | null;
  };

  export type FoodStoreItemSumAggregateOutputType = {
    quantity: number | null;
  };

  export type FoodStoreItemMinAggregateOutputType = {
    id: string | null;
    assetId: string | null;
    foodName: string | null;
    unit: $Enums.AssetUnit | null;
    quantity: number | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    supplierId: string | null;
    trackQuantity: boolean | null;
    status: $Enums.AssetItemStatus | null;
    isConsumable: boolean | null;
  };

  export type FoodStoreItemMaxAggregateOutputType = {
    id: string | null;
    assetId: string | null;
    foodName: string | null;
    unit: $Enums.AssetUnit | null;
    quantity: number | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    supplierId: string | null;
    trackQuantity: boolean | null;
    status: $Enums.AssetItemStatus | null;
    isConsumable: boolean | null;
  };

  export type FoodStoreItemCountAggregateOutputType = {
    id: number;
    assetId: number;
    foodName: number;
    unit: number;
    quantity: number;
    createdAt: number;
    updatedAt: number;
    supplierId: number;
    trackQuantity: number;
    status: number;
    isConsumable: number;
    _all: number;
  };

  export type FoodStoreItemAvgAggregateInputType = {
    quantity?: true;
  };

  export type FoodStoreItemSumAggregateInputType = {
    quantity?: true;
  };

  export type FoodStoreItemMinAggregateInputType = {
    id?: true;
    assetId?: true;
    foodName?: true;
    unit?: true;
    quantity?: true;
    createdAt?: true;
    updatedAt?: true;
    supplierId?: true;
    trackQuantity?: true;
    status?: true;
    isConsumable?: true;
  };

  export type FoodStoreItemMaxAggregateInputType = {
    id?: true;
    assetId?: true;
    foodName?: true;
    unit?: true;
    quantity?: true;
    createdAt?: true;
    updatedAt?: true;
    supplierId?: true;
    trackQuantity?: true;
    status?: true;
    isConsumable?: true;
  };

  export type FoodStoreItemCountAggregateInputType = {
    id?: true;
    assetId?: true;
    foodName?: true;
    unit?: true;
    quantity?: true;
    createdAt?: true;
    updatedAt?: true;
    supplierId?: true;
    trackQuantity?: true;
    status?: true;
    isConsumable?: true;
    _all?: true;
  };

  export type FoodStoreItemAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which FoodStoreItem to aggregate.
     */
    where?: FoodStoreItemWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FoodStoreItems to fetch.
     */
    orderBy?:
      | FoodStoreItemOrderByWithRelationInput
      | FoodStoreItemOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: FoodStoreItemWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FoodStoreItems from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FoodStoreItems.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned FoodStoreItems
     **/
    _count?: true | FoodStoreItemCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: FoodStoreItemAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: FoodStoreItemSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: FoodStoreItemMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: FoodStoreItemMaxAggregateInputType;
  };

  export type GetFoodStoreItemAggregateType<
    T extends FoodStoreItemAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateFoodStoreItem]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFoodStoreItem[P]>
      : GetScalarType<T[P], AggregateFoodStoreItem[P]>;
  };

  export type FoodStoreItemGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: FoodStoreItemWhereInput;
    orderBy?:
      | FoodStoreItemOrderByWithAggregationInput
      | FoodStoreItemOrderByWithAggregationInput[];
    by: FoodStoreItemScalarFieldEnum[] | FoodStoreItemScalarFieldEnum;
    having?: FoodStoreItemScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: FoodStoreItemCountAggregateInputType | true;
    _avg?: FoodStoreItemAvgAggregateInputType;
    _sum?: FoodStoreItemSumAggregateInputType;
    _min?: FoodStoreItemMinAggregateInputType;
    _max?: FoodStoreItemMaxAggregateInputType;
  };

  export type FoodStoreItemGroupByOutputType = {
    id: string;
    assetId: string;
    foodName: string;
    unit: $Enums.AssetUnit;
    quantity: number | null;
    createdAt: Date;
    updatedAt: Date;
    supplierId: string | null;
    trackQuantity: boolean;
    status: $Enums.AssetItemStatus;
    isConsumable: boolean;
    _count: FoodStoreItemCountAggregateOutputType | null;
    _avg: FoodStoreItemAvgAggregateOutputType | null;
    _sum: FoodStoreItemSumAggregateOutputType | null;
    _min: FoodStoreItemMinAggregateOutputType | null;
    _max: FoodStoreItemMaxAggregateOutputType | null;
  };

  type GetFoodStoreItemGroupByPayload<T extends FoodStoreItemGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<FoodStoreItemGroupByOutputType, T["by"]> & {
          [P in keyof T &
            keyof FoodStoreItemGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FoodStoreItemGroupByOutputType[P]>
            : GetScalarType<T[P], FoodStoreItemGroupByOutputType[P]>;
        }
      >
    >;

  export type FoodStoreItemSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      assetId?: boolean;
      foodName?: boolean;
      unit?: boolean;
      quantity?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      supplierId?: boolean;
      trackQuantity?: boolean;
      status?: boolean;
      isConsumable?: boolean;
      consumptions?: boolean | FoodStoreItem$consumptionsArgs<ExtArgs>;
      asset?: boolean | AssetDefaultArgs<ExtArgs>;
      supplier?: boolean | FoodStoreItem$supplierArgs<ExtArgs>;
      individualFoodStoreItems?:
        | boolean
        | FoodStoreItem$individualFoodStoreItemsArgs<ExtArgs>;
      _count?: boolean | FoodStoreItemCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["foodStoreItem"]
  >;

  export type FoodStoreItemSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      assetId?: boolean;
      foodName?: boolean;
      unit?: boolean;
      quantity?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      supplierId?: boolean;
      trackQuantity?: boolean;
      status?: boolean;
      isConsumable?: boolean;
      asset?: boolean | AssetDefaultArgs<ExtArgs>;
      supplier?: boolean | FoodStoreItem$supplierArgs<ExtArgs>;
    },
    ExtArgs["result"]["foodStoreItem"]
  >;

  export type FoodStoreItemSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      assetId?: boolean;
      foodName?: boolean;
      unit?: boolean;
      quantity?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      supplierId?: boolean;
      trackQuantity?: boolean;
      status?: boolean;
      isConsumable?: boolean;
      asset?: boolean | AssetDefaultArgs<ExtArgs>;
      supplier?: boolean | FoodStoreItem$supplierArgs<ExtArgs>;
    },
    ExtArgs["result"]["foodStoreItem"]
  >;

  export type FoodStoreItemSelectScalar = {
    id?: boolean;
    assetId?: boolean;
    foodName?: boolean;
    unit?: boolean;
    quantity?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    supplierId?: boolean;
    trackQuantity?: boolean;
    status?: boolean;
    isConsumable?: boolean;
  };

  export type FoodStoreItemOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | "id"
    | "assetId"
    | "foodName"
    | "unit"
    | "quantity"
    | "createdAt"
    | "updatedAt"
    | "supplierId"
    | "trackQuantity"
    | "status"
    | "isConsumable",
    ExtArgs["result"]["foodStoreItem"]
  >;
  export type FoodStoreItemInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    consumptions?: boolean | FoodStoreItem$consumptionsArgs<ExtArgs>;
    asset?: boolean | AssetDefaultArgs<ExtArgs>;
    supplier?: boolean | FoodStoreItem$supplierArgs<ExtArgs>;
    individualFoodStoreItems?:
      | boolean
      | FoodStoreItem$individualFoodStoreItemsArgs<ExtArgs>;
    _count?: boolean | FoodStoreItemCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type FoodStoreItemIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    asset?: boolean | AssetDefaultArgs<ExtArgs>;
    supplier?: boolean | FoodStoreItem$supplierArgs<ExtArgs>;
  };
  export type FoodStoreItemIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    asset?: boolean | AssetDefaultArgs<ExtArgs>;
    supplier?: boolean | FoodStoreItem$supplierArgs<ExtArgs>;
  };

  export type $FoodStoreItemPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "FoodStoreItem";
    objects: {
      consumptions: Prisma.$FoodConsumptionPayload<ExtArgs>[];
      asset: Prisma.$AssetPayload<ExtArgs>;
      supplier: Prisma.$SupplierPayload<ExtArgs> | null;
      individualFoodStoreItems: Prisma.$IndividualFoodStoreItemPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        assetId: string;
        foodName: string;
        unit: $Enums.AssetUnit;
        quantity: number | null;
        createdAt: Date;
        updatedAt: Date;
        supplierId: string | null;
        trackQuantity: boolean;
        status: $Enums.AssetItemStatus;
        isConsumable: boolean;
      },
      ExtArgs["result"]["foodStoreItem"]
    >;
    composites: {};
  };

  type FoodStoreItemGetPayload<
    S extends boolean | null | undefined | FoodStoreItemDefaultArgs,
  > = $Result.GetResult<Prisma.$FoodStoreItemPayload, S>;

  type FoodStoreItemCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    FoodStoreItemFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: FoodStoreItemCountAggregateInputType | true;
  };

  export interface FoodStoreItemDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["FoodStoreItem"];
      meta: { name: "FoodStoreItem" };
    };
    /**
     * Find zero or one FoodStoreItem that matches the filter.
     * @param {FoodStoreItemFindUniqueArgs} args - Arguments to find a FoodStoreItem
     * @example
     * // Get one FoodStoreItem
     * const foodStoreItem = await prisma.foodStoreItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FoodStoreItemFindUniqueArgs>(
      args: SelectSubset<T, FoodStoreItemFindUniqueArgs<ExtArgs>>,
    ): Prisma__FoodStoreItemClient<
      $Result.GetResult<
        Prisma.$FoodStoreItemPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one FoodStoreItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FoodStoreItemFindUniqueOrThrowArgs} args - Arguments to find a FoodStoreItem
     * @example
     * // Get one FoodStoreItem
     * const foodStoreItem = await prisma.foodStoreItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FoodStoreItemFindUniqueOrThrowArgs>(
      args: SelectSubset<T, FoodStoreItemFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__FoodStoreItemClient<
      $Result.GetResult<
        Prisma.$FoodStoreItemPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first FoodStoreItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodStoreItemFindFirstArgs} args - Arguments to find a FoodStoreItem
     * @example
     * // Get one FoodStoreItem
     * const foodStoreItem = await prisma.foodStoreItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FoodStoreItemFindFirstArgs>(
      args?: SelectSubset<T, FoodStoreItemFindFirstArgs<ExtArgs>>,
    ): Prisma__FoodStoreItemClient<
      $Result.GetResult<
        Prisma.$FoodStoreItemPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first FoodStoreItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodStoreItemFindFirstOrThrowArgs} args - Arguments to find a FoodStoreItem
     * @example
     * // Get one FoodStoreItem
     * const foodStoreItem = await prisma.foodStoreItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FoodStoreItemFindFirstOrThrowArgs>(
      args?: SelectSubset<T, FoodStoreItemFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__FoodStoreItemClient<
      $Result.GetResult<
        Prisma.$FoodStoreItemPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more FoodStoreItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodStoreItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FoodStoreItems
     * const foodStoreItems = await prisma.foodStoreItem.findMany()
     *
     * // Get first 10 FoodStoreItems
     * const foodStoreItems = await prisma.foodStoreItem.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const foodStoreItemWithIdOnly = await prisma.foodStoreItem.findMany({ select: { id: true } })
     *
     */
    findMany<T extends FoodStoreItemFindManyArgs>(
      args?: SelectSubset<T, FoodStoreItemFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$FoodStoreItemPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a FoodStoreItem.
     * @param {FoodStoreItemCreateArgs} args - Arguments to create a FoodStoreItem.
     * @example
     * // Create one FoodStoreItem
     * const FoodStoreItem = await prisma.foodStoreItem.create({
     *   data: {
     *     // ... data to create a FoodStoreItem
     *   }
     * })
     *
     */
    create<T extends FoodStoreItemCreateArgs>(
      args: SelectSubset<T, FoodStoreItemCreateArgs<ExtArgs>>,
    ): Prisma__FoodStoreItemClient<
      $Result.GetResult<
        Prisma.$FoodStoreItemPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many FoodStoreItems.
     * @param {FoodStoreItemCreateManyArgs} args - Arguments to create many FoodStoreItems.
     * @example
     * // Create many FoodStoreItems
     * const foodStoreItem = await prisma.foodStoreItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends FoodStoreItemCreateManyArgs>(
      args?: SelectSubset<T, FoodStoreItemCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many FoodStoreItems and returns the data saved in the database.
     * @param {FoodStoreItemCreateManyAndReturnArgs} args - Arguments to create many FoodStoreItems.
     * @example
     * // Create many FoodStoreItems
     * const foodStoreItem = await prisma.foodStoreItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many FoodStoreItems and only return the `id`
     * const foodStoreItemWithIdOnly = await prisma.foodStoreItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends FoodStoreItemCreateManyAndReturnArgs>(
      args?: SelectSubset<T, FoodStoreItemCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$FoodStoreItemPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a FoodStoreItem.
     * @param {FoodStoreItemDeleteArgs} args - Arguments to delete one FoodStoreItem.
     * @example
     * // Delete one FoodStoreItem
     * const FoodStoreItem = await prisma.foodStoreItem.delete({
     *   where: {
     *     // ... filter to delete one FoodStoreItem
     *   }
     * })
     *
     */
    delete<T extends FoodStoreItemDeleteArgs>(
      args: SelectSubset<T, FoodStoreItemDeleteArgs<ExtArgs>>,
    ): Prisma__FoodStoreItemClient<
      $Result.GetResult<
        Prisma.$FoodStoreItemPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one FoodStoreItem.
     * @param {FoodStoreItemUpdateArgs} args - Arguments to update one FoodStoreItem.
     * @example
     * // Update one FoodStoreItem
     * const foodStoreItem = await prisma.foodStoreItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends FoodStoreItemUpdateArgs>(
      args: SelectSubset<T, FoodStoreItemUpdateArgs<ExtArgs>>,
    ): Prisma__FoodStoreItemClient<
      $Result.GetResult<
        Prisma.$FoodStoreItemPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more FoodStoreItems.
     * @param {FoodStoreItemDeleteManyArgs} args - Arguments to filter FoodStoreItems to delete.
     * @example
     * // Delete a few FoodStoreItems
     * const { count } = await prisma.foodStoreItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends FoodStoreItemDeleteManyArgs>(
      args?: SelectSubset<T, FoodStoreItemDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more FoodStoreItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodStoreItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FoodStoreItems
     * const foodStoreItem = await prisma.foodStoreItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends FoodStoreItemUpdateManyArgs>(
      args: SelectSubset<T, FoodStoreItemUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more FoodStoreItems and returns the data updated in the database.
     * @param {FoodStoreItemUpdateManyAndReturnArgs} args - Arguments to update many FoodStoreItems.
     * @example
     * // Update many FoodStoreItems
     * const foodStoreItem = await prisma.foodStoreItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more FoodStoreItems and only return the `id`
     * const foodStoreItemWithIdOnly = await prisma.foodStoreItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends FoodStoreItemUpdateManyAndReturnArgs>(
      args: SelectSubset<T, FoodStoreItemUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$FoodStoreItemPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one FoodStoreItem.
     * @param {FoodStoreItemUpsertArgs} args - Arguments to update or create a FoodStoreItem.
     * @example
     * // Update or create a FoodStoreItem
     * const foodStoreItem = await prisma.foodStoreItem.upsert({
     *   create: {
     *     // ... data to create a FoodStoreItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FoodStoreItem we want to update
     *   }
     * })
     */
    upsert<T extends FoodStoreItemUpsertArgs>(
      args: SelectSubset<T, FoodStoreItemUpsertArgs<ExtArgs>>,
    ): Prisma__FoodStoreItemClient<
      $Result.GetResult<
        Prisma.$FoodStoreItemPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of FoodStoreItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodStoreItemCountArgs} args - Arguments to filter FoodStoreItems to count.
     * @example
     * // Count the number of FoodStoreItems
     * const count = await prisma.foodStoreItem.count({
     *   where: {
     *     // ... the filter for the FoodStoreItems we want to count
     *   }
     * })
     **/
    count<T extends FoodStoreItemCountArgs>(
      args?: Subset<T, FoodStoreItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], FoodStoreItemCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a FoodStoreItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodStoreItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends FoodStoreItemAggregateArgs>(
      args: Subset<T, FoodStoreItemAggregateArgs>,
    ): Prisma.PrismaPromise<GetFoodStoreItemAggregateType<T>>;

    /**
     * Group by FoodStoreItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodStoreItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends FoodStoreItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FoodStoreItemGroupByArgs["orderBy"] }
        : { orderBy?: FoodStoreItemGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, FoodStoreItemGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetFoodStoreItemGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the FoodStoreItem model
     */
    readonly fields: FoodStoreItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FoodStoreItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FoodStoreItemClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    consumptions<T extends FoodStoreItem$consumptionsArgs<ExtArgs> = {}>(
      args?: Subset<T, FoodStoreItem$consumptionsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$FoodConsumptionPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    asset<T extends AssetDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, AssetDefaultArgs<ExtArgs>>,
    ): Prisma__AssetClient<
      | $Result.GetResult<
          Prisma.$AssetPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    supplier<T extends FoodStoreItem$supplierArgs<ExtArgs> = {}>(
      args?: Subset<T, FoodStoreItem$supplierArgs<ExtArgs>>,
    ): Prisma__SupplierClient<
      $Result.GetResult<
        Prisma.$SupplierPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    individualFoodStoreItems<
      T extends FoodStoreItem$individualFoodStoreItemsArgs<ExtArgs> = {},
    >(
      args?: Subset<T, FoodStoreItem$individualFoodStoreItemsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$IndividualFoodStoreItemPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the FoodStoreItem model
   */
  interface FoodStoreItemFieldRefs {
    readonly id: FieldRef<"FoodStoreItem", "String">;
    readonly assetId: FieldRef<"FoodStoreItem", "String">;
    readonly foodName: FieldRef<"FoodStoreItem", "String">;
    readonly unit: FieldRef<"FoodStoreItem", "AssetUnit">;
    readonly quantity: FieldRef<"FoodStoreItem", "Float">;
    readonly createdAt: FieldRef<"FoodStoreItem", "DateTime">;
    readonly updatedAt: FieldRef<"FoodStoreItem", "DateTime">;
    readonly supplierId: FieldRef<"FoodStoreItem", "String">;
    readonly trackQuantity: FieldRef<"FoodStoreItem", "Boolean">;
    readonly status: FieldRef<"FoodStoreItem", "AssetItemStatus">;
    readonly isConsumable: FieldRef<"FoodStoreItem", "Boolean">;
  }

  // Custom InputTypes
  /**
   * FoodStoreItem findUnique
   */
  export type FoodStoreItemFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FoodStoreItem
     */
    select?: FoodStoreItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FoodStoreItem
     */
    omit?: FoodStoreItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodStoreItemInclude<ExtArgs> | null;
    /**
     * Filter, which FoodStoreItem to fetch.
     */
    where: FoodStoreItemWhereUniqueInput;
  };

  /**
   * FoodStoreItem findUniqueOrThrow
   */
  export type FoodStoreItemFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FoodStoreItem
     */
    select?: FoodStoreItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FoodStoreItem
     */
    omit?: FoodStoreItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodStoreItemInclude<ExtArgs> | null;
    /**
     * Filter, which FoodStoreItem to fetch.
     */
    where: FoodStoreItemWhereUniqueInput;
  };

  /**
   * FoodStoreItem findFirst
   */
  export type FoodStoreItemFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FoodStoreItem
     */
    select?: FoodStoreItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FoodStoreItem
     */
    omit?: FoodStoreItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodStoreItemInclude<ExtArgs> | null;
    /**
     * Filter, which FoodStoreItem to fetch.
     */
    where?: FoodStoreItemWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FoodStoreItems to fetch.
     */
    orderBy?:
      | FoodStoreItemOrderByWithRelationInput
      | FoodStoreItemOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for FoodStoreItems.
     */
    cursor?: FoodStoreItemWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FoodStoreItems from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FoodStoreItems.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of FoodStoreItems.
     */
    distinct?: FoodStoreItemScalarFieldEnum | FoodStoreItemScalarFieldEnum[];
  };

  /**
   * FoodStoreItem findFirstOrThrow
   */
  export type FoodStoreItemFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FoodStoreItem
     */
    select?: FoodStoreItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FoodStoreItem
     */
    omit?: FoodStoreItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodStoreItemInclude<ExtArgs> | null;
    /**
     * Filter, which FoodStoreItem to fetch.
     */
    where?: FoodStoreItemWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FoodStoreItems to fetch.
     */
    orderBy?:
      | FoodStoreItemOrderByWithRelationInput
      | FoodStoreItemOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for FoodStoreItems.
     */
    cursor?: FoodStoreItemWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FoodStoreItems from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FoodStoreItems.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of FoodStoreItems.
     */
    distinct?: FoodStoreItemScalarFieldEnum | FoodStoreItemScalarFieldEnum[];
  };

  /**
   * FoodStoreItem findMany
   */
  export type FoodStoreItemFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FoodStoreItem
     */
    select?: FoodStoreItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FoodStoreItem
     */
    omit?: FoodStoreItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodStoreItemInclude<ExtArgs> | null;
    /**
     * Filter, which FoodStoreItems to fetch.
     */
    where?: FoodStoreItemWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FoodStoreItems to fetch.
     */
    orderBy?:
      | FoodStoreItemOrderByWithRelationInput
      | FoodStoreItemOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing FoodStoreItems.
     */
    cursor?: FoodStoreItemWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FoodStoreItems from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FoodStoreItems.
     */
    skip?: number;
    distinct?: FoodStoreItemScalarFieldEnum | FoodStoreItemScalarFieldEnum[];
  };

  /**
   * FoodStoreItem create
   */
  export type FoodStoreItemCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FoodStoreItem
     */
    select?: FoodStoreItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FoodStoreItem
     */
    omit?: FoodStoreItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodStoreItemInclude<ExtArgs> | null;
    /**
     * The data needed to create a FoodStoreItem.
     */
    data: XOR<FoodStoreItemCreateInput, FoodStoreItemUncheckedCreateInput>;
  };

  /**
   * FoodStoreItem createMany
   */
  export type FoodStoreItemCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many FoodStoreItems.
     */
    data: FoodStoreItemCreateManyInput | FoodStoreItemCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * FoodStoreItem createManyAndReturn
   */
  export type FoodStoreItemCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FoodStoreItem
     */
    select?: FoodStoreItemSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the FoodStoreItem
     */
    omit?: FoodStoreItemOmit<ExtArgs> | null;
    /**
     * The data used to create many FoodStoreItems.
     */
    data: FoodStoreItemCreateManyInput | FoodStoreItemCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodStoreItemIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * FoodStoreItem update
   */
  export type FoodStoreItemUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FoodStoreItem
     */
    select?: FoodStoreItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FoodStoreItem
     */
    omit?: FoodStoreItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodStoreItemInclude<ExtArgs> | null;
    /**
     * The data needed to update a FoodStoreItem.
     */
    data: XOR<FoodStoreItemUpdateInput, FoodStoreItemUncheckedUpdateInput>;
    /**
     * Choose, which FoodStoreItem to update.
     */
    where: FoodStoreItemWhereUniqueInput;
  };

  /**
   * FoodStoreItem updateMany
   */
  export type FoodStoreItemUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update FoodStoreItems.
     */
    data: XOR<
      FoodStoreItemUpdateManyMutationInput,
      FoodStoreItemUncheckedUpdateManyInput
    >;
    /**
     * Filter which FoodStoreItems to update
     */
    where?: FoodStoreItemWhereInput;
    /**
     * Limit how many FoodStoreItems to update.
     */
    limit?: number;
  };

  /**
   * FoodStoreItem updateManyAndReturn
   */
  export type FoodStoreItemUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FoodStoreItem
     */
    select?: FoodStoreItemSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the FoodStoreItem
     */
    omit?: FoodStoreItemOmit<ExtArgs> | null;
    /**
     * The data used to update FoodStoreItems.
     */
    data: XOR<
      FoodStoreItemUpdateManyMutationInput,
      FoodStoreItemUncheckedUpdateManyInput
    >;
    /**
     * Filter which FoodStoreItems to update
     */
    where?: FoodStoreItemWhereInput;
    /**
     * Limit how many FoodStoreItems to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodStoreItemIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * FoodStoreItem upsert
   */
  export type FoodStoreItemUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FoodStoreItem
     */
    select?: FoodStoreItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FoodStoreItem
     */
    omit?: FoodStoreItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodStoreItemInclude<ExtArgs> | null;
    /**
     * The filter to search for the FoodStoreItem to update in case it exists.
     */
    where: FoodStoreItemWhereUniqueInput;
    /**
     * In case the FoodStoreItem found by the `where` argument doesn't exist, create a new FoodStoreItem with this data.
     */
    create: XOR<FoodStoreItemCreateInput, FoodStoreItemUncheckedCreateInput>;
    /**
     * In case the FoodStoreItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FoodStoreItemUpdateInput, FoodStoreItemUncheckedUpdateInput>;
  };

  /**
   * FoodStoreItem delete
   */
  export type FoodStoreItemDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FoodStoreItem
     */
    select?: FoodStoreItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FoodStoreItem
     */
    omit?: FoodStoreItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodStoreItemInclude<ExtArgs> | null;
    /**
     * Filter which FoodStoreItem to delete.
     */
    where: FoodStoreItemWhereUniqueInput;
  };

  /**
   * FoodStoreItem deleteMany
   */
  export type FoodStoreItemDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which FoodStoreItems to delete
     */
    where?: FoodStoreItemWhereInput;
    /**
     * Limit how many FoodStoreItems to delete.
     */
    limit?: number;
  };

  /**
   * FoodStoreItem.consumptions
   */
  export type FoodStoreItem$consumptionsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FoodConsumption
     */
    select?: FoodConsumptionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FoodConsumption
     */
    omit?: FoodConsumptionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodConsumptionInclude<ExtArgs> | null;
    where?: FoodConsumptionWhereInput;
    orderBy?:
      | FoodConsumptionOrderByWithRelationInput
      | FoodConsumptionOrderByWithRelationInput[];
    cursor?: FoodConsumptionWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?:
      | FoodConsumptionScalarFieldEnum
      | FoodConsumptionScalarFieldEnum[];
  };

  /**
   * FoodStoreItem.supplier
   */
  export type FoodStoreItem$supplierArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null;
    where?: SupplierWhereInput;
  };

  /**
   * FoodStoreItem.individualFoodStoreItems
   */
  export type FoodStoreItem$individualFoodStoreItemsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IndividualFoodStoreItem
     */
    select?: IndividualFoodStoreItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the IndividualFoodStoreItem
     */
    omit?: IndividualFoodStoreItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndividualFoodStoreItemInclude<ExtArgs> | null;
    where?: IndividualFoodStoreItemWhereInput;
    orderBy?:
      | IndividualFoodStoreItemOrderByWithRelationInput
      | IndividualFoodStoreItemOrderByWithRelationInput[];
    cursor?: IndividualFoodStoreItemWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?:
      | IndividualFoodStoreItemScalarFieldEnum
      | IndividualFoodStoreItemScalarFieldEnum[];
  };

  /**
   * FoodStoreItem without action
   */
  export type FoodStoreItemDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FoodStoreItem
     */
    select?: FoodStoreItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FoodStoreItem
     */
    omit?: FoodStoreItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodStoreItemInclude<ExtArgs> | null;
  };

  /**
   * Model IndividualFoodStoreItem
   */

  export type AggregateIndividualFoodStoreItem = {
    _count: IndividualFoodStoreItemCountAggregateOutputType | null;
    _min: IndividualFoodStoreItemMinAggregateOutputType | null;
    _max: IndividualFoodStoreItemMaxAggregateOutputType | null;
  };

  export type IndividualFoodStoreItemMinAggregateOutputType = {
    id: string | null;
    foodStoreItemId: string | null;
    uniqueIdentifier: string | null;
    status: $Enums.AssetStatus | null;
    condition: $Enums.AssetCondition | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type IndividualFoodStoreItemMaxAggregateOutputType = {
    id: string | null;
    foodStoreItemId: string | null;
    uniqueIdentifier: string | null;
    status: $Enums.AssetStatus | null;
    condition: $Enums.AssetCondition | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type IndividualFoodStoreItemCountAggregateOutputType = {
    id: number;
    foodStoreItemId: number;
    uniqueIdentifier: number;
    status: number;
    condition: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type IndividualFoodStoreItemMinAggregateInputType = {
    id?: true;
    foodStoreItemId?: true;
    uniqueIdentifier?: true;
    status?: true;
    condition?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type IndividualFoodStoreItemMaxAggregateInputType = {
    id?: true;
    foodStoreItemId?: true;
    uniqueIdentifier?: true;
    status?: true;
    condition?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type IndividualFoodStoreItemCountAggregateInputType = {
    id?: true;
    foodStoreItemId?: true;
    uniqueIdentifier?: true;
    status?: true;
    condition?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type IndividualFoodStoreItemAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which IndividualFoodStoreItem to aggregate.
     */
    where?: IndividualFoodStoreItemWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of IndividualFoodStoreItems to fetch.
     */
    orderBy?:
      | IndividualFoodStoreItemOrderByWithRelationInput
      | IndividualFoodStoreItemOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: IndividualFoodStoreItemWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` IndividualFoodStoreItems from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` IndividualFoodStoreItems.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned IndividualFoodStoreItems
     **/
    _count?: true | IndividualFoodStoreItemCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: IndividualFoodStoreItemMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: IndividualFoodStoreItemMaxAggregateInputType;
  };

  export type GetIndividualFoodStoreItemAggregateType<
    T extends IndividualFoodStoreItemAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateIndividualFoodStoreItem]: P extends
      | "_count"
      | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIndividualFoodStoreItem[P]>
      : GetScalarType<T[P], AggregateIndividualFoodStoreItem[P]>;
  };

  export type IndividualFoodStoreItemGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: IndividualFoodStoreItemWhereInput;
    orderBy?:
      | IndividualFoodStoreItemOrderByWithAggregationInput
      | IndividualFoodStoreItemOrderByWithAggregationInput[];
    by:
      | IndividualFoodStoreItemScalarFieldEnum[]
      | IndividualFoodStoreItemScalarFieldEnum;
    having?: IndividualFoodStoreItemScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: IndividualFoodStoreItemCountAggregateInputType | true;
    _min?: IndividualFoodStoreItemMinAggregateInputType;
    _max?: IndividualFoodStoreItemMaxAggregateInputType;
  };

  export type IndividualFoodStoreItemGroupByOutputType = {
    id: string;
    foodStoreItemId: string;
    uniqueIdentifier: string | null;
    status: $Enums.AssetStatus;
    condition: $Enums.AssetCondition;
    createdAt: Date;
    updatedAt: Date;
    _count: IndividualFoodStoreItemCountAggregateOutputType | null;
    _min: IndividualFoodStoreItemMinAggregateOutputType | null;
    _max: IndividualFoodStoreItemMaxAggregateOutputType | null;
  };

  type GetIndividualFoodStoreItemGroupByPayload<
    T extends IndividualFoodStoreItemGroupByArgs,
  > = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IndividualFoodStoreItemGroupByOutputType, T["by"]> & {
        [P in keyof T &
          keyof IndividualFoodStoreItemGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], IndividualFoodStoreItemGroupByOutputType[P]>
          : GetScalarType<T[P], IndividualFoodStoreItemGroupByOutputType[P]>;
      }
    >
  >;

  export type IndividualFoodStoreItemSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      foodStoreItemId?: boolean;
      uniqueIdentifier?: boolean;
      status?: boolean;
      condition?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      assetDamages?:
        | boolean
        | IndividualFoodStoreItem$assetDamagesArgs<ExtArgs>;
      foodStoreItem?: boolean | FoodStoreItemDefaultArgs<ExtArgs>;
      _count?:
        | boolean
        | IndividualFoodStoreItemCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["individualFoodStoreItem"]
  >;

  export type IndividualFoodStoreItemSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      foodStoreItemId?: boolean;
      uniqueIdentifier?: boolean;
      status?: boolean;
      condition?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      foodStoreItem?: boolean | FoodStoreItemDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["individualFoodStoreItem"]
  >;

  export type IndividualFoodStoreItemSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      foodStoreItemId?: boolean;
      uniqueIdentifier?: boolean;
      status?: boolean;
      condition?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      foodStoreItem?: boolean | FoodStoreItemDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["individualFoodStoreItem"]
  >;

  export type IndividualFoodStoreItemSelectScalar = {
    id?: boolean;
    foodStoreItemId?: boolean;
    uniqueIdentifier?: boolean;
    status?: boolean;
    condition?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type IndividualFoodStoreItemOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | "id"
    | "foodStoreItemId"
    | "uniqueIdentifier"
    | "status"
    | "condition"
    | "createdAt"
    | "updatedAt",
    ExtArgs["result"]["individualFoodStoreItem"]
  >;
  export type IndividualFoodStoreItemInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    assetDamages?: boolean | IndividualFoodStoreItem$assetDamagesArgs<ExtArgs>;
    foodStoreItem?: boolean | FoodStoreItemDefaultArgs<ExtArgs>;
    _count?:
      | boolean
      | IndividualFoodStoreItemCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type IndividualFoodStoreItemIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    foodStoreItem?: boolean | FoodStoreItemDefaultArgs<ExtArgs>;
  };
  export type IndividualFoodStoreItemIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    foodStoreItem?: boolean | FoodStoreItemDefaultArgs<ExtArgs>;
  };

  export type $IndividualFoodStoreItemPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "IndividualFoodStoreItem";
    objects: {
      assetDamages: Prisma.$AssetDamagePayload<ExtArgs>[];
      foodStoreItem: Prisma.$FoodStoreItemPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        foodStoreItemId: string;
        uniqueIdentifier: string | null;
        status: $Enums.AssetStatus;
        condition: $Enums.AssetCondition;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs["result"]["individualFoodStoreItem"]
    >;
    composites: {};
  };

  type IndividualFoodStoreItemGetPayload<
    S extends boolean | null | undefined | IndividualFoodStoreItemDefaultArgs,
  > = $Result.GetResult<Prisma.$IndividualFoodStoreItemPayload, S>;

  type IndividualFoodStoreItemCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    IndividualFoodStoreItemFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: IndividualFoodStoreItemCountAggregateInputType | true;
  };

  export interface IndividualFoodStoreItemDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["IndividualFoodStoreItem"];
      meta: { name: "IndividualFoodStoreItem" };
    };
    /**
     * Find zero or one IndividualFoodStoreItem that matches the filter.
     * @param {IndividualFoodStoreItemFindUniqueArgs} args - Arguments to find a IndividualFoodStoreItem
     * @example
     * // Get one IndividualFoodStoreItem
     * const individualFoodStoreItem = await prisma.individualFoodStoreItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IndividualFoodStoreItemFindUniqueArgs>(
      args: SelectSubset<T, IndividualFoodStoreItemFindUniqueArgs<ExtArgs>>,
    ): Prisma__IndividualFoodStoreItemClient<
      $Result.GetResult<
        Prisma.$IndividualFoodStoreItemPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one IndividualFoodStoreItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {IndividualFoodStoreItemFindUniqueOrThrowArgs} args - Arguments to find a IndividualFoodStoreItem
     * @example
     * // Get one IndividualFoodStoreItem
     * const individualFoodStoreItem = await prisma.individualFoodStoreItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IndividualFoodStoreItemFindUniqueOrThrowArgs>(
      args: SelectSubset<
        T,
        IndividualFoodStoreItemFindUniqueOrThrowArgs<ExtArgs>
      >,
    ): Prisma__IndividualFoodStoreItemClient<
      $Result.GetResult<
        Prisma.$IndividualFoodStoreItemPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first IndividualFoodStoreItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndividualFoodStoreItemFindFirstArgs} args - Arguments to find a IndividualFoodStoreItem
     * @example
     * // Get one IndividualFoodStoreItem
     * const individualFoodStoreItem = await prisma.individualFoodStoreItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IndividualFoodStoreItemFindFirstArgs>(
      args?: SelectSubset<T, IndividualFoodStoreItemFindFirstArgs<ExtArgs>>,
    ): Prisma__IndividualFoodStoreItemClient<
      $Result.GetResult<
        Prisma.$IndividualFoodStoreItemPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first IndividualFoodStoreItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndividualFoodStoreItemFindFirstOrThrowArgs} args - Arguments to find a IndividualFoodStoreItem
     * @example
     * // Get one IndividualFoodStoreItem
     * const individualFoodStoreItem = await prisma.individualFoodStoreItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IndividualFoodStoreItemFindFirstOrThrowArgs>(
      args?: SelectSubset<
        T,
        IndividualFoodStoreItemFindFirstOrThrowArgs<ExtArgs>
      >,
    ): Prisma__IndividualFoodStoreItemClient<
      $Result.GetResult<
        Prisma.$IndividualFoodStoreItemPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more IndividualFoodStoreItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndividualFoodStoreItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IndividualFoodStoreItems
     * const individualFoodStoreItems = await prisma.individualFoodStoreItem.findMany()
     *
     * // Get first 10 IndividualFoodStoreItems
     * const individualFoodStoreItems = await prisma.individualFoodStoreItem.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const individualFoodStoreItemWithIdOnly = await prisma.individualFoodStoreItem.findMany({ select: { id: true } })
     *
     */
    findMany<T extends IndividualFoodStoreItemFindManyArgs>(
      args?: SelectSubset<T, IndividualFoodStoreItemFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$IndividualFoodStoreItemPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a IndividualFoodStoreItem.
     * @param {IndividualFoodStoreItemCreateArgs} args - Arguments to create a IndividualFoodStoreItem.
     * @example
     * // Create one IndividualFoodStoreItem
     * const IndividualFoodStoreItem = await prisma.individualFoodStoreItem.create({
     *   data: {
     *     // ... data to create a IndividualFoodStoreItem
     *   }
     * })
     *
     */
    create<T extends IndividualFoodStoreItemCreateArgs>(
      args: SelectSubset<T, IndividualFoodStoreItemCreateArgs<ExtArgs>>,
    ): Prisma__IndividualFoodStoreItemClient<
      $Result.GetResult<
        Prisma.$IndividualFoodStoreItemPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many IndividualFoodStoreItems.
     * @param {IndividualFoodStoreItemCreateManyArgs} args - Arguments to create many IndividualFoodStoreItems.
     * @example
     * // Create many IndividualFoodStoreItems
     * const individualFoodStoreItem = await prisma.individualFoodStoreItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends IndividualFoodStoreItemCreateManyArgs>(
      args?: SelectSubset<T, IndividualFoodStoreItemCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many IndividualFoodStoreItems and returns the data saved in the database.
     * @param {IndividualFoodStoreItemCreateManyAndReturnArgs} args - Arguments to create many IndividualFoodStoreItems.
     * @example
     * // Create many IndividualFoodStoreItems
     * const individualFoodStoreItem = await prisma.individualFoodStoreItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many IndividualFoodStoreItems and only return the `id`
     * const individualFoodStoreItemWithIdOnly = await prisma.individualFoodStoreItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<
      T extends IndividualFoodStoreItemCreateManyAndReturnArgs,
    >(
      args?: SelectSubset<
        T,
        IndividualFoodStoreItemCreateManyAndReturnArgs<ExtArgs>
      >,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$IndividualFoodStoreItemPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a IndividualFoodStoreItem.
     * @param {IndividualFoodStoreItemDeleteArgs} args - Arguments to delete one IndividualFoodStoreItem.
     * @example
     * // Delete one IndividualFoodStoreItem
     * const IndividualFoodStoreItem = await prisma.individualFoodStoreItem.delete({
     *   where: {
     *     // ... filter to delete one IndividualFoodStoreItem
     *   }
     * })
     *
     */
    delete<T extends IndividualFoodStoreItemDeleteArgs>(
      args: SelectSubset<T, IndividualFoodStoreItemDeleteArgs<ExtArgs>>,
    ): Prisma__IndividualFoodStoreItemClient<
      $Result.GetResult<
        Prisma.$IndividualFoodStoreItemPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one IndividualFoodStoreItem.
     * @param {IndividualFoodStoreItemUpdateArgs} args - Arguments to update one IndividualFoodStoreItem.
     * @example
     * // Update one IndividualFoodStoreItem
     * const individualFoodStoreItem = await prisma.individualFoodStoreItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends IndividualFoodStoreItemUpdateArgs>(
      args: SelectSubset<T, IndividualFoodStoreItemUpdateArgs<ExtArgs>>,
    ): Prisma__IndividualFoodStoreItemClient<
      $Result.GetResult<
        Prisma.$IndividualFoodStoreItemPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more IndividualFoodStoreItems.
     * @param {IndividualFoodStoreItemDeleteManyArgs} args - Arguments to filter IndividualFoodStoreItems to delete.
     * @example
     * // Delete a few IndividualFoodStoreItems
     * const { count } = await prisma.individualFoodStoreItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends IndividualFoodStoreItemDeleteManyArgs>(
      args?: SelectSubset<T, IndividualFoodStoreItemDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more IndividualFoodStoreItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndividualFoodStoreItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IndividualFoodStoreItems
     * const individualFoodStoreItem = await prisma.individualFoodStoreItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends IndividualFoodStoreItemUpdateManyArgs>(
      args: SelectSubset<T, IndividualFoodStoreItemUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more IndividualFoodStoreItems and returns the data updated in the database.
     * @param {IndividualFoodStoreItemUpdateManyAndReturnArgs} args - Arguments to update many IndividualFoodStoreItems.
     * @example
     * // Update many IndividualFoodStoreItems
     * const individualFoodStoreItem = await prisma.individualFoodStoreItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more IndividualFoodStoreItems and only return the `id`
     * const individualFoodStoreItemWithIdOnly = await prisma.individualFoodStoreItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<
      T extends IndividualFoodStoreItemUpdateManyAndReturnArgs,
    >(
      args: SelectSubset<
        T,
        IndividualFoodStoreItemUpdateManyAndReturnArgs<ExtArgs>
      >,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$IndividualFoodStoreItemPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one IndividualFoodStoreItem.
     * @param {IndividualFoodStoreItemUpsertArgs} args - Arguments to update or create a IndividualFoodStoreItem.
     * @example
     * // Update or create a IndividualFoodStoreItem
     * const individualFoodStoreItem = await prisma.individualFoodStoreItem.upsert({
     *   create: {
     *     // ... data to create a IndividualFoodStoreItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IndividualFoodStoreItem we want to update
     *   }
     * })
     */
    upsert<T extends IndividualFoodStoreItemUpsertArgs>(
      args: SelectSubset<T, IndividualFoodStoreItemUpsertArgs<ExtArgs>>,
    ): Prisma__IndividualFoodStoreItemClient<
      $Result.GetResult<
        Prisma.$IndividualFoodStoreItemPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of IndividualFoodStoreItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndividualFoodStoreItemCountArgs} args - Arguments to filter IndividualFoodStoreItems to count.
     * @example
     * // Count the number of IndividualFoodStoreItems
     * const count = await prisma.individualFoodStoreItem.count({
     *   where: {
     *     // ... the filter for the IndividualFoodStoreItems we want to count
     *   }
     * })
     **/
    count<T extends IndividualFoodStoreItemCountArgs>(
      args?: Subset<T, IndividualFoodStoreItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<
              T["select"],
              IndividualFoodStoreItemCountAggregateOutputType
            >
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a IndividualFoodStoreItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndividualFoodStoreItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends IndividualFoodStoreItemAggregateArgs>(
      args: Subset<T, IndividualFoodStoreItemAggregateArgs>,
    ): Prisma.PrismaPromise<GetIndividualFoodStoreItemAggregateType<T>>;

    /**
     * Group by IndividualFoodStoreItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndividualFoodStoreItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends IndividualFoodStoreItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IndividualFoodStoreItemGroupByArgs["orderBy"] }
        : { orderBy?: IndividualFoodStoreItemGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<
        T,
        IndividualFoodStoreItemGroupByArgs,
        OrderByArg
      > &
        InputErrors,
    ): {} extends InputErrors
      ? GetIndividualFoodStoreItemGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the IndividualFoodStoreItem model
     */
    readonly fields: IndividualFoodStoreItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IndividualFoodStoreItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IndividualFoodStoreItemClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    assetDamages<
      T extends IndividualFoodStoreItem$assetDamagesArgs<ExtArgs> = {},
    >(
      args?: Subset<T, IndividualFoodStoreItem$assetDamagesArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$AssetDamagePayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    foodStoreItem<T extends FoodStoreItemDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, FoodStoreItemDefaultArgs<ExtArgs>>,
    ): Prisma__FoodStoreItemClient<
      | $Result.GetResult<
          Prisma.$FoodStoreItemPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the IndividualFoodStoreItem model
   */
  interface IndividualFoodStoreItemFieldRefs {
    readonly id: FieldRef<"IndividualFoodStoreItem", "String">;
    readonly foodStoreItemId: FieldRef<"IndividualFoodStoreItem", "String">;
    readonly uniqueIdentifier: FieldRef<"IndividualFoodStoreItem", "String">;
    readonly status: FieldRef<"IndividualFoodStoreItem", "AssetStatus">;
    readonly condition: FieldRef<"IndividualFoodStoreItem", "AssetCondition">;
    readonly createdAt: FieldRef<"IndividualFoodStoreItem", "DateTime">;
    readonly updatedAt: FieldRef<"IndividualFoodStoreItem", "DateTime">;
  }

  // Custom InputTypes
  /**
   * IndividualFoodStoreItem findUnique
   */
  export type IndividualFoodStoreItemFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IndividualFoodStoreItem
     */
    select?: IndividualFoodStoreItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the IndividualFoodStoreItem
     */
    omit?: IndividualFoodStoreItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndividualFoodStoreItemInclude<ExtArgs> | null;
    /**
     * Filter, which IndividualFoodStoreItem to fetch.
     */
    where: IndividualFoodStoreItemWhereUniqueInput;
  };

  /**
   * IndividualFoodStoreItem findUniqueOrThrow
   */
  export type IndividualFoodStoreItemFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IndividualFoodStoreItem
     */
    select?: IndividualFoodStoreItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the IndividualFoodStoreItem
     */
    omit?: IndividualFoodStoreItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndividualFoodStoreItemInclude<ExtArgs> | null;
    /**
     * Filter, which IndividualFoodStoreItem to fetch.
     */
    where: IndividualFoodStoreItemWhereUniqueInput;
  };

  /**
   * IndividualFoodStoreItem findFirst
   */
  export type IndividualFoodStoreItemFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IndividualFoodStoreItem
     */
    select?: IndividualFoodStoreItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the IndividualFoodStoreItem
     */
    omit?: IndividualFoodStoreItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndividualFoodStoreItemInclude<ExtArgs> | null;
    /**
     * Filter, which IndividualFoodStoreItem to fetch.
     */
    where?: IndividualFoodStoreItemWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of IndividualFoodStoreItems to fetch.
     */
    orderBy?:
      | IndividualFoodStoreItemOrderByWithRelationInput
      | IndividualFoodStoreItemOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for IndividualFoodStoreItems.
     */
    cursor?: IndividualFoodStoreItemWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` IndividualFoodStoreItems from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` IndividualFoodStoreItems.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of IndividualFoodStoreItems.
     */
    distinct?:
      | IndividualFoodStoreItemScalarFieldEnum
      | IndividualFoodStoreItemScalarFieldEnum[];
  };

  /**
   * IndividualFoodStoreItem findFirstOrThrow
   */
  export type IndividualFoodStoreItemFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IndividualFoodStoreItem
     */
    select?: IndividualFoodStoreItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the IndividualFoodStoreItem
     */
    omit?: IndividualFoodStoreItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndividualFoodStoreItemInclude<ExtArgs> | null;
    /**
     * Filter, which IndividualFoodStoreItem to fetch.
     */
    where?: IndividualFoodStoreItemWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of IndividualFoodStoreItems to fetch.
     */
    orderBy?:
      | IndividualFoodStoreItemOrderByWithRelationInput
      | IndividualFoodStoreItemOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for IndividualFoodStoreItems.
     */
    cursor?: IndividualFoodStoreItemWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` IndividualFoodStoreItems from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` IndividualFoodStoreItems.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of IndividualFoodStoreItems.
     */
    distinct?:
      | IndividualFoodStoreItemScalarFieldEnum
      | IndividualFoodStoreItemScalarFieldEnum[];
  };

  /**
   * IndividualFoodStoreItem findMany
   */
  export type IndividualFoodStoreItemFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IndividualFoodStoreItem
     */
    select?: IndividualFoodStoreItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the IndividualFoodStoreItem
     */
    omit?: IndividualFoodStoreItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndividualFoodStoreItemInclude<ExtArgs> | null;
    /**
     * Filter, which IndividualFoodStoreItems to fetch.
     */
    where?: IndividualFoodStoreItemWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of IndividualFoodStoreItems to fetch.
     */
    orderBy?:
      | IndividualFoodStoreItemOrderByWithRelationInput
      | IndividualFoodStoreItemOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing IndividualFoodStoreItems.
     */
    cursor?: IndividualFoodStoreItemWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` IndividualFoodStoreItems from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` IndividualFoodStoreItems.
     */
    skip?: number;
    distinct?:
      | IndividualFoodStoreItemScalarFieldEnum
      | IndividualFoodStoreItemScalarFieldEnum[];
  };

  /**
   * IndividualFoodStoreItem create
   */
  export type IndividualFoodStoreItemCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IndividualFoodStoreItem
     */
    select?: IndividualFoodStoreItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the IndividualFoodStoreItem
     */
    omit?: IndividualFoodStoreItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndividualFoodStoreItemInclude<ExtArgs> | null;
    /**
     * The data needed to create a IndividualFoodStoreItem.
     */
    data: XOR<
      IndividualFoodStoreItemCreateInput,
      IndividualFoodStoreItemUncheckedCreateInput
    >;
  };

  /**
   * IndividualFoodStoreItem createMany
   */
  export type IndividualFoodStoreItemCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many IndividualFoodStoreItems.
     */
    data:
      | IndividualFoodStoreItemCreateManyInput
      | IndividualFoodStoreItemCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * IndividualFoodStoreItem createManyAndReturn
   */
  export type IndividualFoodStoreItemCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IndividualFoodStoreItem
     */
    select?: IndividualFoodStoreItemSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the IndividualFoodStoreItem
     */
    omit?: IndividualFoodStoreItemOmit<ExtArgs> | null;
    /**
     * The data used to create many IndividualFoodStoreItems.
     */
    data:
      | IndividualFoodStoreItemCreateManyInput
      | IndividualFoodStoreItemCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndividualFoodStoreItemIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * IndividualFoodStoreItem update
   */
  export type IndividualFoodStoreItemUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IndividualFoodStoreItem
     */
    select?: IndividualFoodStoreItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the IndividualFoodStoreItem
     */
    omit?: IndividualFoodStoreItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndividualFoodStoreItemInclude<ExtArgs> | null;
    /**
     * The data needed to update a IndividualFoodStoreItem.
     */
    data: XOR<
      IndividualFoodStoreItemUpdateInput,
      IndividualFoodStoreItemUncheckedUpdateInput
    >;
    /**
     * Choose, which IndividualFoodStoreItem to update.
     */
    where: IndividualFoodStoreItemWhereUniqueInput;
  };

  /**
   * IndividualFoodStoreItem updateMany
   */
  export type IndividualFoodStoreItemUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update IndividualFoodStoreItems.
     */
    data: XOR<
      IndividualFoodStoreItemUpdateManyMutationInput,
      IndividualFoodStoreItemUncheckedUpdateManyInput
    >;
    /**
     * Filter which IndividualFoodStoreItems to update
     */
    where?: IndividualFoodStoreItemWhereInput;
    /**
     * Limit how many IndividualFoodStoreItems to update.
     */
    limit?: number;
  };

  /**
   * IndividualFoodStoreItem updateManyAndReturn
   */
  export type IndividualFoodStoreItemUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IndividualFoodStoreItem
     */
    select?: IndividualFoodStoreItemSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the IndividualFoodStoreItem
     */
    omit?: IndividualFoodStoreItemOmit<ExtArgs> | null;
    /**
     * The data used to update IndividualFoodStoreItems.
     */
    data: XOR<
      IndividualFoodStoreItemUpdateManyMutationInput,
      IndividualFoodStoreItemUncheckedUpdateManyInput
    >;
    /**
     * Filter which IndividualFoodStoreItems to update
     */
    where?: IndividualFoodStoreItemWhereInput;
    /**
     * Limit how many IndividualFoodStoreItems to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndividualFoodStoreItemIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * IndividualFoodStoreItem upsert
   */
  export type IndividualFoodStoreItemUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IndividualFoodStoreItem
     */
    select?: IndividualFoodStoreItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the IndividualFoodStoreItem
     */
    omit?: IndividualFoodStoreItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndividualFoodStoreItemInclude<ExtArgs> | null;
    /**
     * The filter to search for the IndividualFoodStoreItem to update in case it exists.
     */
    where: IndividualFoodStoreItemWhereUniqueInput;
    /**
     * In case the IndividualFoodStoreItem found by the `where` argument doesn't exist, create a new IndividualFoodStoreItem with this data.
     */
    create: XOR<
      IndividualFoodStoreItemCreateInput,
      IndividualFoodStoreItemUncheckedCreateInput
    >;
    /**
     * In case the IndividualFoodStoreItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<
      IndividualFoodStoreItemUpdateInput,
      IndividualFoodStoreItemUncheckedUpdateInput
    >;
  };

  /**
   * IndividualFoodStoreItem delete
   */
  export type IndividualFoodStoreItemDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IndividualFoodStoreItem
     */
    select?: IndividualFoodStoreItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the IndividualFoodStoreItem
     */
    omit?: IndividualFoodStoreItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndividualFoodStoreItemInclude<ExtArgs> | null;
    /**
     * Filter which IndividualFoodStoreItem to delete.
     */
    where: IndividualFoodStoreItemWhereUniqueInput;
  };

  /**
   * IndividualFoodStoreItem deleteMany
   */
  export type IndividualFoodStoreItemDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which IndividualFoodStoreItems to delete
     */
    where?: IndividualFoodStoreItemWhereInput;
    /**
     * Limit how many IndividualFoodStoreItems to delete.
     */
    limit?: number;
  };

  /**
   * IndividualFoodStoreItem.assetDamages
   */
  export type IndividualFoodStoreItem$assetDamagesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AssetDamage
     */
    select?: AssetDamageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AssetDamage
     */
    omit?: AssetDamageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetDamageInclude<ExtArgs> | null;
    where?: AssetDamageWhereInput;
    orderBy?:
      | AssetDamageOrderByWithRelationInput
      | AssetDamageOrderByWithRelationInput[];
    cursor?: AssetDamageWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: AssetDamageScalarFieldEnum | AssetDamageScalarFieldEnum[];
  };

  /**
   * IndividualFoodStoreItem without action
   */
  export type IndividualFoodStoreItemDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IndividualFoodStoreItem
     */
    select?: IndividualFoodStoreItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the IndividualFoodStoreItem
     */
    omit?: IndividualFoodStoreItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndividualFoodStoreItemInclude<ExtArgs> | null;
  };

  /**
   * Model FoodConsumption
   */

  export type AggregateFoodConsumption = {
    _count: FoodConsumptionCountAggregateOutputType | null;
    _avg: FoodConsumptionAvgAggregateOutputType | null;
    _sum: FoodConsumptionSumAggregateOutputType | null;
    _min: FoodConsumptionMinAggregateOutputType | null;
    _max: FoodConsumptionMaxAggregateOutputType | null;
  };

  export type FoodConsumptionAvgAggregateOutputType = {
    quantityUsed: number | null;
  };

  export type FoodConsumptionSumAggregateOutputType = {
    quantityUsed: number | null;
  };

  export type FoodConsumptionMinAggregateOutputType = {
    id: string | null;
    quantityUsed: number | null;
    dateUsedAt: Date | null;
    usageDetails: string | null;
    foodStoreItemId: string | null;
  };

  export type FoodConsumptionMaxAggregateOutputType = {
    id: string | null;
    quantityUsed: number | null;
    dateUsedAt: Date | null;
    usageDetails: string | null;
    foodStoreItemId: string | null;
  };

  export type FoodConsumptionCountAggregateOutputType = {
    id: number;
    quantityUsed: number;
    dateUsedAt: number;
    usageDetails: number;
    foodStoreItemId: number;
    _all: number;
  };

  export type FoodConsumptionAvgAggregateInputType = {
    quantityUsed?: true;
  };

  export type FoodConsumptionSumAggregateInputType = {
    quantityUsed?: true;
  };

  export type FoodConsumptionMinAggregateInputType = {
    id?: true;
    quantityUsed?: true;
    dateUsedAt?: true;
    usageDetails?: true;
    foodStoreItemId?: true;
  };

  export type FoodConsumptionMaxAggregateInputType = {
    id?: true;
    quantityUsed?: true;
    dateUsedAt?: true;
    usageDetails?: true;
    foodStoreItemId?: true;
  };

  export type FoodConsumptionCountAggregateInputType = {
    id?: true;
    quantityUsed?: true;
    dateUsedAt?: true;
    usageDetails?: true;
    foodStoreItemId?: true;
    _all?: true;
  };

  export type FoodConsumptionAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which FoodConsumption to aggregate.
     */
    where?: FoodConsumptionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FoodConsumptions to fetch.
     */
    orderBy?:
      | FoodConsumptionOrderByWithRelationInput
      | FoodConsumptionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: FoodConsumptionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FoodConsumptions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FoodConsumptions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned FoodConsumptions
     **/
    _count?: true | FoodConsumptionCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: FoodConsumptionAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: FoodConsumptionSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: FoodConsumptionMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: FoodConsumptionMaxAggregateInputType;
  };

  export type GetFoodConsumptionAggregateType<
    T extends FoodConsumptionAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateFoodConsumption]: P extends
      | "_count"
      | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFoodConsumption[P]>
      : GetScalarType<T[P], AggregateFoodConsumption[P]>;
  };

  export type FoodConsumptionGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: FoodConsumptionWhereInput;
    orderBy?:
      | FoodConsumptionOrderByWithAggregationInput
      | FoodConsumptionOrderByWithAggregationInput[];
    by: FoodConsumptionScalarFieldEnum[] | FoodConsumptionScalarFieldEnum;
    having?: FoodConsumptionScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: FoodConsumptionCountAggregateInputType | true;
    _avg?: FoodConsumptionAvgAggregateInputType;
    _sum?: FoodConsumptionSumAggregateInputType;
    _min?: FoodConsumptionMinAggregateInputType;
    _max?: FoodConsumptionMaxAggregateInputType;
  };

  export type FoodConsumptionGroupByOutputType = {
    id: string;
    quantityUsed: number | null;
    dateUsedAt: Date;
    usageDetails: string | null;
    foodStoreItemId: string;
    _count: FoodConsumptionCountAggregateOutputType | null;
    _avg: FoodConsumptionAvgAggregateOutputType | null;
    _sum: FoodConsumptionSumAggregateOutputType | null;
    _min: FoodConsumptionMinAggregateOutputType | null;
    _max: FoodConsumptionMaxAggregateOutputType | null;
  };

  type GetFoodConsumptionGroupByPayload<T extends FoodConsumptionGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<FoodConsumptionGroupByOutputType, T["by"]> & {
          [P in keyof T &
            keyof FoodConsumptionGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FoodConsumptionGroupByOutputType[P]>
            : GetScalarType<T[P], FoodConsumptionGroupByOutputType[P]>;
        }
      >
    >;

  export type FoodConsumptionSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      quantityUsed?: boolean;
      dateUsedAt?: boolean;
      usageDetails?: boolean;
      foodStoreItemId?: boolean;
      foodItem?: boolean | FoodStoreItemDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["foodConsumption"]
  >;

  export type FoodConsumptionSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      quantityUsed?: boolean;
      dateUsedAt?: boolean;
      usageDetails?: boolean;
      foodStoreItemId?: boolean;
      foodItem?: boolean | FoodStoreItemDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["foodConsumption"]
  >;

  export type FoodConsumptionSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      quantityUsed?: boolean;
      dateUsedAt?: boolean;
      usageDetails?: boolean;
      foodStoreItemId?: boolean;
      foodItem?: boolean | FoodStoreItemDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["foodConsumption"]
  >;

  export type FoodConsumptionSelectScalar = {
    id?: boolean;
    quantityUsed?: boolean;
    dateUsedAt?: boolean;
    usageDetails?: boolean;
    foodStoreItemId?: boolean;
  };

  export type FoodConsumptionOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    "id" | "quantityUsed" | "dateUsedAt" | "usageDetails" | "foodStoreItemId",
    ExtArgs["result"]["foodConsumption"]
  >;
  export type FoodConsumptionInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    foodItem?: boolean | FoodStoreItemDefaultArgs<ExtArgs>;
  };
  export type FoodConsumptionIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    foodItem?: boolean | FoodStoreItemDefaultArgs<ExtArgs>;
  };
  export type FoodConsumptionIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    foodItem?: boolean | FoodStoreItemDefaultArgs<ExtArgs>;
  };

  export type $FoodConsumptionPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "FoodConsumption";
    objects: {
      foodItem: Prisma.$FoodStoreItemPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        quantityUsed: number | null;
        dateUsedAt: Date;
        usageDetails: string | null;
        foodStoreItemId: string;
      },
      ExtArgs["result"]["foodConsumption"]
    >;
    composites: {};
  };

  type FoodConsumptionGetPayload<
    S extends boolean | null | undefined | FoodConsumptionDefaultArgs,
  > = $Result.GetResult<Prisma.$FoodConsumptionPayload, S>;

  type FoodConsumptionCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    FoodConsumptionFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: FoodConsumptionCountAggregateInputType | true;
  };

  export interface FoodConsumptionDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["FoodConsumption"];
      meta: { name: "FoodConsumption" };
    };
    /**
     * Find zero or one FoodConsumption that matches the filter.
     * @param {FoodConsumptionFindUniqueArgs} args - Arguments to find a FoodConsumption
     * @example
     * // Get one FoodConsumption
     * const foodConsumption = await prisma.foodConsumption.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FoodConsumptionFindUniqueArgs>(
      args: SelectSubset<T, FoodConsumptionFindUniqueArgs<ExtArgs>>,
    ): Prisma__FoodConsumptionClient<
      $Result.GetResult<
        Prisma.$FoodConsumptionPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one FoodConsumption that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FoodConsumptionFindUniqueOrThrowArgs} args - Arguments to find a FoodConsumption
     * @example
     * // Get one FoodConsumption
     * const foodConsumption = await prisma.foodConsumption.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FoodConsumptionFindUniqueOrThrowArgs>(
      args: SelectSubset<T, FoodConsumptionFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__FoodConsumptionClient<
      $Result.GetResult<
        Prisma.$FoodConsumptionPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first FoodConsumption that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodConsumptionFindFirstArgs} args - Arguments to find a FoodConsumption
     * @example
     * // Get one FoodConsumption
     * const foodConsumption = await prisma.foodConsumption.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FoodConsumptionFindFirstArgs>(
      args?: SelectSubset<T, FoodConsumptionFindFirstArgs<ExtArgs>>,
    ): Prisma__FoodConsumptionClient<
      $Result.GetResult<
        Prisma.$FoodConsumptionPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first FoodConsumption that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodConsumptionFindFirstOrThrowArgs} args - Arguments to find a FoodConsumption
     * @example
     * // Get one FoodConsumption
     * const foodConsumption = await prisma.foodConsumption.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FoodConsumptionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, FoodConsumptionFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__FoodConsumptionClient<
      $Result.GetResult<
        Prisma.$FoodConsumptionPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more FoodConsumptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodConsumptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FoodConsumptions
     * const foodConsumptions = await prisma.foodConsumption.findMany()
     *
     * // Get first 10 FoodConsumptions
     * const foodConsumptions = await prisma.foodConsumption.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const foodConsumptionWithIdOnly = await prisma.foodConsumption.findMany({ select: { id: true } })
     *
     */
    findMany<T extends FoodConsumptionFindManyArgs>(
      args?: SelectSubset<T, FoodConsumptionFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$FoodConsumptionPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a FoodConsumption.
     * @param {FoodConsumptionCreateArgs} args - Arguments to create a FoodConsumption.
     * @example
     * // Create one FoodConsumption
     * const FoodConsumption = await prisma.foodConsumption.create({
     *   data: {
     *     // ... data to create a FoodConsumption
     *   }
     * })
     *
     */
    create<T extends FoodConsumptionCreateArgs>(
      args: SelectSubset<T, FoodConsumptionCreateArgs<ExtArgs>>,
    ): Prisma__FoodConsumptionClient<
      $Result.GetResult<
        Prisma.$FoodConsumptionPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many FoodConsumptions.
     * @param {FoodConsumptionCreateManyArgs} args - Arguments to create many FoodConsumptions.
     * @example
     * // Create many FoodConsumptions
     * const foodConsumption = await prisma.foodConsumption.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends FoodConsumptionCreateManyArgs>(
      args?: SelectSubset<T, FoodConsumptionCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many FoodConsumptions and returns the data saved in the database.
     * @param {FoodConsumptionCreateManyAndReturnArgs} args - Arguments to create many FoodConsumptions.
     * @example
     * // Create many FoodConsumptions
     * const foodConsumption = await prisma.foodConsumption.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many FoodConsumptions and only return the `id`
     * const foodConsumptionWithIdOnly = await prisma.foodConsumption.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends FoodConsumptionCreateManyAndReturnArgs>(
      args?: SelectSubset<T, FoodConsumptionCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$FoodConsumptionPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a FoodConsumption.
     * @param {FoodConsumptionDeleteArgs} args - Arguments to delete one FoodConsumption.
     * @example
     * // Delete one FoodConsumption
     * const FoodConsumption = await prisma.foodConsumption.delete({
     *   where: {
     *     // ... filter to delete one FoodConsumption
     *   }
     * })
     *
     */
    delete<T extends FoodConsumptionDeleteArgs>(
      args: SelectSubset<T, FoodConsumptionDeleteArgs<ExtArgs>>,
    ): Prisma__FoodConsumptionClient<
      $Result.GetResult<
        Prisma.$FoodConsumptionPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one FoodConsumption.
     * @param {FoodConsumptionUpdateArgs} args - Arguments to update one FoodConsumption.
     * @example
     * // Update one FoodConsumption
     * const foodConsumption = await prisma.foodConsumption.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends FoodConsumptionUpdateArgs>(
      args: SelectSubset<T, FoodConsumptionUpdateArgs<ExtArgs>>,
    ): Prisma__FoodConsumptionClient<
      $Result.GetResult<
        Prisma.$FoodConsumptionPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more FoodConsumptions.
     * @param {FoodConsumptionDeleteManyArgs} args - Arguments to filter FoodConsumptions to delete.
     * @example
     * // Delete a few FoodConsumptions
     * const { count } = await prisma.foodConsumption.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends FoodConsumptionDeleteManyArgs>(
      args?: SelectSubset<T, FoodConsumptionDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more FoodConsumptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodConsumptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FoodConsumptions
     * const foodConsumption = await prisma.foodConsumption.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends FoodConsumptionUpdateManyArgs>(
      args: SelectSubset<T, FoodConsumptionUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more FoodConsumptions and returns the data updated in the database.
     * @param {FoodConsumptionUpdateManyAndReturnArgs} args - Arguments to update many FoodConsumptions.
     * @example
     * // Update many FoodConsumptions
     * const foodConsumption = await prisma.foodConsumption.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more FoodConsumptions and only return the `id`
     * const foodConsumptionWithIdOnly = await prisma.foodConsumption.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends FoodConsumptionUpdateManyAndReturnArgs>(
      args: SelectSubset<T, FoodConsumptionUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$FoodConsumptionPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one FoodConsumption.
     * @param {FoodConsumptionUpsertArgs} args - Arguments to update or create a FoodConsumption.
     * @example
     * // Update or create a FoodConsumption
     * const foodConsumption = await prisma.foodConsumption.upsert({
     *   create: {
     *     // ... data to create a FoodConsumption
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FoodConsumption we want to update
     *   }
     * })
     */
    upsert<T extends FoodConsumptionUpsertArgs>(
      args: SelectSubset<T, FoodConsumptionUpsertArgs<ExtArgs>>,
    ): Prisma__FoodConsumptionClient<
      $Result.GetResult<
        Prisma.$FoodConsumptionPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of FoodConsumptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodConsumptionCountArgs} args - Arguments to filter FoodConsumptions to count.
     * @example
     * // Count the number of FoodConsumptions
     * const count = await prisma.foodConsumption.count({
     *   where: {
     *     // ... the filter for the FoodConsumptions we want to count
     *   }
     * })
     **/
    count<T extends FoodConsumptionCountArgs>(
      args?: Subset<T, FoodConsumptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], FoodConsumptionCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a FoodConsumption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodConsumptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends FoodConsumptionAggregateArgs>(
      args: Subset<T, FoodConsumptionAggregateArgs>,
    ): Prisma.PrismaPromise<GetFoodConsumptionAggregateType<T>>;

    /**
     * Group by FoodConsumption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodConsumptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends FoodConsumptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FoodConsumptionGroupByArgs["orderBy"] }
        : { orderBy?: FoodConsumptionGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, FoodConsumptionGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetFoodConsumptionGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the FoodConsumption model
     */
    readonly fields: FoodConsumptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FoodConsumption.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FoodConsumptionClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    foodItem<T extends FoodStoreItemDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, FoodStoreItemDefaultArgs<ExtArgs>>,
    ): Prisma__FoodStoreItemClient<
      | $Result.GetResult<
          Prisma.$FoodStoreItemPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the FoodConsumption model
   */
  interface FoodConsumptionFieldRefs {
    readonly id: FieldRef<"FoodConsumption", "String">;
    readonly quantityUsed: FieldRef<"FoodConsumption", "Float">;
    readonly dateUsedAt: FieldRef<"FoodConsumption", "DateTime">;
    readonly usageDetails: FieldRef<"FoodConsumption", "String">;
    readonly foodStoreItemId: FieldRef<"FoodConsumption", "String">;
  }

  // Custom InputTypes
  /**
   * FoodConsumption findUnique
   */
  export type FoodConsumptionFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FoodConsumption
     */
    select?: FoodConsumptionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FoodConsumption
     */
    omit?: FoodConsumptionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodConsumptionInclude<ExtArgs> | null;
    /**
     * Filter, which FoodConsumption to fetch.
     */
    where: FoodConsumptionWhereUniqueInput;
  };

  /**
   * FoodConsumption findUniqueOrThrow
   */
  export type FoodConsumptionFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FoodConsumption
     */
    select?: FoodConsumptionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FoodConsumption
     */
    omit?: FoodConsumptionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodConsumptionInclude<ExtArgs> | null;
    /**
     * Filter, which FoodConsumption to fetch.
     */
    where: FoodConsumptionWhereUniqueInput;
  };

  /**
   * FoodConsumption findFirst
   */
  export type FoodConsumptionFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FoodConsumption
     */
    select?: FoodConsumptionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FoodConsumption
     */
    omit?: FoodConsumptionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodConsumptionInclude<ExtArgs> | null;
    /**
     * Filter, which FoodConsumption to fetch.
     */
    where?: FoodConsumptionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FoodConsumptions to fetch.
     */
    orderBy?:
      | FoodConsumptionOrderByWithRelationInput
      | FoodConsumptionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for FoodConsumptions.
     */
    cursor?: FoodConsumptionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FoodConsumptions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FoodConsumptions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of FoodConsumptions.
     */
    distinct?:
      | FoodConsumptionScalarFieldEnum
      | FoodConsumptionScalarFieldEnum[];
  };

  /**
   * FoodConsumption findFirstOrThrow
   */
  export type FoodConsumptionFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FoodConsumption
     */
    select?: FoodConsumptionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FoodConsumption
     */
    omit?: FoodConsumptionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodConsumptionInclude<ExtArgs> | null;
    /**
     * Filter, which FoodConsumption to fetch.
     */
    where?: FoodConsumptionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FoodConsumptions to fetch.
     */
    orderBy?:
      | FoodConsumptionOrderByWithRelationInput
      | FoodConsumptionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for FoodConsumptions.
     */
    cursor?: FoodConsumptionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FoodConsumptions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FoodConsumptions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of FoodConsumptions.
     */
    distinct?:
      | FoodConsumptionScalarFieldEnum
      | FoodConsumptionScalarFieldEnum[];
  };

  /**
   * FoodConsumption findMany
   */
  export type FoodConsumptionFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FoodConsumption
     */
    select?: FoodConsumptionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FoodConsumption
     */
    omit?: FoodConsumptionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodConsumptionInclude<ExtArgs> | null;
    /**
     * Filter, which FoodConsumptions to fetch.
     */
    where?: FoodConsumptionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FoodConsumptions to fetch.
     */
    orderBy?:
      | FoodConsumptionOrderByWithRelationInput
      | FoodConsumptionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing FoodConsumptions.
     */
    cursor?: FoodConsumptionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FoodConsumptions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FoodConsumptions.
     */
    skip?: number;
    distinct?:
      | FoodConsumptionScalarFieldEnum
      | FoodConsumptionScalarFieldEnum[];
  };

  /**
   * FoodConsumption create
   */
  export type FoodConsumptionCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FoodConsumption
     */
    select?: FoodConsumptionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FoodConsumption
     */
    omit?: FoodConsumptionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodConsumptionInclude<ExtArgs> | null;
    /**
     * The data needed to create a FoodConsumption.
     */
    data: XOR<FoodConsumptionCreateInput, FoodConsumptionUncheckedCreateInput>;
  };

  /**
   * FoodConsumption createMany
   */
  export type FoodConsumptionCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many FoodConsumptions.
     */
    data: FoodConsumptionCreateManyInput | FoodConsumptionCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * FoodConsumption createManyAndReturn
   */
  export type FoodConsumptionCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FoodConsumption
     */
    select?: FoodConsumptionSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the FoodConsumption
     */
    omit?: FoodConsumptionOmit<ExtArgs> | null;
    /**
     * The data used to create many FoodConsumptions.
     */
    data: FoodConsumptionCreateManyInput | FoodConsumptionCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodConsumptionIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * FoodConsumption update
   */
  export type FoodConsumptionUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FoodConsumption
     */
    select?: FoodConsumptionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FoodConsumption
     */
    omit?: FoodConsumptionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodConsumptionInclude<ExtArgs> | null;
    /**
     * The data needed to update a FoodConsumption.
     */
    data: XOR<FoodConsumptionUpdateInput, FoodConsumptionUncheckedUpdateInput>;
    /**
     * Choose, which FoodConsumption to update.
     */
    where: FoodConsumptionWhereUniqueInput;
  };

  /**
   * FoodConsumption updateMany
   */
  export type FoodConsumptionUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update FoodConsumptions.
     */
    data: XOR<
      FoodConsumptionUpdateManyMutationInput,
      FoodConsumptionUncheckedUpdateManyInput
    >;
    /**
     * Filter which FoodConsumptions to update
     */
    where?: FoodConsumptionWhereInput;
    /**
     * Limit how many FoodConsumptions to update.
     */
    limit?: number;
  };

  /**
   * FoodConsumption updateManyAndReturn
   */
  export type FoodConsumptionUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FoodConsumption
     */
    select?: FoodConsumptionSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the FoodConsumption
     */
    omit?: FoodConsumptionOmit<ExtArgs> | null;
    /**
     * The data used to update FoodConsumptions.
     */
    data: XOR<
      FoodConsumptionUpdateManyMutationInput,
      FoodConsumptionUncheckedUpdateManyInput
    >;
    /**
     * Filter which FoodConsumptions to update
     */
    where?: FoodConsumptionWhereInput;
    /**
     * Limit how many FoodConsumptions to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodConsumptionIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * FoodConsumption upsert
   */
  export type FoodConsumptionUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FoodConsumption
     */
    select?: FoodConsumptionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FoodConsumption
     */
    omit?: FoodConsumptionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodConsumptionInclude<ExtArgs> | null;
    /**
     * The filter to search for the FoodConsumption to update in case it exists.
     */
    where: FoodConsumptionWhereUniqueInput;
    /**
     * In case the FoodConsumption found by the `where` argument doesn't exist, create a new FoodConsumption with this data.
     */
    create: XOR<
      FoodConsumptionCreateInput,
      FoodConsumptionUncheckedCreateInput
    >;
    /**
     * In case the FoodConsumption was found with the provided `where` argument, update it with this data.
     */
    update: XOR<
      FoodConsumptionUpdateInput,
      FoodConsumptionUncheckedUpdateInput
    >;
  };

  /**
   * FoodConsumption delete
   */
  export type FoodConsumptionDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FoodConsumption
     */
    select?: FoodConsumptionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FoodConsumption
     */
    omit?: FoodConsumptionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodConsumptionInclude<ExtArgs> | null;
    /**
     * Filter which FoodConsumption to delete.
     */
    where: FoodConsumptionWhereUniqueInput;
  };

  /**
   * FoodConsumption deleteMany
   */
  export type FoodConsumptionDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which FoodConsumptions to delete
     */
    where?: FoodConsumptionWhereInput;
    /**
     * Limit how many FoodConsumptions to delete.
     */
    limit?: number;
  };

  /**
   * FoodConsumption without action
   */
  export type FoodConsumptionDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FoodConsumption
     */
    select?: FoodConsumptionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FoodConsumption
     */
    omit?: FoodConsumptionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodConsumptionInclude<ExtArgs> | null;
  };

  /**
   * Model Supplier
   */

  export type AggregateSupplier = {
    _count: SupplierCountAggregateOutputType | null;
    _min: SupplierMinAggregateOutputType | null;
    _max: SupplierMaxAggregateOutputType | null;
  };

  export type SupplierMinAggregateOutputType = {
    id: string | null;
    name: string | null;
    contactInfo: string | null;
    address: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type SupplierMaxAggregateOutputType = {
    id: string | null;
    name: string | null;
    contactInfo: string | null;
    address: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type SupplierCountAggregateOutputType = {
    id: number;
    name: number;
    contactInfo: number;
    address: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type SupplierMinAggregateInputType = {
    id?: true;
    name?: true;
    contactInfo?: true;
    address?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type SupplierMaxAggregateInputType = {
    id?: true;
    name?: true;
    contactInfo?: true;
    address?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type SupplierCountAggregateInputType = {
    id?: true;
    name?: true;
    contactInfo?: true;
    address?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type SupplierAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Supplier to aggregate.
     */
    where?: SupplierWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Suppliers to fetch.
     */
    orderBy?:
      | SupplierOrderByWithRelationInput
      | SupplierOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: SupplierWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Suppliers.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Suppliers
     **/
    _count?: true | SupplierCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: SupplierMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: SupplierMaxAggregateInputType;
  };

  export type GetSupplierAggregateType<T extends SupplierAggregateArgs> = {
    [P in keyof T & keyof AggregateSupplier]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupplier[P]>
      : GetScalarType<T[P], AggregateSupplier[P]>;
  };

  export type SupplierGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: SupplierWhereInput;
    orderBy?:
      | SupplierOrderByWithAggregationInput
      | SupplierOrderByWithAggregationInput[];
    by: SupplierScalarFieldEnum[] | SupplierScalarFieldEnum;
    having?: SupplierScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: SupplierCountAggregateInputType | true;
    _min?: SupplierMinAggregateInputType;
    _max?: SupplierMaxAggregateInputType;
  };

  export type SupplierGroupByOutputType = {
    id: string;
    name: string;
    contactInfo: string | null;
    address: string | null;
    createdAt: Date;
    updatedAt: Date;
    _count: SupplierCountAggregateOutputType | null;
    _min: SupplierMinAggregateOutputType | null;
    _max: SupplierMaxAggregateOutputType | null;
  };

  type GetSupplierGroupByPayload<T extends SupplierGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<SupplierGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof SupplierGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SupplierGroupByOutputType[P]>
            : GetScalarType<T[P], SupplierGroupByOutputType[P]>;
        }
      >
    >;

  export type SupplierSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      contactInfo?: boolean;
      address?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      foodStoreItems?: boolean | Supplier$foodStoreItemsArgs<ExtArgs>;
      _count?: boolean | SupplierCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["supplier"]
  >;

  export type SupplierSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      contactInfo?: boolean;
      address?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
    },
    ExtArgs["result"]["supplier"]
  >;

  export type SupplierSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      contactInfo?: boolean;
      address?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
    },
    ExtArgs["result"]["supplier"]
  >;

  export type SupplierSelectScalar = {
    id?: boolean;
    name?: boolean;
    contactInfo?: boolean;
    address?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type SupplierOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    "id" | "name" | "contactInfo" | "address" | "createdAt" | "updatedAt",
    ExtArgs["result"]["supplier"]
  >;
  export type SupplierInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    foodStoreItems?: boolean | Supplier$foodStoreItemsArgs<ExtArgs>;
    _count?: boolean | SupplierCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type SupplierIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};
  export type SupplierIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};

  export type $SupplierPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "Supplier";
    objects: {
      foodStoreItems: Prisma.$FoodStoreItemPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        name: string;
        contactInfo: string | null;
        address: string | null;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs["result"]["supplier"]
    >;
    composites: {};
  };

  type SupplierGetPayload<
    S extends boolean | null | undefined | SupplierDefaultArgs,
  > = $Result.GetResult<Prisma.$SupplierPayload, S>;

  type SupplierCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<SupplierFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
    select?: SupplierCountAggregateInputType | true;
  };

  export interface SupplierDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["Supplier"];
      meta: { name: "Supplier" };
    };
    /**
     * Find zero or one Supplier that matches the filter.
     * @param {SupplierFindUniqueArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SupplierFindUniqueArgs>(
      args: SelectSubset<T, SupplierFindUniqueArgs<ExtArgs>>,
    ): Prisma__SupplierClient<
      $Result.GetResult<
        Prisma.$SupplierPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Supplier that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SupplierFindUniqueOrThrowArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SupplierFindUniqueOrThrowArgs>(
      args: SelectSubset<T, SupplierFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__SupplierClient<
      $Result.GetResult<
        Prisma.$SupplierPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Supplier that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindFirstArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SupplierFindFirstArgs>(
      args?: SelectSubset<T, SupplierFindFirstArgs<ExtArgs>>,
    ): Prisma__SupplierClient<
      $Result.GetResult<
        Prisma.$SupplierPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Supplier that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindFirstOrThrowArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SupplierFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SupplierFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__SupplierClient<
      $Result.GetResult<
        Prisma.$SupplierPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Suppliers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Suppliers
     * const suppliers = await prisma.supplier.findMany()
     *
     * // Get first 10 Suppliers
     * const suppliers = await prisma.supplier.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const supplierWithIdOnly = await prisma.supplier.findMany({ select: { id: true } })
     *
     */
    findMany<T extends SupplierFindManyArgs>(
      args?: SelectSubset<T, SupplierFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$SupplierPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Supplier.
     * @param {SupplierCreateArgs} args - Arguments to create a Supplier.
     * @example
     * // Create one Supplier
     * const Supplier = await prisma.supplier.create({
     *   data: {
     *     // ... data to create a Supplier
     *   }
     * })
     *
     */
    create<T extends SupplierCreateArgs>(
      args: SelectSubset<T, SupplierCreateArgs<ExtArgs>>,
    ): Prisma__SupplierClient<
      $Result.GetResult<
        Prisma.$SupplierPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Suppliers.
     * @param {SupplierCreateManyArgs} args - Arguments to create many Suppliers.
     * @example
     * // Create many Suppliers
     * const supplier = await prisma.supplier.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends SupplierCreateManyArgs>(
      args?: SelectSubset<T, SupplierCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Suppliers and returns the data saved in the database.
     * @param {SupplierCreateManyAndReturnArgs} args - Arguments to create many Suppliers.
     * @example
     * // Create many Suppliers
     * const supplier = await prisma.supplier.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Suppliers and only return the `id`
     * const supplierWithIdOnly = await prisma.supplier.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends SupplierCreateManyAndReturnArgs>(
      args?: SelectSubset<T, SupplierCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$SupplierPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Supplier.
     * @param {SupplierDeleteArgs} args - Arguments to delete one Supplier.
     * @example
     * // Delete one Supplier
     * const Supplier = await prisma.supplier.delete({
     *   where: {
     *     // ... filter to delete one Supplier
     *   }
     * })
     *
     */
    delete<T extends SupplierDeleteArgs>(
      args: SelectSubset<T, SupplierDeleteArgs<ExtArgs>>,
    ): Prisma__SupplierClient<
      $Result.GetResult<
        Prisma.$SupplierPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Supplier.
     * @param {SupplierUpdateArgs} args - Arguments to update one Supplier.
     * @example
     * // Update one Supplier
     * const supplier = await prisma.supplier.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends SupplierUpdateArgs>(
      args: SelectSubset<T, SupplierUpdateArgs<ExtArgs>>,
    ): Prisma__SupplierClient<
      $Result.GetResult<
        Prisma.$SupplierPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Suppliers.
     * @param {SupplierDeleteManyArgs} args - Arguments to filter Suppliers to delete.
     * @example
     * // Delete a few Suppliers
     * const { count } = await prisma.supplier.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends SupplierDeleteManyArgs>(
      args?: SelectSubset<T, SupplierDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Suppliers
     * const supplier = await prisma.supplier.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends SupplierUpdateManyArgs>(
      args: SelectSubset<T, SupplierUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Suppliers and returns the data updated in the database.
     * @param {SupplierUpdateManyAndReturnArgs} args - Arguments to update many Suppliers.
     * @example
     * // Update many Suppliers
     * const supplier = await prisma.supplier.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Suppliers and only return the `id`
     * const supplierWithIdOnly = await prisma.supplier.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends SupplierUpdateManyAndReturnArgs>(
      args: SelectSubset<T, SupplierUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$SupplierPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Supplier.
     * @param {SupplierUpsertArgs} args - Arguments to update or create a Supplier.
     * @example
     * // Update or create a Supplier
     * const supplier = await prisma.supplier.upsert({
     *   create: {
     *     // ... data to create a Supplier
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Supplier we want to update
     *   }
     * })
     */
    upsert<T extends SupplierUpsertArgs>(
      args: SelectSubset<T, SupplierUpsertArgs<ExtArgs>>,
    ): Prisma__SupplierClient<
      $Result.GetResult<
        Prisma.$SupplierPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierCountArgs} args - Arguments to filter Suppliers to count.
     * @example
     * // Count the number of Suppliers
     * const count = await prisma.supplier.count({
     *   where: {
     *     // ... the filter for the Suppliers we want to count
     *   }
     * })
     **/
    count<T extends SupplierCountArgs>(
      args?: Subset<T, SupplierCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], SupplierCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Supplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends SupplierAggregateArgs>(
      args: Subset<T, SupplierAggregateArgs>,
    ): Prisma.PrismaPromise<GetSupplierAggregateType<T>>;

    /**
     * Group by Supplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends SupplierGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SupplierGroupByArgs["orderBy"] }
        : { orderBy?: SupplierGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, SupplierGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetSupplierGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Supplier model
     */
    readonly fields: SupplierFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Supplier.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SupplierClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    foodStoreItems<T extends Supplier$foodStoreItemsArgs<ExtArgs> = {}>(
      args?: Subset<T, Supplier$foodStoreItemsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$FoodStoreItemPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Supplier model
   */
  interface SupplierFieldRefs {
    readonly id: FieldRef<"Supplier", "String">;
    readonly name: FieldRef<"Supplier", "String">;
    readonly contactInfo: FieldRef<"Supplier", "String">;
    readonly address: FieldRef<"Supplier", "String">;
    readonly createdAt: FieldRef<"Supplier", "DateTime">;
    readonly updatedAt: FieldRef<"Supplier", "DateTime">;
  }

  // Custom InputTypes
  /**
   * Supplier findUnique
   */
  export type SupplierFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null;
    /**
     * Filter, which Supplier to fetch.
     */
    where: SupplierWhereUniqueInput;
  };

  /**
   * Supplier findUniqueOrThrow
   */
  export type SupplierFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null;
    /**
     * Filter, which Supplier to fetch.
     */
    where: SupplierWhereUniqueInput;
  };

  /**
   * Supplier findFirst
   */
  export type SupplierFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null;
    /**
     * Filter, which Supplier to fetch.
     */
    where?: SupplierWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Suppliers to fetch.
     */
    orderBy?:
      | SupplierOrderByWithRelationInput
      | SupplierOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Suppliers.
     */
    cursor?: SupplierWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Suppliers.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Suppliers.
     */
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[];
  };

  /**
   * Supplier findFirstOrThrow
   */
  export type SupplierFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null;
    /**
     * Filter, which Supplier to fetch.
     */
    where?: SupplierWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Suppliers to fetch.
     */
    orderBy?:
      | SupplierOrderByWithRelationInput
      | SupplierOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Suppliers.
     */
    cursor?: SupplierWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Suppliers.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Suppliers.
     */
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[];
  };

  /**
   * Supplier findMany
   */
  export type SupplierFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null;
    /**
     * Filter, which Suppliers to fetch.
     */
    where?: SupplierWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Suppliers to fetch.
     */
    orderBy?:
      | SupplierOrderByWithRelationInput
      | SupplierOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Suppliers.
     */
    cursor?: SupplierWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Suppliers.
     */
    skip?: number;
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[];
  };

  /**
   * Supplier create
   */
  export type SupplierCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null;
    /**
     * The data needed to create a Supplier.
     */
    data: XOR<SupplierCreateInput, SupplierUncheckedCreateInput>;
  };

  /**
   * Supplier createMany
   */
  export type SupplierCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Suppliers.
     */
    data: SupplierCreateManyInput | SupplierCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Supplier createManyAndReturn
   */
  export type SupplierCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null;
    /**
     * The data used to create many Suppliers.
     */
    data: SupplierCreateManyInput | SupplierCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Supplier update
   */
  export type SupplierUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null;
    /**
     * The data needed to update a Supplier.
     */
    data: XOR<SupplierUpdateInput, SupplierUncheckedUpdateInput>;
    /**
     * Choose, which Supplier to update.
     */
    where: SupplierWhereUniqueInput;
  };

  /**
   * Supplier updateMany
   */
  export type SupplierUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Suppliers.
     */
    data: XOR<
      SupplierUpdateManyMutationInput,
      SupplierUncheckedUpdateManyInput
    >;
    /**
     * Filter which Suppliers to update
     */
    where?: SupplierWhereInput;
    /**
     * Limit how many Suppliers to update.
     */
    limit?: number;
  };

  /**
   * Supplier updateManyAndReturn
   */
  export type SupplierUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null;
    /**
     * The data used to update Suppliers.
     */
    data: XOR<
      SupplierUpdateManyMutationInput,
      SupplierUncheckedUpdateManyInput
    >;
    /**
     * Filter which Suppliers to update
     */
    where?: SupplierWhereInput;
    /**
     * Limit how many Suppliers to update.
     */
    limit?: number;
  };

  /**
   * Supplier upsert
   */
  export type SupplierUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null;
    /**
     * The filter to search for the Supplier to update in case it exists.
     */
    where: SupplierWhereUniqueInput;
    /**
     * In case the Supplier found by the `where` argument doesn't exist, create a new Supplier with this data.
     */
    create: XOR<SupplierCreateInput, SupplierUncheckedCreateInput>;
    /**
     * In case the Supplier was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SupplierUpdateInput, SupplierUncheckedUpdateInput>;
  };

  /**
   * Supplier delete
   */
  export type SupplierDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null;
    /**
     * Filter which Supplier to delete.
     */
    where: SupplierWhereUniqueInput;
  };

  /**
   * Supplier deleteMany
   */
  export type SupplierDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Suppliers to delete
     */
    where?: SupplierWhereInput;
    /**
     * Limit how many Suppliers to delete.
     */
    limit?: number;
  };

  /**
   * Supplier.foodStoreItems
   */
  export type Supplier$foodStoreItemsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FoodStoreItem
     */
    select?: FoodStoreItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FoodStoreItem
     */
    omit?: FoodStoreItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodStoreItemInclude<ExtArgs> | null;
    where?: FoodStoreItemWhereInput;
    orderBy?:
      | FoodStoreItemOrderByWithRelationInput
      | FoodStoreItemOrderByWithRelationInput[];
    cursor?: FoodStoreItemWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: FoodStoreItemScalarFieldEnum | FoodStoreItemScalarFieldEnum[];
  };

  /**
   * Supplier without action
   */
  export type SupplierDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null;
  };

  /**
   * Model LibraryBook
   */

  export type AggregateLibraryBook = {
    _count: LibraryBookCountAggregateOutputType | null;
    _avg: LibraryBookAvgAggregateOutputType | null;
    _sum: LibraryBookSumAggregateOutputType | null;
    _min: LibraryBookMinAggregateOutputType | null;
    _max: LibraryBookMaxAggregateOutputType | null;
  };

  export type LibraryBookAvgAggregateOutputType = {
    quantity: number | null;
  };

  export type LibraryBookSumAggregateOutputType = {
    quantity: number | null;
  };

  export type LibraryBookMinAggregateOutputType = {
    id: string | null;
    title: string | null;
    author: string | null;
    assetId: string | null;
    libraryBookCategoryId: string | null;
    quantity: number | null;
    trackQuantity: boolean | null;
    unit: $Enums.AssetUnit | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type LibraryBookMaxAggregateOutputType = {
    id: string | null;
    title: string | null;
    author: string | null;
    assetId: string | null;
    libraryBookCategoryId: string | null;
    quantity: number | null;
    trackQuantity: boolean | null;
    unit: $Enums.AssetUnit | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type LibraryBookCountAggregateOutputType = {
    id: number;
    title: number;
    author: number;
    assetId: number;
    libraryBookCategoryId: number;
    quantity: number;
    trackQuantity: number;
    unit: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type LibraryBookAvgAggregateInputType = {
    quantity?: true;
  };

  export type LibraryBookSumAggregateInputType = {
    quantity?: true;
  };

  export type LibraryBookMinAggregateInputType = {
    id?: true;
    title?: true;
    author?: true;
    assetId?: true;
    libraryBookCategoryId?: true;
    quantity?: true;
    trackQuantity?: true;
    unit?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type LibraryBookMaxAggregateInputType = {
    id?: true;
    title?: true;
    author?: true;
    assetId?: true;
    libraryBookCategoryId?: true;
    quantity?: true;
    trackQuantity?: true;
    unit?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type LibraryBookCountAggregateInputType = {
    id?: true;
    title?: true;
    author?: true;
    assetId?: true;
    libraryBookCategoryId?: true;
    quantity?: true;
    trackQuantity?: true;
    unit?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type LibraryBookAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which LibraryBook to aggregate.
     */
    where?: LibraryBookWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of LibraryBooks to fetch.
     */
    orderBy?:
      | LibraryBookOrderByWithRelationInput
      | LibraryBookOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: LibraryBookWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` LibraryBooks from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` LibraryBooks.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned LibraryBooks
     **/
    _count?: true | LibraryBookCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: LibraryBookAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: LibraryBookSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: LibraryBookMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: LibraryBookMaxAggregateInputType;
  };

  export type GetLibraryBookAggregateType<T extends LibraryBookAggregateArgs> =
    {
      [P in keyof T & keyof AggregateLibraryBook]: P extends "_count" | "count"
        ? T[P] extends true
          ? number
          : GetScalarType<T[P], AggregateLibraryBook[P]>
        : GetScalarType<T[P], AggregateLibraryBook[P]>;
    };

  export type LibraryBookGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: LibraryBookWhereInput;
    orderBy?:
      | LibraryBookOrderByWithAggregationInput
      | LibraryBookOrderByWithAggregationInput[];
    by: LibraryBookScalarFieldEnum[] | LibraryBookScalarFieldEnum;
    having?: LibraryBookScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: LibraryBookCountAggregateInputType | true;
    _avg?: LibraryBookAvgAggregateInputType;
    _sum?: LibraryBookSumAggregateInputType;
    _min?: LibraryBookMinAggregateInputType;
    _max?: LibraryBookMaxAggregateInputType;
  };

  export type LibraryBookGroupByOutputType = {
    id: string;
    title: string;
    author: string;
    assetId: string;
    libraryBookCategoryId: string;
    quantity: number | null;
    trackQuantity: boolean;
    unit: $Enums.AssetUnit;
    createdAt: Date;
    updatedAt: Date;
    _count: LibraryBookCountAggregateOutputType | null;
    _avg: LibraryBookAvgAggregateOutputType | null;
    _sum: LibraryBookSumAggregateOutputType | null;
    _min: LibraryBookMinAggregateOutputType | null;
    _max: LibraryBookMaxAggregateOutputType | null;
  };

  type GetLibraryBookGroupByPayload<T extends LibraryBookGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<LibraryBookGroupByOutputType, T["by"]> & {
          [P in keyof T &
            keyof LibraryBookGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LibraryBookGroupByOutputType[P]>
            : GetScalarType<T[P], LibraryBookGroupByOutputType[P]>;
        }
      >
    >;

  export type LibraryBookSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      title?: boolean;
      author?: boolean;
      assetId?: boolean;
      libraryBookCategoryId?: boolean;
      quantity?: boolean;
      trackQuantity?: boolean;
      unit?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      individualBooks?: boolean | LibraryBook$individualBooksArgs<ExtArgs>;
      asset?: boolean | AssetDefaultArgs<ExtArgs>;
      category?: boolean | LibraryBookCategoryDefaultArgs<ExtArgs>;
      _count?: boolean | LibraryBookCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["libraryBook"]
  >;

  export type LibraryBookSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      title?: boolean;
      author?: boolean;
      assetId?: boolean;
      libraryBookCategoryId?: boolean;
      quantity?: boolean;
      trackQuantity?: boolean;
      unit?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      asset?: boolean | AssetDefaultArgs<ExtArgs>;
      category?: boolean | LibraryBookCategoryDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["libraryBook"]
  >;

  export type LibraryBookSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      title?: boolean;
      author?: boolean;
      assetId?: boolean;
      libraryBookCategoryId?: boolean;
      quantity?: boolean;
      trackQuantity?: boolean;
      unit?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      asset?: boolean | AssetDefaultArgs<ExtArgs>;
      category?: boolean | LibraryBookCategoryDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["libraryBook"]
  >;

  export type LibraryBookSelectScalar = {
    id?: boolean;
    title?: boolean;
    author?: boolean;
    assetId?: boolean;
    libraryBookCategoryId?: boolean;
    quantity?: boolean;
    trackQuantity?: boolean;
    unit?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type LibraryBookOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | "id"
    | "title"
    | "author"
    | "assetId"
    | "libraryBookCategoryId"
    | "quantity"
    | "trackQuantity"
    | "unit"
    | "createdAt"
    | "updatedAt",
    ExtArgs["result"]["libraryBook"]
  >;
  export type LibraryBookInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    individualBooks?: boolean | LibraryBook$individualBooksArgs<ExtArgs>;
    asset?: boolean | AssetDefaultArgs<ExtArgs>;
    category?: boolean | LibraryBookCategoryDefaultArgs<ExtArgs>;
    _count?: boolean | LibraryBookCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type LibraryBookIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    asset?: boolean | AssetDefaultArgs<ExtArgs>;
    category?: boolean | LibraryBookCategoryDefaultArgs<ExtArgs>;
  };
  export type LibraryBookIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    asset?: boolean | AssetDefaultArgs<ExtArgs>;
    category?: boolean | LibraryBookCategoryDefaultArgs<ExtArgs>;
  };

  export type $LibraryBookPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "LibraryBook";
    objects: {
      individualBooks: Prisma.$IndividualBookPayload<ExtArgs>[];
      asset: Prisma.$AssetPayload<ExtArgs>;
      category: Prisma.$LibraryBookCategoryPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        title: string;
        author: string;
        assetId: string;
        libraryBookCategoryId: string;
        quantity: number | null;
        trackQuantity: boolean;
        unit: $Enums.AssetUnit;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs["result"]["libraryBook"]
    >;
    composites: {};
  };

  type LibraryBookGetPayload<
    S extends boolean | null | undefined | LibraryBookDefaultArgs,
  > = $Result.GetResult<Prisma.$LibraryBookPayload, S>;

  type LibraryBookCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    LibraryBookFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: LibraryBookCountAggregateInputType | true;
  };

  export interface LibraryBookDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["LibraryBook"];
      meta: { name: "LibraryBook" };
    };
    /**
     * Find zero or one LibraryBook that matches the filter.
     * @param {LibraryBookFindUniqueArgs} args - Arguments to find a LibraryBook
     * @example
     * // Get one LibraryBook
     * const libraryBook = await prisma.libraryBook.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LibraryBookFindUniqueArgs>(
      args: SelectSubset<T, LibraryBookFindUniqueArgs<ExtArgs>>,
    ): Prisma__LibraryBookClient<
      $Result.GetResult<
        Prisma.$LibraryBookPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one LibraryBook that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LibraryBookFindUniqueOrThrowArgs} args - Arguments to find a LibraryBook
     * @example
     * // Get one LibraryBook
     * const libraryBook = await prisma.libraryBook.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LibraryBookFindUniqueOrThrowArgs>(
      args: SelectSubset<T, LibraryBookFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__LibraryBookClient<
      $Result.GetResult<
        Prisma.$LibraryBookPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first LibraryBook that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryBookFindFirstArgs} args - Arguments to find a LibraryBook
     * @example
     * // Get one LibraryBook
     * const libraryBook = await prisma.libraryBook.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LibraryBookFindFirstArgs>(
      args?: SelectSubset<T, LibraryBookFindFirstArgs<ExtArgs>>,
    ): Prisma__LibraryBookClient<
      $Result.GetResult<
        Prisma.$LibraryBookPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first LibraryBook that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryBookFindFirstOrThrowArgs} args - Arguments to find a LibraryBook
     * @example
     * // Get one LibraryBook
     * const libraryBook = await prisma.libraryBook.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LibraryBookFindFirstOrThrowArgs>(
      args?: SelectSubset<T, LibraryBookFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__LibraryBookClient<
      $Result.GetResult<
        Prisma.$LibraryBookPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more LibraryBooks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryBookFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LibraryBooks
     * const libraryBooks = await prisma.libraryBook.findMany()
     *
     * // Get first 10 LibraryBooks
     * const libraryBooks = await prisma.libraryBook.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const libraryBookWithIdOnly = await prisma.libraryBook.findMany({ select: { id: true } })
     *
     */
    findMany<T extends LibraryBookFindManyArgs>(
      args?: SelectSubset<T, LibraryBookFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$LibraryBookPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a LibraryBook.
     * @param {LibraryBookCreateArgs} args - Arguments to create a LibraryBook.
     * @example
     * // Create one LibraryBook
     * const LibraryBook = await prisma.libraryBook.create({
     *   data: {
     *     // ... data to create a LibraryBook
     *   }
     * })
     *
     */
    create<T extends LibraryBookCreateArgs>(
      args: SelectSubset<T, LibraryBookCreateArgs<ExtArgs>>,
    ): Prisma__LibraryBookClient<
      $Result.GetResult<
        Prisma.$LibraryBookPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many LibraryBooks.
     * @param {LibraryBookCreateManyArgs} args - Arguments to create many LibraryBooks.
     * @example
     * // Create many LibraryBooks
     * const libraryBook = await prisma.libraryBook.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends LibraryBookCreateManyArgs>(
      args?: SelectSubset<T, LibraryBookCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many LibraryBooks and returns the data saved in the database.
     * @param {LibraryBookCreateManyAndReturnArgs} args - Arguments to create many LibraryBooks.
     * @example
     * // Create many LibraryBooks
     * const libraryBook = await prisma.libraryBook.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many LibraryBooks and only return the `id`
     * const libraryBookWithIdOnly = await prisma.libraryBook.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends LibraryBookCreateManyAndReturnArgs>(
      args?: SelectSubset<T, LibraryBookCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$LibraryBookPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a LibraryBook.
     * @param {LibraryBookDeleteArgs} args - Arguments to delete one LibraryBook.
     * @example
     * // Delete one LibraryBook
     * const LibraryBook = await prisma.libraryBook.delete({
     *   where: {
     *     // ... filter to delete one LibraryBook
     *   }
     * })
     *
     */
    delete<T extends LibraryBookDeleteArgs>(
      args: SelectSubset<T, LibraryBookDeleteArgs<ExtArgs>>,
    ): Prisma__LibraryBookClient<
      $Result.GetResult<
        Prisma.$LibraryBookPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one LibraryBook.
     * @param {LibraryBookUpdateArgs} args - Arguments to update one LibraryBook.
     * @example
     * // Update one LibraryBook
     * const libraryBook = await prisma.libraryBook.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends LibraryBookUpdateArgs>(
      args: SelectSubset<T, LibraryBookUpdateArgs<ExtArgs>>,
    ): Prisma__LibraryBookClient<
      $Result.GetResult<
        Prisma.$LibraryBookPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more LibraryBooks.
     * @param {LibraryBookDeleteManyArgs} args - Arguments to filter LibraryBooks to delete.
     * @example
     * // Delete a few LibraryBooks
     * const { count } = await prisma.libraryBook.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends LibraryBookDeleteManyArgs>(
      args?: SelectSubset<T, LibraryBookDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more LibraryBooks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryBookUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LibraryBooks
     * const libraryBook = await prisma.libraryBook.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends LibraryBookUpdateManyArgs>(
      args: SelectSubset<T, LibraryBookUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more LibraryBooks and returns the data updated in the database.
     * @param {LibraryBookUpdateManyAndReturnArgs} args - Arguments to update many LibraryBooks.
     * @example
     * // Update many LibraryBooks
     * const libraryBook = await prisma.libraryBook.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more LibraryBooks and only return the `id`
     * const libraryBookWithIdOnly = await prisma.libraryBook.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends LibraryBookUpdateManyAndReturnArgs>(
      args: SelectSubset<T, LibraryBookUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$LibraryBookPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one LibraryBook.
     * @param {LibraryBookUpsertArgs} args - Arguments to update or create a LibraryBook.
     * @example
     * // Update or create a LibraryBook
     * const libraryBook = await prisma.libraryBook.upsert({
     *   create: {
     *     // ... data to create a LibraryBook
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LibraryBook we want to update
     *   }
     * })
     */
    upsert<T extends LibraryBookUpsertArgs>(
      args: SelectSubset<T, LibraryBookUpsertArgs<ExtArgs>>,
    ): Prisma__LibraryBookClient<
      $Result.GetResult<
        Prisma.$LibraryBookPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of LibraryBooks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryBookCountArgs} args - Arguments to filter LibraryBooks to count.
     * @example
     * // Count the number of LibraryBooks
     * const count = await prisma.libraryBook.count({
     *   where: {
     *     // ... the filter for the LibraryBooks we want to count
     *   }
     * })
     **/
    count<T extends LibraryBookCountArgs>(
      args?: Subset<T, LibraryBookCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], LibraryBookCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a LibraryBook.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryBookAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends LibraryBookAggregateArgs>(
      args: Subset<T, LibraryBookAggregateArgs>,
    ): Prisma.PrismaPromise<GetLibraryBookAggregateType<T>>;

    /**
     * Group by LibraryBook.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryBookGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends LibraryBookGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LibraryBookGroupByArgs["orderBy"] }
        : { orderBy?: LibraryBookGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, LibraryBookGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetLibraryBookGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the LibraryBook model
     */
    readonly fields: LibraryBookFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LibraryBook.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LibraryBookClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    individualBooks<T extends LibraryBook$individualBooksArgs<ExtArgs> = {}>(
      args?: Subset<T, LibraryBook$individualBooksArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$IndividualBookPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    asset<T extends AssetDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, AssetDefaultArgs<ExtArgs>>,
    ): Prisma__AssetClient<
      | $Result.GetResult<
          Prisma.$AssetPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    category<T extends LibraryBookCategoryDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, LibraryBookCategoryDefaultArgs<ExtArgs>>,
    ): Prisma__LibraryBookCategoryClient<
      | $Result.GetResult<
          Prisma.$LibraryBookCategoryPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the LibraryBook model
   */
  interface LibraryBookFieldRefs {
    readonly id: FieldRef<"LibraryBook", "String">;
    readonly title: FieldRef<"LibraryBook", "String">;
    readonly author: FieldRef<"LibraryBook", "String">;
    readonly assetId: FieldRef<"LibraryBook", "String">;
    readonly libraryBookCategoryId: FieldRef<"LibraryBook", "String">;
    readonly quantity: FieldRef<"LibraryBook", "Float">;
    readonly trackQuantity: FieldRef<"LibraryBook", "Boolean">;
    readonly unit: FieldRef<"LibraryBook", "AssetUnit">;
    readonly createdAt: FieldRef<"LibraryBook", "DateTime">;
    readonly updatedAt: FieldRef<"LibraryBook", "DateTime">;
  }

  // Custom InputTypes
  /**
   * LibraryBook findUnique
   */
  export type LibraryBookFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LibraryBook
     */
    select?: LibraryBookSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the LibraryBook
     */
    omit?: LibraryBookOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryBookInclude<ExtArgs> | null;
    /**
     * Filter, which LibraryBook to fetch.
     */
    where: LibraryBookWhereUniqueInput;
  };

  /**
   * LibraryBook findUniqueOrThrow
   */
  export type LibraryBookFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LibraryBook
     */
    select?: LibraryBookSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the LibraryBook
     */
    omit?: LibraryBookOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryBookInclude<ExtArgs> | null;
    /**
     * Filter, which LibraryBook to fetch.
     */
    where: LibraryBookWhereUniqueInput;
  };

  /**
   * LibraryBook findFirst
   */
  export type LibraryBookFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LibraryBook
     */
    select?: LibraryBookSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the LibraryBook
     */
    omit?: LibraryBookOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryBookInclude<ExtArgs> | null;
    /**
     * Filter, which LibraryBook to fetch.
     */
    where?: LibraryBookWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of LibraryBooks to fetch.
     */
    orderBy?:
      | LibraryBookOrderByWithRelationInput
      | LibraryBookOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for LibraryBooks.
     */
    cursor?: LibraryBookWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` LibraryBooks from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` LibraryBooks.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of LibraryBooks.
     */
    distinct?: LibraryBookScalarFieldEnum | LibraryBookScalarFieldEnum[];
  };

  /**
   * LibraryBook findFirstOrThrow
   */
  export type LibraryBookFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LibraryBook
     */
    select?: LibraryBookSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the LibraryBook
     */
    omit?: LibraryBookOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryBookInclude<ExtArgs> | null;
    /**
     * Filter, which LibraryBook to fetch.
     */
    where?: LibraryBookWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of LibraryBooks to fetch.
     */
    orderBy?:
      | LibraryBookOrderByWithRelationInput
      | LibraryBookOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for LibraryBooks.
     */
    cursor?: LibraryBookWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` LibraryBooks from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` LibraryBooks.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of LibraryBooks.
     */
    distinct?: LibraryBookScalarFieldEnum | LibraryBookScalarFieldEnum[];
  };

  /**
   * LibraryBook findMany
   */
  export type LibraryBookFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LibraryBook
     */
    select?: LibraryBookSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the LibraryBook
     */
    omit?: LibraryBookOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryBookInclude<ExtArgs> | null;
    /**
     * Filter, which LibraryBooks to fetch.
     */
    where?: LibraryBookWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of LibraryBooks to fetch.
     */
    orderBy?:
      | LibraryBookOrderByWithRelationInput
      | LibraryBookOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing LibraryBooks.
     */
    cursor?: LibraryBookWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` LibraryBooks from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` LibraryBooks.
     */
    skip?: number;
    distinct?: LibraryBookScalarFieldEnum | LibraryBookScalarFieldEnum[];
  };

  /**
   * LibraryBook create
   */
  export type LibraryBookCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LibraryBook
     */
    select?: LibraryBookSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the LibraryBook
     */
    omit?: LibraryBookOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryBookInclude<ExtArgs> | null;
    /**
     * The data needed to create a LibraryBook.
     */
    data: XOR<LibraryBookCreateInput, LibraryBookUncheckedCreateInput>;
  };

  /**
   * LibraryBook createMany
   */
  export type LibraryBookCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many LibraryBooks.
     */
    data: LibraryBookCreateManyInput | LibraryBookCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * LibraryBook createManyAndReturn
   */
  export type LibraryBookCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LibraryBook
     */
    select?: LibraryBookSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the LibraryBook
     */
    omit?: LibraryBookOmit<ExtArgs> | null;
    /**
     * The data used to create many LibraryBooks.
     */
    data: LibraryBookCreateManyInput | LibraryBookCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryBookIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * LibraryBook update
   */
  export type LibraryBookUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LibraryBook
     */
    select?: LibraryBookSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the LibraryBook
     */
    omit?: LibraryBookOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryBookInclude<ExtArgs> | null;
    /**
     * The data needed to update a LibraryBook.
     */
    data: XOR<LibraryBookUpdateInput, LibraryBookUncheckedUpdateInput>;
    /**
     * Choose, which LibraryBook to update.
     */
    where: LibraryBookWhereUniqueInput;
  };

  /**
   * LibraryBook updateMany
   */
  export type LibraryBookUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update LibraryBooks.
     */
    data: XOR<
      LibraryBookUpdateManyMutationInput,
      LibraryBookUncheckedUpdateManyInput
    >;
    /**
     * Filter which LibraryBooks to update
     */
    where?: LibraryBookWhereInput;
    /**
     * Limit how many LibraryBooks to update.
     */
    limit?: number;
  };

  /**
   * LibraryBook updateManyAndReturn
   */
  export type LibraryBookUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LibraryBook
     */
    select?: LibraryBookSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the LibraryBook
     */
    omit?: LibraryBookOmit<ExtArgs> | null;
    /**
     * The data used to update LibraryBooks.
     */
    data: XOR<
      LibraryBookUpdateManyMutationInput,
      LibraryBookUncheckedUpdateManyInput
    >;
    /**
     * Filter which LibraryBooks to update
     */
    where?: LibraryBookWhereInput;
    /**
     * Limit how many LibraryBooks to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryBookIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * LibraryBook upsert
   */
  export type LibraryBookUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LibraryBook
     */
    select?: LibraryBookSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the LibraryBook
     */
    omit?: LibraryBookOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryBookInclude<ExtArgs> | null;
    /**
     * The filter to search for the LibraryBook to update in case it exists.
     */
    where: LibraryBookWhereUniqueInput;
    /**
     * In case the LibraryBook found by the `where` argument doesn't exist, create a new LibraryBook with this data.
     */
    create: XOR<LibraryBookCreateInput, LibraryBookUncheckedCreateInput>;
    /**
     * In case the LibraryBook was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LibraryBookUpdateInput, LibraryBookUncheckedUpdateInput>;
  };

  /**
   * LibraryBook delete
   */
  export type LibraryBookDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LibraryBook
     */
    select?: LibraryBookSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the LibraryBook
     */
    omit?: LibraryBookOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryBookInclude<ExtArgs> | null;
    /**
     * Filter which LibraryBook to delete.
     */
    where: LibraryBookWhereUniqueInput;
  };

  /**
   * LibraryBook deleteMany
   */
  export type LibraryBookDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which LibraryBooks to delete
     */
    where?: LibraryBookWhereInput;
    /**
     * Limit how many LibraryBooks to delete.
     */
    limit?: number;
  };

  /**
   * LibraryBook.individualBooks
   */
  export type LibraryBook$individualBooksArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IndividualBook
     */
    select?: IndividualBookSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the IndividualBook
     */
    omit?: IndividualBookOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndividualBookInclude<ExtArgs> | null;
    where?: IndividualBookWhereInput;
    orderBy?:
      | IndividualBookOrderByWithRelationInput
      | IndividualBookOrderByWithRelationInput[];
    cursor?: IndividualBookWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: IndividualBookScalarFieldEnum | IndividualBookScalarFieldEnum[];
  };

  /**
   * LibraryBook without action
   */
  export type LibraryBookDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LibraryBook
     */
    select?: LibraryBookSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the LibraryBook
     */
    omit?: LibraryBookOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryBookInclude<ExtArgs> | null;
  };

  /**
   * Model IndividualBook
   */

  export type AggregateIndividualBook = {
    _count: IndividualBookCountAggregateOutputType | null;
    _avg: IndividualBookAvgAggregateOutputType | null;
    _sum: IndividualBookSumAggregateOutputType | null;
    _min: IndividualBookMinAggregateOutputType | null;
    _max: IndividualBookMaxAggregateOutputType | null;
  };

  export type IndividualBookAvgAggregateOutputType = {
    borrowCount: number | null;
  };

  export type IndividualBookSumAggregateOutputType = {
    borrowCount: number | null;
  };

  export type IndividualBookMinAggregateOutputType = {
    id: string | null;
    isbn: string | null;
    status: $Enums.BookStatus | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    libraryBookId: string | null;
    condition: $Enums.AssetCondition | null;
    borrowCount: number | null;
  };

  export type IndividualBookMaxAggregateOutputType = {
    id: string | null;
    isbn: string | null;
    status: $Enums.BookStatus | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    libraryBookId: string | null;
    condition: $Enums.AssetCondition | null;
    borrowCount: number | null;
  };

  export type IndividualBookCountAggregateOutputType = {
    id: number;
    isbn: number;
    status: number;
    createdAt: number;
    updatedAt: number;
    libraryBookId: number;
    condition: number;
    borrowCount: number;
    _all: number;
  };

  export type IndividualBookAvgAggregateInputType = {
    borrowCount?: true;
  };

  export type IndividualBookSumAggregateInputType = {
    borrowCount?: true;
  };

  export type IndividualBookMinAggregateInputType = {
    id?: true;
    isbn?: true;
    status?: true;
    createdAt?: true;
    updatedAt?: true;
    libraryBookId?: true;
    condition?: true;
    borrowCount?: true;
  };

  export type IndividualBookMaxAggregateInputType = {
    id?: true;
    isbn?: true;
    status?: true;
    createdAt?: true;
    updatedAt?: true;
    libraryBookId?: true;
    condition?: true;
    borrowCount?: true;
  };

  export type IndividualBookCountAggregateInputType = {
    id?: true;
    isbn?: true;
    status?: true;
    createdAt?: true;
    updatedAt?: true;
    libraryBookId?: true;
    condition?: true;
    borrowCount?: true;
    _all?: true;
  };

  export type IndividualBookAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which IndividualBook to aggregate.
     */
    where?: IndividualBookWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of IndividualBooks to fetch.
     */
    orderBy?:
      | IndividualBookOrderByWithRelationInput
      | IndividualBookOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: IndividualBookWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` IndividualBooks from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` IndividualBooks.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned IndividualBooks
     **/
    _count?: true | IndividualBookCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: IndividualBookAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: IndividualBookSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: IndividualBookMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: IndividualBookMaxAggregateInputType;
  };

  export type GetIndividualBookAggregateType<
    T extends IndividualBookAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateIndividualBook]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIndividualBook[P]>
      : GetScalarType<T[P], AggregateIndividualBook[P]>;
  };

  export type IndividualBookGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: IndividualBookWhereInput;
    orderBy?:
      | IndividualBookOrderByWithAggregationInput
      | IndividualBookOrderByWithAggregationInput[];
    by: IndividualBookScalarFieldEnum[] | IndividualBookScalarFieldEnum;
    having?: IndividualBookScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: IndividualBookCountAggregateInputType | true;
    _avg?: IndividualBookAvgAggregateInputType;
    _sum?: IndividualBookSumAggregateInputType;
    _min?: IndividualBookMinAggregateInputType;
    _max?: IndividualBookMaxAggregateInputType;
  };

  export type IndividualBookGroupByOutputType = {
    id: string;
    isbn: string | null;
    status: $Enums.BookStatus;
    createdAt: Date;
    updatedAt: Date;
    libraryBookId: string;
    condition: $Enums.AssetCondition;
    borrowCount: number;
    _count: IndividualBookCountAggregateOutputType | null;
    _avg: IndividualBookAvgAggregateOutputType | null;
    _sum: IndividualBookSumAggregateOutputType | null;
    _min: IndividualBookMinAggregateOutputType | null;
    _max: IndividualBookMaxAggregateOutputType | null;
  };

  type GetIndividualBookGroupByPayload<T extends IndividualBookGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<IndividualBookGroupByOutputType, T["by"]> & {
          [P in keyof T &
            keyof IndividualBookGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IndividualBookGroupByOutputType[P]>
            : GetScalarType<T[P], IndividualBookGroupByOutputType[P]>;
        }
      >
    >;

  export type IndividualBookSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      isbn?: boolean;
      status?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      libraryBookId?: boolean;
      condition?: boolean;
      borrowCount?: boolean;
      bookDamages?: boolean | IndividualBook$bookDamagesArgs<ExtArgs>;
      borrowers?: boolean | IndividualBook$borrowersArgs<ExtArgs>;
      libraryBook?: boolean | LibraryBookDefaultArgs<ExtArgs>;
      _count?: boolean | IndividualBookCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["individualBook"]
  >;

  export type IndividualBookSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      isbn?: boolean;
      status?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      libraryBookId?: boolean;
      condition?: boolean;
      borrowCount?: boolean;
      libraryBook?: boolean | LibraryBookDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["individualBook"]
  >;

  export type IndividualBookSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      isbn?: boolean;
      status?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      libraryBookId?: boolean;
      condition?: boolean;
      borrowCount?: boolean;
      libraryBook?: boolean | LibraryBookDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["individualBook"]
  >;

  export type IndividualBookSelectScalar = {
    id?: boolean;
    isbn?: boolean;
    status?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    libraryBookId?: boolean;
    condition?: boolean;
    borrowCount?: boolean;
  };

  export type IndividualBookOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | "id"
    | "isbn"
    | "status"
    | "createdAt"
    | "updatedAt"
    | "libraryBookId"
    | "condition"
    | "borrowCount",
    ExtArgs["result"]["individualBook"]
  >;
  export type IndividualBookInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    bookDamages?: boolean | IndividualBook$bookDamagesArgs<ExtArgs>;
    borrowers?: boolean | IndividualBook$borrowersArgs<ExtArgs>;
    libraryBook?: boolean | LibraryBookDefaultArgs<ExtArgs>;
    _count?: boolean | IndividualBookCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type IndividualBookIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    libraryBook?: boolean | LibraryBookDefaultArgs<ExtArgs>;
  };
  export type IndividualBookIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    libraryBook?: boolean | LibraryBookDefaultArgs<ExtArgs>;
  };

  export type $IndividualBookPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "IndividualBook";
    objects: {
      bookDamages: Prisma.$AssetDamagePayload<ExtArgs>[];
      borrowers: Prisma.$BorrowerPayload<ExtArgs>[];
      libraryBook: Prisma.$LibraryBookPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        isbn: string | null;
        status: $Enums.BookStatus;
        createdAt: Date;
        updatedAt: Date;
        libraryBookId: string;
        condition: $Enums.AssetCondition;
        borrowCount: number;
      },
      ExtArgs["result"]["individualBook"]
    >;
    composites: {};
  };

  type IndividualBookGetPayload<
    S extends boolean | null | undefined | IndividualBookDefaultArgs,
  > = $Result.GetResult<Prisma.$IndividualBookPayload, S>;

  type IndividualBookCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    IndividualBookFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: IndividualBookCountAggregateInputType | true;
  };

  export interface IndividualBookDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["IndividualBook"];
      meta: { name: "IndividualBook" };
    };
    /**
     * Find zero or one IndividualBook that matches the filter.
     * @param {IndividualBookFindUniqueArgs} args - Arguments to find a IndividualBook
     * @example
     * // Get one IndividualBook
     * const individualBook = await prisma.individualBook.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IndividualBookFindUniqueArgs>(
      args: SelectSubset<T, IndividualBookFindUniqueArgs<ExtArgs>>,
    ): Prisma__IndividualBookClient<
      $Result.GetResult<
        Prisma.$IndividualBookPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one IndividualBook that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {IndividualBookFindUniqueOrThrowArgs} args - Arguments to find a IndividualBook
     * @example
     * // Get one IndividualBook
     * const individualBook = await prisma.individualBook.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IndividualBookFindUniqueOrThrowArgs>(
      args: SelectSubset<T, IndividualBookFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__IndividualBookClient<
      $Result.GetResult<
        Prisma.$IndividualBookPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first IndividualBook that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndividualBookFindFirstArgs} args - Arguments to find a IndividualBook
     * @example
     * // Get one IndividualBook
     * const individualBook = await prisma.individualBook.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IndividualBookFindFirstArgs>(
      args?: SelectSubset<T, IndividualBookFindFirstArgs<ExtArgs>>,
    ): Prisma__IndividualBookClient<
      $Result.GetResult<
        Prisma.$IndividualBookPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first IndividualBook that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndividualBookFindFirstOrThrowArgs} args - Arguments to find a IndividualBook
     * @example
     * // Get one IndividualBook
     * const individualBook = await prisma.individualBook.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IndividualBookFindFirstOrThrowArgs>(
      args?: SelectSubset<T, IndividualBookFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__IndividualBookClient<
      $Result.GetResult<
        Prisma.$IndividualBookPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more IndividualBooks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndividualBookFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IndividualBooks
     * const individualBooks = await prisma.individualBook.findMany()
     *
     * // Get first 10 IndividualBooks
     * const individualBooks = await prisma.individualBook.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const individualBookWithIdOnly = await prisma.individualBook.findMany({ select: { id: true } })
     *
     */
    findMany<T extends IndividualBookFindManyArgs>(
      args?: SelectSubset<T, IndividualBookFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$IndividualBookPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a IndividualBook.
     * @param {IndividualBookCreateArgs} args - Arguments to create a IndividualBook.
     * @example
     * // Create one IndividualBook
     * const IndividualBook = await prisma.individualBook.create({
     *   data: {
     *     // ... data to create a IndividualBook
     *   }
     * })
     *
     */
    create<T extends IndividualBookCreateArgs>(
      args: SelectSubset<T, IndividualBookCreateArgs<ExtArgs>>,
    ): Prisma__IndividualBookClient<
      $Result.GetResult<
        Prisma.$IndividualBookPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many IndividualBooks.
     * @param {IndividualBookCreateManyArgs} args - Arguments to create many IndividualBooks.
     * @example
     * // Create many IndividualBooks
     * const individualBook = await prisma.individualBook.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends IndividualBookCreateManyArgs>(
      args?: SelectSubset<T, IndividualBookCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many IndividualBooks and returns the data saved in the database.
     * @param {IndividualBookCreateManyAndReturnArgs} args - Arguments to create many IndividualBooks.
     * @example
     * // Create many IndividualBooks
     * const individualBook = await prisma.individualBook.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many IndividualBooks and only return the `id`
     * const individualBookWithIdOnly = await prisma.individualBook.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends IndividualBookCreateManyAndReturnArgs>(
      args?: SelectSubset<T, IndividualBookCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$IndividualBookPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a IndividualBook.
     * @param {IndividualBookDeleteArgs} args - Arguments to delete one IndividualBook.
     * @example
     * // Delete one IndividualBook
     * const IndividualBook = await prisma.individualBook.delete({
     *   where: {
     *     // ... filter to delete one IndividualBook
     *   }
     * })
     *
     */
    delete<T extends IndividualBookDeleteArgs>(
      args: SelectSubset<T, IndividualBookDeleteArgs<ExtArgs>>,
    ): Prisma__IndividualBookClient<
      $Result.GetResult<
        Prisma.$IndividualBookPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one IndividualBook.
     * @param {IndividualBookUpdateArgs} args - Arguments to update one IndividualBook.
     * @example
     * // Update one IndividualBook
     * const individualBook = await prisma.individualBook.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends IndividualBookUpdateArgs>(
      args: SelectSubset<T, IndividualBookUpdateArgs<ExtArgs>>,
    ): Prisma__IndividualBookClient<
      $Result.GetResult<
        Prisma.$IndividualBookPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more IndividualBooks.
     * @param {IndividualBookDeleteManyArgs} args - Arguments to filter IndividualBooks to delete.
     * @example
     * // Delete a few IndividualBooks
     * const { count } = await prisma.individualBook.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends IndividualBookDeleteManyArgs>(
      args?: SelectSubset<T, IndividualBookDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more IndividualBooks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndividualBookUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IndividualBooks
     * const individualBook = await prisma.individualBook.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends IndividualBookUpdateManyArgs>(
      args: SelectSubset<T, IndividualBookUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more IndividualBooks and returns the data updated in the database.
     * @param {IndividualBookUpdateManyAndReturnArgs} args - Arguments to update many IndividualBooks.
     * @example
     * // Update many IndividualBooks
     * const individualBook = await prisma.individualBook.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more IndividualBooks and only return the `id`
     * const individualBookWithIdOnly = await prisma.individualBook.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends IndividualBookUpdateManyAndReturnArgs>(
      args: SelectSubset<T, IndividualBookUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$IndividualBookPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one IndividualBook.
     * @param {IndividualBookUpsertArgs} args - Arguments to update or create a IndividualBook.
     * @example
     * // Update or create a IndividualBook
     * const individualBook = await prisma.individualBook.upsert({
     *   create: {
     *     // ... data to create a IndividualBook
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IndividualBook we want to update
     *   }
     * })
     */
    upsert<T extends IndividualBookUpsertArgs>(
      args: SelectSubset<T, IndividualBookUpsertArgs<ExtArgs>>,
    ): Prisma__IndividualBookClient<
      $Result.GetResult<
        Prisma.$IndividualBookPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of IndividualBooks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndividualBookCountArgs} args - Arguments to filter IndividualBooks to count.
     * @example
     * // Count the number of IndividualBooks
     * const count = await prisma.individualBook.count({
     *   where: {
     *     // ... the filter for the IndividualBooks we want to count
     *   }
     * })
     **/
    count<T extends IndividualBookCountArgs>(
      args?: Subset<T, IndividualBookCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], IndividualBookCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a IndividualBook.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndividualBookAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends IndividualBookAggregateArgs>(
      args: Subset<T, IndividualBookAggregateArgs>,
    ): Prisma.PrismaPromise<GetIndividualBookAggregateType<T>>;

    /**
     * Group by IndividualBook.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndividualBookGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends IndividualBookGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IndividualBookGroupByArgs["orderBy"] }
        : { orderBy?: IndividualBookGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, IndividualBookGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetIndividualBookGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the IndividualBook model
     */
    readonly fields: IndividualBookFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IndividualBook.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IndividualBookClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    bookDamages<T extends IndividualBook$bookDamagesArgs<ExtArgs> = {}>(
      args?: Subset<T, IndividualBook$bookDamagesArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$AssetDamagePayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    borrowers<T extends IndividualBook$borrowersArgs<ExtArgs> = {}>(
      args?: Subset<T, IndividualBook$borrowersArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$BorrowerPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    libraryBook<T extends LibraryBookDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, LibraryBookDefaultArgs<ExtArgs>>,
    ): Prisma__LibraryBookClient<
      | $Result.GetResult<
          Prisma.$LibraryBookPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the IndividualBook model
   */
  interface IndividualBookFieldRefs {
    readonly id: FieldRef<"IndividualBook", "String">;
    readonly isbn: FieldRef<"IndividualBook", "String">;
    readonly status: FieldRef<"IndividualBook", "BookStatus">;
    readonly createdAt: FieldRef<"IndividualBook", "DateTime">;
    readonly updatedAt: FieldRef<"IndividualBook", "DateTime">;
    readonly libraryBookId: FieldRef<"IndividualBook", "String">;
    readonly condition: FieldRef<"IndividualBook", "AssetCondition">;
    readonly borrowCount: FieldRef<"IndividualBook", "Int">;
  }

  // Custom InputTypes
  /**
   * IndividualBook findUnique
   */
  export type IndividualBookFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IndividualBook
     */
    select?: IndividualBookSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the IndividualBook
     */
    omit?: IndividualBookOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndividualBookInclude<ExtArgs> | null;
    /**
     * Filter, which IndividualBook to fetch.
     */
    where: IndividualBookWhereUniqueInput;
  };

  /**
   * IndividualBook findUniqueOrThrow
   */
  export type IndividualBookFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IndividualBook
     */
    select?: IndividualBookSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the IndividualBook
     */
    omit?: IndividualBookOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndividualBookInclude<ExtArgs> | null;
    /**
     * Filter, which IndividualBook to fetch.
     */
    where: IndividualBookWhereUniqueInput;
  };

  /**
   * IndividualBook findFirst
   */
  export type IndividualBookFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IndividualBook
     */
    select?: IndividualBookSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the IndividualBook
     */
    omit?: IndividualBookOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndividualBookInclude<ExtArgs> | null;
    /**
     * Filter, which IndividualBook to fetch.
     */
    where?: IndividualBookWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of IndividualBooks to fetch.
     */
    orderBy?:
      | IndividualBookOrderByWithRelationInput
      | IndividualBookOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for IndividualBooks.
     */
    cursor?: IndividualBookWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` IndividualBooks from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` IndividualBooks.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of IndividualBooks.
     */
    distinct?: IndividualBookScalarFieldEnum | IndividualBookScalarFieldEnum[];
  };

  /**
   * IndividualBook findFirstOrThrow
   */
  export type IndividualBookFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IndividualBook
     */
    select?: IndividualBookSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the IndividualBook
     */
    omit?: IndividualBookOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndividualBookInclude<ExtArgs> | null;
    /**
     * Filter, which IndividualBook to fetch.
     */
    where?: IndividualBookWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of IndividualBooks to fetch.
     */
    orderBy?:
      | IndividualBookOrderByWithRelationInput
      | IndividualBookOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for IndividualBooks.
     */
    cursor?: IndividualBookWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` IndividualBooks from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` IndividualBooks.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of IndividualBooks.
     */
    distinct?: IndividualBookScalarFieldEnum | IndividualBookScalarFieldEnum[];
  };

  /**
   * IndividualBook findMany
   */
  export type IndividualBookFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IndividualBook
     */
    select?: IndividualBookSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the IndividualBook
     */
    omit?: IndividualBookOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndividualBookInclude<ExtArgs> | null;
    /**
     * Filter, which IndividualBooks to fetch.
     */
    where?: IndividualBookWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of IndividualBooks to fetch.
     */
    orderBy?:
      | IndividualBookOrderByWithRelationInput
      | IndividualBookOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing IndividualBooks.
     */
    cursor?: IndividualBookWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` IndividualBooks from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` IndividualBooks.
     */
    skip?: number;
    distinct?: IndividualBookScalarFieldEnum | IndividualBookScalarFieldEnum[];
  };

  /**
   * IndividualBook create
   */
  export type IndividualBookCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IndividualBook
     */
    select?: IndividualBookSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the IndividualBook
     */
    omit?: IndividualBookOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndividualBookInclude<ExtArgs> | null;
    /**
     * The data needed to create a IndividualBook.
     */
    data: XOR<IndividualBookCreateInput, IndividualBookUncheckedCreateInput>;
  };

  /**
   * IndividualBook createMany
   */
  export type IndividualBookCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many IndividualBooks.
     */
    data: IndividualBookCreateManyInput | IndividualBookCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * IndividualBook createManyAndReturn
   */
  export type IndividualBookCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IndividualBook
     */
    select?: IndividualBookSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the IndividualBook
     */
    omit?: IndividualBookOmit<ExtArgs> | null;
    /**
     * The data used to create many IndividualBooks.
     */
    data: IndividualBookCreateManyInput | IndividualBookCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndividualBookIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * IndividualBook update
   */
  export type IndividualBookUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IndividualBook
     */
    select?: IndividualBookSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the IndividualBook
     */
    omit?: IndividualBookOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndividualBookInclude<ExtArgs> | null;
    /**
     * The data needed to update a IndividualBook.
     */
    data: XOR<IndividualBookUpdateInput, IndividualBookUncheckedUpdateInput>;
    /**
     * Choose, which IndividualBook to update.
     */
    where: IndividualBookWhereUniqueInput;
  };

  /**
   * IndividualBook updateMany
   */
  export type IndividualBookUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update IndividualBooks.
     */
    data: XOR<
      IndividualBookUpdateManyMutationInput,
      IndividualBookUncheckedUpdateManyInput
    >;
    /**
     * Filter which IndividualBooks to update
     */
    where?: IndividualBookWhereInput;
    /**
     * Limit how many IndividualBooks to update.
     */
    limit?: number;
  };

  /**
   * IndividualBook updateManyAndReturn
   */
  export type IndividualBookUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IndividualBook
     */
    select?: IndividualBookSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the IndividualBook
     */
    omit?: IndividualBookOmit<ExtArgs> | null;
    /**
     * The data used to update IndividualBooks.
     */
    data: XOR<
      IndividualBookUpdateManyMutationInput,
      IndividualBookUncheckedUpdateManyInput
    >;
    /**
     * Filter which IndividualBooks to update
     */
    where?: IndividualBookWhereInput;
    /**
     * Limit how many IndividualBooks to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndividualBookIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * IndividualBook upsert
   */
  export type IndividualBookUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IndividualBook
     */
    select?: IndividualBookSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the IndividualBook
     */
    omit?: IndividualBookOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndividualBookInclude<ExtArgs> | null;
    /**
     * The filter to search for the IndividualBook to update in case it exists.
     */
    where: IndividualBookWhereUniqueInput;
    /**
     * In case the IndividualBook found by the `where` argument doesn't exist, create a new IndividualBook with this data.
     */
    create: XOR<IndividualBookCreateInput, IndividualBookUncheckedCreateInput>;
    /**
     * In case the IndividualBook was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IndividualBookUpdateInput, IndividualBookUncheckedUpdateInput>;
  };

  /**
   * IndividualBook delete
   */
  export type IndividualBookDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IndividualBook
     */
    select?: IndividualBookSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the IndividualBook
     */
    omit?: IndividualBookOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndividualBookInclude<ExtArgs> | null;
    /**
     * Filter which IndividualBook to delete.
     */
    where: IndividualBookWhereUniqueInput;
  };

  /**
   * IndividualBook deleteMany
   */
  export type IndividualBookDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which IndividualBooks to delete
     */
    where?: IndividualBookWhereInput;
    /**
     * Limit how many IndividualBooks to delete.
     */
    limit?: number;
  };

  /**
   * IndividualBook.bookDamages
   */
  export type IndividualBook$bookDamagesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AssetDamage
     */
    select?: AssetDamageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AssetDamage
     */
    omit?: AssetDamageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetDamageInclude<ExtArgs> | null;
    where?: AssetDamageWhereInput;
    orderBy?:
      | AssetDamageOrderByWithRelationInput
      | AssetDamageOrderByWithRelationInput[];
    cursor?: AssetDamageWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: AssetDamageScalarFieldEnum | AssetDamageScalarFieldEnum[];
  };

  /**
   * IndividualBook.borrowers
   */
  export type IndividualBook$borrowersArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Borrower
     */
    select?: BorrowerSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Borrower
     */
    omit?: BorrowerOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BorrowerInclude<ExtArgs> | null;
    where?: BorrowerWhereInput;
    orderBy?:
      | BorrowerOrderByWithRelationInput
      | BorrowerOrderByWithRelationInput[];
    cursor?: BorrowerWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: BorrowerScalarFieldEnum | BorrowerScalarFieldEnum[];
  };

  /**
   * IndividualBook without action
   */
  export type IndividualBookDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IndividualBook
     */
    select?: IndividualBookSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the IndividualBook
     */
    omit?: IndividualBookOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndividualBookInclude<ExtArgs> | null;
  };

  /**
   * Model LibraryBookCategory
   */

  export type AggregateLibraryBookCategory = {
    _count: LibraryBookCategoryCountAggregateOutputType | null;
    _min: LibraryBookCategoryMinAggregateOutputType | null;
    _max: LibraryBookCategoryMaxAggregateOutputType | null;
  };

  export type LibraryBookCategoryMinAggregateOutputType = {
    id: string | null;
    category: string | null;
    description: string | null;
  };

  export type LibraryBookCategoryMaxAggregateOutputType = {
    id: string | null;
    category: string | null;
    description: string | null;
  };

  export type LibraryBookCategoryCountAggregateOutputType = {
    id: number;
    category: number;
    description: number;
    _all: number;
  };

  export type LibraryBookCategoryMinAggregateInputType = {
    id?: true;
    category?: true;
    description?: true;
  };

  export type LibraryBookCategoryMaxAggregateInputType = {
    id?: true;
    category?: true;
    description?: true;
  };

  export type LibraryBookCategoryCountAggregateInputType = {
    id?: true;
    category?: true;
    description?: true;
    _all?: true;
  };

  export type LibraryBookCategoryAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which LibraryBookCategory to aggregate.
     */
    where?: LibraryBookCategoryWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of LibraryBookCategories to fetch.
     */
    orderBy?:
      | LibraryBookCategoryOrderByWithRelationInput
      | LibraryBookCategoryOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: LibraryBookCategoryWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` LibraryBookCategories from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` LibraryBookCategories.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned LibraryBookCategories
     **/
    _count?: true | LibraryBookCategoryCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: LibraryBookCategoryMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: LibraryBookCategoryMaxAggregateInputType;
  };

  export type GetLibraryBookCategoryAggregateType<
    T extends LibraryBookCategoryAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateLibraryBookCategory]: P extends
      | "_count"
      | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLibraryBookCategory[P]>
      : GetScalarType<T[P], AggregateLibraryBookCategory[P]>;
  };

  export type LibraryBookCategoryGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: LibraryBookCategoryWhereInput;
    orderBy?:
      | LibraryBookCategoryOrderByWithAggregationInput
      | LibraryBookCategoryOrderByWithAggregationInput[];
    by:
      | LibraryBookCategoryScalarFieldEnum[]
      | LibraryBookCategoryScalarFieldEnum;
    having?: LibraryBookCategoryScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: LibraryBookCategoryCountAggregateInputType | true;
    _min?: LibraryBookCategoryMinAggregateInputType;
    _max?: LibraryBookCategoryMaxAggregateInputType;
  };

  export type LibraryBookCategoryGroupByOutputType = {
    id: string;
    category: string;
    description: string | null;
    _count: LibraryBookCategoryCountAggregateOutputType | null;
    _min: LibraryBookCategoryMinAggregateOutputType | null;
    _max: LibraryBookCategoryMaxAggregateOutputType | null;
  };

  type GetLibraryBookCategoryGroupByPayload<
    T extends LibraryBookCategoryGroupByArgs,
  > = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LibraryBookCategoryGroupByOutputType, T["by"]> & {
        [P in keyof T &
          keyof LibraryBookCategoryGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], LibraryBookCategoryGroupByOutputType[P]>
          : GetScalarType<T[P], LibraryBookCategoryGroupByOutputType[P]>;
      }
    >
  >;

  export type LibraryBookCategorySelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      category?: boolean;
      description?: boolean;
      libraryBooks?: boolean | LibraryBookCategory$libraryBooksArgs<ExtArgs>;
      _count?: boolean | LibraryBookCategoryCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["libraryBookCategory"]
  >;

  export type LibraryBookCategorySelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      category?: boolean;
      description?: boolean;
    },
    ExtArgs["result"]["libraryBookCategory"]
  >;

  export type LibraryBookCategorySelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      category?: boolean;
      description?: boolean;
    },
    ExtArgs["result"]["libraryBookCategory"]
  >;

  export type LibraryBookCategorySelectScalar = {
    id?: boolean;
    category?: boolean;
    description?: boolean;
  };

  export type LibraryBookCategoryOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    "id" | "category" | "description",
    ExtArgs["result"]["libraryBookCategory"]
  >;
  export type LibraryBookCategoryInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    libraryBooks?: boolean | LibraryBookCategory$libraryBooksArgs<ExtArgs>;
    _count?: boolean | LibraryBookCategoryCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type LibraryBookCategoryIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};
  export type LibraryBookCategoryIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};

  export type $LibraryBookCategoryPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "LibraryBookCategory";
    objects: {
      libraryBooks: Prisma.$LibraryBookPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        category: string;
        description: string | null;
      },
      ExtArgs["result"]["libraryBookCategory"]
    >;
    composites: {};
  };

  type LibraryBookCategoryGetPayload<
    S extends boolean | null | undefined | LibraryBookCategoryDefaultArgs,
  > = $Result.GetResult<Prisma.$LibraryBookCategoryPayload, S>;

  type LibraryBookCategoryCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    LibraryBookCategoryFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: LibraryBookCategoryCountAggregateInputType | true;
  };

  export interface LibraryBookCategoryDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["LibraryBookCategory"];
      meta: { name: "LibraryBookCategory" };
    };
    /**
     * Find zero or one LibraryBookCategory that matches the filter.
     * @param {LibraryBookCategoryFindUniqueArgs} args - Arguments to find a LibraryBookCategory
     * @example
     * // Get one LibraryBookCategory
     * const libraryBookCategory = await prisma.libraryBookCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LibraryBookCategoryFindUniqueArgs>(
      args: SelectSubset<T, LibraryBookCategoryFindUniqueArgs<ExtArgs>>,
    ): Prisma__LibraryBookCategoryClient<
      $Result.GetResult<
        Prisma.$LibraryBookCategoryPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one LibraryBookCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LibraryBookCategoryFindUniqueOrThrowArgs} args - Arguments to find a LibraryBookCategory
     * @example
     * // Get one LibraryBookCategory
     * const libraryBookCategory = await prisma.libraryBookCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LibraryBookCategoryFindUniqueOrThrowArgs>(
      args: SelectSubset<T, LibraryBookCategoryFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__LibraryBookCategoryClient<
      $Result.GetResult<
        Prisma.$LibraryBookCategoryPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first LibraryBookCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryBookCategoryFindFirstArgs} args - Arguments to find a LibraryBookCategory
     * @example
     * // Get one LibraryBookCategory
     * const libraryBookCategory = await prisma.libraryBookCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LibraryBookCategoryFindFirstArgs>(
      args?: SelectSubset<T, LibraryBookCategoryFindFirstArgs<ExtArgs>>,
    ): Prisma__LibraryBookCategoryClient<
      $Result.GetResult<
        Prisma.$LibraryBookCategoryPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first LibraryBookCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryBookCategoryFindFirstOrThrowArgs} args - Arguments to find a LibraryBookCategory
     * @example
     * // Get one LibraryBookCategory
     * const libraryBookCategory = await prisma.libraryBookCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LibraryBookCategoryFindFirstOrThrowArgs>(
      args?: SelectSubset<T, LibraryBookCategoryFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__LibraryBookCategoryClient<
      $Result.GetResult<
        Prisma.$LibraryBookCategoryPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more LibraryBookCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryBookCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LibraryBookCategories
     * const libraryBookCategories = await prisma.libraryBookCategory.findMany()
     *
     * // Get first 10 LibraryBookCategories
     * const libraryBookCategories = await prisma.libraryBookCategory.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const libraryBookCategoryWithIdOnly = await prisma.libraryBookCategory.findMany({ select: { id: true } })
     *
     */
    findMany<T extends LibraryBookCategoryFindManyArgs>(
      args?: SelectSubset<T, LibraryBookCategoryFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$LibraryBookCategoryPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a LibraryBookCategory.
     * @param {LibraryBookCategoryCreateArgs} args - Arguments to create a LibraryBookCategory.
     * @example
     * // Create one LibraryBookCategory
     * const LibraryBookCategory = await prisma.libraryBookCategory.create({
     *   data: {
     *     // ... data to create a LibraryBookCategory
     *   }
     * })
     *
     */
    create<T extends LibraryBookCategoryCreateArgs>(
      args: SelectSubset<T, LibraryBookCategoryCreateArgs<ExtArgs>>,
    ): Prisma__LibraryBookCategoryClient<
      $Result.GetResult<
        Prisma.$LibraryBookCategoryPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many LibraryBookCategories.
     * @param {LibraryBookCategoryCreateManyArgs} args - Arguments to create many LibraryBookCategories.
     * @example
     * // Create many LibraryBookCategories
     * const libraryBookCategory = await prisma.libraryBookCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends LibraryBookCategoryCreateManyArgs>(
      args?: SelectSubset<T, LibraryBookCategoryCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many LibraryBookCategories and returns the data saved in the database.
     * @param {LibraryBookCategoryCreateManyAndReturnArgs} args - Arguments to create many LibraryBookCategories.
     * @example
     * // Create many LibraryBookCategories
     * const libraryBookCategory = await prisma.libraryBookCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many LibraryBookCategories and only return the `id`
     * const libraryBookCategoryWithIdOnly = await prisma.libraryBookCategory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends LibraryBookCategoryCreateManyAndReturnArgs>(
      args?: SelectSubset<
        T,
        LibraryBookCategoryCreateManyAndReturnArgs<ExtArgs>
      >,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$LibraryBookCategoryPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a LibraryBookCategory.
     * @param {LibraryBookCategoryDeleteArgs} args - Arguments to delete one LibraryBookCategory.
     * @example
     * // Delete one LibraryBookCategory
     * const LibraryBookCategory = await prisma.libraryBookCategory.delete({
     *   where: {
     *     // ... filter to delete one LibraryBookCategory
     *   }
     * })
     *
     */
    delete<T extends LibraryBookCategoryDeleteArgs>(
      args: SelectSubset<T, LibraryBookCategoryDeleteArgs<ExtArgs>>,
    ): Prisma__LibraryBookCategoryClient<
      $Result.GetResult<
        Prisma.$LibraryBookCategoryPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one LibraryBookCategory.
     * @param {LibraryBookCategoryUpdateArgs} args - Arguments to update one LibraryBookCategory.
     * @example
     * // Update one LibraryBookCategory
     * const libraryBookCategory = await prisma.libraryBookCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends LibraryBookCategoryUpdateArgs>(
      args: SelectSubset<T, LibraryBookCategoryUpdateArgs<ExtArgs>>,
    ): Prisma__LibraryBookCategoryClient<
      $Result.GetResult<
        Prisma.$LibraryBookCategoryPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more LibraryBookCategories.
     * @param {LibraryBookCategoryDeleteManyArgs} args - Arguments to filter LibraryBookCategories to delete.
     * @example
     * // Delete a few LibraryBookCategories
     * const { count } = await prisma.libraryBookCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends LibraryBookCategoryDeleteManyArgs>(
      args?: SelectSubset<T, LibraryBookCategoryDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more LibraryBookCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryBookCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LibraryBookCategories
     * const libraryBookCategory = await prisma.libraryBookCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends LibraryBookCategoryUpdateManyArgs>(
      args: SelectSubset<T, LibraryBookCategoryUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more LibraryBookCategories and returns the data updated in the database.
     * @param {LibraryBookCategoryUpdateManyAndReturnArgs} args - Arguments to update many LibraryBookCategories.
     * @example
     * // Update many LibraryBookCategories
     * const libraryBookCategory = await prisma.libraryBookCategory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more LibraryBookCategories and only return the `id`
     * const libraryBookCategoryWithIdOnly = await prisma.libraryBookCategory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends LibraryBookCategoryUpdateManyAndReturnArgs>(
      args: SelectSubset<
        T,
        LibraryBookCategoryUpdateManyAndReturnArgs<ExtArgs>
      >,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$LibraryBookCategoryPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one LibraryBookCategory.
     * @param {LibraryBookCategoryUpsertArgs} args - Arguments to update or create a LibraryBookCategory.
     * @example
     * // Update or create a LibraryBookCategory
     * const libraryBookCategory = await prisma.libraryBookCategory.upsert({
     *   create: {
     *     // ... data to create a LibraryBookCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LibraryBookCategory we want to update
     *   }
     * })
     */
    upsert<T extends LibraryBookCategoryUpsertArgs>(
      args: SelectSubset<T, LibraryBookCategoryUpsertArgs<ExtArgs>>,
    ): Prisma__LibraryBookCategoryClient<
      $Result.GetResult<
        Prisma.$LibraryBookCategoryPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of LibraryBookCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryBookCategoryCountArgs} args - Arguments to filter LibraryBookCategories to count.
     * @example
     * // Count the number of LibraryBookCategories
     * const count = await prisma.libraryBookCategory.count({
     *   where: {
     *     // ... the filter for the LibraryBookCategories we want to count
     *   }
     * })
     **/
    count<T extends LibraryBookCategoryCountArgs>(
      args?: Subset<T, LibraryBookCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<
              T["select"],
              LibraryBookCategoryCountAggregateOutputType
            >
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a LibraryBookCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryBookCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends LibraryBookCategoryAggregateArgs>(
      args: Subset<T, LibraryBookCategoryAggregateArgs>,
    ): Prisma.PrismaPromise<GetLibraryBookCategoryAggregateType<T>>;

    /**
     * Group by LibraryBookCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryBookCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends LibraryBookCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LibraryBookCategoryGroupByArgs["orderBy"] }
        : { orderBy?: LibraryBookCategoryGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, LibraryBookCategoryGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetLibraryBookCategoryGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the LibraryBookCategory model
     */
    readonly fields: LibraryBookCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LibraryBookCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LibraryBookCategoryClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    libraryBooks<T extends LibraryBookCategory$libraryBooksArgs<ExtArgs> = {}>(
      args?: Subset<T, LibraryBookCategory$libraryBooksArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$LibraryBookPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the LibraryBookCategory model
   */
  interface LibraryBookCategoryFieldRefs {
    readonly id: FieldRef<"LibraryBookCategory", "String">;
    readonly category: FieldRef<"LibraryBookCategory", "String">;
    readonly description: FieldRef<"LibraryBookCategory", "String">;
  }

  // Custom InputTypes
  /**
   * LibraryBookCategory findUnique
   */
  export type LibraryBookCategoryFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LibraryBookCategory
     */
    select?: LibraryBookCategorySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the LibraryBookCategory
     */
    omit?: LibraryBookCategoryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryBookCategoryInclude<ExtArgs> | null;
    /**
     * Filter, which LibraryBookCategory to fetch.
     */
    where: LibraryBookCategoryWhereUniqueInput;
  };

  /**
   * LibraryBookCategory findUniqueOrThrow
   */
  export type LibraryBookCategoryFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LibraryBookCategory
     */
    select?: LibraryBookCategorySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the LibraryBookCategory
     */
    omit?: LibraryBookCategoryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryBookCategoryInclude<ExtArgs> | null;
    /**
     * Filter, which LibraryBookCategory to fetch.
     */
    where: LibraryBookCategoryWhereUniqueInput;
  };

  /**
   * LibraryBookCategory findFirst
   */
  export type LibraryBookCategoryFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LibraryBookCategory
     */
    select?: LibraryBookCategorySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the LibraryBookCategory
     */
    omit?: LibraryBookCategoryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryBookCategoryInclude<ExtArgs> | null;
    /**
     * Filter, which LibraryBookCategory to fetch.
     */
    where?: LibraryBookCategoryWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of LibraryBookCategories to fetch.
     */
    orderBy?:
      | LibraryBookCategoryOrderByWithRelationInput
      | LibraryBookCategoryOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for LibraryBookCategories.
     */
    cursor?: LibraryBookCategoryWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` LibraryBookCategories from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` LibraryBookCategories.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of LibraryBookCategories.
     */
    distinct?:
      | LibraryBookCategoryScalarFieldEnum
      | LibraryBookCategoryScalarFieldEnum[];
  };

  /**
   * LibraryBookCategory findFirstOrThrow
   */
  export type LibraryBookCategoryFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LibraryBookCategory
     */
    select?: LibraryBookCategorySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the LibraryBookCategory
     */
    omit?: LibraryBookCategoryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryBookCategoryInclude<ExtArgs> | null;
    /**
     * Filter, which LibraryBookCategory to fetch.
     */
    where?: LibraryBookCategoryWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of LibraryBookCategories to fetch.
     */
    orderBy?:
      | LibraryBookCategoryOrderByWithRelationInput
      | LibraryBookCategoryOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for LibraryBookCategories.
     */
    cursor?: LibraryBookCategoryWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` LibraryBookCategories from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` LibraryBookCategories.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of LibraryBookCategories.
     */
    distinct?:
      | LibraryBookCategoryScalarFieldEnum
      | LibraryBookCategoryScalarFieldEnum[];
  };

  /**
   * LibraryBookCategory findMany
   */
  export type LibraryBookCategoryFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LibraryBookCategory
     */
    select?: LibraryBookCategorySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the LibraryBookCategory
     */
    omit?: LibraryBookCategoryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryBookCategoryInclude<ExtArgs> | null;
    /**
     * Filter, which LibraryBookCategories to fetch.
     */
    where?: LibraryBookCategoryWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of LibraryBookCategories to fetch.
     */
    orderBy?:
      | LibraryBookCategoryOrderByWithRelationInput
      | LibraryBookCategoryOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing LibraryBookCategories.
     */
    cursor?: LibraryBookCategoryWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` LibraryBookCategories from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` LibraryBookCategories.
     */
    skip?: number;
    distinct?:
      | LibraryBookCategoryScalarFieldEnum
      | LibraryBookCategoryScalarFieldEnum[];
  };

  /**
   * LibraryBookCategory create
   */
  export type LibraryBookCategoryCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LibraryBookCategory
     */
    select?: LibraryBookCategorySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the LibraryBookCategory
     */
    omit?: LibraryBookCategoryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryBookCategoryInclude<ExtArgs> | null;
    /**
     * The data needed to create a LibraryBookCategory.
     */
    data: XOR<
      LibraryBookCategoryCreateInput,
      LibraryBookCategoryUncheckedCreateInput
    >;
  };

  /**
   * LibraryBookCategory createMany
   */
  export type LibraryBookCategoryCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many LibraryBookCategories.
     */
    data:
      | LibraryBookCategoryCreateManyInput
      | LibraryBookCategoryCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * LibraryBookCategory createManyAndReturn
   */
  export type LibraryBookCategoryCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LibraryBookCategory
     */
    select?: LibraryBookCategorySelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the LibraryBookCategory
     */
    omit?: LibraryBookCategoryOmit<ExtArgs> | null;
    /**
     * The data used to create many LibraryBookCategories.
     */
    data:
      | LibraryBookCategoryCreateManyInput
      | LibraryBookCategoryCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * LibraryBookCategory update
   */
  export type LibraryBookCategoryUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LibraryBookCategory
     */
    select?: LibraryBookCategorySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the LibraryBookCategory
     */
    omit?: LibraryBookCategoryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryBookCategoryInclude<ExtArgs> | null;
    /**
     * The data needed to update a LibraryBookCategory.
     */
    data: XOR<
      LibraryBookCategoryUpdateInput,
      LibraryBookCategoryUncheckedUpdateInput
    >;
    /**
     * Choose, which LibraryBookCategory to update.
     */
    where: LibraryBookCategoryWhereUniqueInput;
  };

  /**
   * LibraryBookCategory updateMany
   */
  export type LibraryBookCategoryUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update LibraryBookCategories.
     */
    data: XOR<
      LibraryBookCategoryUpdateManyMutationInput,
      LibraryBookCategoryUncheckedUpdateManyInput
    >;
    /**
     * Filter which LibraryBookCategories to update
     */
    where?: LibraryBookCategoryWhereInput;
    /**
     * Limit how many LibraryBookCategories to update.
     */
    limit?: number;
  };

  /**
   * LibraryBookCategory updateManyAndReturn
   */
  export type LibraryBookCategoryUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LibraryBookCategory
     */
    select?: LibraryBookCategorySelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the LibraryBookCategory
     */
    omit?: LibraryBookCategoryOmit<ExtArgs> | null;
    /**
     * The data used to update LibraryBookCategories.
     */
    data: XOR<
      LibraryBookCategoryUpdateManyMutationInput,
      LibraryBookCategoryUncheckedUpdateManyInput
    >;
    /**
     * Filter which LibraryBookCategories to update
     */
    where?: LibraryBookCategoryWhereInput;
    /**
     * Limit how many LibraryBookCategories to update.
     */
    limit?: number;
  };

  /**
   * LibraryBookCategory upsert
   */
  export type LibraryBookCategoryUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LibraryBookCategory
     */
    select?: LibraryBookCategorySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the LibraryBookCategory
     */
    omit?: LibraryBookCategoryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryBookCategoryInclude<ExtArgs> | null;
    /**
     * The filter to search for the LibraryBookCategory to update in case it exists.
     */
    where: LibraryBookCategoryWhereUniqueInput;
    /**
     * In case the LibraryBookCategory found by the `where` argument doesn't exist, create a new LibraryBookCategory with this data.
     */
    create: XOR<
      LibraryBookCategoryCreateInput,
      LibraryBookCategoryUncheckedCreateInput
    >;
    /**
     * In case the LibraryBookCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<
      LibraryBookCategoryUpdateInput,
      LibraryBookCategoryUncheckedUpdateInput
    >;
  };

  /**
   * LibraryBookCategory delete
   */
  export type LibraryBookCategoryDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LibraryBookCategory
     */
    select?: LibraryBookCategorySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the LibraryBookCategory
     */
    omit?: LibraryBookCategoryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryBookCategoryInclude<ExtArgs> | null;
    /**
     * Filter which LibraryBookCategory to delete.
     */
    where: LibraryBookCategoryWhereUniqueInput;
  };

  /**
   * LibraryBookCategory deleteMany
   */
  export type LibraryBookCategoryDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which LibraryBookCategories to delete
     */
    where?: LibraryBookCategoryWhereInput;
    /**
     * Limit how many LibraryBookCategories to delete.
     */
    limit?: number;
  };

  /**
   * LibraryBookCategory.libraryBooks
   */
  export type LibraryBookCategory$libraryBooksArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LibraryBook
     */
    select?: LibraryBookSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the LibraryBook
     */
    omit?: LibraryBookOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryBookInclude<ExtArgs> | null;
    where?: LibraryBookWhereInput;
    orderBy?:
      | LibraryBookOrderByWithRelationInput
      | LibraryBookOrderByWithRelationInput[];
    cursor?: LibraryBookWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: LibraryBookScalarFieldEnum | LibraryBookScalarFieldEnum[];
  };

  /**
   * LibraryBookCategory without action
   */
  export type LibraryBookCategoryDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LibraryBookCategory
     */
    select?: LibraryBookCategorySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the LibraryBookCategory
     */
    omit?: LibraryBookCategoryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryBookCategoryInclude<ExtArgs> | null;
  };

  /**
   * Model Borrower
   */

  export type AggregateBorrower = {
    _count: BorrowerCountAggregateOutputType | null;
    _min: BorrowerMinAggregateOutputType | null;
    _max: BorrowerMaxAggregateOutputType | null;
  };

  export type BorrowerMinAggregateOutputType = {
    id: string | null;
    borrowedAt: Date | null;
    returnAt: Date | null;
    status: $Enums.BorrowStatus | null;
    userId: string | null;
    individualBookId: string | null;
  };

  export type BorrowerMaxAggregateOutputType = {
    id: string | null;
    borrowedAt: Date | null;
    returnAt: Date | null;
    status: $Enums.BorrowStatus | null;
    userId: string | null;
    individualBookId: string | null;
  };

  export type BorrowerCountAggregateOutputType = {
    id: number;
    borrowedAt: number;
    returnAt: number;
    status: number;
    userId: number;
    individualBookId: number;
    _all: number;
  };

  export type BorrowerMinAggregateInputType = {
    id?: true;
    borrowedAt?: true;
    returnAt?: true;
    status?: true;
    userId?: true;
    individualBookId?: true;
  };

  export type BorrowerMaxAggregateInputType = {
    id?: true;
    borrowedAt?: true;
    returnAt?: true;
    status?: true;
    userId?: true;
    individualBookId?: true;
  };

  export type BorrowerCountAggregateInputType = {
    id?: true;
    borrowedAt?: true;
    returnAt?: true;
    status?: true;
    userId?: true;
    individualBookId?: true;
    _all?: true;
  };

  export type BorrowerAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Borrower to aggregate.
     */
    where?: BorrowerWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Borrowers to fetch.
     */
    orderBy?:
      | BorrowerOrderByWithRelationInput
      | BorrowerOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: BorrowerWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Borrowers from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Borrowers.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Borrowers
     **/
    _count?: true | BorrowerCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: BorrowerMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: BorrowerMaxAggregateInputType;
  };

  export type GetBorrowerAggregateType<T extends BorrowerAggregateArgs> = {
    [P in keyof T & keyof AggregateBorrower]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBorrower[P]>
      : GetScalarType<T[P], AggregateBorrower[P]>;
  };

  export type BorrowerGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: BorrowerWhereInput;
    orderBy?:
      | BorrowerOrderByWithAggregationInput
      | BorrowerOrderByWithAggregationInput[];
    by: BorrowerScalarFieldEnum[] | BorrowerScalarFieldEnum;
    having?: BorrowerScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: BorrowerCountAggregateInputType | true;
    _min?: BorrowerMinAggregateInputType;
    _max?: BorrowerMaxAggregateInputType;
  };

  export type BorrowerGroupByOutputType = {
    id: string;
    borrowedAt: Date;
    returnAt: Date | null;
    status: $Enums.BorrowStatus;
    userId: string;
    individualBookId: string | null;
    _count: BorrowerCountAggregateOutputType | null;
    _min: BorrowerMinAggregateOutputType | null;
    _max: BorrowerMaxAggregateOutputType | null;
  };

  type GetBorrowerGroupByPayload<T extends BorrowerGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<BorrowerGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof BorrowerGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BorrowerGroupByOutputType[P]>
            : GetScalarType<T[P], BorrowerGroupByOutputType[P]>;
        }
      >
    >;

  export type BorrowerSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      borrowedAt?: boolean;
      returnAt?: boolean;
      status?: boolean;
      userId?: boolean;
      individualBookId?: boolean;
      libraryBook?: boolean | Borrower$libraryBookArgs<ExtArgs>;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["borrower"]
  >;

  export type BorrowerSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      borrowedAt?: boolean;
      returnAt?: boolean;
      status?: boolean;
      userId?: boolean;
      individualBookId?: boolean;
      libraryBook?: boolean | Borrower$libraryBookArgs<ExtArgs>;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["borrower"]
  >;

  export type BorrowerSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      borrowedAt?: boolean;
      returnAt?: boolean;
      status?: boolean;
      userId?: boolean;
      individualBookId?: boolean;
      libraryBook?: boolean | Borrower$libraryBookArgs<ExtArgs>;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["borrower"]
  >;

  export type BorrowerSelectScalar = {
    id?: boolean;
    borrowedAt?: boolean;
    returnAt?: boolean;
    status?: boolean;
    userId?: boolean;
    individualBookId?: boolean;
  };

  export type BorrowerOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    "id" | "borrowedAt" | "returnAt" | "status" | "userId" | "individualBookId",
    ExtArgs["result"]["borrower"]
  >;
  export type BorrowerInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    libraryBook?: boolean | Borrower$libraryBookArgs<ExtArgs>;
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type BorrowerIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    libraryBook?: boolean | Borrower$libraryBookArgs<ExtArgs>;
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type BorrowerIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    libraryBook?: boolean | Borrower$libraryBookArgs<ExtArgs>;
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $BorrowerPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "Borrower";
    objects: {
      libraryBook: Prisma.$IndividualBookPayload<ExtArgs> | null;
      user: Prisma.$UserPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        borrowedAt: Date;
        returnAt: Date | null;
        status: $Enums.BorrowStatus;
        userId: string;
        individualBookId: string | null;
      },
      ExtArgs["result"]["borrower"]
    >;
    composites: {};
  };

  type BorrowerGetPayload<
    S extends boolean | null | undefined | BorrowerDefaultArgs,
  > = $Result.GetResult<Prisma.$BorrowerPayload, S>;

  type BorrowerCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<BorrowerFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
    select?: BorrowerCountAggregateInputType | true;
  };

  export interface BorrowerDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["Borrower"];
      meta: { name: "Borrower" };
    };
    /**
     * Find zero or one Borrower that matches the filter.
     * @param {BorrowerFindUniqueArgs} args - Arguments to find a Borrower
     * @example
     * // Get one Borrower
     * const borrower = await prisma.borrower.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BorrowerFindUniqueArgs>(
      args: SelectSubset<T, BorrowerFindUniqueArgs<ExtArgs>>,
    ): Prisma__BorrowerClient<
      $Result.GetResult<
        Prisma.$BorrowerPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Borrower that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BorrowerFindUniqueOrThrowArgs} args - Arguments to find a Borrower
     * @example
     * // Get one Borrower
     * const borrower = await prisma.borrower.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BorrowerFindUniqueOrThrowArgs>(
      args: SelectSubset<T, BorrowerFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__BorrowerClient<
      $Result.GetResult<
        Prisma.$BorrowerPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Borrower that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BorrowerFindFirstArgs} args - Arguments to find a Borrower
     * @example
     * // Get one Borrower
     * const borrower = await prisma.borrower.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BorrowerFindFirstArgs>(
      args?: SelectSubset<T, BorrowerFindFirstArgs<ExtArgs>>,
    ): Prisma__BorrowerClient<
      $Result.GetResult<
        Prisma.$BorrowerPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Borrower that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BorrowerFindFirstOrThrowArgs} args - Arguments to find a Borrower
     * @example
     * // Get one Borrower
     * const borrower = await prisma.borrower.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BorrowerFindFirstOrThrowArgs>(
      args?: SelectSubset<T, BorrowerFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__BorrowerClient<
      $Result.GetResult<
        Prisma.$BorrowerPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Borrowers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BorrowerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Borrowers
     * const borrowers = await prisma.borrower.findMany()
     *
     * // Get first 10 Borrowers
     * const borrowers = await prisma.borrower.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const borrowerWithIdOnly = await prisma.borrower.findMany({ select: { id: true } })
     *
     */
    findMany<T extends BorrowerFindManyArgs>(
      args?: SelectSubset<T, BorrowerFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$BorrowerPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Borrower.
     * @param {BorrowerCreateArgs} args - Arguments to create a Borrower.
     * @example
     * // Create one Borrower
     * const Borrower = await prisma.borrower.create({
     *   data: {
     *     // ... data to create a Borrower
     *   }
     * })
     *
     */
    create<T extends BorrowerCreateArgs>(
      args: SelectSubset<T, BorrowerCreateArgs<ExtArgs>>,
    ): Prisma__BorrowerClient<
      $Result.GetResult<
        Prisma.$BorrowerPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Borrowers.
     * @param {BorrowerCreateManyArgs} args - Arguments to create many Borrowers.
     * @example
     * // Create many Borrowers
     * const borrower = await prisma.borrower.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends BorrowerCreateManyArgs>(
      args?: SelectSubset<T, BorrowerCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Borrowers and returns the data saved in the database.
     * @param {BorrowerCreateManyAndReturnArgs} args - Arguments to create many Borrowers.
     * @example
     * // Create many Borrowers
     * const borrower = await prisma.borrower.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Borrowers and only return the `id`
     * const borrowerWithIdOnly = await prisma.borrower.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends BorrowerCreateManyAndReturnArgs>(
      args?: SelectSubset<T, BorrowerCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$BorrowerPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Borrower.
     * @param {BorrowerDeleteArgs} args - Arguments to delete one Borrower.
     * @example
     * // Delete one Borrower
     * const Borrower = await prisma.borrower.delete({
     *   where: {
     *     // ... filter to delete one Borrower
     *   }
     * })
     *
     */
    delete<T extends BorrowerDeleteArgs>(
      args: SelectSubset<T, BorrowerDeleteArgs<ExtArgs>>,
    ): Prisma__BorrowerClient<
      $Result.GetResult<
        Prisma.$BorrowerPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Borrower.
     * @param {BorrowerUpdateArgs} args - Arguments to update one Borrower.
     * @example
     * // Update one Borrower
     * const borrower = await prisma.borrower.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends BorrowerUpdateArgs>(
      args: SelectSubset<T, BorrowerUpdateArgs<ExtArgs>>,
    ): Prisma__BorrowerClient<
      $Result.GetResult<
        Prisma.$BorrowerPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Borrowers.
     * @param {BorrowerDeleteManyArgs} args - Arguments to filter Borrowers to delete.
     * @example
     * // Delete a few Borrowers
     * const { count } = await prisma.borrower.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends BorrowerDeleteManyArgs>(
      args?: SelectSubset<T, BorrowerDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Borrowers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BorrowerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Borrowers
     * const borrower = await prisma.borrower.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends BorrowerUpdateManyArgs>(
      args: SelectSubset<T, BorrowerUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Borrowers and returns the data updated in the database.
     * @param {BorrowerUpdateManyAndReturnArgs} args - Arguments to update many Borrowers.
     * @example
     * // Update many Borrowers
     * const borrower = await prisma.borrower.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Borrowers and only return the `id`
     * const borrowerWithIdOnly = await prisma.borrower.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends BorrowerUpdateManyAndReturnArgs>(
      args: SelectSubset<T, BorrowerUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$BorrowerPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Borrower.
     * @param {BorrowerUpsertArgs} args - Arguments to update or create a Borrower.
     * @example
     * // Update or create a Borrower
     * const borrower = await prisma.borrower.upsert({
     *   create: {
     *     // ... data to create a Borrower
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Borrower we want to update
     *   }
     * })
     */
    upsert<T extends BorrowerUpsertArgs>(
      args: SelectSubset<T, BorrowerUpsertArgs<ExtArgs>>,
    ): Prisma__BorrowerClient<
      $Result.GetResult<
        Prisma.$BorrowerPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Borrowers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BorrowerCountArgs} args - Arguments to filter Borrowers to count.
     * @example
     * // Count the number of Borrowers
     * const count = await prisma.borrower.count({
     *   where: {
     *     // ... the filter for the Borrowers we want to count
     *   }
     * })
     **/
    count<T extends BorrowerCountArgs>(
      args?: Subset<T, BorrowerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], BorrowerCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Borrower.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BorrowerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends BorrowerAggregateArgs>(
      args: Subset<T, BorrowerAggregateArgs>,
    ): Prisma.PrismaPromise<GetBorrowerAggregateType<T>>;

    /**
     * Group by Borrower.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BorrowerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends BorrowerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BorrowerGroupByArgs["orderBy"] }
        : { orderBy?: BorrowerGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, BorrowerGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetBorrowerGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Borrower model
     */
    readonly fields: BorrowerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Borrower.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BorrowerClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    libraryBook<T extends Borrower$libraryBookArgs<ExtArgs> = {}>(
      args?: Subset<T, Borrower$libraryBookArgs<ExtArgs>>,
    ): Prisma__IndividualBookClient<
      $Result.GetResult<
        Prisma.$IndividualBookPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>,
    ): Prisma__UserClient<
      | $Result.GetResult<
          Prisma.$UserPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Borrower model
   */
  interface BorrowerFieldRefs {
    readonly id: FieldRef<"Borrower", "String">;
    readonly borrowedAt: FieldRef<"Borrower", "DateTime">;
    readonly returnAt: FieldRef<"Borrower", "DateTime">;
    readonly status: FieldRef<"Borrower", "BorrowStatus">;
    readonly userId: FieldRef<"Borrower", "String">;
    readonly individualBookId: FieldRef<"Borrower", "String">;
  }

  // Custom InputTypes
  /**
   * Borrower findUnique
   */
  export type BorrowerFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Borrower
     */
    select?: BorrowerSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Borrower
     */
    omit?: BorrowerOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BorrowerInclude<ExtArgs> | null;
    /**
     * Filter, which Borrower to fetch.
     */
    where: BorrowerWhereUniqueInput;
  };

  /**
   * Borrower findUniqueOrThrow
   */
  export type BorrowerFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Borrower
     */
    select?: BorrowerSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Borrower
     */
    omit?: BorrowerOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BorrowerInclude<ExtArgs> | null;
    /**
     * Filter, which Borrower to fetch.
     */
    where: BorrowerWhereUniqueInput;
  };

  /**
   * Borrower findFirst
   */
  export type BorrowerFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Borrower
     */
    select?: BorrowerSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Borrower
     */
    omit?: BorrowerOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BorrowerInclude<ExtArgs> | null;
    /**
     * Filter, which Borrower to fetch.
     */
    where?: BorrowerWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Borrowers to fetch.
     */
    orderBy?:
      | BorrowerOrderByWithRelationInput
      | BorrowerOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Borrowers.
     */
    cursor?: BorrowerWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Borrowers from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Borrowers.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Borrowers.
     */
    distinct?: BorrowerScalarFieldEnum | BorrowerScalarFieldEnum[];
  };

  /**
   * Borrower findFirstOrThrow
   */
  export type BorrowerFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Borrower
     */
    select?: BorrowerSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Borrower
     */
    omit?: BorrowerOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BorrowerInclude<ExtArgs> | null;
    /**
     * Filter, which Borrower to fetch.
     */
    where?: BorrowerWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Borrowers to fetch.
     */
    orderBy?:
      | BorrowerOrderByWithRelationInput
      | BorrowerOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Borrowers.
     */
    cursor?: BorrowerWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Borrowers from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Borrowers.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Borrowers.
     */
    distinct?: BorrowerScalarFieldEnum | BorrowerScalarFieldEnum[];
  };

  /**
   * Borrower findMany
   */
  export type BorrowerFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Borrower
     */
    select?: BorrowerSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Borrower
     */
    omit?: BorrowerOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BorrowerInclude<ExtArgs> | null;
    /**
     * Filter, which Borrowers to fetch.
     */
    where?: BorrowerWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Borrowers to fetch.
     */
    orderBy?:
      | BorrowerOrderByWithRelationInput
      | BorrowerOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Borrowers.
     */
    cursor?: BorrowerWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Borrowers from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Borrowers.
     */
    skip?: number;
    distinct?: BorrowerScalarFieldEnum | BorrowerScalarFieldEnum[];
  };

  /**
   * Borrower create
   */
  export type BorrowerCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Borrower
     */
    select?: BorrowerSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Borrower
     */
    omit?: BorrowerOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BorrowerInclude<ExtArgs> | null;
    /**
     * The data needed to create a Borrower.
     */
    data: XOR<BorrowerCreateInput, BorrowerUncheckedCreateInput>;
  };

  /**
   * Borrower createMany
   */
  export type BorrowerCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Borrowers.
     */
    data: BorrowerCreateManyInput | BorrowerCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Borrower createManyAndReturn
   */
  export type BorrowerCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Borrower
     */
    select?: BorrowerSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Borrower
     */
    omit?: BorrowerOmit<ExtArgs> | null;
    /**
     * The data used to create many Borrowers.
     */
    data: BorrowerCreateManyInput | BorrowerCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BorrowerIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Borrower update
   */
  export type BorrowerUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Borrower
     */
    select?: BorrowerSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Borrower
     */
    omit?: BorrowerOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BorrowerInclude<ExtArgs> | null;
    /**
     * The data needed to update a Borrower.
     */
    data: XOR<BorrowerUpdateInput, BorrowerUncheckedUpdateInput>;
    /**
     * Choose, which Borrower to update.
     */
    where: BorrowerWhereUniqueInput;
  };

  /**
   * Borrower updateMany
   */
  export type BorrowerUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Borrowers.
     */
    data: XOR<
      BorrowerUpdateManyMutationInput,
      BorrowerUncheckedUpdateManyInput
    >;
    /**
     * Filter which Borrowers to update
     */
    where?: BorrowerWhereInput;
    /**
     * Limit how many Borrowers to update.
     */
    limit?: number;
  };

  /**
   * Borrower updateManyAndReturn
   */
  export type BorrowerUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Borrower
     */
    select?: BorrowerSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Borrower
     */
    omit?: BorrowerOmit<ExtArgs> | null;
    /**
     * The data used to update Borrowers.
     */
    data: XOR<
      BorrowerUpdateManyMutationInput,
      BorrowerUncheckedUpdateManyInput
    >;
    /**
     * Filter which Borrowers to update
     */
    where?: BorrowerWhereInput;
    /**
     * Limit how many Borrowers to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BorrowerIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Borrower upsert
   */
  export type BorrowerUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Borrower
     */
    select?: BorrowerSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Borrower
     */
    omit?: BorrowerOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BorrowerInclude<ExtArgs> | null;
    /**
     * The filter to search for the Borrower to update in case it exists.
     */
    where: BorrowerWhereUniqueInput;
    /**
     * In case the Borrower found by the `where` argument doesn't exist, create a new Borrower with this data.
     */
    create: XOR<BorrowerCreateInput, BorrowerUncheckedCreateInput>;
    /**
     * In case the Borrower was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BorrowerUpdateInput, BorrowerUncheckedUpdateInput>;
  };

  /**
   * Borrower delete
   */
  export type BorrowerDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Borrower
     */
    select?: BorrowerSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Borrower
     */
    omit?: BorrowerOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BorrowerInclude<ExtArgs> | null;
    /**
     * Filter which Borrower to delete.
     */
    where: BorrowerWhereUniqueInput;
  };

  /**
   * Borrower deleteMany
   */
  export type BorrowerDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Borrowers to delete
     */
    where?: BorrowerWhereInput;
    /**
     * Limit how many Borrowers to delete.
     */
    limit?: number;
  };

  /**
   * Borrower.libraryBook
   */
  export type Borrower$libraryBookArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IndividualBook
     */
    select?: IndividualBookSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the IndividualBook
     */
    omit?: IndividualBookOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndividualBookInclude<ExtArgs> | null;
    where?: IndividualBookWhereInput;
  };

  /**
   * Borrower without action
   */
  export type BorrowerDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Borrower
     */
    select?: BorrowerSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Borrower
     */
    omit?: BorrowerOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BorrowerInclude<ExtArgs> | null;
  };

  /**
   * Model LabItem
   */

  export type AggregateLabItem = {
    _count: LabItemCountAggregateOutputType | null;
    _avg: LabItemAvgAggregateOutputType | null;
    _sum: LabItemSumAggregateOutputType | null;
    _min: LabItemMinAggregateOutputType | null;
    _max: LabItemMaxAggregateOutputType | null;
  };

  export type LabItemAvgAggregateOutputType = {
    quantity: number | null;
  };

  export type LabItemSumAggregateOutputType = {
    quantity: number | null;
  };

  export type LabItemMinAggregateOutputType = {
    id: string | null;
    name: string | null;
    quantity: number | null;
    unit: $Enums.AssetUnit | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    assetId: string | null;
    trackQuantity: boolean | null;
    status: $Enums.AssetStatus | null;
  };

  export type LabItemMaxAggregateOutputType = {
    id: string | null;
    name: string | null;
    quantity: number | null;
    unit: $Enums.AssetUnit | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    assetId: string | null;
    trackQuantity: boolean | null;
    status: $Enums.AssetStatus | null;
  };

  export type LabItemCountAggregateOutputType = {
    id: number;
    name: number;
    quantity: number;
    unit: number;
    createdAt: number;
    updatedAt: number;
    assetId: number;
    trackQuantity: number;
    status: number;
    _all: number;
  };

  export type LabItemAvgAggregateInputType = {
    quantity?: true;
  };

  export type LabItemSumAggregateInputType = {
    quantity?: true;
  };

  export type LabItemMinAggregateInputType = {
    id?: true;
    name?: true;
    quantity?: true;
    unit?: true;
    createdAt?: true;
    updatedAt?: true;
    assetId?: true;
    trackQuantity?: true;
    status?: true;
  };

  export type LabItemMaxAggregateInputType = {
    id?: true;
    name?: true;
    quantity?: true;
    unit?: true;
    createdAt?: true;
    updatedAt?: true;
    assetId?: true;
    trackQuantity?: true;
    status?: true;
  };

  export type LabItemCountAggregateInputType = {
    id?: true;
    name?: true;
    quantity?: true;
    unit?: true;
    createdAt?: true;
    updatedAt?: true;
    assetId?: true;
    trackQuantity?: true;
    status?: true;
    _all?: true;
  };

  export type LabItemAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which LabItem to aggregate.
     */
    where?: LabItemWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of LabItems to fetch.
     */
    orderBy?:
      | LabItemOrderByWithRelationInput
      | LabItemOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: LabItemWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` LabItems from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` LabItems.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned LabItems
     **/
    _count?: true | LabItemCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: LabItemAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: LabItemSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: LabItemMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: LabItemMaxAggregateInputType;
  };

  export type GetLabItemAggregateType<T extends LabItemAggregateArgs> = {
    [P in keyof T & keyof AggregateLabItem]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLabItem[P]>
      : GetScalarType<T[P], AggregateLabItem[P]>;
  };

  export type LabItemGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: LabItemWhereInput;
    orderBy?:
      | LabItemOrderByWithAggregationInput
      | LabItemOrderByWithAggregationInput[];
    by: LabItemScalarFieldEnum[] | LabItemScalarFieldEnum;
    having?: LabItemScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: LabItemCountAggregateInputType | true;
    _avg?: LabItemAvgAggregateInputType;
    _sum?: LabItemSumAggregateInputType;
    _min?: LabItemMinAggregateInputType;
    _max?: LabItemMaxAggregateInputType;
  };

  export type LabItemGroupByOutputType = {
    id: string;
    name: string;
    quantity: number | null;
    unit: $Enums.AssetUnit;
    createdAt: Date;
    updatedAt: Date;
    assetId: string;
    trackQuantity: boolean;
    status: $Enums.AssetStatus;
    _count: LabItemCountAggregateOutputType | null;
    _avg: LabItemAvgAggregateOutputType | null;
    _sum: LabItemSumAggregateOutputType | null;
    _min: LabItemMinAggregateOutputType | null;
    _max: LabItemMaxAggregateOutputType | null;
  };

  type GetLabItemGroupByPayload<T extends LabItemGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<LabItemGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof LabItemGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LabItemGroupByOutputType[P]>
            : GetScalarType<T[P], LabItemGroupByOutputType[P]>;
        }
      >
    >;

  export type LabItemSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      quantity?: boolean;
      unit?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      assetId?: boolean;
      trackQuantity?: boolean;
      status?: boolean;
      individualLabItems?: boolean | LabItem$individualLabItemsArgs<ExtArgs>;
      asset?: boolean | AssetDefaultArgs<ExtArgs>;
      _count?: boolean | LabItemCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["labItem"]
  >;

  export type LabItemSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      quantity?: boolean;
      unit?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      assetId?: boolean;
      trackQuantity?: boolean;
      status?: boolean;
      asset?: boolean | AssetDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["labItem"]
  >;

  export type LabItemSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      quantity?: boolean;
      unit?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      assetId?: boolean;
      trackQuantity?: boolean;
      status?: boolean;
      asset?: boolean | AssetDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["labItem"]
  >;

  export type LabItemSelectScalar = {
    id?: boolean;
    name?: boolean;
    quantity?: boolean;
    unit?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    assetId?: boolean;
    trackQuantity?: boolean;
    status?: boolean;
  };

  export type LabItemOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | "id"
    | "name"
    | "quantity"
    | "unit"
    | "createdAt"
    | "updatedAt"
    | "assetId"
    | "trackQuantity"
    | "status",
    ExtArgs["result"]["labItem"]
  >;
  export type LabItemInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    individualLabItems?: boolean | LabItem$individualLabItemsArgs<ExtArgs>;
    asset?: boolean | AssetDefaultArgs<ExtArgs>;
    _count?: boolean | LabItemCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type LabItemIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    asset?: boolean | AssetDefaultArgs<ExtArgs>;
  };
  export type LabItemIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    asset?: boolean | AssetDefaultArgs<ExtArgs>;
  };

  export type $LabItemPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "LabItem";
    objects: {
      individualLabItems: Prisma.$IndividualLabItemPayload<ExtArgs>[];
      asset: Prisma.$AssetPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        name: string;
        quantity: number | null;
        unit: $Enums.AssetUnit;
        createdAt: Date;
        updatedAt: Date;
        assetId: string;
        trackQuantity: boolean;
        status: $Enums.AssetStatus;
      },
      ExtArgs["result"]["labItem"]
    >;
    composites: {};
  };

  type LabItemGetPayload<
    S extends boolean | null | undefined | LabItemDefaultArgs,
  > = $Result.GetResult<Prisma.$LabItemPayload, S>;

  type LabItemCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<LabItemFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
    select?: LabItemCountAggregateInputType | true;
  };

  export interface LabItemDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["LabItem"];
      meta: { name: "LabItem" };
    };
    /**
     * Find zero or one LabItem that matches the filter.
     * @param {LabItemFindUniqueArgs} args - Arguments to find a LabItem
     * @example
     * // Get one LabItem
     * const labItem = await prisma.labItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LabItemFindUniqueArgs>(
      args: SelectSubset<T, LabItemFindUniqueArgs<ExtArgs>>,
    ): Prisma__LabItemClient<
      $Result.GetResult<
        Prisma.$LabItemPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one LabItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LabItemFindUniqueOrThrowArgs} args - Arguments to find a LabItem
     * @example
     * // Get one LabItem
     * const labItem = await prisma.labItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LabItemFindUniqueOrThrowArgs>(
      args: SelectSubset<T, LabItemFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__LabItemClient<
      $Result.GetResult<
        Prisma.$LabItemPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first LabItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabItemFindFirstArgs} args - Arguments to find a LabItem
     * @example
     * // Get one LabItem
     * const labItem = await prisma.labItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LabItemFindFirstArgs>(
      args?: SelectSubset<T, LabItemFindFirstArgs<ExtArgs>>,
    ): Prisma__LabItemClient<
      $Result.GetResult<
        Prisma.$LabItemPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first LabItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabItemFindFirstOrThrowArgs} args - Arguments to find a LabItem
     * @example
     * // Get one LabItem
     * const labItem = await prisma.labItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LabItemFindFirstOrThrowArgs>(
      args?: SelectSubset<T, LabItemFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__LabItemClient<
      $Result.GetResult<
        Prisma.$LabItemPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more LabItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LabItems
     * const labItems = await prisma.labItem.findMany()
     *
     * // Get first 10 LabItems
     * const labItems = await prisma.labItem.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const labItemWithIdOnly = await prisma.labItem.findMany({ select: { id: true } })
     *
     */
    findMany<T extends LabItemFindManyArgs>(
      args?: SelectSubset<T, LabItemFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$LabItemPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a LabItem.
     * @param {LabItemCreateArgs} args - Arguments to create a LabItem.
     * @example
     * // Create one LabItem
     * const LabItem = await prisma.labItem.create({
     *   data: {
     *     // ... data to create a LabItem
     *   }
     * })
     *
     */
    create<T extends LabItemCreateArgs>(
      args: SelectSubset<T, LabItemCreateArgs<ExtArgs>>,
    ): Prisma__LabItemClient<
      $Result.GetResult<
        Prisma.$LabItemPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many LabItems.
     * @param {LabItemCreateManyArgs} args - Arguments to create many LabItems.
     * @example
     * // Create many LabItems
     * const labItem = await prisma.labItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends LabItemCreateManyArgs>(
      args?: SelectSubset<T, LabItemCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many LabItems and returns the data saved in the database.
     * @param {LabItemCreateManyAndReturnArgs} args - Arguments to create many LabItems.
     * @example
     * // Create many LabItems
     * const labItem = await prisma.labItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many LabItems and only return the `id`
     * const labItemWithIdOnly = await prisma.labItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends LabItemCreateManyAndReturnArgs>(
      args?: SelectSubset<T, LabItemCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$LabItemPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a LabItem.
     * @param {LabItemDeleteArgs} args - Arguments to delete one LabItem.
     * @example
     * // Delete one LabItem
     * const LabItem = await prisma.labItem.delete({
     *   where: {
     *     // ... filter to delete one LabItem
     *   }
     * })
     *
     */
    delete<T extends LabItemDeleteArgs>(
      args: SelectSubset<T, LabItemDeleteArgs<ExtArgs>>,
    ): Prisma__LabItemClient<
      $Result.GetResult<
        Prisma.$LabItemPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one LabItem.
     * @param {LabItemUpdateArgs} args - Arguments to update one LabItem.
     * @example
     * // Update one LabItem
     * const labItem = await prisma.labItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends LabItemUpdateArgs>(
      args: SelectSubset<T, LabItemUpdateArgs<ExtArgs>>,
    ): Prisma__LabItemClient<
      $Result.GetResult<
        Prisma.$LabItemPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more LabItems.
     * @param {LabItemDeleteManyArgs} args - Arguments to filter LabItems to delete.
     * @example
     * // Delete a few LabItems
     * const { count } = await prisma.labItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends LabItemDeleteManyArgs>(
      args?: SelectSubset<T, LabItemDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more LabItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LabItems
     * const labItem = await prisma.labItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends LabItemUpdateManyArgs>(
      args: SelectSubset<T, LabItemUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more LabItems and returns the data updated in the database.
     * @param {LabItemUpdateManyAndReturnArgs} args - Arguments to update many LabItems.
     * @example
     * // Update many LabItems
     * const labItem = await prisma.labItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more LabItems and only return the `id`
     * const labItemWithIdOnly = await prisma.labItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends LabItemUpdateManyAndReturnArgs>(
      args: SelectSubset<T, LabItemUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$LabItemPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one LabItem.
     * @param {LabItemUpsertArgs} args - Arguments to update or create a LabItem.
     * @example
     * // Update or create a LabItem
     * const labItem = await prisma.labItem.upsert({
     *   create: {
     *     // ... data to create a LabItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LabItem we want to update
     *   }
     * })
     */
    upsert<T extends LabItemUpsertArgs>(
      args: SelectSubset<T, LabItemUpsertArgs<ExtArgs>>,
    ): Prisma__LabItemClient<
      $Result.GetResult<
        Prisma.$LabItemPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of LabItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabItemCountArgs} args - Arguments to filter LabItems to count.
     * @example
     * // Count the number of LabItems
     * const count = await prisma.labItem.count({
     *   where: {
     *     // ... the filter for the LabItems we want to count
     *   }
     * })
     **/
    count<T extends LabItemCountArgs>(
      args?: Subset<T, LabItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], LabItemCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a LabItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends LabItemAggregateArgs>(
      args: Subset<T, LabItemAggregateArgs>,
    ): Prisma.PrismaPromise<GetLabItemAggregateType<T>>;

    /**
     * Group by LabItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends LabItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LabItemGroupByArgs["orderBy"] }
        : { orderBy?: LabItemGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, LabItemGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetLabItemGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the LabItem model
     */
    readonly fields: LabItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LabItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LabItemClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    individualLabItems<T extends LabItem$individualLabItemsArgs<ExtArgs> = {}>(
      args?: Subset<T, LabItem$individualLabItemsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$IndividualLabItemPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    asset<T extends AssetDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, AssetDefaultArgs<ExtArgs>>,
    ): Prisma__AssetClient<
      | $Result.GetResult<
          Prisma.$AssetPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the LabItem model
   */
  interface LabItemFieldRefs {
    readonly id: FieldRef<"LabItem", "String">;
    readonly name: FieldRef<"LabItem", "String">;
    readonly quantity: FieldRef<"LabItem", "Float">;
    readonly unit: FieldRef<"LabItem", "AssetUnit">;
    readonly createdAt: FieldRef<"LabItem", "DateTime">;
    readonly updatedAt: FieldRef<"LabItem", "DateTime">;
    readonly assetId: FieldRef<"LabItem", "String">;
    readonly trackQuantity: FieldRef<"LabItem", "Boolean">;
    readonly status: FieldRef<"LabItem", "AssetStatus">;
  }

  // Custom InputTypes
  /**
   * LabItem findUnique
   */
  export type LabItemFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LabItem
     */
    select?: LabItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the LabItem
     */
    omit?: LabItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabItemInclude<ExtArgs> | null;
    /**
     * Filter, which LabItem to fetch.
     */
    where: LabItemWhereUniqueInput;
  };

  /**
   * LabItem findUniqueOrThrow
   */
  export type LabItemFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LabItem
     */
    select?: LabItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the LabItem
     */
    omit?: LabItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabItemInclude<ExtArgs> | null;
    /**
     * Filter, which LabItem to fetch.
     */
    where: LabItemWhereUniqueInput;
  };

  /**
   * LabItem findFirst
   */
  export type LabItemFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LabItem
     */
    select?: LabItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the LabItem
     */
    omit?: LabItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabItemInclude<ExtArgs> | null;
    /**
     * Filter, which LabItem to fetch.
     */
    where?: LabItemWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of LabItems to fetch.
     */
    orderBy?:
      | LabItemOrderByWithRelationInput
      | LabItemOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for LabItems.
     */
    cursor?: LabItemWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` LabItems from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` LabItems.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of LabItems.
     */
    distinct?: LabItemScalarFieldEnum | LabItemScalarFieldEnum[];
  };

  /**
   * LabItem findFirstOrThrow
   */
  export type LabItemFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LabItem
     */
    select?: LabItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the LabItem
     */
    omit?: LabItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabItemInclude<ExtArgs> | null;
    /**
     * Filter, which LabItem to fetch.
     */
    where?: LabItemWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of LabItems to fetch.
     */
    orderBy?:
      | LabItemOrderByWithRelationInput
      | LabItemOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for LabItems.
     */
    cursor?: LabItemWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` LabItems from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` LabItems.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of LabItems.
     */
    distinct?: LabItemScalarFieldEnum | LabItemScalarFieldEnum[];
  };

  /**
   * LabItem findMany
   */
  export type LabItemFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LabItem
     */
    select?: LabItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the LabItem
     */
    omit?: LabItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabItemInclude<ExtArgs> | null;
    /**
     * Filter, which LabItems to fetch.
     */
    where?: LabItemWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of LabItems to fetch.
     */
    orderBy?:
      | LabItemOrderByWithRelationInput
      | LabItemOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing LabItems.
     */
    cursor?: LabItemWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` LabItems from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` LabItems.
     */
    skip?: number;
    distinct?: LabItemScalarFieldEnum | LabItemScalarFieldEnum[];
  };

  /**
   * LabItem create
   */
  export type LabItemCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LabItem
     */
    select?: LabItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the LabItem
     */
    omit?: LabItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabItemInclude<ExtArgs> | null;
    /**
     * The data needed to create a LabItem.
     */
    data: XOR<LabItemCreateInput, LabItemUncheckedCreateInput>;
  };

  /**
   * LabItem createMany
   */
  export type LabItemCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many LabItems.
     */
    data: LabItemCreateManyInput | LabItemCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * LabItem createManyAndReturn
   */
  export type LabItemCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LabItem
     */
    select?: LabItemSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the LabItem
     */
    omit?: LabItemOmit<ExtArgs> | null;
    /**
     * The data used to create many LabItems.
     */
    data: LabItemCreateManyInput | LabItemCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabItemIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * LabItem update
   */
  export type LabItemUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LabItem
     */
    select?: LabItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the LabItem
     */
    omit?: LabItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabItemInclude<ExtArgs> | null;
    /**
     * The data needed to update a LabItem.
     */
    data: XOR<LabItemUpdateInput, LabItemUncheckedUpdateInput>;
    /**
     * Choose, which LabItem to update.
     */
    where: LabItemWhereUniqueInput;
  };

  /**
   * LabItem updateMany
   */
  export type LabItemUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update LabItems.
     */
    data: XOR<LabItemUpdateManyMutationInput, LabItemUncheckedUpdateManyInput>;
    /**
     * Filter which LabItems to update
     */
    where?: LabItemWhereInput;
    /**
     * Limit how many LabItems to update.
     */
    limit?: number;
  };

  /**
   * LabItem updateManyAndReturn
   */
  export type LabItemUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LabItem
     */
    select?: LabItemSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the LabItem
     */
    omit?: LabItemOmit<ExtArgs> | null;
    /**
     * The data used to update LabItems.
     */
    data: XOR<LabItemUpdateManyMutationInput, LabItemUncheckedUpdateManyInput>;
    /**
     * Filter which LabItems to update
     */
    where?: LabItemWhereInput;
    /**
     * Limit how many LabItems to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabItemIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * LabItem upsert
   */
  export type LabItemUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LabItem
     */
    select?: LabItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the LabItem
     */
    omit?: LabItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabItemInclude<ExtArgs> | null;
    /**
     * The filter to search for the LabItem to update in case it exists.
     */
    where: LabItemWhereUniqueInput;
    /**
     * In case the LabItem found by the `where` argument doesn't exist, create a new LabItem with this data.
     */
    create: XOR<LabItemCreateInput, LabItemUncheckedCreateInput>;
    /**
     * In case the LabItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LabItemUpdateInput, LabItemUncheckedUpdateInput>;
  };

  /**
   * LabItem delete
   */
  export type LabItemDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LabItem
     */
    select?: LabItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the LabItem
     */
    omit?: LabItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabItemInclude<ExtArgs> | null;
    /**
     * Filter which LabItem to delete.
     */
    where: LabItemWhereUniqueInput;
  };

  /**
   * LabItem deleteMany
   */
  export type LabItemDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which LabItems to delete
     */
    where?: LabItemWhereInput;
    /**
     * Limit how many LabItems to delete.
     */
    limit?: number;
  };

  /**
   * LabItem.individualLabItems
   */
  export type LabItem$individualLabItemsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IndividualLabItem
     */
    select?: IndividualLabItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the IndividualLabItem
     */
    omit?: IndividualLabItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndividualLabItemInclude<ExtArgs> | null;
    where?: IndividualLabItemWhereInput;
    orderBy?:
      | IndividualLabItemOrderByWithRelationInput
      | IndividualLabItemOrderByWithRelationInput[];
    cursor?: IndividualLabItemWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?:
      | IndividualLabItemScalarFieldEnum
      | IndividualLabItemScalarFieldEnum[];
  };

  /**
   * LabItem without action
   */
  export type LabItemDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LabItem
     */
    select?: LabItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the LabItem
     */
    omit?: LabItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabItemInclude<ExtArgs> | null;
  };

  /**
   * Model IndividualLabItem
   */

  export type AggregateIndividualLabItem = {
    _count: IndividualLabItemCountAggregateOutputType | null;
    _min: IndividualLabItemMinAggregateOutputType | null;
    _max: IndividualLabItemMaxAggregateOutputType | null;
  };

  export type IndividualLabItemMinAggregateOutputType = {
    id: string | null;
    labItemId: string | null;
    uniqueIdentifier: string | null;
    status: $Enums.AssetStatus | null;
    condition: $Enums.AssetCondition | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type IndividualLabItemMaxAggregateOutputType = {
    id: string | null;
    labItemId: string | null;
    uniqueIdentifier: string | null;
    status: $Enums.AssetStatus | null;
    condition: $Enums.AssetCondition | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type IndividualLabItemCountAggregateOutputType = {
    id: number;
    labItemId: number;
    uniqueIdentifier: number;
    status: number;
    condition: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type IndividualLabItemMinAggregateInputType = {
    id?: true;
    labItemId?: true;
    uniqueIdentifier?: true;
    status?: true;
    condition?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type IndividualLabItemMaxAggregateInputType = {
    id?: true;
    labItemId?: true;
    uniqueIdentifier?: true;
    status?: true;
    condition?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type IndividualLabItemCountAggregateInputType = {
    id?: true;
    labItemId?: true;
    uniqueIdentifier?: true;
    status?: true;
    condition?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type IndividualLabItemAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which IndividualLabItem to aggregate.
     */
    where?: IndividualLabItemWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of IndividualLabItems to fetch.
     */
    orderBy?:
      | IndividualLabItemOrderByWithRelationInput
      | IndividualLabItemOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: IndividualLabItemWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` IndividualLabItems from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` IndividualLabItems.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned IndividualLabItems
     **/
    _count?: true | IndividualLabItemCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: IndividualLabItemMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: IndividualLabItemMaxAggregateInputType;
  };

  export type GetIndividualLabItemAggregateType<
    T extends IndividualLabItemAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateIndividualLabItem]: P extends
      | "_count"
      | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIndividualLabItem[P]>
      : GetScalarType<T[P], AggregateIndividualLabItem[P]>;
  };

  export type IndividualLabItemGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: IndividualLabItemWhereInput;
    orderBy?:
      | IndividualLabItemOrderByWithAggregationInput
      | IndividualLabItemOrderByWithAggregationInput[];
    by: IndividualLabItemScalarFieldEnum[] | IndividualLabItemScalarFieldEnum;
    having?: IndividualLabItemScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: IndividualLabItemCountAggregateInputType | true;
    _min?: IndividualLabItemMinAggregateInputType;
    _max?: IndividualLabItemMaxAggregateInputType;
  };

  export type IndividualLabItemGroupByOutputType = {
    id: string;
    labItemId: string;
    uniqueIdentifier: string | null;
    status: $Enums.AssetStatus;
    condition: $Enums.AssetCondition;
    createdAt: Date;
    updatedAt: Date;
    _count: IndividualLabItemCountAggregateOutputType | null;
    _min: IndividualLabItemMinAggregateOutputType | null;
    _max: IndividualLabItemMaxAggregateOutputType | null;
  };

  type GetIndividualLabItemGroupByPayload<
    T extends IndividualLabItemGroupByArgs,
  > = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IndividualLabItemGroupByOutputType, T["by"]> & {
        [P in keyof T &
          keyof IndividualLabItemGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], IndividualLabItemGroupByOutputType[P]>
          : GetScalarType<T[P], IndividualLabItemGroupByOutputType[P]>;
      }
    >
  >;

  export type IndividualLabItemSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      labItemId?: boolean;
      uniqueIdentifier?: boolean;
      status?: boolean;
      condition?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      assetDamages?: boolean | IndividualLabItem$assetDamagesArgs<ExtArgs>;
      labItem?: boolean | LabItemDefaultArgs<ExtArgs>;
      _count?: boolean | IndividualLabItemCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["individualLabItem"]
  >;

  export type IndividualLabItemSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      labItemId?: boolean;
      uniqueIdentifier?: boolean;
      status?: boolean;
      condition?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      labItem?: boolean | LabItemDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["individualLabItem"]
  >;

  export type IndividualLabItemSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      labItemId?: boolean;
      uniqueIdentifier?: boolean;
      status?: boolean;
      condition?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      labItem?: boolean | LabItemDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["individualLabItem"]
  >;

  export type IndividualLabItemSelectScalar = {
    id?: boolean;
    labItemId?: boolean;
    uniqueIdentifier?: boolean;
    status?: boolean;
    condition?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type IndividualLabItemOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | "id"
    | "labItemId"
    | "uniqueIdentifier"
    | "status"
    | "condition"
    | "createdAt"
    | "updatedAt",
    ExtArgs["result"]["individualLabItem"]
  >;
  export type IndividualLabItemInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    assetDamages?: boolean | IndividualLabItem$assetDamagesArgs<ExtArgs>;
    labItem?: boolean | LabItemDefaultArgs<ExtArgs>;
    _count?: boolean | IndividualLabItemCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type IndividualLabItemIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    labItem?: boolean | LabItemDefaultArgs<ExtArgs>;
  };
  export type IndividualLabItemIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    labItem?: boolean | LabItemDefaultArgs<ExtArgs>;
  };

  export type $IndividualLabItemPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "IndividualLabItem";
    objects: {
      assetDamages: Prisma.$AssetDamagePayload<ExtArgs>[];
      labItem: Prisma.$LabItemPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        labItemId: string;
        uniqueIdentifier: string | null;
        status: $Enums.AssetStatus;
        condition: $Enums.AssetCondition;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs["result"]["individualLabItem"]
    >;
    composites: {};
  };

  type IndividualLabItemGetPayload<
    S extends boolean | null | undefined | IndividualLabItemDefaultArgs,
  > = $Result.GetResult<Prisma.$IndividualLabItemPayload, S>;

  type IndividualLabItemCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    IndividualLabItemFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: IndividualLabItemCountAggregateInputType | true;
  };

  export interface IndividualLabItemDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["IndividualLabItem"];
      meta: { name: "IndividualLabItem" };
    };
    /**
     * Find zero or one IndividualLabItem that matches the filter.
     * @param {IndividualLabItemFindUniqueArgs} args - Arguments to find a IndividualLabItem
     * @example
     * // Get one IndividualLabItem
     * const individualLabItem = await prisma.individualLabItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IndividualLabItemFindUniqueArgs>(
      args: SelectSubset<T, IndividualLabItemFindUniqueArgs<ExtArgs>>,
    ): Prisma__IndividualLabItemClient<
      $Result.GetResult<
        Prisma.$IndividualLabItemPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one IndividualLabItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {IndividualLabItemFindUniqueOrThrowArgs} args - Arguments to find a IndividualLabItem
     * @example
     * // Get one IndividualLabItem
     * const individualLabItem = await prisma.individualLabItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IndividualLabItemFindUniqueOrThrowArgs>(
      args: SelectSubset<T, IndividualLabItemFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__IndividualLabItemClient<
      $Result.GetResult<
        Prisma.$IndividualLabItemPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first IndividualLabItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndividualLabItemFindFirstArgs} args - Arguments to find a IndividualLabItem
     * @example
     * // Get one IndividualLabItem
     * const individualLabItem = await prisma.individualLabItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IndividualLabItemFindFirstArgs>(
      args?: SelectSubset<T, IndividualLabItemFindFirstArgs<ExtArgs>>,
    ): Prisma__IndividualLabItemClient<
      $Result.GetResult<
        Prisma.$IndividualLabItemPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first IndividualLabItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndividualLabItemFindFirstOrThrowArgs} args - Arguments to find a IndividualLabItem
     * @example
     * // Get one IndividualLabItem
     * const individualLabItem = await prisma.individualLabItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IndividualLabItemFindFirstOrThrowArgs>(
      args?: SelectSubset<T, IndividualLabItemFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__IndividualLabItemClient<
      $Result.GetResult<
        Prisma.$IndividualLabItemPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more IndividualLabItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndividualLabItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IndividualLabItems
     * const individualLabItems = await prisma.individualLabItem.findMany()
     *
     * // Get first 10 IndividualLabItems
     * const individualLabItems = await prisma.individualLabItem.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const individualLabItemWithIdOnly = await prisma.individualLabItem.findMany({ select: { id: true } })
     *
     */
    findMany<T extends IndividualLabItemFindManyArgs>(
      args?: SelectSubset<T, IndividualLabItemFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$IndividualLabItemPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a IndividualLabItem.
     * @param {IndividualLabItemCreateArgs} args - Arguments to create a IndividualLabItem.
     * @example
     * // Create one IndividualLabItem
     * const IndividualLabItem = await prisma.individualLabItem.create({
     *   data: {
     *     // ... data to create a IndividualLabItem
     *   }
     * })
     *
     */
    create<T extends IndividualLabItemCreateArgs>(
      args: SelectSubset<T, IndividualLabItemCreateArgs<ExtArgs>>,
    ): Prisma__IndividualLabItemClient<
      $Result.GetResult<
        Prisma.$IndividualLabItemPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many IndividualLabItems.
     * @param {IndividualLabItemCreateManyArgs} args - Arguments to create many IndividualLabItems.
     * @example
     * // Create many IndividualLabItems
     * const individualLabItem = await prisma.individualLabItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends IndividualLabItemCreateManyArgs>(
      args?: SelectSubset<T, IndividualLabItemCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many IndividualLabItems and returns the data saved in the database.
     * @param {IndividualLabItemCreateManyAndReturnArgs} args - Arguments to create many IndividualLabItems.
     * @example
     * // Create many IndividualLabItems
     * const individualLabItem = await prisma.individualLabItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many IndividualLabItems and only return the `id`
     * const individualLabItemWithIdOnly = await prisma.individualLabItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends IndividualLabItemCreateManyAndReturnArgs>(
      args?: SelectSubset<T, IndividualLabItemCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$IndividualLabItemPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a IndividualLabItem.
     * @param {IndividualLabItemDeleteArgs} args - Arguments to delete one IndividualLabItem.
     * @example
     * // Delete one IndividualLabItem
     * const IndividualLabItem = await prisma.individualLabItem.delete({
     *   where: {
     *     // ... filter to delete one IndividualLabItem
     *   }
     * })
     *
     */
    delete<T extends IndividualLabItemDeleteArgs>(
      args: SelectSubset<T, IndividualLabItemDeleteArgs<ExtArgs>>,
    ): Prisma__IndividualLabItemClient<
      $Result.GetResult<
        Prisma.$IndividualLabItemPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one IndividualLabItem.
     * @param {IndividualLabItemUpdateArgs} args - Arguments to update one IndividualLabItem.
     * @example
     * // Update one IndividualLabItem
     * const individualLabItem = await prisma.individualLabItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends IndividualLabItemUpdateArgs>(
      args: SelectSubset<T, IndividualLabItemUpdateArgs<ExtArgs>>,
    ): Prisma__IndividualLabItemClient<
      $Result.GetResult<
        Prisma.$IndividualLabItemPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more IndividualLabItems.
     * @param {IndividualLabItemDeleteManyArgs} args - Arguments to filter IndividualLabItems to delete.
     * @example
     * // Delete a few IndividualLabItems
     * const { count } = await prisma.individualLabItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends IndividualLabItemDeleteManyArgs>(
      args?: SelectSubset<T, IndividualLabItemDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more IndividualLabItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndividualLabItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IndividualLabItems
     * const individualLabItem = await prisma.individualLabItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends IndividualLabItemUpdateManyArgs>(
      args: SelectSubset<T, IndividualLabItemUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more IndividualLabItems and returns the data updated in the database.
     * @param {IndividualLabItemUpdateManyAndReturnArgs} args - Arguments to update many IndividualLabItems.
     * @example
     * // Update many IndividualLabItems
     * const individualLabItem = await prisma.individualLabItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more IndividualLabItems and only return the `id`
     * const individualLabItemWithIdOnly = await prisma.individualLabItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends IndividualLabItemUpdateManyAndReturnArgs>(
      args: SelectSubset<T, IndividualLabItemUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$IndividualLabItemPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one IndividualLabItem.
     * @param {IndividualLabItemUpsertArgs} args - Arguments to update or create a IndividualLabItem.
     * @example
     * // Update or create a IndividualLabItem
     * const individualLabItem = await prisma.individualLabItem.upsert({
     *   create: {
     *     // ... data to create a IndividualLabItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IndividualLabItem we want to update
     *   }
     * })
     */
    upsert<T extends IndividualLabItemUpsertArgs>(
      args: SelectSubset<T, IndividualLabItemUpsertArgs<ExtArgs>>,
    ): Prisma__IndividualLabItemClient<
      $Result.GetResult<
        Prisma.$IndividualLabItemPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of IndividualLabItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndividualLabItemCountArgs} args - Arguments to filter IndividualLabItems to count.
     * @example
     * // Count the number of IndividualLabItems
     * const count = await prisma.individualLabItem.count({
     *   where: {
     *     // ... the filter for the IndividualLabItems we want to count
     *   }
     * })
     **/
    count<T extends IndividualLabItemCountArgs>(
      args?: Subset<T, IndividualLabItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<
              T["select"],
              IndividualLabItemCountAggregateOutputType
            >
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a IndividualLabItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndividualLabItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends IndividualLabItemAggregateArgs>(
      args: Subset<T, IndividualLabItemAggregateArgs>,
    ): Prisma.PrismaPromise<GetIndividualLabItemAggregateType<T>>;

    /**
     * Group by IndividualLabItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndividualLabItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends IndividualLabItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IndividualLabItemGroupByArgs["orderBy"] }
        : { orderBy?: IndividualLabItemGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, IndividualLabItemGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetIndividualLabItemGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the IndividualLabItem model
     */
    readonly fields: IndividualLabItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IndividualLabItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IndividualLabItemClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    assetDamages<T extends IndividualLabItem$assetDamagesArgs<ExtArgs> = {}>(
      args?: Subset<T, IndividualLabItem$assetDamagesArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$AssetDamagePayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    labItem<T extends LabItemDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, LabItemDefaultArgs<ExtArgs>>,
    ): Prisma__LabItemClient<
      | $Result.GetResult<
          Prisma.$LabItemPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the IndividualLabItem model
   */
  interface IndividualLabItemFieldRefs {
    readonly id: FieldRef<"IndividualLabItem", "String">;
    readonly labItemId: FieldRef<"IndividualLabItem", "String">;
    readonly uniqueIdentifier: FieldRef<"IndividualLabItem", "String">;
    readonly status: FieldRef<"IndividualLabItem", "AssetStatus">;
    readonly condition: FieldRef<"IndividualLabItem", "AssetCondition">;
    readonly createdAt: FieldRef<"IndividualLabItem", "DateTime">;
    readonly updatedAt: FieldRef<"IndividualLabItem", "DateTime">;
  }

  // Custom InputTypes
  /**
   * IndividualLabItem findUnique
   */
  export type IndividualLabItemFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IndividualLabItem
     */
    select?: IndividualLabItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the IndividualLabItem
     */
    omit?: IndividualLabItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndividualLabItemInclude<ExtArgs> | null;
    /**
     * Filter, which IndividualLabItem to fetch.
     */
    where: IndividualLabItemWhereUniqueInput;
  };

  /**
   * IndividualLabItem findUniqueOrThrow
   */
  export type IndividualLabItemFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IndividualLabItem
     */
    select?: IndividualLabItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the IndividualLabItem
     */
    omit?: IndividualLabItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndividualLabItemInclude<ExtArgs> | null;
    /**
     * Filter, which IndividualLabItem to fetch.
     */
    where: IndividualLabItemWhereUniqueInput;
  };

  /**
   * IndividualLabItem findFirst
   */
  export type IndividualLabItemFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IndividualLabItem
     */
    select?: IndividualLabItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the IndividualLabItem
     */
    omit?: IndividualLabItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndividualLabItemInclude<ExtArgs> | null;
    /**
     * Filter, which IndividualLabItem to fetch.
     */
    where?: IndividualLabItemWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of IndividualLabItems to fetch.
     */
    orderBy?:
      | IndividualLabItemOrderByWithRelationInput
      | IndividualLabItemOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for IndividualLabItems.
     */
    cursor?: IndividualLabItemWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` IndividualLabItems from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` IndividualLabItems.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of IndividualLabItems.
     */
    distinct?:
      | IndividualLabItemScalarFieldEnum
      | IndividualLabItemScalarFieldEnum[];
  };

  /**
   * IndividualLabItem findFirstOrThrow
   */
  export type IndividualLabItemFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IndividualLabItem
     */
    select?: IndividualLabItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the IndividualLabItem
     */
    omit?: IndividualLabItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndividualLabItemInclude<ExtArgs> | null;
    /**
     * Filter, which IndividualLabItem to fetch.
     */
    where?: IndividualLabItemWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of IndividualLabItems to fetch.
     */
    orderBy?:
      | IndividualLabItemOrderByWithRelationInput
      | IndividualLabItemOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for IndividualLabItems.
     */
    cursor?: IndividualLabItemWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` IndividualLabItems from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` IndividualLabItems.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of IndividualLabItems.
     */
    distinct?:
      | IndividualLabItemScalarFieldEnum
      | IndividualLabItemScalarFieldEnum[];
  };

  /**
   * IndividualLabItem findMany
   */
  export type IndividualLabItemFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IndividualLabItem
     */
    select?: IndividualLabItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the IndividualLabItem
     */
    omit?: IndividualLabItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndividualLabItemInclude<ExtArgs> | null;
    /**
     * Filter, which IndividualLabItems to fetch.
     */
    where?: IndividualLabItemWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of IndividualLabItems to fetch.
     */
    orderBy?:
      | IndividualLabItemOrderByWithRelationInput
      | IndividualLabItemOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing IndividualLabItems.
     */
    cursor?: IndividualLabItemWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` IndividualLabItems from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` IndividualLabItems.
     */
    skip?: number;
    distinct?:
      | IndividualLabItemScalarFieldEnum
      | IndividualLabItemScalarFieldEnum[];
  };

  /**
   * IndividualLabItem create
   */
  export type IndividualLabItemCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IndividualLabItem
     */
    select?: IndividualLabItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the IndividualLabItem
     */
    omit?: IndividualLabItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndividualLabItemInclude<ExtArgs> | null;
    /**
     * The data needed to create a IndividualLabItem.
     */
    data: XOR<
      IndividualLabItemCreateInput,
      IndividualLabItemUncheckedCreateInput
    >;
  };

  /**
   * IndividualLabItem createMany
   */
  export type IndividualLabItemCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many IndividualLabItems.
     */
    data: IndividualLabItemCreateManyInput | IndividualLabItemCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * IndividualLabItem createManyAndReturn
   */
  export type IndividualLabItemCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IndividualLabItem
     */
    select?: IndividualLabItemSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the IndividualLabItem
     */
    omit?: IndividualLabItemOmit<ExtArgs> | null;
    /**
     * The data used to create many IndividualLabItems.
     */
    data: IndividualLabItemCreateManyInput | IndividualLabItemCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndividualLabItemIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * IndividualLabItem update
   */
  export type IndividualLabItemUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IndividualLabItem
     */
    select?: IndividualLabItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the IndividualLabItem
     */
    omit?: IndividualLabItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndividualLabItemInclude<ExtArgs> | null;
    /**
     * The data needed to update a IndividualLabItem.
     */
    data: XOR<
      IndividualLabItemUpdateInput,
      IndividualLabItemUncheckedUpdateInput
    >;
    /**
     * Choose, which IndividualLabItem to update.
     */
    where: IndividualLabItemWhereUniqueInput;
  };

  /**
   * IndividualLabItem updateMany
   */
  export type IndividualLabItemUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update IndividualLabItems.
     */
    data: XOR<
      IndividualLabItemUpdateManyMutationInput,
      IndividualLabItemUncheckedUpdateManyInput
    >;
    /**
     * Filter which IndividualLabItems to update
     */
    where?: IndividualLabItemWhereInput;
    /**
     * Limit how many IndividualLabItems to update.
     */
    limit?: number;
  };

  /**
   * IndividualLabItem updateManyAndReturn
   */
  export type IndividualLabItemUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IndividualLabItem
     */
    select?: IndividualLabItemSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the IndividualLabItem
     */
    omit?: IndividualLabItemOmit<ExtArgs> | null;
    /**
     * The data used to update IndividualLabItems.
     */
    data: XOR<
      IndividualLabItemUpdateManyMutationInput,
      IndividualLabItemUncheckedUpdateManyInput
    >;
    /**
     * Filter which IndividualLabItems to update
     */
    where?: IndividualLabItemWhereInput;
    /**
     * Limit how many IndividualLabItems to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndividualLabItemIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * IndividualLabItem upsert
   */
  export type IndividualLabItemUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IndividualLabItem
     */
    select?: IndividualLabItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the IndividualLabItem
     */
    omit?: IndividualLabItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndividualLabItemInclude<ExtArgs> | null;
    /**
     * The filter to search for the IndividualLabItem to update in case it exists.
     */
    where: IndividualLabItemWhereUniqueInput;
    /**
     * In case the IndividualLabItem found by the `where` argument doesn't exist, create a new IndividualLabItem with this data.
     */
    create: XOR<
      IndividualLabItemCreateInput,
      IndividualLabItemUncheckedCreateInput
    >;
    /**
     * In case the IndividualLabItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<
      IndividualLabItemUpdateInput,
      IndividualLabItemUncheckedUpdateInput
    >;
  };

  /**
   * IndividualLabItem delete
   */
  export type IndividualLabItemDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IndividualLabItem
     */
    select?: IndividualLabItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the IndividualLabItem
     */
    omit?: IndividualLabItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndividualLabItemInclude<ExtArgs> | null;
    /**
     * Filter which IndividualLabItem to delete.
     */
    where: IndividualLabItemWhereUniqueInput;
  };

  /**
   * IndividualLabItem deleteMany
   */
  export type IndividualLabItemDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which IndividualLabItems to delete
     */
    where?: IndividualLabItemWhereInput;
    /**
     * Limit how many IndividualLabItems to delete.
     */
    limit?: number;
  };

  /**
   * IndividualLabItem.assetDamages
   */
  export type IndividualLabItem$assetDamagesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AssetDamage
     */
    select?: AssetDamageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AssetDamage
     */
    omit?: AssetDamageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetDamageInclude<ExtArgs> | null;
    where?: AssetDamageWhereInput;
    orderBy?:
      | AssetDamageOrderByWithRelationInput
      | AssetDamageOrderByWithRelationInput[];
    cursor?: AssetDamageWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: AssetDamageScalarFieldEnum | AssetDamageScalarFieldEnum[];
  };

  /**
   * IndividualLabItem without action
   */
  export type IndividualLabItemDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IndividualLabItem
     */
    select?: IndividualLabItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the IndividualLabItem
     */
    omit?: IndividualLabItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndividualLabItemInclude<ExtArgs> | null;
  };

  /**
   * Model ComputerLabItem
   */

  export type AggregateComputerLabItem = {
    _count: ComputerLabItemCountAggregateOutputType | null;
    _avg: ComputerLabItemAvgAggregateOutputType | null;
    _sum: ComputerLabItemSumAggregateOutputType | null;
    _min: ComputerLabItemMinAggregateOutputType | null;
    _max: ComputerLabItemMaxAggregateOutputType | null;
  };

  export type ComputerLabItemAvgAggregateOutputType = {
    quantity: number | null;
  };

  export type ComputerLabItemSumAggregateOutputType = {
    quantity: number | null;
  };

  export type ComputerLabItemMinAggregateOutputType = {
    id: string | null;
    name: string | null;
    model: string | null;
    specification: string | null;
    quantity: number | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    assetId: string | null;
    trackQuantity: boolean | null;
    unit: $Enums.AssetUnit | null;
  };

  export type ComputerLabItemMaxAggregateOutputType = {
    id: string | null;
    name: string | null;
    model: string | null;
    specification: string | null;
    quantity: number | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    assetId: string | null;
    trackQuantity: boolean | null;
    unit: $Enums.AssetUnit | null;
  };

  export type ComputerLabItemCountAggregateOutputType = {
    id: number;
    name: number;
    model: number;
    specification: number;
    quantity: number;
    createdAt: number;
    updatedAt: number;
    assetId: number;
    trackQuantity: number;
    unit: number;
    _all: number;
  };

  export type ComputerLabItemAvgAggregateInputType = {
    quantity?: true;
  };

  export type ComputerLabItemSumAggregateInputType = {
    quantity?: true;
  };

  export type ComputerLabItemMinAggregateInputType = {
    id?: true;
    name?: true;
    model?: true;
    specification?: true;
    quantity?: true;
    createdAt?: true;
    updatedAt?: true;
    assetId?: true;
    trackQuantity?: true;
    unit?: true;
  };

  export type ComputerLabItemMaxAggregateInputType = {
    id?: true;
    name?: true;
    model?: true;
    specification?: true;
    quantity?: true;
    createdAt?: true;
    updatedAt?: true;
    assetId?: true;
    trackQuantity?: true;
    unit?: true;
  };

  export type ComputerLabItemCountAggregateInputType = {
    id?: true;
    name?: true;
    model?: true;
    specification?: true;
    quantity?: true;
    createdAt?: true;
    updatedAt?: true;
    assetId?: true;
    trackQuantity?: true;
    unit?: true;
    _all?: true;
  };

  export type ComputerLabItemAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which ComputerLabItem to aggregate.
     */
    where?: ComputerLabItemWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ComputerLabItems to fetch.
     */
    orderBy?:
      | ComputerLabItemOrderByWithRelationInput
      | ComputerLabItemOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ComputerLabItemWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ComputerLabItems from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ComputerLabItems.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned ComputerLabItems
     **/
    _count?: true | ComputerLabItemCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: ComputerLabItemAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: ComputerLabItemSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ComputerLabItemMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ComputerLabItemMaxAggregateInputType;
  };

  export type GetComputerLabItemAggregateType<
    T extends ComputerLabItemAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateComputerLabItem]: P extends
      | "_count"
      | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComputerLabItem[P]>
      : GetScalarType<T[P], AggregateComputerLabItem[P]>;
  };

  export type ComputerLabItemGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ComputerLabItemWhereInput;
    orderBy?:
      | ComputerLabItemOrderByWithAggregationInput
      | ComputerLabItemOrderByWithAggregationInput[];
    by: ComputerLabItemScalarFieldEnum[] | ComputerLabItemScalarFieldEnum;
    having?: ComputerLabItemScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ComputerLabItemCountAggregateInputType | true;
    _avg?: ComputerLabItemAvgAggregateInputType;
    _sum?: ComputerLabItemSumAggregateInputType;
    _min?: ComputerLabItemMinAggregateInputType;
    _max?: ComputerLabItemMaxAggregateInputType;
  };

  export type ComputerLabItemGroupByOutputType = {
    id: string;
    name: string;
    model: string | null;
    specification: string | null;
    quantity: number | null;
    createdAt: Date;
    updatedAt: Date;
    assetId: string;
    trackQuantity: boolean;
    unit: $Enums.AssetUnit;
    _count: ComputerLabItemCountAggregateOutputType | null;
    _avg: ComputerLabItemAvgAggregateOutputType | null;
    _sum: ComputerLabItemSumAggregateOutputType | null;
    _min: ComputerLabItemMinAggregateOutputType | null;
    _max: ComputerLabItemMaxAggregateOutputType | null;
  };

  type GetComputerLabItemGroupByPayload<T extends ComputerLabItemGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<ComputerLabItemGroupByOutputType, T["by"]> & {
          [P in keyof T &
            keyof ComputerLabItemGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ComputerLabItemGroupByOutputType[P]>
            : GetScalarType<T[P], ComputerLabItemGroupByOutputType[P]>;
        }
      >
    >;

  export type ComputerLabItemSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      model?: boolean;
      specification?: boolean;
      quantity?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      assetId?: boolean;
      trackQuantity?: boolean;
      unit?: boolean;
      asset?: boolean | AssetDefaultArgs<ExtArgs>;
      individualComputerLabItems?:
        | boolean
        | ComputerLabItem$individualComputerLabItemsArgs<ExtArgs>;
      _count?: boolean | ComputerLabItemCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["computerLabItem"]
  >;

  export type ComputerLabItemSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      model?: boolean;
      specification?: boolean;
      quantity?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      assetId?: boolean;
      trackQuantity?: boolean;
      unit?: boolean;
      asset?: boolean | AssetDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["computerLabItem"]
  >;

  export type ComputerLabItemSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      model?: boolean;
      specification?: boolean;
      quantity?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      assetId?: boolean;
      trackQuantity?: boolean;
      unit?: boolean;
      asset?: boolean | AssetDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["computerLabItem"]
  >;

  export type ComputerLabItemSelectScalar = {
    id?: boolean;
    name?: boolean;
    model?: boolean;
    specification?: boolean;
    quantity?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    assetId?: boolean;
    trackQuantity?: boolean;
    unit?: boolean;
  };

  export type ComputerLabItemOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | "id"
    | "name"
    | "model"
    | "specification"
    | "quantity"
    | "createdAt"
    | "updatedAt"
    | "assetId"
    | "trackQuantity"
    | "unit",
    ExtArgs["result"]["computerLabItem"]
  >;
  export type ComputerLabItemInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    asset?: boolean | AssetDefaultArgs<ExtArgs>;
    individualComputerLabItems?:
      | boolean
      | ComputerLabItem$individualComputerLabItemsArgs<ExtArgs>;
    _count?: boolean | ComputerLabItemCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type ComputerLabItemIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    asset?: boolean | AssetDefaultArgs<ExtArgs>;
  };
  export type ComputerLabItemIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    asset?: boolean | AssetDefaultArgs<ExtArgs>;
  };

  export type $ComputerLabItemPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "ComputerLabItem";
    objects: {
      asset: Prisma.$AssetPayload<ExtArgs>;
      individualComputerLabItems: Prisma.$IndividualComputerLabItemPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        name: string;
        model: string | null;
        specification: string | null;
        quantity: number | null;
        createdAt: Date;
        updatedAt: Date;
        assetId: string;
        trackQuantity: boolean;
        unit: $Enums.AssetUnit;
      },
      ExtArgs["result"]["computerLabItem"]
    >;
    composites: {};
  };

  type ComputerLabItemGetPayload<
    S extends boolean | null | undefined | ComputerLabItemDefaultArgs,
  > = $Result.GetResult<Prisma.$ComputerLabItemPayload, S>;

  type ComputerLabItemCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    ComputerLabItemFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: ComputerLabItemCountAggregateInputType | true;
  };

  export interface ComputerLabItemDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["ComputerLabItem"];
      meta: { name: "ComputerLabItem" };
    };
    /**
     * Find zero or one ComputerLabItem that matches the filter.
     * @param {ComputerLabItemFindUniqueArgs} args - Arguments to find a ComputerLabItem
     * @example
     * // Get one ComputerLabItem
     * const computerLabItem = await prisma.computerLabItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ComputerLabItemFindUniqueArgs>(
      args: SelectSubset<T, ComputerLabItemFindUniqueArgs<ExtArgs>>,
    ): Prisma__ComputerLabItemClient<
      $Result.GetResult<
        Prisma.$ComputerLabItemPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one ComputerLabItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ComputerLabItemFindUniqueOrThrowArgs} args - Arguments to find a ComputerLabItem
     * @example
     * // Get one ComputerLabItem
     * const computerLabItem = await prisma.computerLabItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ComputerLabItemFindUniqueOrThrowArgs>(
      args: SelectSubset<T, ComputerLabItemFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__ComputerLabItemClient<
      $Result.GetResult<
        Prisma.$ComputerLabItemPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first ComputerLabItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComputerLabItemFindFirstArgs} args - Arguments to find a ComputerLabItem
     * @example
     * // Get one ComputerLabItem
     * const computerLabItem = await prisma.computerLabItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ComputerLabItemFindFirstArgs>(
      args?: SelectSubset<T, ComputerLabItemFindFirstArgs<ExtArgs>>,
    ): Prisma__ComputerLabItemClient<
      $Result.GetResult<
        Prisma.$ComputerLabItemPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first ComputerLabItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComputerLabItemFindFirstOrThrowArgs} args - Arguments to find a ComputerLabItem
     * @example
     * // Get one ComputerLabItem
     * const computerLabItem = await prisma.computerLabItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ComputerLabItemFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ComputerLabItemFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__ComputerLabItemClient<
      $Result.GetResult<
        Prisma.$ComputerLabItemPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more ComputerLabItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComputerLabItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ComputerLabItems
     * const computerLabItems = await prisma.computerLabItem.findMany()
     *
     * // Get first 10 ComputerLabItems
     * const computerLabItems = await prisma.computerLabItem.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const computerLabItemWithIdOnly = await prisma.computerLabItem.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ComputerLabItemFindManyArgs>(
      args?: SelectSubset<T, ComputerLabItemFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ComputerLabItemPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a ComputerLabItem.
     * @param {ComputerLabItemCreateArgs} args - Arguments to create a ComputerLabItem.
     * @example
     * // Create one ComputerLabItem
     * const ComputerLabItem = await prisma.computerLabItem.create({
     *   data: {
     *     // ... data to create a ComputerLabItem
     *   }
     * })
     *
     */
    create<T extends ComputerLabItemCreateArgs>(
      args: SelectSubset<T, ComputerLabItemCreateArgs<ExtArgs>>,
    ): Prisma__ComputerLabItemClient<
      $Result.GetResult<
        Prisma.$ComputerLabItemPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many ComputerLabItems.
     * @param {ComputerLabItemCreateManyArgs} args - Arguments to create many ComputerLabItems.
     * @example
     * // Create many ComputerLabItems
     * const computerLabItem = await prisma.computerLabItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ComputerLabItemCreateManyArgs>(
      args?: SelectSubset<T, ComputerLabItemCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many ComputerLabItems and returns the data saved in the database.
     * @param {ComputerLabItemCreateManyAndReturnArgs} args - Arguments to create many ComputerLabItems.
     * @example
     * // Create many ComputerLabItems
     * const computerLabItem = await prisma.computerLabItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many ComputerLabItems and only return the `id`
     * const computerLabItemWithIdOnly = await prisma.computerLabItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends ComputerLabItemCreateManyAndReturnArgs>(
      args?: SelectSubset<T, ComputerLabItemCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ComputerLabItemPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a ComputerLabItem.
     * @param {ComputerLabItemDeleteArgs} args - Arguments to delete one ComputerLabItem.
     * @example
     * // Delete one ComputerLabItem
     * const ComputerLabItem = await prisma.computerLabItem.delete({
     *   where: {
     *     // ... filter to delete one ComputerLabItem
     *   }
     * })
     *
     */
    delete<T extends ComputerLabItemDeleteArgs>(
      args: SelectSubset<T, ComputerLabItemDeleteArgs<ExtArgs>>,
    ): Prisma__ComputerLabItemClient<
      $Result.GetResult<
        Prisma.$ComputerLabItemPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one ComputerLabItem.
     * @param {ComputerLabItemUpdateArgs} args - Arguments to update one ComputerLabItem.
     * @example
     * // Update one ComputerLabItem
     * const computerLabItem = await prisma.computerLabItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ComputerLabItemUpdateArgs>(
      args: SelectSubset<T, ComputerLabItemUpdateArgs<ExtArgs>>,
    ): Prisma__ComputerLabItemClient<
      $Result.GetResult<
        Prisma.$ComputerLabItemPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more ComputerLabItems.
     * @param {ComputerLabItemDeleteManyArgs} args - Arguments to filter ComputerLabItems to delete.
     * @example
     * // Delete a few ComputerLabItems
     * const { count } = await prisma.computerLabItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ComputerLabItemDeleteManyArgs>(
      args?: SelectSubset<T, ComputerLabItemDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more ComputerLabItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComputerLabItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ComputerLabItems
     * const computerLabItem = await prisma.computerLabItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ComputerLabItemUpdateManyArgs>(
      args: SelectSubset<T, ComputerLabItemUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more ComputerLabItems and returns the data updated in the database.
     * @param {ComputerLabItemUpdateManyAndReturnArgs} args - Arguments to update many ComputerLabItems.
     * @example
     * // Update many ComputerLabItems
     * const computerLabItem = await prisma.computerLabItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more ComputerLabItems and only return the `id`
     * const computerLabItemWithIdOnly = await prisma.computerLabItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends ComputerLabItemUpdateManyAndReturnArgs>(
      args: SelectSubset<T, ComputerLabItemUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ComputerLabItemPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one ComputerLabItem.
     * @param {ComputerLabItemUpsertArgs} args - Arguments to update or create a ComputerLabItem.
     * @example
     * // Update or create a ComputerLabItem
     * const computerLabItem = await prisma.computerLabItem.upsert({
     *   create: {
     *     // ... data to create a ComputerLabItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ComputerLabItem we want to update
     *   }
     * })
     */
    upsert<T extends ComputerLabItemUpsertArgs>(
      args: SelectSubset<T, ComputerLabItemUpsertArgs<ExtArgs>>,
    ): Prisma__ComputerLabItemClient<
      $Result.GetResult<
        Prisma.$ComputerLabItemPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of ComputerLabItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComputerLabItemCountArgs} args - Arguments to filter ComputerLabItems to count.
     * @example
     * // Count the number of ComputerLabItems
     * const count = await prisma.computerLabItem.count({
     *   where: {
     *     // ... the filter for the ComputerLabItems we want to count
     *   }
     * })
     **/
    count<T extends ComputerLabItemCountArgs>(
      args?: Subset<T, ComputerLabItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], ComputerLabItemCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a ComputerLabItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComputerLabItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ComputerLabItemAggregateArgs>(
      args: Subset<T, ComputerLabItemAggregateArgs>,
    ): Prisma.PrismaPromise<GetComputerLabItemAggregateType<T>>;

    /**
     * Group by ComputerLabItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComputerLabItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends ComputerLabItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ComputerLabItemGroupByArgs["orderBy"] }
        : { orderBy?: ComputerLabItemGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, ComputerLabItemGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetComputerLabItemGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the ComputerLabItem model
     */
    readonly fields: ComputerLabItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ComputerLabItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ComputerLabItemClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    asset<T extends AssetDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, AssetDefaultArgs<ExtArgs>>,
    ): Prisma__AssetClient<
      | $Result.GetResult<
          Prisma.$AssetPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    individualComputerLabItems<
      T extends ComputerLabItem$individualComputerLabItemsArgs<ExtArgs> = {},
    >(
      args?: Subset<T, ComputerLabItem$individualComputerLabItemsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$IndividualComputerLabItemPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the ComputerLabItem model
   */
  interface ComputerLabItemFieldRefs {
    readonly id: FieldRef<"ComputerLabItem", "String">;
    readonly name: FieldRef<"ComputerLabItem", "String">;
    readonly model: FieldRef<"ComputerLabItem", "String">;
    readonly specification: FieldRef<"ComputerLabItem", "String">;
    readonly quantity: FieldRef<"ComputerLabItem", "Float">;
    readonly createdAt: FieldRef<"ComputerLabItem", "DateTime">;
    readonly updatedAt: FieldRef<"ComputerLabItem", "DateTime">;
    readonly assetId: FieldRef<"ComputerLabItem", "String">;
    readonly trackQuantity: FieldRef<"ComputerLabItem", "Boolean">;
    readonly unit: FieldRef<"ComputerLabItem", "AssetUnit">;
  }

  // Custom InputTypes
  /**
   * ComputerLabItem findUnique
   */
  export type ComputerLabItemFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ComputerLabItem
     */
    select?: ComputerLabItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ComputerLabItem
     */
    omit?: ComputerLabItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComputerLabItemInclude<ExtArgs> | null;
    /**
     * Filter, which ComputerLabItem to fetch.
     */
    where: ComputerLabItemWhereUniqueInput;
  };

  /**
   * ComputerLabItem findUniqueOrThrow
   */
  export type ComputerLabItemFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ComputerLabItem
     */
    select?: ComputerLabItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ComputerLabItem
     */
    omit?: ComputerLabItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComputerLabItemInclude<ExtArgs> | null;
    /**
     * Filter, which ComputerLabItem to fetch.
     */
    where: ComputerLabItemWhereUniqueInput;
  };

  /**
   * ComputerLabItem findFirst
   */
  export type ComputerLabItemFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ComputerLabItem
     */
    select?: ComputerLabItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ComputerLabItem
     */
    omit?: ComputerLabItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComputerLabItemInclude<ExtArgs> | null;
    /**
     * Filter, which ComputerLabItem to fetch.
     */
    where?: ComputerLabItemWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ComputerLabItems to fetch.
     */
    orderBy?:
      | ComputerLabItemOrderByWithRelationInput
      | ComputerLabItemOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ComputerLabItems.
     */
    cursor?: ComputerLabItemWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ComputerLabItems from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ComputerLabItems.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ComputerLabItems.
     */
    distinct?:
      | ComputerLabItemScalarFieldEnum
      | ComputerLabItemScalarFieldEnum[];
  };

  /**
   * ComputerLabItem findFirstOrThrow
   */
  export type ComputerLabItemFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ComputerLabItem
     */
    select?: ComputerLabItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ComputerLabItem
     */
    omit?: ComputerLabItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComputerLabItemInclude<ExtArgs> | null;
    /**
     * Filter, which ComputerLabItem to fetch.
     */
    where?: ComputerLabItemWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ComputerLabItems to fetch.
     */
    orderBy?:
      | ComputerLabItemOrderByWithRelationInput
      | ComputerLabItemOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ComputerLabItems.
     */
    cursor?: ComputerLabItemWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ComputerLabItems from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ComputerLabItems.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ComputerLabItems.
     */
    distinct?:
      | ComputerLabItemScalarFieldEnum
      | ComputerLabItemScalarFieldEnum[];
  };

  /**
   * ComputerLabItem findMany
   */
  export type ComputerLabItemFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ComputerLabItem
     */
    select?: ComputerLabItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ComputerLabItem
     */
    omit?: ComputerLabItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComputerLabItemInclude<ExtArgs> | null;
    /**
     * Filter, which ComputerLabItems to fetch.
     */
    where?: ComputerLabItemWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ComputerLabItems to fetch.
     */
    orderBy?:
      | ComputerLabItemOrderByWithRelationInput
      | ComputerLabItemOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing ComputerLabItems.
     */
    cursor?: ComputerLabItemWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ComputerLabItems from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ComputerLabItems.
     */
    skip?: number;
    distinct?:
      | ComputerLabItemScalarFieldEnum
      | ComputerLabItemScalarFieldEnum[];
  };

  /**
   * ComputerLabItem create
   */
  export type ComputerLabItemCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ComputerLabItem
     */
    select?: ComputerLabItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ComputerLabItem
     */
    omit?: ComputerLabItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComputerLabItemInclude<ExtArgs> | null;
    /**
     * The data needed to create a ComputerLabItem.
     */
    data: XOR<ComputerLabItemCreateInput, ComputerLabItemUncheckedCreateInput>;
  };

  /**
   * ComputerLabItem createMany
   */
  export type ComputerLabItemCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many ComputerLabItems.
     */
    data: ComputerLabItemCreateManyInput | ComputerLabItemCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * ComputerLabItem createManyAndReturn
   */
  export type ComputerLabItemCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ComputerLabItem
     */
    select?: ComputerLabItemSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the ComputerLabItem
     */
    omit?: ComputerLabItemOmit<ExtArgs> | null;
    /**
     * The data used to create many ComputerLabItems.
     */
    data: ComputerLabItemCreateManyInput | ComputerLabItemCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComputerLabItemIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * ComputerLabItem update
   */
  export type ComputerLabItemUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ComputerLabItem
     */
    select?: ComputerLabItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ComputerLabItem
     */
    omit?: ComputerLabItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComputerLabItemInclude<ExtArgs> | null;
    /**
     * The data needed to update a ComputerLabItem.
     */
    data: XOR<ComputerLabItemUpdateInput, ComputerLabItemUncheckedUpdateInput>;
    /**
     * Choose, which ComputerLabItem to update.
     */
    where: ComputerLabItemWhereUniqueInput;
  };

  /**
   * ComputerLabItem updateMany
   */
  export type ComputerLabItemUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update ComputerLabItems.
     */
    data: XOR<
      ComputerLabItemUpdateManyMutationInput,
      ComputerLabItemUncheckedUpdateManyInput
    >;
    /**
     * Filter which ComputerLabItems to update
     */
    where?: ComputerLabItemWhereInput;
    /**
     * Limit how many ComputerLabItems to update.
     */
    limit?: number;
  };

  /**
   * ComputerLabItem updateManyAndReturn
   */
  export type ComputerLabItemUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ComputerLabItem
     */
    select?: ComputerLabItemSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the ComputerLabItem
     */
    omit?: ComputerLabItemOmit<ExtArgs> | null;
    /**
     * The data used to update ComputerLabItems.
     */
    data: XOR<
      ComputerLabItemUpdateManyMutationInput,
      ComputerLabItemUncheckedUpdateManyInput
    >;
    /**
     * Filter which ComputerLabItems to update
     */
    where?: ComputerLabItemWhereInput;
    /**
     * Limit how many ComputerLabItems to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComputerLabItemIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * ComputerLabItem upsert
   */
  export type ComputerLabItemUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ComputerLabItem
     */
    select?: ComputerLabItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ComputerLabItem
     */
    omit?: ComputerLabItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComputerLabItemInclude<ExtArgs> | null;
    /**
     * The filter to search for the ComputerLabItem to update in case it exists.
     */
    where: ComputerLabItemWhereUniqueInput;
    /**
     * In case the ComputerLabItem found by the `where` argument doesn't exist, create a new ComputerLabItem with this data.
     */
    create: XOR<
      ComputerLabItemCreateInput,
      ComputerLabItemUncheckedCreateInput
    >;
    /**
     * In case the ComputerLabItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<
      ComputerLabItemUpdateInput,
      ComputerLabItemUncheckedUpdateInput
    >;
  };

  /**
   * ComputerLabItem delete
   */
  export type ComputerLabItemDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ComputerLabItem
     */
    select?: ComputerLabItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ComputerLabItem
     */
    omit?: ComputerLabItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComputerLabItemInclude<ExtArgs> | null;
    /**
     * Filter which ComputerLabItem to delete.
     */
    where: ComputerLabItemWhereUniqueInput;
  };

  /**
   * ComputerLabItem deleteMany
   */
  export type ComputerLabItemDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which ComputerLabItems to delete
     */
    where?: ComputerLabItemWhereInput;
    /**
     * Limit how many ComputerLabItems to delete.
     */
    limit?: number;
  };

  /**
   * ComputerLabItem.individualComputerLabItems
   */
  export type ComputerLabItem$individualComputerLabItemsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IndividualComputerLabItem
     */
    select?: IndividualComputerLabItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the IndividualComputerLabItem
     */
    omit?: IndividualComputerLabItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndividualComputerLabItemInclude<ExtArgs> | null;
    where?: IndividualComputerLabItemWhereInput;
    orderBy?:
      | IndividualComputerLabItemOrderByWithRelationInput
      | IndividualComputerLabItemOrderByWithRelationInput[];
    cursor?: IndividualComputerLabItemWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?:
      | IndividualComputerLabItemScalarFieldEnum
      | IndividualComputerLabItemScalarFieldEnum[];
  };

  /**
   * ComputerLabItem without action
   */
  export type ComputerLabItemDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ComputerLabItem
     */
    select?: ComputerLabItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ComputerLabItem
     */
    omit?: ComputerLabItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComputerLabItemInclude<ExtArgs> | null;
  };

  /**
   * Model IndividualComputerLabItem
   */

  export type AggregateIndividualComputerLabItem = {
    _count: IndividualComputerLabItemCountAggregateOutputType | null;
    _min: IndividualComputerLabItemMinAggregateOutputType | null;
    _max: IndividualComputerLabItemMaxAggregateOutputType | null;
  };

  export type IndividualComputerLabItemMinAggregateOutputType = {
    id: string | null;
    computerLabItemId: string | null;
    uniqueIdentifier: string | null;
    status: $Enums.AssetStatus | null;
    condition: $Enums.AssetCondition | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type IndividualComputerLabItemMaxAggregateOutputType = {
    id: string | null;
    computerLabItemId: string | null;
    uniqueIdentifier: string | null;
    status: $Enums.AssetStatus | null;
    condition: $Enums.AssetCondition | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type IndividualComputerLabItemCountAggregateOutputType = {
    id: number;
    computerLabItemId: number;
    uniqueIdentifier: number;
    status: number;
    condition: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type IndividualComputerLabItemMinAggregateInputType = {
    id?: true;
    computerLabItemId?: true;
    uniqueIdentifier?: true;
    status?: true;
    condition?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type IndividualComputerLabItemMaxAggregateInputType = {
    id?: true;
    computerLabItemId?: true;
    uniqueIdentifier?: true;
    status?: true;
    condition?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type IndividualComputerLabItemCountAggregateInputType = {
    id?: true;
    computerLabItemId?: true;
    uniqueIdentifier?: true;
    status?: true;
    condition?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type IndividualComputerLabItemAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which IndividualComputerLabItem to aggregate.
     */
    where?: IndividualComputerLabItemWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of IndividualComputerLabItems to fetch.
     */
    orderBy?:
      | IndividualComputerLabItemOrderByWithRelationInput
      | IndividualComputerLabItemOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: IndividualComputerLabItemWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` IndividualComputerLabItems from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` IndividualComputerLabItems.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned IndividualComputerLabItems
     **/
    _count?: true | IndividualComputerLabItemCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: IndividualComputerLabItemMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: IndividualComputerLabItemMaxAggregateInputType;
  };

  export type GetIndividualComputerLabItemAggregateType<
    T extends IndividualComputerLabItemAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateIndividualComputerLabItem]: P extends
      | "_count"
      | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIndividualComputerLabItem[P]>
      : GetScalarType<T[P], AggregateIndividualComputerLabItem[P]>;
  };

  export type IndividualComputerLabItemGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: IndividualComputerLabItemWhereInput;
    orderBy?:
      | IndividualComputerLabItemOrderByWithAggregationInput
      | IndividualComputerLabItemOrderByWithAggregationInput[];
    by:
      | IndividualComputerLabItemScalarFieldEnum[]
      | IndividualComputerLabItemScalarFieldEnum;
    having?: IndividualComputerLabItemScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: IndividualComputerLabItemCountAggregateInputType | true;
    _min?: IndividualComputerLabItemMinAggregateInputType;
    _max?: IndividualComputerLabItemMaxAggregateInputType;
  };

  export type IndividualComputerLabItemGroupByOutputType = {
    id: string;
    computerLabItemId: string;
    uniqueIdentifier: string | null;
    status: $Enums.AssetStatus;
    condition: $Enums.AssetCondition;
    createdAt: Date;
    updatedAt: Date;
    _count: IndividualComputerLabItemCountAggregateOutputType | null;
    _min: IndividualComputerLabItemMinAggregateOutputType | null;
    _max: IndividualComputerLabItemMaxAggregateOutputType | null;
  };

  type GetIndividualComputerLabItemGroupByPayload<
    T extends IndividualComputerLabItemGroupByArgs,
  > = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IndividualComputerLabItemGroupByOutputType, T["by"]> & {
        [P in keyof T &
          keyof IndividualComputerLabItemGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], IndividualComputerLabItemGroupByOutputType[P]>
          : GetScalarType<T[P], IndividualComputerLabItemGroupByOutputType[P]>;
      }
    >
  >;

  export type IndividualComputerLabItemSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      computerLabItemId?: boolean;
      uniqueIdentifier?: boolean;
      status?: boolean;
      condition?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      assetDamages?:
        | boolean
        | IndividualComputerLabItem$assetDamagesArgs<ExtArgs>;
      computerLabItem?: boolean | ComputerLabItemDefaultArgs<ExtArgs>;
      _count?:
        | boolean
        | IndividualComputerLabItemCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["individualComputerLabItem"]
  >;

  export type IndividualComputerLabItemSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      computerLabItemId?: boolean;
      uniqueIdentifier?: boolean;
      status?: boolean;
      condition?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      computerLabItem?: boolean | ComputerLabItemDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["individualComputerLabItem"]
  >;

  export type IndividualComputerLabItemSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      computerLabItemId?: boolean;
      uniqueIdentifier?: boolean;
      status?: boolean;
      condition?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      computerLabItem?: boolean | ComputerLabItemDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["individualComputerLabItem"]
  >;

  export type IndividualComputerLabItemSelectScalar = {
    id?: boolean;
    computerLabItemId?: boolean;
    uniqueIdentifier?: boolean;
    status?: boolean;
    condition?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type IndividualComputerLabItemOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | "id"
    | "computerLabItemId"
    | "uniqueIdentifier"
    | "status"
    | "condition"
    | "createdAt"
    | "updatedAt",
    ExtArgs["result"]["individualComputerLabItem"]
  >;
  export type IndividualComputerLabItemInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    assetDamages?:
      | boolean
      | IndividualComputerLabItem$assetDamagesArgs<ExtArgs>;
    computerLabItem?: boolean | ComputerLabItemDefaultArgs<ExtArgs>;
    _count?:
      | boolean
      | IndividualComputerLabItemCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type IndividualComputerLabItemIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    computerLabItem?: boolean | ComputerLabItemDefaultArgs<ExtArgs>;
  };
  export type IndividualComputerLabItemIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    computerLabItem?: boolean | ComputerLabItemDefaultArgs<ExtArgs>;
  };

  export type $IndividualComputerLabItemPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "IndividualComputerLabItem";
    objects: {
      assetDamages: Prisma.$AssetDamagePayload<ExtArgs>[];
      computerLabItem: Prisma.$ComputerLabItemPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        computerLabItemId: string;
        uniqueIdentifier: string | null;
        status: $Enums.AssetStatus;
        condition: $Enums.AssetCondition;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs["result"]["individualComputerLabItem"]
    >;
    composites: {};
  };

  type IndividualComputerLabItemGetPayload<
    S extends boolean | null | undefined | IndividualComputerLabItemDefaultArgs,
  > = $Result.GetResult<Prisma.$IndividualComputerLabItemPayload, S>;

  type IndividualComputerLabItemCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    IndividualComputerLabItemFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: IndividualComputerLabItemCountAggregateInputType | true;
  };

  export interface IndividualComputerLabItemDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["IndividualComputerLabItem"];
      meta: { name: "IndividualComputerLabItem" };
    };
    /**
     * Find zero or one IndividualComputerLabItem that matches the filter.
     * @param {IndividualComputerLabItemFindUniqueArgs} args - Arguments to find a IndividualComputerLabItem
     * @example
     * // Get one IndividualComputerLabItem
     * const individualComputerLabItem = await prisma.individualComputerLabItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IndividualComputerLabItemFindUniqueArgs>(
      args: SelectSubset<T, IndividualComputerLabItemFindUniqueArgs<ExtArgs>>,
    ): Prisma__IndividualComputerLabItemClient<
      $Result.GetResult<
        Prisma.$IndividualComputerLabItemPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one IndividualComputerLabItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {IndividualComputerLabItemFindUniqueOrThrowArgs} args - Arguments to find a IndividualComputerLabItem
     * @example
     * // Get one IndividualComputerLabItem
     * const individualComputerLabItem = await prisma.individualComputerLabItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IndividualComputerLabItemFindUniqueOrThrowArgs>(
      args: SelectSubset<
        T,
        IndividualComputerLabItemFindUniqueOrThrowArgs<ExtArgs>
      >,
    ): Prisma__IndividualComputerLabItemClient<
      $Result.GetResult<
        Prisma.$IndividualComputerLabItemPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first IndividualComputerLabItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndividualComputerLabItemFindFirstArgs} args - Arguments to find a IndividualComputerLabItem
     * @example
     * // Get one IndividualComputerLabItem
     * const individualComputerLabItem = await prisma.individualComputerLabItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IndividualComputerLabItemFindFirstArgs>(
      args?: SelectSubset<T, IndividualComputerLabItemFindFirstArgs<ExtArgs>>,
    ): Prisma__IndividualComputerLabItemClient<
      $Result.GetResult<
        Prisma.$IndividualComputerLabItemPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first IndividualComputerLabItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndividualComputerLabItemFindFirstOrThrowArgs} args - Arguments to find a IndividualComputerLabItem
     * @example
     * // Get one IndividualComputerLabItem
     * const individualComputerLabItem = await prisma.individualComputerLabItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IndividualComputerLabItemFindFirstOrThrowArgs>(
      args?: SelectSubset<
        T,
        IndividualComputerLabItemFindFirstOrThrowArgs<ExtArgs>
      >,
    ): Prisma__IndividualComputerLabItemClient<
      $Result.GetResult<
        Prisma.$IndividualComputerLabItemPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more IndividualComputerLabItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndividualComputerLabItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IndividualComputerLabItems
     * const individualComputerLabItems = await prisma.individualComputerLabItem.findMany()
     *
     * // Get first 10 IndividualComputerLabItems
     * const individualComputerLabItems = await prisma.individualComputerLabItem.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const individualComputerLabItemWithIdOnly = await prisma.individualComputerLabItem.findMany({ select: { id: true } })
     *
     */
    findMany<T extends IndividualComputerLabItemFindManyArgs>(
      args?: SelectSubset<T, IndividualComputerLabItemFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$IndividualComputerLabItemPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a IndividualComputerLabItem.
     * @param {IndividualComputerLabItemCreateArgs} args - Arguments to create a IndividualComputerLabItem.
     * @example
     * // Create one IndividualComputerLabItem
     * const IndividualComputerLabItem = await prisma.individualComputerLabItem.create({
     *   data: {
     *     // ... data to create a IndividualComputerLabItem
     *   }
     * })
     *
     */
    create<T extends IndividualComputerLabItemCreateArgs>(
      args: SelectSubset<T, IndividualComputerLabItemCreateArgs<ExtArgs>>,
    ): Prisma__IndividualComputerLabItemClient<
      $Result.GetResult<
        Prisma.$IndividualComputerLabItemPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many IndividualComputerLabItems.
     * @param {IndividualComputerLabItemCreateManyArgs} args - Arguments to create many IndividualComputerLabItems.
     * @example
     * // Create many IndividualComputerLabItems
     * const individualComputerLabItem = await prisma.individualComputerLabItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends IndividualComputerLabItemCreateManyArgs>(
      args?: SelectSubset<T, IndividualComputerLabItemCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many IndividualComputerLabItems and returns the data saved in the database.
     * @param {IndividualComputerLabItemCreateManyAndReturnArgs} args - Arguments to create many IndividualComputerLabItems.
     * @example
     * // Create many IndividualComputerLabItems
     * const individualComputerLabItem = await prisma.individualComputerLabItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many IndividualComputerLabItems and only return the `id`
     * const individualComputerLabItemWithIdOnly = await prisma.individualComputerLabItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<
      T extends IndividualComputerLabItemCreateManyAndReturnArgs,
    >(
      args?: SelectSubset<
        T,
        IndividualComputerLabItemCreateManyAndReturnArgs<ExtArgs>
      >,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$IndividualComputerLabItemPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a IndividualComputerLabItem.
     * @param {IndividualComputerLabItemDeleteArgs} args - Arguments to delete one IndividualComputerLabItem.
     * @example
     * // Delete one IndividualComputerLabItem
     * const IndividualComputerLabItem = await prisma.individualComputerLabItem.delete({
     *   where: {
     *     // ... filter to delete one IndividualComputerLabItem
     *   }
     * })
     *
     */
    delete<T extends IndividualComputerLabItemDeleteArgs>(
      args: SelectSubset<T, IndividualComputerLabItemDeleteArgs<ExtArgs>>,
    ): Prisma__IndividualComputerLabItemClient<
      $Result.GetResult<
        Prisma.$IndividualComputerLabItemPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one IndividualComputerLabItem.
     * @param {IndividualComputerLabItemUpdateArgs} args - Arguments to update one IndividualComputerLabItem.
     * @example
     * // Update one IndividualComputerLabItem
     * const individualComputerLabItem = await prisma.individualComputerLabItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends IndividualComputerLabItemUpdateArgs>(
      args: SelectSubset<T, IndividualComputerLabItemUpdateArgs<ExtArgs>>,
    ): Prisma__IndividualComputerLabItemClient<
      $Result.GetResult<
        Prisma.$IndividualComputerLabItemPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more IndividualComputerLabItems.
     * @param {IndividualComputerLabItemDeleteManyArgs} args - Arguments to filter IndividualComputerLabItems to delete.
     * @example
     * // Delete a few IndividualComputerLabItems
     * const { count } = await prisma.individualComputerLabItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends IndividualComputerLabItemDeleteManyArgs>(
      args?: SelectSubset<T, IndividualComputerLabItemDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more IndividualComputerLabItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndividualComputerLabItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IndividualComputerLabItems
     * const individualComputerLabItem = await prisma.individualComputerLabItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends IndividualComputerLabItemUpdateManyArgs>(
      args: SelectSubset<T, IndividualComputerLabItemUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more IndividualComputerLabItems and returns the data updated in the database.
     * @param {IndividualComputerLabItemUpdateManyAndReturnArgs} args - Arguments to update many IndividualComputerLabItems.
     * @example
     * // Update many IndividualComputerLabItems
     * const individualComputerLabItem = await prisma.individualComputerLabItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more IndividualComputerLabItems and only return the `id`
     * const individualComputerLabItemWithIdOnly = await prisma.individualComputerLabItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<
      T extends IndividualComputerLabItemUpdateManyAndReturnArgs,
    >(
      args: SelectSubset<
        T,
        IndividualComputerLabItemUpdateManyAndReturnArgs<ExtArgs>
      >,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$IndividualComputerLabItemPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one IndividualComputerLabItem.
     * @param {IndividualComputerLabItemUpsertArgs} args - Arguments to update or create a IndividualComputerLabItem.
     * @example
     * // Update or create a IndividualComputerLabItem
     * const individualComputerLabItem = await prisma.individualComputerLabItem.upsert({
     *   create: {
     *     // ... data to create a IndividualComputerLabItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IndividualComputerLabItem we want to update
     *   }
     * })
     */
    upsert<T extends IndividualComputerLabItemUpsertArgs>(
      args: SelectSubset<T, IndividualComputerLabItemUpsertArgs<ExtArgs>>,
    ): Prisma__IndividualComputerLabItemClient<
      $Result.GetResult<
        Prisma.$IndividualComputerLabItemPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of IndividualComputerLabItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndividualComputerLabItemCountArgs} args - Arguments to filter IndividualComputerLabItems to count.
     * @example
     * // Count the number of IndividualComputerLabItems
     * const count = await prisma.individualComputerLabItem.count({
     *   where: {
     *     // ... the filter for the IndividualComputerLabItems we want to count
     *   }
     * })
     **/
    count<T extends IndividualComputerLabItemCountArgs>(
      args?: Subset<T, IndividualComputerLabItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<
              T["select"],
              IndividualComputerLabItemCountAggregateOutputType
            >
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a IndividualComputerLabItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndividualComputerLabItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends IndividualComputerLabItemAggregateArgs>(
      args: Subset<T, IndividualComputerLabItemAggregateArgs>,
    ): Prisma.PrismaPromise<GetIndividualComputerLabItemAggregateType<T>>;

    /**
     * Group by IndividualComputerLabItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndividualComputerLabItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends IndividualComputerLabItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IndividualComputerLabItemGroupByArgs["orderBy"] }
        : { orderBy?: IndividualComputerLabItemGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<
        T,
        IndividualComputerLabItemGroupByArgs,
        OrderByArg
      > &
        InputErrors,
    ): {} extends InputErrors
      ? GetIndividualComputerLabItemGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the IndividualComputerLabItem model
     */
    readonly fields: IndividualComputerLabItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IndividualComputerLabItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IndividualComputerLabItemClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    assetDamages<
      T extends IndividualComputerLabItem$assetDamagesArgs<ExtArgs> = {},
    >(
      args?: Subset<T, IndividualComputerLabItem$assetDamagesArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$AssetDamagePayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    computerLabItem<T extends ComputerLabItemDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, ComputerLabItemDefaultArgs<ExtArgs>>,
    ): Prisma__ComputerLabItemClient<
      | $Result.GetResult<
          Prisma.$ComputerLabItemPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the IndividualComputerLabItem model
   */
  interface IndividualComputerLabItemFieldRefs {
    readonly id: FieldRef<"IndividualComputerLabItem", "String">;
    readonly computerLabItemId: FieldRef<"IndividualComputerLabItem", "String">;
    readonly uniqueIdentifier: FieldRef<"IndividualComputerLabItem", "String">;
    readonly status: FieldRef<"IndividualComputerLabItem", "AssetStatus">;
    readonly condition: FieldRef<"IndividualComputerLabItem", "AssetCondition">;
    readonly createdAt: FieldRef<"IndividualComputerLabItem", "DateTime">;
    readonly updatedAt: FieldRef<"IndividualComputerLabItem", "DateTime">;
  }

  // Custom InputTypes
  /**
   * IndividualComputerLabItem findUnique
   */
  export type IndividualComputerLabItemFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IndividualComputerLabItem
     */
    select?: IndividualComputerLabItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the IndividualComputerLabItem
     */
    omit?: IndividualComputerLabItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndividualComputerLabItemInclude<ExtArgs> | null;
    /**
     * Filter, which IndividualComputerLabItem to fetch.
     */
    where: IndividualComputerLabItemWhereUniqueInput;
  };

  /**
   * IndividualComputerLabItem findUniqueOrThrow
   */
  export type IndividualComputerLabItemFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IndividualComputerLabItem
     */
    select?: IndividualComputerLabItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the IndividualComputerLabItem
     */
    omit?: IndividualComputerLabItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndividualComputerLabItemInclude<ExtArgs> | null;
    /**
     * Filter, which IndividualComputerLabItem to fetch.
     */
    where: IndividualComputerLabItemWhereUniqueInput;
  };

  /**
   * IndividualComputerLabItem findFirst
   */
  export type IndividualComputerLabItemFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IndividualComputerLabItem
     */
    select?: IndividualComputerLabItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the IndividualComputerLabItem
     */
    omit?: IndividualComputerLabItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndividualComputerLabItemInclude<ExtArgs> | null;
    /**
     * Filter, which IndividualComputerLabItem to fetch.
     */
    where?: IndividualComputerLabItemWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of IndividualComputerLabItems to fetch.
     */
    orderBy?:
      | IndividualComputerLabItemOrderByWithRelationInput
      | IndividualComputerLabItemOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for IndividualComputerLabItems.
     */
    cursor?: IndividualComputerLabItemWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` IndividualComputerLabItems from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` IndividualComputerLabItems.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of IndividualComputerLabItems.
     */
    distinct?:
      | IndividualComputerLabItemScalarFieldEnum
      | IndividualComputerLabItemScalarFieldEnum[];
  };

  /**
   * IndividualComputerLabItem findFirstOrThrow
   */
  export type IndividualComputerLabItemFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IndividualComputerLabItem
     */
    select?: IndividualComputerLabItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the IndividualComputerLabItem
     */
    omit?: IndividualComputerLabItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndividualComputerLabItemInclude<ExtArgs> | null;
    /**
     * Filter, which IndividualComputerLabItem to fetch.
     */
    where?: IndividualComputerLabItemWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of IndividualComputerLabItems to fetch.
     */
    orderBy?:
      | IndividualComputerLabItemOrderByWithRelationInput
      | IndividualComputerLabItemOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for IndividualComputerLabItems.
     */
    cursor?: IndividualComputerLabItemWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` IndividualComputerLabItems from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` IndividualComputerLabItems.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of IndividualComputerLabItems.
     */
    distinct?:
      | IndividualComputerLabItemScalarFieldEnum
      | IndividualComputerLabItemScalarFieldEnum[];
  };

  /**
   * IndividualComputerLabItem findMany
   */
  export type IndividualComputerLabItemFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IndividualComputerLabItem
     */
    select?: IndividualComputerLabItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the IndividualComputerLabItem
     */
    omit?: IndividualComputerLabItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndividualComputerLabItemInclude<ExtArgs> | null;
    /**
     * Filter, which IndividualComputerLabItems to fetch.
     */
    where?: IndividualComputerLabItemWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of IndividualComputerLabItems to fetch.
     */
    orderBy?:
      | IndividualComputerLabItemOrderByWithRelationInput
      | IndividualComputerLabItemOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing IndividualComputerLabItems.
     */
    cursor?: IndividualComputerLabItemWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` IndividualComputerLabItems from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` IndividualComputerLabItems.
     */
    skip?: number;
    distinct?:
      | IndividualComputerLabItemScalarFieldEnum
      | IndividualComputerLabItemScalarFieldEnum[];
  };

  /**
   * IndividualComputerLabItem create
   */
  export type IndividualComputerLabItemCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IndividualComputerLabItem
     */
    select?: IndividualComputerLabItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the IndividualComputerLabItem
     */
    omit?: IndividualComputerLabItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndividualComputerLabItemInclude<ExtArgs> | null;
    /**
     * The data needed to create a IndividualComputerLabItem.
     */
    data: XOR<
      IndividualComputerLabItemCreateInput,
      IndividualComputerLabItemUncheckedCreateInput
    >;
  };

  /**
   * IndividualComputerLabItem createMany
   */
  export type IndividualComputerLabItemCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many IndividualComputerLabItems.
     */
    data:
      | IndividualComputerLabItemCreateManyInput
      | IndividualComputerLabItemCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * IndividualComputerLabItem createManyAndReturn
   */
  export type IndividualComputerLabItemCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IndividualComputerLabItem
     */
    select?: IndividualComputerLabItemSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the IndividualComputerLabItem
     */
    omit?: IndividualComputerLabItemOmit<ExtArgs> | null;
    /**
     * The data used to create many IndividualComputerLabItems.
     */
    data:
      | IndividualComputerLabItemCreateManyInput
      | IndividualComputerLabItemCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndividualComputerLabItemIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * IndividualComputerLabItem update
   */
  export type IndividualComputerLabItemUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IndividualComputerLabItem
     */
    select?: IndividualComputerLabItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the IndividualComputerLabItem
     */
    omit?: IndividualComputerLabItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndividualComputerLabItemInclude<ExtArgs> | null;
    /**
     * The data needed to update a IndividualComputerLabItem.
     */
    data: XOR<
      IndividualComputerLabItemUpdateInput,
      IndividualComputerLabItemUncheckedUpdateInput
    >;
    /**
     * Choose, which IndividualComputerLabItem to update.
     */
    where: IndividualComputerLabItemWhereUniqueInput;
  };

  /**
   * IndividualComputerLabItem updateMany
   */
  export type IndividualComputerLabItemUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update IndividualComputerLabItems.
     */
    data: XOR<
      IndividualComputerLabItemUpdateManyMutationInput,
      IndividualComputerLabItemUncheckedUpdateManyInput
    >;
    /**
     * Filter which IndividualComputerLabItems to update
     */
    where?: IndividualComputerLabItemWhereInput;
    /**
     * Limit how many IndividualComputerLabItems to update.
     */
    limit?: number;
  };

  /**
   * IndividualComputerLabItem updateManyAndReturn
   */
  export type IndividualComputerLabItemUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IndividualComputerLabItem
     */
    select?: IndividualComputerLabItemSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the IndividualComputerLabItem
     */
    omit?: IndividualComputerLabItemOmit<ExtArgs> | null;
    /**
     * The data used to update IndividualComputerLabItems.
     */
    data: XOR<
      IndividualComputerLabItemUpdateManyMutationInput,
      IndividualComputerLabItemUncheckedUpdateManyInput
    >;
    /**
     * Filter which IndividualComputerLabItems to update
     */
    where?: IndividualComputerLabItemWhereInput;
    /**
     * Limit how many IndividualComputerLabItems to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndividualComputerLabItemIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * IndividualComputerLabItem upsert
   */
  export type IndividualComputerLabItemUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IndividualComputerLabItem
     */
    select?: IndividualComputerLabItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the IndividualComputerLabItem
     */
    omit?: IndividualComputerLabItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndividualComputerLabItemInclude<ExtArgs> | null;
    /**
     * The filter to search for the IndividualComputerLabItem to update in case it exists.
     */
    where: IndividualComputerLabItemWhereUniqueInput;
    /**
     * In case the IndividualComputerLabItem found by the `where` argument doesn't exist, create a new IndividualComputerLabItem with this data.
     */
    create: XOR<
      IndividualComputerLabItemCreateInput,
      IndividualComputerLabItemUncheckedCreateInput
    >;
    /**
     * In case the IndividualComputerLabItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<
      IndividualComputerLabItemUpdateInput,
      IndividualComputerLabItemUncheckedUpdateInput
    >;
  };

  /**
   * IndividualComputerLabItem delete
   */
  export type IndividualComputerLabItemDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IndividualComputerLabItem
     */
    select?: IndividualComputerLabItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the IndividualComputerLabItem
     */
    omit?: IndividualComputerLabItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndividualComputerLabItemInclude<ExtArgs> | null;
    /**
     * Filter which IndividualComputerLabItem to delete.
     */
    where: IndividualComputerLabItemWhereUniqueInput;
  };

  /**
   * IndividualComputerLabItem deleteMany
   */
  export type IndividualComputerLabItemDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which IndividualComputerLabItems to delete
     */
    where?: IndividualComputerLabItemWhereInput;
    /**
     * Limit how many IndividualComputerLabItems to delete.
     */
    limit?: number;
  };

  /**
   * IndividualComputerLabItem.assetDamages
   */
  export type IndividualComputerLabItem$assetDamagesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AssetDamage
     */
    select?: AssetDamageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AssetDamage
     */
    omit?: AssetDamageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetDamageInclude<ExtArgs> | null;
    where?: AssetDamageWhereInput;
    orderBy?:
      | AssetDamageOrderByWithRelationInput
      | AssetDamageOrderByWithRelationInput[];
    cursor?: AssetDamageWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: AssetDamageScalarFieldEnum | AssetDamageScalarFieldEnum[];
  };

  /**
   * IndividualComputerLabItem without action
   */
  export type IndividualComputerLabItemDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IndividualComputerLabItem
     */
    select?: IndividualComputerLabItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the IndividualComputerLabItem
     */
    omit?: IndividualComputerLabItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndividualComputerLabItemInclude<ExtArgs> | null;
  };

  /**
   * Model GeneralStoreItem
   */

  export type AggregateGeneralStoreItem = {
    _count: GeneralStoreItemCountAggregateOutputType | null;
    _avg: GeneralStoreItemAvgAggregateOutputType | null;
    _sum: GeneralStoreItemSumAggregateOutputType | null;
    _min: GeneralStoreItemMinAggregateOutputType | null;
    _max: GeneralStoreItemMaxAggregateOutputType | null;
  };

  export type GeneralStoreItemAvgAggregateOutputType = {
    quantity: number | null;
  };

  export type GeneralStoreItemSumAggregateOutputType = {
    quantity: number | null;
  };

  export type GeneralStoreItemMinAggregateOutputType = {
    id: string | null;
    name: string | null;
    quantity: number | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    assetId: string | null;
    status: $Enums.AssetItemStatus | null;
    trackQuantity: boolean | null;
    unit: $Enums.AssetUnit | null;
  };

  export type GeneralStoreItemMaxAggregateOutputType = {
    id: string | null;
    name: string | null;
    quantity: number | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    assetId: string | null;
    status: $Enums.AssetItemStatus | null;
    trackQuantity: boolean | null;
    unit: $Enums.AssetUnit | null;
  };

  export type GeneralStoreItemCountAggregateOutputType = {
    id: number;
    name: number;
    quantity: number;
    createdAt: number;
    updatedAt: number;
    assetId: number;
    status: number;
    trackQuantity: number;
    unit: number;
    _all: number;
  };

  export type GeneralStoreItemAvgAggregateInputType = {
    quantity?: true;
  };

  export type GeneralStoreItemSumAggregateInputType = {
    quantity?: true;
  };

  export type GeneralStoreItemMinAggregateInputType = {
    id?: true;
    name?: true;
    quantity?: true;
    createdAt?: true;
    updatedAt?: true;
    assetId?: true;
    status?: true;
    trackQuantity?: true;
    unit?: true;
  };

  export type GeneralStoreItemMaxAggregateInputType = {
    id?: true;
    name?: true;
    quantity?: true;
    createdAt?: true;
    updatedAt?: true;
    assetId?: true;
    status?: true;
    trackQuantity?: true;
    unit?: true;
  };

  export type GeneralStoreItemCountAggregateInputType = {
    id?: true;
    name?: true;
    quantity?: true;
    createdAt?: true;
    updatedAt?: true;
    assetId?: true;
    status?: true;
    trackQuantity?: true;
    unit?: true;
    _all?: true;
  };

  export type GeneralStoreItemAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which GeneralStoreItem to aggregate.
     */
    where?: GeneralStoreItemWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of GeneralStoreItems to fetch.
     */
    orderBy?:
      | GeneralStoreItemOrderByWithRelationInput
      | GeneralStoreItemOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: GeneralStoreItemWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` GeneralStoreItems from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` GeneralStoreItems.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned GeneralStoreItems
     **/
    _count?: true | GeneralStoreItemCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: GeneralStoreItemAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: GeneralStoreItemSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: GeneralStoreItemMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: GeneralStoreItemMaxAggregateInputType;
  };

  export type GetGeneralStoreItemAggregateType<
    T extends GeneralStoreItemAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateGeneralStoreItem]: P extends
      | "_count"
      | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGeneralStoreItem[P]>
      : GetScalarType<T[P], AggregateGeneralStoreItem[P]>;
  };

  export type GeneralStoreItemGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: GeneralStoreItemWhereInput;
    orderBy?:
      | GeneralStoreItemOrderByWithAggregationInput
      | GeneralStoreItemOrderByWithAggregationInput[];
    by: GeneralStoreItemScalarFieldEnum[] | GeneralStoreItemScalarFieldEnum;
    having?: GeneralStoreItemScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: GeneralStoreItemCountAggregateInputType | true;
    _avg?: GeneralStoreItemAvgAggregateInputType;
    _sum?: GeneralStoreItemSumAggregateInputType;
    _min?: GeneralStoreItemMinAggregateInputType;
    _max?: GeneralStoreItemMaxAggregateInputType;
  };

  export type GeneralStoreItemGroupByOutputType = {
    id: string;
    name: string;
    quantity: number | null;
    createdAt: Date;
    updatedAt: Date;
    assetId: string;
    status: $Enums.AssetItemStatus;
    trackQuantity: boolean;
    unit: $Enums.AssetUnit;
    _count: GeneralStoreItemCountAggregateOutputType | null;
    _avg: GeneralStoreItemAvgAggregateOutputType | null;
    _sum: GeneralStoreItemSumAggregateOutputType | null;
    _min: GeneralStoreItemMinAggregateOutputType | null;
    _max: GeneralStoreItemMaxAggregateOutputType | null;
  };

  type GetGeneralStoreItemGroupByPayload<
    T extends GeneralStoreItemGroupByArgs,
  > = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GeneralStoreItemGroupByOutputType, T["by"]> & {
        [P in keyof T &
          keyof GeneralStoreItemGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], GeneralStoreItemGroupByOutputType[P]>
          : GetScalarType<T[P], GeneralStoreItemGroupByOutputType[P]>;
      }
    >
  >;

  export type GeneralStoreItemSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      quantity?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      assetId?: boolean;
      status?: boolean;
      trackQuantity?: boolean;
      unit?: boolean;
      asset?: boolean | AssetDefaultArgs<ExtArgs>;
      individualGeneralStoreItems?:
        | boolean
        | GeneralStoreItem$individualGeneralStoreItemsArgs<ExtArgs>;
      _count?: boolean | GeneralStoreItemCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["generalStoreItem"]
  >;

  export type GeneralStoreItemSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      quantity?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      assetId?: boolean;
      status?: boolean;
      trackQuantity?: boolean;
      unit?: boolean;
      asset?: boolean | AssetDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["generalStoreItem"]
  >;

  export type GeneralStoreItemSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      quantity?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      assetId?: boolean;
      status?: boolean;
      trackQuantity?: boolean;
      unit?: boolean;
      asset?: boolean | AssetDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["generalStoreItem"]
  >;

  export type GeneralStoreItemSelectScalar = {
    id?: boolean;
    name?: boolean;
    quantity?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    assetId?: boolean;
    status?: boolean;
    trackQuantity?: boolean;
    unit?: boolean;
  };

  export type GeneralStoreItemOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | "id"
    | "name"
    | "quantity"
    | "createdAt"
    | "updatedAt"
    | "assetId"
    | "status"
    | "trackQuantity"
    | "unit",
    ExtArgs["result"]["generalStoreItem"]
  >;
  export type GeneralStoreItemInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    asset?: boolean | AssetDefaultArgs<ExtArgs>;
    individualGeneralStoreItems?:
      | boolean
      | GeneralStoreItem$individualGeneralStoreItemsArgs<ExtArgs>;
    _count?: boolean | GeneralStoreItemCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type GeneralStoreItemIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    asset?: boolean | AssetDefaultArgs<ExtArgs>;
  };
  export type GeneralStoreItemIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    asset?: boolean | AssetDefaultArgs<ExtArgs>;
  };

  export type $GeneralStoreItemPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "GeneralStoreItem";
    objects: {
      asset: Prisma.$AssetPayload<ExtArgs>;
      individualGeneralStoreItems: Prisma.$IndividualGeneralStoreItemPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        name: string;
        quantity: number | null;
        createdAt: Date;
        updatedAt: Date;
        assetId: string;
        status: $Enums.AssetItemStatus;
        trackQuantity: boolean;
        unit: $Enums.AssetUnit;
      },
      ExtArgs["result"]["generalStoreItem"]
    >;
    composites: {};
  };

  type GeneralStoreItemGetPayload<
    S extends boolean | null | undefined | GeneralStoreItemDefaultArgs,
  > = $Result.GetResult<Prisma.$GeneralStoreItemPayload, S>;

  type GeneralStoreItemCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    GeneralStoreItemFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: GeneralStoreItemCountAggregateInputType | true;
  };

  export interface GeneralStoreItemDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["GeneralStoreItem"];
      meta: { name: "GeneralStoreItem" };
    };
    /**
     * Find zero or one GeneralStoreItem that matches the filter.
     * @param {GeneralStoreItemFindUniqueArgs} args - Arguments to find a GeneralStoreItem
     * @example
     * // Get one GeneralStoreItem
     * const generalStoreItem = await prisma.generalStoreItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GeneralStoreItemFindUniqueArgs>(
      args: SelectSubset<T, GeneralStoreItemFindUniqueArgs<ExtArgs>>,
    ): Prisma__GeneralStoreItemClient<
      $Result.GetResult<
        Prisma.$GeneralStoreItemPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one GeneralStoreItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GeneralStoreItemFindUniqueOrThrowArgs} args - Arguments to find a GeneralStoreItem
     * @example
     * // Get one GeneralStoreItem
     * const generalStoreItem = await prisma.generalStoreItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GeneralStoreItemFindUniqueOrThrowArgs>(
      args: SelectSubset<T, GeneralStoreItemFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__GeneralStoreItemClient<
      $Result.GetResult<
        Prisma.$GeneralStoreItemPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first GeneralStoreItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneralStoreItemFindFirstArgs} args - Arguments to find a GeneralStoreItem
     * @example
     * // Get one GeneralStoreItem
     * const generalStoreItem = await prisma.generalStoreItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GeneralStoreItemFindFirstArgs>(
      args?: SelectSubset<T, GeneralStoreItemFindFirstArgs<ExtArgs>>,
    ): Prisma__GeneralStoreItemClient<
      $Result.GetResult<
        Prisma.$GeneralStoreItemPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first GeneralStoreItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneralStoreItemFindFirstOrThrowArgs} args - Arguments to find a GeneralStoreItem
     * @example
     * // Get one GeneralStoreItem
     * const generalStoreItem = await prisma.generalStoreItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GeneralStoreItemFindFirstOrThrowArgs>(
      args?: SelectSubset<T, GeneralStoreItemFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__GeneralStoreItemClient<
      $Result.GetResult<
        Prisma.$GeneralStoreItemPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more GeneralStoreItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneralStoreItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GeneralStoreItems
     * const generalStoreItems = await prisma.generalStoreItem.findMany()
     *
     * // Get first 10 GeneralStoreItems
     * const generalStoreItems = await prisma.generalStoreItem.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const generalStoreItemWithIdOnly = await prisma.generalStoreItem.findMany({ select: { id: true } })
     *
     */
    findMany<T extends GeneralStoreItemFindManyArgs>(
      args?: SelectSubset<T, GeneralStoreItemFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$GeneralStoreItemPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a GeneralStoreItem.
     * @param {GeneralStoreItemCreateArgs} args - Arguments to create a GeneralStoreItem.
     * @example
     * // Create one GeneralStoreItem
     * const GeneralStoreItem = await prisma.generalStoreItem.create({
     *   data: {
     *     // ... data to create a GeneralStoreItem
     *   }
     * })
     *
     */
    create<T extends GeneralStoreItemCreateArgs>(
      args: SelectSubset<T, GeneralStoreItemCreateArgs<ExtArgs>>,
    ): Prisma__GeneralStoreItemClient<
      $Result.GetResult<
        Prisma.$GeneralStoreItemPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many GeneralStoreItems.
     * @param {GeneralStoreItemCreateManyArgs} args - Arguments to create many GeneralStoreItems.
     * @example
     * // Create many GeneralStoreItems
     * const generalStoreItem = await prisma.generalStoreItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends GeneralStoreItemCreateManyArgs>(
      args?: SelectSubset<T, GeneralStoreItemCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many GeneralStoreItems and returns the data saved in the database.
     * @param {GeneralStoreItemCreateManyAndReturnArgs} args - Arguments to create many GeneralStoreItems.
     * @example
     * // Create many GeneralStoreItems
     * const generalStoreItem = await prisma.generalStoreItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many GeneralStoreItems and only return the `id`
     * const generalStoreItemWithIdOnly = await prisma.generalStoreItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends GeneralStoreItemCreateManyAndReturnArgs>(
      args?: SelectSubset<T, GeneralStoreItemCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$GeneralStoreItemPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a GeneralStoreItem.
     * @param {GeneralStoreItemDeleteArgs} args - Arguments to delete one GeneralStoreItem.
     * @example
     * // Delete one GeneralStoreItem
     * const GeneralStoreItem = await prisma.generalStoreItem.delete({
     *   where: {
     *     // ... filter to delete one GeneralStoreItem
     *   }
     * })
     *
     */
    delete<T extends GeneralStoreItemDeleteArgs>(
      args: SelectSubset<T, GeneralStoreItemDeleteArgs<ExtArgs>>,
    ): Prisma__GeneralStoreItemClient<
      $Result.GetResult<
        Prisma.$GeneralStoreItemPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one GeneralStoreItem.
     * @param {GeneralStoreItemUpdateArgs} args - Arguments to update one GeneralStoreItem.
     * @example
     * // Update one GeneralStoreItem
     * const generalStoreItem = await prisma.generalStoreItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends GeneralStoreItemUpdateArgs>(
      args: SelectSubset<T, GeneralStoreItemUpdateArgs<ExtArgs>>,
    ): Prisma__GeneralStoreItemClient<
      $Result.GetResult<
        Prisma.$GeneralStoreItemPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more GeneralStoreItems.
     * @param {GeneralStoreItemDeleteManyArgs} args - Arguments to filter GeneralStoreItems to delete.
     * @example
     * // Delete a few GeneralStoreItems
     * const { count } = await prisma.generalStoreItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends GeneralStoreItemDeleteManyArgs>(
      args?: SelectSubset<T, GeneralStoreItemDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more GeneralStoreItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneralStoreItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GeneralStoreItems
     * const generalStoreItem = await prisma.generalStoreItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends GeneralStoreItemUpdateManyArgs>(
      args: SelectSubset<T, GeneralStoreItemUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more GeneralStoreItems and returns the data updated in the database.
     * @param {GeneralStoreItemUpdateManyAndReturnArgs} args - Arguments to update many GeneralStoreItems.
     * @example
     * // Update many GeneralStoreItems
     * const generalStoreItem = await prisma.generalStoreItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more GeneralStoreItems and only return the `id`
     * const generalStoreItemWithIdOnly = await prisma.generalStoreItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends GeneralStoreItemUpdateManyAndReturnArgs>(
      args: SelectSubset<T, GeneralStoreItemUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$GeneralStoreItemPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one GeneralStoreItem.
     * @param {GeneralStoreItemUpsertArgs} args - Arguments to update or create a GeneralStoreItem.
     * @example
     * // Update or create a GeneralStoreItem
     * const generalStoreItem = await prisma.generalStoreItem.upsert({
     *   create: {
     *     // ... data to create a GeneralStoreItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GeneralStoreItem we want to update
     *   }
     * })
     */
    upsert<T extends GeneralStoreItemUpsertArgs>(
      args: SelectSubset<T, GeneralStoreItemUpsertArgs<ExtArgs>>,
    ): Prisma__GeneralStoreItemClient<
      $Result.GetResult<
        Prisma.$GeneralStoreItemPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of GeneralStoreItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneralStoreItemCountArgs} args - Arguments to filter GeneralStoreItems to count.
     * @example
     * // Count the number of GeneralStoreItems
     * const count = await prisma.generalStoreItem.count({
     *   where: {
     *     // ... the filter for the GeneralStoreItems we want to count
     *   }
     * })
     **/
    count<T extends GeneralStoreItemCountArgs>(
      args?: Subset<T, GeneralStoreItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], GeneralStoreItemCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a GeneralStoreItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneralStoreItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends GeneralStoreItemAggregateArgs>(
      args: Subset<T, GeneralStoreItemAggregateArgs>,
    ): Prisma.PrismaPromise<GetGeneralStoreItemAggregateType<T>>;

    /**
     * Group by GeneralStoreItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneralStoreItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends GeneralStoreItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GeneralStoreItemGroupByArgs["orderBy"] }
        : { orderBy?: GeneralStoreItemGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, GeneralStoreItemGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetGeneralStoreItemGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the GeneralStoreItem model
     */
    readonly fields: GeneralStoreItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GeneralStoreItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GeneralStoreItemClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    asset<T extends AssetDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, AssetDefaultArgs<ExtArgs>>,
    ): Prisma__AssetClient<
      | $Result.GetResult<
          Prisma.$AssetPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    individualGeneralStoreItems<
      T extends GeneralStoreItem$individualGeneralStoreItemsArgs<ExtArgs> = {},
    >(
      args?: Subset<
        T,
        GeneralStoreItem$individualGeneralStoreItemsArgs<ExtArgs>
      >,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$IndividualGeneralStoreItemPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the GeneralStoreItem model
   */
  interface GeneralStoreItemFieldRefs {
    readonly id: FieldRef<"GeneralStoreItem", "String">;
    readonly name: FieldRef<"GeneralStoreItem", "String">;
    readonly quantity: FieldRef<"GeneralStoreItem", "Float">;
    readonly createdAt: FieldRef<"GeneralStoreItem", "DateTime">;
    readonly updatedAt: FieldRef<"GeneralStoreItem", "DateTime">;
    readonly assetId: FieldRef<"GeneralStoreItem", "String">;
    readonly status: FieldRef<"GeneralStoreItem", "AssetItemStatus">;
    readonly trackQuantity: FieldRef<"GeneralStoreItem", "Boolean">;
    readonly unit: FieldRef<"GeneralStoreItem", "AssetUnit">;
  }

  // Custom InputTypes
  /**
   * GeneralStoreItem findUnique
   */
  export type GeneralStoreItemFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the GeneralStoreItem
     */
    select?: GeneralStoreItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the GeneralStoreItem
     */
    omit?: GeneralStoreItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneralStoreItemInclude<ExtArgs> | null;
    /**
     * Filter, which GeneralStoreItem to fetch.
     */
    where: GeneralStoreItemWhereUniqueInput;
  };

  /**
   * GeneralStoreItem findUniqueOrThrow
   */
  export type GeneralStoreItemFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the GeneralStoreItem
     */
    select?: GeneralStoreItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the GeneralStoreItem
     */
    omit?: GeneralStoreItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneralStoreItemInclude<ExtArgs> | null;
    /**
     * Filter, which GeneralStoreItem to fetch.
     */
    where: GeneralStoreItemWhereUniqueInput;
  };

  /**
   * GeneralStoreItem findFirst
   */
  export type GeneralStoreItemFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the GeneralStoreItem
     */
    select?: GeneralStoreItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the GeneralStoreItem
     */
    omit?: GeneralStoreItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneralStoreItemInclude<ExtArgs> | null;
    /**
     * Filter, which GeneralStoreItem to fetch.
     */
    where?: GeneralStoreItemWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of GeneralStoreItems to fetch.
     */
    orderBy?:
      | GeneralStoreItemOrderByWithRelationInput
      | GeneralStoreItemOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for GeneralStoreItems.
     */
    cursor?: GeneralStoreItemWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` GeneralStoreItems from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` GeneralStoreItems.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of GeneralStoreItems.
     */
    distinct?:
      | GeneralStoreItemScalarFieldEnum
      | GeneralStoreItemScalarFieldEnum[];
  };

  /**
   * GeneralStoreItem findFirstOrThrow
   */
  export type GeneralStoreItemFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the GeneralStoreItem
     */
    select?: GeneralStoreItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the GeneralStoreItem
     */
    omit?: GeneralStoreItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneralStoreItemInclude<ExtArgs> | null;
    /**
     * Filter, which GeneralStoreItem to fetch.
     */
    where?: GeneralStoreItemWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of GeneralStoreItems to fetch.
     */
    orderBy?:
      | GeneralStoreItemOrderByWithRelationInput
      | GeneralStoreItemOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for GeneralStoreItems.
     */
    cursor?: GeneralStoreItemWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` GeneralStoreItems from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` GeneralStoreItems.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of GeneralStoreItems.
     */
    distinct?:
      | GeneralStoreItemScalarFieldEnum
      | GeneralStoreItemScalarFieldEnum[];
  };

  /**
   * GeneralStoreItem findMany
   */
  export type GeneralStoreItemFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the GeneralStoreItem
     */
    select?: GeneralStoreItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the GeneralStoreItem
     */
    omit?: GeneralStoreItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneralStoreItemInclude<ExtArgs> | null;
    /**
     * Filter, which GeneralStoreItems to fetch.
     */
    where?: GeneralStoreItemWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of GeneralStoreItems to fetch.
     */
    orderBy?:
      | GeneralStoreItemOrderByWithRelationInput
      | GeneralStoreItemOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing GeneralStoreItems.
     */
    cursor?: GeneralStoreItemWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` GeneralStoreItems from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` GeneralStoreItems.
     */
    skip?: number;
    distinct?:
      | GeneralStoreItemScalarFieldEnum
      | GeneralStoreItemScalarFieldEnum[];
  };

  /**
   * GeneralStoreItem create
   */
  export type GeneralStoreItemCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the GeneralStoreItem
     */
    select?: GeneralStoreItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the GeneralStoreItem
     */
    omit?: GeneralStoreItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneralStoreItemInclude<ExtArgs> | null;
    /**
     * The data needed to create a GeneralStoreItem.
     */
    data: XOR<
      GeneralStoreItemCreateInput,
      GeneralStoreItemUncheckedCreateInput
    >;
  };

  /**
   * GeneralStoreItem createMany
   */
  export type GeneralStoreItemCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many GeneralStoreItems.
     */
    data: GeneralStoreItemCreateManyInput | GeneralStoreItemCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * GeneralStoreItem createManyAndReturn
   */
  export type GeneralStoreItemCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the GeneralStoreItem
     */
    select?: GeneralStoreItemSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the GeneralStoreItem
     */
    omit?: GeneralStoreItemOmit<ExtArgs> | null;
    /**
     * The data used to create many GeneralStoreItems.
     */
    data: GeneralStoreItemCreateManyInput | GeneralStoreItemCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneralStoreItemIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * GeneralStoreItem update
   */
  export type GeneralStoreItemUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the GeneralStoreItem
     */
    select?: GeneralStoreItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the GeneralStoreItem
     */
    omit?: GeneralStoreItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneralStoreItemInclude<ExtArgs> | null;
    /**
     * The data needed to update a GeneralStoreItem.
     */
    data: XOR<
      GeneralStoreItemUpdateInput,
      GeneralStoreItemUncheckedUpdateInput
    >;
    /**
     * Choose, which GeneralStoreItem to update.
     */
    where: GeneralStoreItemWhereUniqueInput;
  };

  /**
   * GeneralStoreItem updateMany
   */
  export type GeneralStoreItemUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update GeneralStoreItems.
     */
    data: XOR<
      GeneralStoreItemUpdateManyMutationInput,
      GeneralStoreItemUncheckedUpdateManyInput
    >;
    /**
     * Filter which GeneralStoreItems to update
     */
    where?: GeneralStoreItemWhereInput;
    /**
     * Limit how many GeneralStoreItems to update.
     */
    limit?: number;
  };

  /**
   * GeneralStoreItem updateManyAndReturn
   */
  export type GeneralStoreItemUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the GeneralStoreItem
     */
    select?: GeneralStoreItemSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the GeneralStoreItem
     */
    omit?: GeneralStoreItemOmit<ExtArgs> | null;
    /**
     * The data used to update GeneralStoreItems.
     */
    data: XOR<
      GeneralStoreItemUpdateManyMutationInput,
      GeneralStoreItemUncheckedUpdateManyInput
    >;
    /**
     * Filter which GeneralStoreItems to update
     */
    where?: GeneralStoreItemWhereInput;
    /**
     * Limit how many GeneralStoreItems to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneralStoreItemIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * GeneralStoreItem upsert
   */
  export type GeneralStoreItemUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the GeneralStoreItem
     */
    select?: GeneralStoreItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the GeneralStoreItem
     */
    omit?: GeneralStoreItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneralStoreItemInclude<ExtArgs> | null;
    /**
     * The filter to search for the GeneralStoreItem to update in case it exists.
     */
    where: GeneralStoreItemWhereUniqueInput;
    /**
     * In case the GeneralStoreItem found by the `where` argument doesn't exist, create a new GeneralStoreItem with this data.
     */
    create: XOR<
      GeneralStoreItemCreateInput,
      GeneralStoreItemUncheckedCreateInput
    >;
    /**
     * In case the GeneralStoreItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<
      GeneralStoreItemUpdateInput,
      GeneralStoreItemUncheckedUpdateInput
    >;
  };

  /**
   * GeneralStoreItem delete
   */
  export type GeneralStoreItemDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the GeneralStoreItem
     */
    select?: GeneralStoreItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the GeneralStoreItem
     */
    omit?: GeneralStoreItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneralStoreItemInclude<ExtArgs> | null;
    /**
     * Filter which GeneralStoreItem to delete.
     */
    where: GeneralStoreItemWhereUniqueInput;
  };

  /**
   * GeneralStoreItem deleteMany
   */
  export type GeneralStoreItemDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which GeneralStoreItems to delete
     */
    where?: GeneralStoreItemWhereInput;
    /**
     * Limit how many GeneralStoreItems to delete.
     */
    limit?: number;
  };

  /**
   * GeneralStoreItem.individualGeneralStoreItems
   */
  export type GeneralStoreItem$individualGeneralStoreItemsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IndividualGeneralStoreItem
     */
    select?: IndividualGeneralStoreItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the IndividualGeneralStoreItem
     */
    omit?: IndividualGeneralStoreItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndividualGeneralStoreItemInclude<ExtArgs> | null;
    where?: IndividualGeneralStoreItemWhereInput;
    orderBy?:
      | IndividualGeneralStoreItemOrderByWithRelationInput
      | IndividualGeneralStoreItemOrderByWithRelationInput[];
    cursor?: IndividualGeneralStoreItemWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?:
      | IndividualGeneralStoreItemScalarFieldEnum
      | IndividualGeneralStoreItemScalarFieldEnum[];
  };

  /**
   * GeneralStoreItem without action
   */
  export type GeneralStoreItemDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the GeneralStoreItem
     */
    select?: GeneralStoreItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the GeneralStoreItem
     */
    omit?: GeneralStoreItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneralStoreItemInclude<ExtArgs> | null;
  };

  /**
   * Model IndividualGeneralStoreItem
   */

  export type AggregateIndividualGeneralStoreItem = {
    _count: IndividualGeneralStoreItemCountAggregateOutputType | null;
    _min: IndividualGeneralStoreItemMinAggregateOutputType | null;
    _max: IndividualGeneralStoreItemMaxAggregateOutputType | null;
  };

  export type IndividualGeneralStoreItemMinAggregateOutputType = {
    id: string | null;
    generalStoreItemId: string | null;
    uniqueIdentifier: string | null;
    status: $Enums.AssetStatus | null;
    condition: $Enums.AssetCondition | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type IndividualGeneralStoreItemMaxAggregateOutputType = {
    id: string | null;
    generalStoreItemId: string | null;
    uniqueIdentifier: string | null;
    status: $Enums.AssetStatus | null;
    condition: $Enums.AssetCondition | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type IndividualGeneralStoreItemCountAggregateOutputType = {
    id: number;
    generalStoreItemId: number;
    uniqueIdentifier: number;
    status: number;
    condition: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type IndividualGeneralStoreItemMinAggregateInputType = {
    id?: true;
    generalStoreItemId?: true;
    uniqueIdentifier?: true;
    status?: true;
    condition?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type IndividualGeneralStoreItemMaxAggregateInputType = {
    id?: true;
    generalStoreItemId?: true;
    uniqueIdentifier?: true;
    status?: true;
    condition?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type IndividualGeneralStoreItemCountAggregateInputType = {
    id?: true;
    generalStoreItemId?: true;
    uniqueIdentifier?: true;
    status?: true;
    condition?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type IndividualGeneralStoreItemAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which IndividualGeneralStoreItem to aggregate.
     */
    where?: IndividualGeneralStoreItemWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of IndividualGeneralStoreItems to fetch.
     */
    orderBy?:
      | IndividualGeneralStoreItemOrderByWithRelationInput
      | IndividualGeneralStoreItemOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: IndividualGeneralStoreItemWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` IndividualGeneralStoreItems from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` IndividualGeneralStoreItems.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned IndividualGeneralStoreItems
     **/
    _count?: true | IndividualGeneralStoreItemCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: IndividualGeneralStoreItemMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: IndividualGeneralStoreItemMaxAggregateInputType;
  };

  export type GetIndividualGeneralStoreItemAggregateType<
    T extends IndividualGeneralStoreItemAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateIndividualGeneralStoreItem]: P extends
      | "_count"
      | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIndividualGeneralStoreItem[P]>
      : GetScalarType<T[P], AggregateIndividualGeneralStoreItem[P]>;
  };

  export type IndividualGeneralStoreItemGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: IndividualGeneralStoreItemWhereInput;
    orderBy?:
      | IndividualGeneralStoreItemOrderByWithAggregationInput
      | IndividualGeneralStoreItemOrderByWithAggregationInput[];
    by:
      | IndividualGeneralStoreItemScalarFieldEnum[]
      | IndividualGeneralStoreItemScalarFieldEnum;
    having?: IndividualGeneralStoreItemScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: IndividualGeneralStoreItemCountAggregateInputType | true;
    _min?: IndividualGeneralStoreItemMinAggregateInputType;
    _max?: IndividualGeneralStoreItemMaxAggregateInputType;
  };

  export type IndividualGeneralStoreItemGroupByOutputType = {
    id: string;
    generalStoreItemId: string;
    uniqueIdentifier: string | null;
    status: $Enums.AssetStatus;
    condition: $Enums.AssetCondition;
    createdAt: Date;
    updatedAt: Date;
    _count: IndividualGeneralStoreItemCountAggregateOutputType | null;
    _min: IndividualGeneralStoreItemMinAggregateOutputType | null;
    _max: IndividualGeneralStoreItemMaxAggregateOutputType | null;
  };

  type GetIndividualGeneralStoreItemGroupByPayload<
    T extends IndividualGeneralStoreItemGroupByArgs,
  > = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IndividualGeneralStoreItemGroupByOutputType, T["by"]> & {
        [P in keyof T &
          keyof IndividualGeneralStoreItemGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : GetScalarType<
                T[P],
                IndividualGeneralStoreItemGroupByOutputType[P]
              >
          : GetScalarType<T[P], IndividualGeneralStoreItemGroupByOutputType[P]>;
      }
    >
  >;

  export type IndividualGeneralStoreItemSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      generalStoreItemId?: boolean;
      uniqueIdentifier?: boolean;
      status?: boolean;
      condition?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      assetDamages?:
        | boolean
        | IndividualGeneralStoreItem$assetDamagesArgs<ExtArgs>;
      generalStoreItem?: boolean | GeneralStoreItemDefaultArgs<ExtArgs>;
      _count?:
        | boolean
        | IndividualGeneralStoreItemCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["individualGeneralStoreItem"]
  >;

  export type IndividualGeneralStoreItemSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      generalStoreItemId?: boolean;
      uniqueIdentifier?: boolean;
      status?: boolean;
      condition?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      generalStoreItem?: boolean | GeneralStoreItemDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["individualGeneralStoreItem"]
  >;

  export type IndividualGeneralStoreItemSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      generalStoreItemId?: boolean;
      uniqueIdentifier?: boolean;
      status?: boolean;
      condition?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      generalStoreItem?: boolean | GeneralStoreItemDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["individualGeneralStoreItem"]
  >;

  export type IndividualGeneralStoreItemSelectScalar = {
    id?: boolean;
    generalStoreItemId?: boolean;
    uniqueIdentifier?: boolean;
    status?: boolean;
    condition?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type IndividualGeneralStoreItemOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | "id"
    | "generalStoreItemId"
    | "uniqueIdentifier"
    | "status"
    | "condition"
    | "createdAt"
    | "updatedAt",
    ExtArgs["result"]["individualGeneralStoreItem"]
  >;
  export type IndividualGeneralStoreItemInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    assetDamages?:
      | boolean
      | IndividualGeneralStoreItem$assetDamagesArgs<ExtArgs>;
    generalStoreItem?: boolean | GeneralStoreItemDefaultArgs<ExtArgs>;
    _count?:
      | boolean
      | IndividualGeneralStoreItemCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type IndividualGeneralStoreItemIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    generalStoreItem?: boolean | GeneralStoreItemDefaultArgs<ExtArgs>;
  };
  export type IndividualGeneralStoreItemIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    generalStoreItem?: boolean | GeneralStoreItemDefaultArgs<ExtArgs>;
  };

  export type $IndividualGeneralStoreItemPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "IndividualGeneralStoreItem";
    objects: {
      assetDamages: Prisma.$AssetDamagePayload<ExtArgs>[];
      generalStoreItem: Prisma.$GeneralStoreItemPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        generalStoreItemId: string;
        uniqueIdentifier: string | null;
        status: $Enums.AssetStatus;
        condition: $Enums.AssetCondition;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs["result"]["individualGeneralStoreItem"]
    >;
    composites: {};
  };

  type IndividualGeneralStoreItemGetPayload<
    S extends
      | boolean
      | null
      | undefined
      | IndividualGeneralStoreItemDefaultArgs,
  > = $Result.GetResult<Prisma.$IndividualGeneralStoreItemPayload, S>;

  type IndividualGeneralStoreItemCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    IndividualGeneralStoreItemFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: IndividualGeneralStoreItemCountAggregateInputType | true;
  };

  export interface IndividualGeneralStoreItemDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["IndividualGeneralStoreItem"];
      meta: { name: "IndividualGeneralStoreItem" };
    };
    /**
     * Find zero or one IndividualGeneralStoreItem that matches the filter.
     * @param {IndividualGeneralStoreItemFindUniqueArgs} args - Arguments to find a IndividualGeneralStoreItem
     * @example
     * // Get one IndividualGeneralStoreItem
     * const individualGeneralStoreItem = await prisma.individualGeneralStoreItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IndividualGeneralStoreItemFindUniqueArgs>(
      args: SelectSubset<T, IndividualGeneralStoreItemFindUniqueArgs<ExtArgs>>,
    ): Prisma__IndividualGeneralStoreItemClient<
      $Result.GetResult<
        Prisma.$IndividualGeneralStoreItemPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one IndividualGeneralStoreItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {IndividualGeneralStoreItemFindUniqueOrThrowArgs} args - Arguments to find a IndividualGeneralStoreItem
     * @example
     * // Get one IndividualGeneralStoreItem
     * const individualGeneralStoreItem = await prisma.individualGeneralStoreItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<
      T extends IndividualGeneralStoreItemFindUniqueOrThrowArgs,
    >(
      args: SelectSubset<
        T,
        IndividualGeneralStoreItemFindUniqueOrThrowArgs<ExtArgs>
      >,
    ): Prisma__IndividualGeneralStoreItemClient<
      $Result.GetResult<
        Prisma.$IndividualGeneralStoreItemPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first IndividualGeneralStoreItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndividualGeneralStoreItemFindFirstArgs} args - Arguments to find a IndividualGeneralStoreItem
     * @example
     * // Get one IndividualGeneralStoreItem
     * const individualGeneralStoreItem = await prisma.individualGeneralStoreItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IndividualGeneralStoreItemFindFirstArgs>(
      args?: SelectSubset<T, IndividualGeneralStoreItemFindFirstArgs<ExtArgs>>,
    ): Prisma__IndividualGeneralStoreItemClient<
      $Result.GetResult<
        Prisma.$IndividualGeneralStoreItemPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first IndividualGeneralStoreItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndividualGeneralStoreItemFindFirstOrThrowArgs} args - Arguments to find a IndividualGeneralStoreItem
     * @example
     * // Get one IndividualGeneralStoreItem
     * const individualGeneralStoreItem = await prisma.individualGeneralStoreItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IndividualGeneralStoreItemFindFirstOrThrowArgs>(
      args?: SelectSubset<
        T,
        IndividualGeneralStoreItemFindFirstOrThrowArgs<ExtArgs>
      >,
    ): Prisma__IndividualGeneralStoreItemClient<
      $Result.GetResult<
        Prisma.$IndividualGeneralStoreItemPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more IndividualGeneralStoreItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndividualGeneralStoreItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IndividualGeneralStoreItems
     * const individualGeneralStoreItems = await prisma.individualGeneralStoreItem.findMany()
     *
     * // Get first 10 IndividualGeneralStoreItems
     * const individualGeneralStoreItems = await prisma.individualGeneralStoreItem.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const individualGeneralStoreItemWithIdOnly = await prisma.individualGeneralStoreItem.findMany({ select: { id: true } })
     *
     */
    findMany<T extends IndividualGeneralStoreItemFindManyArgs>(
      args?: SelectSubset<T, IndividualGeneralStoreItemFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$IndividualGeneralStoreItemPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a IndividualGeneralStoreItem.
     * @param {IndividualGeneralStoreItemCreateArgs} args - Arguments to create a IndividualGeneralStoreItem.
     * @example
     * // Create one IndividualGeneralStoreItem
     * const IndividualGeneralStoreItem = await prisma.individualGeneralStoreItem.create({
     *   data: {
     *     // ... data to create a IndividualGeneralStoreItem
     *   }
     * })
     *
     */
    create<T extends IndividualGeneralStoreItemCreateArgs>(
      args: SelectSubset<T, IndividualGeneralStoreItemCreateArgs<ExtArgs>>,
    ): Prisma__IndividualGeneralStoreItemClient<
      $Result.GetResult<
        Prisma.$IndividualGeneralStoreItemPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many IndividualGeneralStoreItems.
     * @param {IndividualGeneralStoreItemCreateManyArgs} args - Arguments to create many IndividualGeneralStoreItems.
     * @example
     * // Create many IndividualGeneralStoreItems
     * const individualGeneralStoreItem = await prisma.individualGeneralStoreItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends IndividualGeneralStoreItemCreateManyArgs>(
      args?: SelectSubset<T, IndividualGeneralStoreItemCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many IndividualGeneralStoreItems and returns the data saved in the database.
     * @param {IndividualGeneralStoreItemCreateManyAndReturnArgs} args - Arguments to create many IndividualGeneralStoreItems.
     * @example
     * // Create many IndividualGeneralStoreItems
     * const individualGeneralStoreItem = await prisma.individualGeneralStoreItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many IndividualGeneralStoreItems and only return the `id`
     * const individualGeneralStoreItemWithIdOnly = await prisma.individualGeneralStoreItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<
      T extends IndividualGeneralStoreItemCreateManyAndReturnArgs,
    >(
      args?: SelectSubset<
        T,
        IndividualGeneralStoreItemCreateManyAndReturnArgs<ExtArgs>
      >,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$IndividualGeneralStoreItemPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a IndividualGeneralStoreItem.
     * @param {IndividualGeneralStoreItemDeleteArgs} args - Arguments to delete one IndividualGeneralStoreItem.
     * @example
     * // Delete one IndividualGeneralStoreItem
     * const IndividualGeneralStoreItem = await prisma.individualGeneralStoreItem.delete({
     *   where: {
     *     // ... filter to delete one IndividualGeneralStoreItem
     *   }
     * })
     *
     */
    delete<T extends IndividualGeneralStoreItemDeleteArgs>(
      args: SelectSubset<T, IndividualGeneralStoreItemDeleteArgs<ExtArgs>>,
    ): Prisma__IndividualGeneralStoreItemClient<
      $Result.GetResult<
        Prisma.$IndividualGeneralStoreItemPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one IndividualGeneralStoreItem.
     * @param {IndividualGeneralStoreItemUpdateArgs} args - Arguments to update one IndividualGeneralStoreItem.
     * @example
     * // Update one IndividualGeneralStoreItem
     * const individualGeneralStoreItem = await prisma.individualGeneralStoreItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends IndividualGeneralStoreItemUpdateArgs>(
      args: SelectSubset<T, IndividualGeneralStoreItemUpdateArgs<ExtArgs>>,
    ): Prisma__IndividualGeneralStoreItemClient<
      $Result.GetResult<
        Prisma.$IndividualGeneralStoreItemPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more IndividualGeneralStoreItems.
     * @param {IndividualGeneralStoreItemDeleteManyArgs} args - Arguments to filter IndividualGeneralStoreItems to delete.
     * @example
     * // Delete a few IndividualGeneralStoreItems
     * const { count } = await prisma.individualGeneralStoreItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends IndividualGeneralStoreItemDeleteManyArgs>(
      args?: SelectSubset<T, IndividualGeneralStoreItemDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more IndividualGeneralStoreItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndividualGeneralStoreItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IndividualGeneralStoreItems
     * const individualGeneralStoreItem = await prisma.individualGeneralStoreItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends IndividualGeneralStoreItemUpdateManyArgs>(
      args: SelectSubset<T, IndividualGeneralStoreItemUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more IndividualGeneralStoreItems and returns the data updated in the database.
     * @param {IndividualGeneralStoreItemUpdateManyAndReturnArgs} args - Arguments to update many IndividualGeneralStoreItems.
     * @example
     * // Update many IndividualGeneralStoreItems
     * const individualGeneralStoreItem = await prisma.individualGeneralStoreItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more IndividualGeneralStoreItems and only return the `id`
     * const individualGeneralStoreItemWithIdOnly = await prisma.individualGeneralStoreItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<
      T extends IndividualGeneralStoreItemUpdateManyAndReturnArgs,
    >(
      args: SelectSubset<
        T,
        IndividualGeneralStoreItemUpdateManyAndReturnArgs<ExtArgs>
      >,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$IndividualGeneralStoreItemPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one IndividualGeneralStoreItem.
     * @param {IndividualGeneralStoreItemUpsertArgs} args - Arguments to update or create a IndividualGeneralStoreItem.
     * @example
     * // Update or create a IndividualGeneralStoreItem
     * const individualGeneralStoreItem = await prisma.individualGeneralStoreItem.upsert({
     *   create: {
     *     // ... data to create a IndividualGeneralStoreItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IndividualGeneralStoreItem we want to update
     *   }
     * })
     */
    upsert<T extends IndividualGeneralStoreItemUpsertArgs>(
      args: SelectSubset<T, IndividualGeneralStoreItemUpsertArgs<ExtArgs>>,
    ): Prisma__IndividualGeneralStoreItemClient<
      $Result.GetResult<
        Prisma.$IndividualGeneralStoreItemPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of IndividualGeneralStoreItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndividualGeneralStoreItemCountArgs} args - Arguments to filter IndividualGeneralStoreItems to count.
     * @example
     * // Count the number of IndividualGeneralStoreItems
     * const count = await prisma.individualGeneralStoreItem.count({
     *   where: {
     *     // ... the filter for the IndividualGeneralStoreItems we want to count
     *   }
     * })
     **/
    count<T extends IndividualGeneralStoreItemCountArgs>(
      args?: Subset<T, IndividualGeneralStoreItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<
              T["select"],
              IndividualGeneralStoreItemCountAggregateOutputType
            >
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a IndividualGeneralStoreItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndividualGeneralStoreItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends IndividualGeneralStoreItemAggregateArgs>(
      args: Subset<T, IndividualGeneralStoreItemAggregateArgs>,
    ): Prisma.PrismaPromise<GetIndividualGeneralStoreItemAggregateType<T>>;

    /**
     * Group by IndividualGeneralStoreItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndividualGeneralStoreItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends IndividualGeneralStoreItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IndividualGeneralStoreItemGroupByArgs["orderBy"] }
        : { orderBy?: IndividualGeneralStoreItemGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<
        T,
        IndividualGeneralStoreItemGroupByArgs,
        OrderByArg
      > &
        InputErrors,
    ): {} extends InputErrors
      ? GetIndividualGeneralStoreItemGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the IndividualGeneralStoreItem model
     */
    readonly fields: IndividualGeneralStoreItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IndividualGeneralStoreItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IndividualGeneralStoreItemClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    assetDamages<
      T extends IndividualGeneralStoreItem$assetDamagesArgs<ExtArgs> = {},
    >(
      args?: Subset<T, IndividualGeneralStoreItem$assetDamagesArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$AssetDamagePayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    generalStoreItem<T extends GeneralStoreItemDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, GeneralStoreItemDefaultArgs<ExtArgs>>,
    ): Prisma__GeneralStoreItemClient<
      | $Result.GetResult<
          Prisma.$GeneralStoreItemPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the IndividualGeneralStoreItem model
   */
  interface IndividualGeneralStoreItemFieldRefs {
    readonly id: FieldRef<"IndividualGeneralStoreItem", "String">;
    readonly generalStoreItemId: FieldRef<
      "IndividualGeneralStoreItem",
      "String"
    >;
    readonly uniqueIdentifier: FieldRef<"IndividualGeneralStoreItem", "String">;
    readonly status: FieldRef<"IndividualGeneralStoreItem", "AssetStatus">;
    readonly condition: FieldRef<
      "IndividualGeneralStoreItem",
      "AssetCondition"
    >;
    readonly createdAt: FieldRef<"IndividualGeneralStoreItem", "DateTime">;
    readonly updatedAt: FieldRef<"IndividualGeneralStoreItem", "DateTime">;
  }

  // Custom InputTypes
  /**
   * IndividualGeneralStoreItem findUnique
   */
  export type IndividualGeneralStoreItemFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IndividualGeneralStoreItem
     */
    select?: IndividualGeneralStoreItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the IndividualGeneralStoreItem
     */
    omit?: IndividualGeneralStoreItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndividualGeneralStoreItemInclude<ExtArgs> | null;
    /**
     * Filter, which IndividualGeneralStoreItem to fetch.
     */
    where: IndividualGeneralStoreItemWhereUniqueInput;
  };

  /**
   * IndividualGeneralStoreItem findUniqueOrThrow
   */
  export type IndividualGeneralStoreItemFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IndividualGeneralStoreItem
     */
    select?: IndividualGeneralStoreItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the IndividualGeneralStoreItem
     */
    omit?: IndividualGeneralStoreItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndividualGeneralStoreItemInclude<ExtArgs> | null;
    /**
     * Filter, which IndividualGeneralStoreItem to fetch.
     */
    where: IndividualGeneralStoreItemWhereUniqueInput;
  };

  /**
   * IndividualGeneralStoreItem findFirst
   */
  export type IndividualGeneralStoreItemFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IndividualGeneralStoreItem
     */
    select?: IndividualGeneralStoreItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the IndividualGeneralStoreItem
     */
    omit?: IndividualGeneralStoreItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndividualGeneralStoreItemInclude<ExtArgs> | null;
    /**
     * Filter, which IndividualGeneralStoreItem to fetch.
     */
    where?: IndividualGeneralStoreItemWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of IndividualGeneralStoreItems to fetch.
     */
    orderBy?:
      | IndividualGeneralStoreItemOrderByWithRelationInput
      | IndividualGeneralStoreItemOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for IndividualGeneralStoreItems.
     */
    cursor?: IndividualGeneralStoreItemWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` IndividualGeneralStoreItems from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` IndividualGeneralStoreItems.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of IndividualGeneralStoreItems.
     */
    distinct?:
      | IndividualGeneralStoreItemScalarFieldEnum
      | IndividualGeneralStoreItemScalarFieldEnum[];
  };

  /**
   * IndividualGeneralStoreItem findFirstOrThrow
   */
  export type IndividualGeneralStoreItemFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IndividualGeneralStoreItem
     */
    select?: IndividualGeneralStoreItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the IndividualGeneralStoreItem
     */
    omit?: IndividualGeneralStoreItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndividualGeneralStoreItemInclude<ExtArgs> | null;
    /**
     * Filter, which IndividualGeneralStoreItem to fetch.
     */
    where?: IndividualGeneralStoreItemWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of IndividualGeneralStoreItems to fetch.
     */
    orderBy?:
      | IndividualGeneralStoreItemOrderByWithRelationInput
      | IndividualGeneralStoreItemOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for IndividualGeneralStoreItems.
     */
    cursor?: IndividualGeneralStoreItemWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` IndividualGeneralStoreItems from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` IndividualGeneralStoreItems.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of IndividualGeneralStoreItems.
     */
    distinct?:
      | IndividualGeneralStoreItemScalarFieldEnum
      | IndividualGeneralStoreItemScalarFieldEnum[];
  };

  /**
   * IndividualGeneralStoreItem findMany
   */
  export type IndividualGeneralStoreItemFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IndividualGeneralStoreItem
     */
    select?: IndividualGeneralStoreItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the IndividualGeneralStoreItem
     */
    omit?: IndividualGeneralStoreItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndividualGeneralStoreItemInclude<ExtArgs> | null;
    /**
     * Filter, which IndividualGeneralStoreItems to fetch.
     */
    where?: IndividualGeneralStoreItemWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of IndividualGeneralStoreItems to fetch.
     */
    orderBy?:
      | IndividualGeneralStoreItemOrderByWithRelationInput
      | IndividualGeneralStoreItemOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing IndividualGeneralStoreItems.
     */
    cursor?: IndividualGeneralStoreItemWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` IndividualGeneralStoreItems from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` IndividualGeneralStoreItems.
     */
    skip?: number;
    distinct?:
      | IndividualGeneralStoreItemScalarFieldEnum
      | IndividualGeneralStoreItemScalarFieldEnum[];
  };

  /**
   * IndividualGeneralStoreItem create
   */
  export type IndividualGeneralStoreItemCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IndividualGeneralStoreItem
     */
    select?: IndividualGeneralStoreItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the IndividualGeneralStoreItem
     */
    omit?: IndividualGeneralStoreItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndividualGeneralStoreItemInclude<ExtArgs> | null;
    /**
     * The data needed to create a IndividualGeneralStoreItem.
     */
    data: XOR<
      IndividualGeneralStoreItemCreateInput,
      IndividualGeneralStoreItemUncheckedCreateInput
    >;
  };

  /**
   * IndividualGeneralStoreItem createMany
   */
  export type IndividualGeneralStoreItemCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many IndividualGeneralStoreItems.
     */
    data:
      | IndividualGeneralStoreItemCreateManyInput
      | IndividualGeneralStoreItemCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * IndividualGeneralStoreItem createManyAndReturn
   */
  export type IndividualGeneralStoreItemCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IndividualGeneralStoreItem
     */
    select?: IndividualGeneralStoreItemSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the IndividualGeneralStoreItem
     */
    omit?: IndividualGeneralStoreItemOmit<ExtArgs> | null;
    /**
     * The data used to create many IndividualGeneralStoreItems.
     */
    data:
      | IndividualGeneralStoreItemCreateManyInput
      | IndividualGeneralStoreItemCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndividualGeneralStoreItemIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * IndividualGeneralStoreItem update
   */
  export type IndividualGeneralStoreItemUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IndividualGeneralStoreItem
     */
    select?: IndividualGeneralStoreItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the IndividualGeneralStoreItem
     */
    omit?: IndividualGeneralStoreItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndividualGeneralStoreItemInclude<ExtArgs> | null;
    /**
     * The data needed to update a IndividualGeneralStoreItem.
     */
    data: XOR<
      IndividualGeneralStoreItemUpdateInput,
      IndividualGeneralStoreItemUncheckedUpdateInput
    >;
    /**
     * Choose, which IndividualGeneralStoreItem to update.
     */
    where: IndividualGeneralStoreItemWhereUniqueInput;
  };

  /**
   * IndividualGeneralStoreItem updateMany
   */
  export type IndividualGeneralStoreItemUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update IndividualGeneralStoreItems.
     */
    data: XOR<
      IndividualGeneralStoreItemUpdateManyMutationInput,
      IndividualGeneralStoreItemUncheckedUpdateManyInput
    >;
    /**
     * Filter which IndividualGeneralStoreItems to update
     */
    where?: IndividualGeneralStoreItemWhereInput;
    /**
     * Limit how many IndividualGeneralStoreItems to update.
     */
    limit?: number;
  };

  /**
   * IndividualGeneralStoreItem updateManyAndReturn
   */
  export type IndividualGeneralStoreItemUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IndividualGeneralStoreItem
     */
    select?: IndividualGeneralStoreItemSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the IndividualGeneralStoreItem
     */
    omit?: IndividualGeneralStoreItemOmit<ExtArgs> | null;
    /**
     * The data used to update IndividualGeneralStoreItems.
     */
    data: XOR<
      IndividualGeneralStoreItemUpdateManyMutationInput,
      IndividualGeneralStoreItemUncheckedUpdateManyInput
    >;
    /**
     * Filter which IndividualGeneralStoreItems to update
     */
    where?: IndividualGeneralStoreItemWhereInput;
    /**
     * Limit how many IndividualGeneralStoreItems to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndividualGeneralStoreItemIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * IndividualGeneralStoreItem upsert
   */
  export type IndividualGeneralStoreItemUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IndividualGeneralStoreItem
     */
    select?: IndividualGeneralStoreItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the IndividualGeneralStoreItem
     */
    omit?: IndividualGeneralStoreItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndividualGeneralStoreItemInclude<ExtArgs> | null;
    /**
     * The filter to search for the IndividualGeneralStoreItem to update in case it exists.
     */
    where: IndividualGeneralStoreItemWhereUniqueInput;
    /**
     * In case the IndividualGeneralStoreItem found by the `where` argument doesn't exist, create a new IndividualGeneralStoreItem with this data.
     */
    create: XOR<
      IndividualGeneralStoreItemCreateInput,
      IndividualGeneralStoreItemUncheckedCreateInput
    >;
    /**
     * In case the IndividualGeneralStoreItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<
      IndividualGeneralStoreItemUpdateInput,
      IndividualGeneralStoreItemUncheckedUpdateInput
    >;
  };

  /**
   * IndividualGeneralStoreItem delete
   */
  export type IndividualGeneralStoreItemDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IndividualGeneralStoreItem
     */
    select?: IndividualGeneralStoreItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the IndividualGeneralStoreItem
     */
    omit?: IndividualGeneralStoreItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndividualGeneralStoreItemInclude<ExtArgs> | null;
    /**
     * Filter which IndividualGeneralStoreItem to delete.
     */
    where: IndividualGeneralStoreItemWhereUniqueInput;
  };

  /**
   * IndividualGeneralStoreItem deleteMany
   */
  export type IndividualGeneralStoreItemDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which IndividualGeneralStoreItems to delete
     */
    where?: IndividualGeneralStoreItemWhereInput;
    /**
     * Limit how many IndividualGeneralStoreItems to delete.
     */
    limit?: number;
  };

  /**
   * IndividualGeneralStoreItem.assetDamages
   */
  export type IndividualGeneralStoreItem$assetDamagesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AssetDamage
     */
    select?: AssetDamageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AssetDamage
     */
    omit?: AssetDamageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetDamageInclude<ExtArgs> | null;
    where?: AssetDamageWhereInput;
    orderBy?:
      | AssetDamageOrderByWithRelationInput
      | AssetDamageOrderByWithRelationInput[];
    cursor?: AssetDamageWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: AssetDamageScalarFieldEnum | AssetDamageScalarFieldEnum[];
  };

  /**
   * IndividualGeneralStoreItem without action
   */
  export type IndividualGeneralStoreItemDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IndividualGeneralStoreItem
     */
    select?: IndividualGeneralStoreItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the IndividualGeneralStoreItem
     */
    omit?: IndividualGeneralStoreItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndividualGeneralStoreItemInclude<ExtArgs> | null;
  };

  /**
   * Model AssetDamage
   */

  export type AggregateAssetDamage = {
    _count: AssetDamageCountAggregateOutputType | null;
    _avg: AssetDamageAvgAggregateOutputType | null;
    _sum: AssetDamageSumAggregateOutputType | null;
    _min: AssetDamageMinAggregateOutputType | null;
    _max: AssetDamageMaxAggregateOutputType | null;
  };

  export type AssetDamageAvgAggregateOutputType = {
    quantity: number | null;
    repairBalance: number | null;
    repairPrice: number | null;
  };

  export type AssetDamageSumAggregateOutputType = {
    quantity: number | null;
    repairBalance: number | null;
    repairPrice: number | null;
  };

  export type AssetDamageMinAggregateOutputType = {
    id: string | null;
    damageDetails: string | null;
    condition: $Enums.AssetCondition | null;
    quantity: number | null;
    userId: string | null;
    individualComputerLabItemId: string | null;
    isRepaired: boolean | null;
    repairedAt: Date | null;
    createdAt: Date | null;
    individualBookId: string | null;
    individualLabItemId: string | null;
    individualFoodStoreItemId: string | null;
    individualGeneralStoreItemId: string | null;
    isSchoolCost: boolean | null;
    repairBalance: number | null;
    repairPrice: number | null;
  };

  export type AssetDamageMaxAggregateOutputType = {
    id: string | null;
    damageDetails: string | null;
    condition: $Enums.AssetCondition | null;
    quantity: number | null;
    userId: string | null;
    individualComputerLabItemId: string | null;
    isRepaired: boolean | null;
    repairedAt: Date | null;
    createdAt: Date | null;
    individualBookId: string | null;
    individualLabItemId: string | null;
    individualFoodStoreItemId: string | null;
    individualGeneralStoreItemId: string | null;
    isSchoolCost: boolean | null;
    repairBalance: number | null;
    repairPrice: number | null;
  };

  export type AssetDamageCountAggregateOutputType = {
    id: number;
    damageDetails: number;
    condition: number;
    quantity: number;
    userId: number;
    individualComputerLabItemId: number;
    isRepaired: number;
    repairedAt: number;
    createdAt: number;
    individualBookId: number;
    individualLabItemId: number;
    individualFoodStoreItemId: number;
    individualGeneralStoreItemId: number;
    isSchoolCost: number;
    repairBalance: number;
    repairPrice: number;
    _all: number;
  };

  export type AssetDamageAvgAggregateInputType = {
    quantity?: true;
    repairBalance?: true;
    repairPrice?: true;
  };

  export type AssetDamageSumAggregateInputType = {
    quantity?: true;
    repairBalance?: true;
    repairPrice?: true;
  };

  export type AssetDamageMinAggregateInputType = {
    id?: true;
    damageDetails?: true;
    condition?: true;
    quantity?: true;
    userId?: true;
    individualComputerLabItemId?: true;
    isRepaired?: true;
    repairedAt?: true;
    createdAt?: true;
    individualBookId?: true;
    individualLabItemId?: true;
    individualFoodStoreItemId?: true;
    individualGeneralStoreItemId?: true;
    isSchoolCost?: true;
    repairBalance?: true;
    repairPrice?: true;
  };

  export type AssetDamageMaxAggregateInputType = {
    id?: true;
    damageDetails?: true;
    condition?: true;
    quantity?: true;
    userId?: true;
    individualComputerLabItemId?: true;
    isRepaired?: true;
    repairedAt?: true;
    createdAt?: true;
    individualBookId?: true;
    individualLabItemId?: true;
    individualFoodStoreItemId?: true;
    individualGeneralStoreItemId?: true;
    isSchoolCost?: true;
    repairBalance?: true;
    repairPrice?: true;
  };

  export type AssetDamageCountAggregateInputType = {
    id?: true;
    damageDetails?: true;
    condition?: true;
    quantity?: true;
    userId?: true;
    individualComputerLabItemId?: true;
    isRepaired?: true;
    repairedAt?: true;
    createdAt?: true;
    individualBookId?: true;
    individualLabItemId?: true;
    individualFoodStoreItemId?: true;
    individualGeneralStoreItemId?: true;
    isSchoolCost?: true;
    repairBalance?: true;
    repairPrice?: true;
    _all?: true;
  };

  export type AssetDamageAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which AssetDamage to aggregate.
     */
    where?: AssetDamageWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AssetDamages to fetch.
     */
    orderBy?:
      | AssetDamageOrderByWithRelationInput
      | AssetDamageOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: AssetDamageWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AssetDamages from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AssetDamages.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned AssetDamages
     **/
    _count?: true | AssetDamageCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: AssetDamageAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: AssetDamageSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: AssetDamageMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: AssetDamageMaxAggregateInputType;
  };

  export type GetAssetDamageAggregateType<T extends AssetDamageAggregateArgs> =
    {
      [P in keyof T & keyof AggregateAssetDamage]: P extends "_count" | "count"
        ? T[P] extends true
          ? number
          : GetScalarType<T[P], AggregateAssetDamage[P]>
        : GetScalarType<T[P], AggregateAssetDamage[P]>;
    };

  export type AssetDamageGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AssetDamageWhereInput;
    orderBy?:
      | AssetDamageOrderByWithAggregationInput
      | AssetDamageOrderByWithAggregationInput[];
    by: AssetDamageScalarFieldEnum[] | AssetDamageScalarFieldEnum;
    having?: AssetDamageScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: AssetDamageCountAggregateInputType | true;
    _avg?: AssetDamageAvgAggregateInputType;
    _sum?: AssetDamageSumAggregateInputType;
    _min?: AssetDamageMinAggregateInputType;
    _max?: AssetDamageMaxAggregateInputType;
  };

  export type AssetDamageGroupByOutputType = {
    id: string;
    damageDetails: string;
    condition: $Enums.AssetCondition;
    quantity: number;
    userId: string | null;
    individualComputerLabItemId: string | null;
    isRepaired: boolean;
    repairedAt: Date | null;
    createdAt: Date;
    individualBookId: string | null;
    individualLabItemId: string | null;
    individualFoodStoreItemId: string | null;
    individualGeneralStoreItemId: string | null;
    isSchoolCost: boolean;
    repairBalance: number;
    repairPrice: number | null;
    _count: AssetDamageCountAggregateOutputType | null;
    _avg: AssetDamageAvgAggregateOutputType | null;
    _sum: AssetDamageSumAggregateOutputType | null;
    _min: AssetDamageMinAggregateOutputType | null;
    _max: AssetDamageMaxAggregateOutputType | null;
  };

  type GetAssetDamageGroupByPayload<T extends AssetDamageGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<AssetDamageGroupByOutputType, T["by"]> & {
          [P in keyof T &
            keyof AssetDamageGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AssetDamageGroupByOutputType[P]>
            : GetScalarType<T[P], AssetDamageGroupByOutputType[P]>;
        }
      >
    >;

  export type AssetDamageSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      damageDetails?: boolean;
      condition?: boolean;
      quantity?: boolean;
      userId?: boolean;
      individualComputerLabItemId?: boolean;
      isRepaired?: boolean;
      repairedAt?: boolean;
      createdAt?: boolean;
      individualBookId?: boolean;
      individualLabItemId?: boolean;
      individualFoodStoreItemId?: boolean;
      individualGeneralStoreItemId?: boolean;
      isSchoolCost?: boolean;
      repairBalance?: boolean;
      repairPrice?: boolean;
      individualBook?: boolean | AssetDamage$individualBookArgs<ExtArgs>;
      individualComputerLabItem?:
        | boolean
        | AssetDamage$individualComputerLabItemArgs<ExtArgs>;
      individualFoodStoreItem?:
        | boolean
        | AssetDamage$individualFoodStoreItemArgs<ExtArgs>;
      individualGeneralStoreItem?:
        | boolean
        | AssetDamage$individualGeneralStoreItemArgs<ExtArgs>;
      individualLabItem?: boolean | AssetDamage$individualLabItemArgs<ExtArgs>;
      damagedBy?: boolean | AssetDamage$damagedByArgs<ExtArgs>;
      assetRepairPayments?:
        | boolean
        | AssetDamage$assetRepairPaymentsArgs<ExtArgs>;
      _count?: boolean | AssetDamageCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["assetDamage"]
  >;

  export type AssetDamageSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      damageDetails?: boolean;
      condition?: boolean;
      quantity?: boolean;
      userId?: boolean;
      individualComputerLabItemId?: boolean;
      isRepaired?: boolean;
      repairedAt?: boolean;
      createdAt?: boolean;
      individualBookId?: boolean;
      individualLabItemId?: boolean;
      individualFoodStoreItemId?: boolean;
      individualGeneralStoreItemId?: boolean;
      isSchoolCost?: boolean;
      repairBalance?: boolean;
      repairPrice?: boolean;
      individualBook?: boolean | AssetDamage$individualBookArgs<ExtArgs>;
      individualComputerLabItem?:
        | boolean
        | AssetDamage$individualComputerLabItemArgs<ExtArgs>;
      individualFoodStoreItem?:
        | boolean
        | AssetDamage$individualFoodStoreItemArgs<ExtArgs>;
      individualGeneralStoreItem?:
        | boolean
        | AssetDamage$individualGeneralStoreItemArgs<ExtArgs>;
      individualLabItem?: boolean | AssetDamage$individualLabItemArgs<ExtArgs>;
      damagedBy?: boolean | AssetDamage$damagedByArgs<ExtArgs>;
    },
    ExtArgs["result"]["assetDamage"]
  >;

  export type AssetDamageSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      damageDetails?: boolean;
      condition?: boolean;
      quantity?: boolean;
      userId?: boolean;
      individualComputerLabItemId?: boolean;
      isRepaired?: boolean;
      repairedAt?: boolean;
      createdAt?: boolean;
      individualBookId?: boolean;
      individualLabItemId?: boolean;
      individualFoodStoreItemId?: boolean;
      individualGeneralStoreItemId?: boolean;
      isSchoolCost?: boolean;
      repairBalance?: boolean;
      repairPrice?: boolean;
      individualBook?: boolean | AssetDamage$individualBookArgs<ExtArgs>;
      individualComputerLabItem?:
        | boolean
        | AssetDamage$individualComputerLabItemArgs<ExtArgs>;
      individualFoodStoreItem?:
        | boolean
        | AssetDamage$individualFoodStoreItemArgs<ExtArgs>;
      individualGeneralStoreItem?:
        | boolean
        | AssetDamage$individualGeneralStoreItemArgs<ExtArgs>;
      individualLabItem?: boolean | AssetDamage$individualLabItemArgs<ExtArgs>;
      damagedBy?: boolean | AssetDamage$damagedByArgs<ExtArgs>;
    },
    ExtArgs["result"]["assetDamage"]
  >;

  export type AssetDamageSelectScalar = {
    id?: boolean;
    damageDetails?: boolean;
    condition?: boolean;
    quantity?: boolean;
    userId?: boolean;
    individualComputerLabItemId?: boolean;
    isRepaired?: boolean;
    repairedAt?: boolean;
    createdAt?: boolean;
    individualBookId?: boolean;
    individualLabItemId?: boolean;
    individualFoodStoreItemId?: boolean;
    individualGeneralStoreItemId?: boolean;
    isSchoolCost?: boolean;
    repairBalance?: boolean;
    repairPrice?: boolean;
  };

  export type AssetDamageOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | "id"
    | "damageDetails"
    | "condition"
    | "quantity"
    | "userId"
    | "individualComputerLabItemId"
    | "isRepaired"
    | "repairedAt"
    | "createdAt"
    | "individualBookId"
    | "individualLabItemId"
    | "individualFoodStoreItemId"
    | "individualGeneralStoreItemId"
    | "isSchoolCost"
    | "repairBalance"
    | "repairPrice",
    ExtArgs["result"]["assetDamage"]
  >;
  export type AssetDamageInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    individualBook?: boolean | AssetDamage$individualBookArgs<ExtArgs>;
    individualComputerLabItem?:
      | boolean
      | AssetDamage$individualComputerLabItemArgs<ExtArgs>;
    individualFoodStoreItem?:
      | boolean
      | AssetDamage$individualFoodStoreItemArgs<ExtArgs>;
    individualGeneralStoreItem?:
      | boolean
      | AssetDamage$individualGeneralStoreItemArgs<ExtArgs>;
    individualLabItem?: boolean | AssetDamage$individualLabItemArgs<ExtArgs>;
    damagedBy?: boolean | AssetDamage$damagedByArgs<ExtArgs>;
    assetRepairPayments?:
      | boolean
      | AssetDamage$assetRepairPaymentsArgs<ExtArgs>;
    _count?: boolean | AssetDamageCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type AssetDamageIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    individualBook?: boolean | AssetDamage$individualBookArgs<ExtArgs>;
    individualComputerLabItem?:
      | boolean
      | AssetDamage$individualComputerLabItemArgs<ExtArgs>;
    individualFoodStoreItem?:
      | boolean
      | AssetDamage$individualFoodStoreItemArgs<ExtArgs>;
    individualGeneralStoreItem?:
      | boolean
      | AssetDamage$individualGeneralStoreItemArgs<ExtArgs>;
    individualLabItem?: boolean | AssetDamage$individualLabItemArgs<ExtArgs>;
    damagedBy?: boolean | AssetDamage$damagedByArgs<ExtArgs>;
  };
  export type AssetDamageIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    individualBook?: boolean | AssetDamage$individualBookArgs<ExtArgs>;
    individualComputerLabItem?:
      | boolean
      | AssetDamage$individualComputerLabItemArgs<ExtArgs>;
    individualFoodStoreItem?:
      | boolean
      | AssetDamage$individualFoodStoreItemArgs<ExtArgs>;
    individualGeneralStoreItem?:
      | boolean
      | AssetDamage$individualGeneralStoreItemArgs<ExtArgs>;
    individualLabItem?: boolean | AssetDamage$individualLabItemArgs<ExtArgs>;
    damagedBy?: boolean | AssetDamage$damagedByArgs<ExtArgs>;
  };

  export type $AssetDamagePayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "AssetDamage";
    objects: {
      individualBook: Prisma.$IndividualBookPayload<ExtArgs> | null;
      individualComputerLabItem: Prisma.$IndividualComputerLabItemPayload<ExtArgs> | null;
      individualFoodStoreItem: Prisma.$IndividualFoodStoreItemPayload<ExtArgs> | null;
      individualGeneralStoreItem: Prisma.$IndividualGeneralStoreItemPayload<ExtArgs> | null;
      individualLabItem: Prisma.$IndividualLabItemPayload<ExtArgs> | null;
      damagedBy: Prisma.$UserPayload<ExtArgs> | null;
      assetRepairPayments: Prisma.$AssetRepairPaymentPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        damageDetails: string;
        condition: $Enums.AssetCondition;
        quantity: number;
        userId: string | null;
        individualComputerLabItemId: string | null;
        isRepaired: boolean;
        repairedAt: Date | null;
        createdAt: Date;
        individualBookId: string | null;
        individualLabItemId: string | null;
        individualFoodStoreItemId: string | null;
        individualGeneralStoreItemId: string | null;
        isSchoolCost: boolean;
        repairBalance: number;
        repairPrice: number | null;
      },
      ExtArgs["result"]["assetDamage"]
    >;
    composites: {};
  };

  type AssetDamageGetPayload<
    S extends boolean | null | undefined | AssetDamageDefaultArgs,
  > = $Result.GetResult<Prisma.$AssetDamagePayload, S>;

  type AssetDamageCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    AssetDamageFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: AssetDamageCountAggregateInputType | true;
  };

  export interface AssetDamageDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["AssetDamage"];
      meta: { name: "AssetDamage" };
    };
    /**
     * Find zero or one AssetDamage that matches the filter.
     * @param {AssetDamageFindUniqueArgs} args - Arguments to find a AssetDamage
     * @example
     * // Get one AssetDamage
     * const assetDamage = await prisma.assetDamage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AssetDamageFindUniqueArgs>(
      args: SelectSubset<T, AssetDamageFindUniqueArgs<ExtArgs>>,
    ): Prisma__AssetDamageClient<
      $Result.GetResult<
        Prisma.$AssetDamagePayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one AssetDamage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AssetDamageFindUniqueOrThrowArgs} args - Arguments to find a AssetDamage
     * @example
     * // Get one AssetDamage
     * const assetDamage = await prisma.assetDamage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AssetDamageFindUniqueOrThrowArgs>(
      args: SelectSubset<T, AssetDamageFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__AssetDamageClient<
      $Result.GetResult<
        Prisma.$AssetDamagePayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first AssetDamage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetDamageFindFirstArgs} args - Arguments to find a AssetDamage
     * @example
     * // Get one AssetDamage
     * const assetDamage = await prisma.assetDamage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AssetDamageFindFirstArgs>(
      args?: SelectSubset<T, AssetDamageFindFirstArgs<ExtArgs>>,
    ): Prisma__AssetDamageClient<
      $Result.GetResult<
        Prisma.$AssetDamagePayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first AssetDamage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetDamageFindFirstOrThrowArgs} args - Arguments to find a AssetDamage
     * @example
     * // Get one AssetDamage
     * const assetDamage = await prisma.assetDamage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AssetDamageFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AssetDamageFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__AssetDamageClient<
      $Result.GetResult<
        Prisma.$AssetDamagePayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more AssetDamages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetDamageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AssetDamages
     * const assetDamages = await prisma.assetDamage.findMany()
     *
     * // Get first 10 AssetDamages
     * const assetDamages = await prisma.assetDamage.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const assetDamageWithIdOnly = await prisma.assetDamage.findMany({ select: { id: true } })
     *
     */
    findMany<T extends AssetDamageFindManyArgs>(
      args?: SelectSubset<T, AssetDamageFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$AssetDamagePayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a AssetDamage.
     * @param {AssetDamageCreateArgs} args - Arguments to create a AssetDamage.
     * @example
     * // Create one AssetDamage
     * const AssetDamage = await prisma.assetDamage.create({
     *   data: {
     *     // ... data to create a AssetDamage
     *   }
     * })
     *
     */
    create<T extends AssetDamageCreateArgs>(
      args: SelectSubset<T, AssetDamageCreateArgs<ExtArgs>>,
    ): Prisma__AssetDamageClient<
      $Result.GetResult<
        Prisma.$AssetDamagePayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many AssetDamages.
     * @param {AssetDamageCreateManyArgs} args - Arguments to create many AssetDamages.
     * @example
     * // Create many AssetDamages
     * const assetDamage = await prisma.assetDamage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends AssetDamageCreateManyArgs>(
      args?: SelectSubset<T, AssetDamageCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many AssetDamages and returns the data saved in the database.
     * @param {AssetDamageCreateManyAndReturnArgs} args - Arguments to create many AssetDamages.
     * @example
     * // Create many AssetDamages
     * const assetDamage = await prisma.assetDamage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many AssetDamages and only return the `id`
     * const assetDamageWithIdOnly = await prisma.assetDamage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends AssetDamageCreateManyAndReturnArgs>(
      args?: SelectSubset<T, AssetDamageCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$AssetDamagePayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a AssetDamage.
     * @param {AssetDamageDeleteArgs} args - Arguments to delete one AssetDamage.
     * @example
     * // Delete one AssetDamage
     * const AssetDamage = await prisma.assetDamage.delete({
     *   where: {
     *     // ... filter to delete one AssetDamage
     *   }
     * })
     *
     */
    delete<T extends AssetDamageDeleteArgs>(
      args: SelectSubset<T, AssetDamageDeleteArgs<ExtArgs>>,
    ): Prisma__AssetDamageClient<
      $Result.GetResult<
        Prisma.$AssetDamagePayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one AssetDamage.
     * @param {AssetDamageUpdateArgs} args - Arguments to update one AssetDamage.
     * @example
     * // Update one AssetDamage
     * const assetDamage = await prisma.assetDamage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends AssetDamageUpdateArgs>(
      args: SelectSubset<T, AssetDamageUpdateArgs<ExtArgs>>,
    ): Prisma__AssetDamageClient<
      $Result.GetResult<
        Prisma.$AssetDamagePayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more AssetDamages.
     * @param {AssetDamageDeleteManyArgs} args - Arguments to filter AssetDamages to delete.
     * @example
     * // Delete a few AssetDamages
     * const { count } = await prisma.assetDamage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends AssetDamageDeleteManyArgs>(
      args?: SelectSubset<T, AssetDamageDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more AssetDamages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetDamageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AssetDamages
     * const assetDamage = await prisma.assetDamage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends AssetDamageUpdateManyArgs>(
      args: SelectSubset<T, AssetDamageUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more AssetDamages and returns the data updated in the database.
     * @param {AssetDamageUpdateManyAndReturnArgs} args - Arguments to update many AssetDamages.
     * @example
     * // Update many AssetDamages
     * const assetDamage = await prisma.assetDamage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more AssetDamages and only return the `id`
     * const assetDamageWithIdOnly = await prisma.assetDamage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends AssetDamageUpdateManyAndReturnArgs>(
      args: SelectSubset<T, AssetDamageUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$AssetDamagePayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one AssetDamage.
     * @param {AssetDamageUpsertArgs} args - Arguments to update or create a AssetDamage.
     * @example
     * // Update or create a AssetDamage
     * const assetDamage = await prisma.assetDamage.upsert({
     *   create: {
     *     // ... data to create a AssetDamage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AssetDamage we want to update
     *   }
     * })
     */
    upsert<T extends AssetDamageUpsertArgs>(
      args: SelectSubset<T, AssetDamageUpsertArgs<ExtArgs>>,
    ): Prisma__AssetDamageClient<
      $Result.GetResult<
        Prisma.$AssetDamagePayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of AssetDamages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetDamageCountArgs} args - Arguments to filter AssetDamages to count.
     * @example
     * // Count the number of AssetDamages
     * const count = await prisma.assetDamage.count({
     *   where: {
     *     // ... the filter for the AssetDamages we want to count
     *   }
     * })
     **/
    count<T extends AssetDamageCountArgs>(
      args?: Subset<T, AssetDamageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], AssetDamageCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a AssetDamage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetDamageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends AssetDamageAggregateArgs>(
      args: Subset<T, AssetDamageAggregateArgs>,
    ): Prisma.PrismaPromise<GetAssetDamageAggregateType<T>>;

    /**
     * Group by AssetDamage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetDamageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends AssetDamageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AssetDamageGroupByArgs["orderBy"] }
        : { orderBy?: AssetDamageGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, AssetDamageGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetAssetDamageGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the AssetDamage model
     */
    readonly fields: AssetDamageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AssetDamage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AssetDamageClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    individualBook<T extends AssetDamage$individualBookArgs<ExtArgs> = {}>(
      args?: Subset<T, AssetDamage$individualBookArgs<ExtArgs>>,
    ): Prisma__IndividualBookClient<
      $Result.GetResult<
        Prisma.$IndividualBookPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    individualComputerLabItem<
      T extends AssetDamage$individualComputerLabItemArgs<ExtArgs> = {},
    >(
      args?: Subset<T, AssetDamage$individualComputerLabItemArgs<ExtArgs>>,
    ): Prisma__IndividualComputerLabItemClient<
      $Result.GetResult<
        Prisma.$IndividualComputerLabItemPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    individualFoodStoreItem<
      T extends AssetDamage$individualFoodStoreItemArgs<ExtArgs> = {},
    >(
      args?: Subset<T, AssetDamage$individualFoodStoreItemArgs<ExtArgs>>,
    ): Prisma__IndividualFoodStoreItemClient<
      $Result.GetResult<
        Prisma.$IndividualFoodStoreItemPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    individualGeneralStoreItem<
      T extends AssetDamage$individualGeneralStoreItemArgs<ExtArgs> = {},
    >(
      args?: Subset<T, AssetDamage$individualGeneralStoreItemArgs<ExtArgs>>,
    ): Prisma__IndividualGeneralStoreItemClient<
      $Result.GetResult<
        Prisma.$IndividualGeneralStoreItemPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    individualLabItem<
      T extends AssetDamage$individualLabItemArgs<ExtArgs> = {},
    >(
      args?: Subset<T, AssetDamage$individualLabItemArgs<ExtArgs>>,
    ): Prisma__IndividualLabItemClient<
      $Result.GetResult<
        Prisma.$IndividualLabItemPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    damagedBy<T extends AssetDamage$damagedByArgs<ExtArgs> = {}>(
      args?: Subset<T, AssetDamage$damagedByArgs<ExtArgs>>,
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    assetRepairPayments<
      T extends AssetDamage$assetRepairPaymentsArgs<ExtArgs> = {},
    >(
      args?: Subset<T, AssetDamage$assetRepairPaymentsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$AssetRepairPaymentPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the AssetDamage model
   */
  interface AssetDamageFieldRefs {
    readonly id: FieldRef<"AssetDamage", "String">;
    readonly damageDetails: FieldRef<"AssetDamage", "String">;
    readonly condition: FieldRef<"AssetDamage", "AssetCondition">;
    readonly quantity: FieldRef<"AssetDamage", "Int">;
    readonly userId: FieldRef<"AssetDamage", "String">;
    readonly individualComputerLabItemId: FieldRef<"AssetDamage", "String">;
    readonly isRepaired: FieldRef<"AssetDamage", "Boolean">;
    readonly repairedAt: FieldRef<"AssetDamage", "DateTime">;
    readonly createdAt: FieldRef<"AssetDamage", "DateTime">;
    readonly individualBookId: FieldRef<"AssetDamage", "String">;
    readonly individualLabItemId: FieldRef<"AssetDamage", "String">;
    readonly individualFoodStoreItemId: FieldRef<"AssetDamage", "String">;
    readonly individualGeneralStoreItemId: FieldRef<"AssetDamage", "String">;
    readonly isSchoolCost: FieldRef<"AssetDamage", "Boolean">;
    readonly repairBalance: FieldRef<"AssetDamage", "Float">;
    readonly repairPrice: FieldRef<"AssetDamage", "Float">;
  }

  // Custom InputTypes
  /**
   * AssetDamage findUnique
   */
  export type AssetDamageFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AssetDamage
     */
    select?: AssetDamageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AssetDamage
     */
    omit?: AssetDamageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetDamageInclude<ExtArgs> | null;
    /**
     * Filter, which AssetDamage to fetch.
     */
    where: AssetDamageWhereUniqueInput;
  };

  /**
   * AssetDamage findUniqueOrThrow
   */
  export type AssetDamageFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AssetDamage
     */
    select?: AssetDamageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AssetDamage
     */
    omit?: AssetDamageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetDamageInclude<ExtArgs> | null;
    /**
     * Filter, which AssetDamage to fetch.
     */
    where: AssetDamageWhereUniqueInput;
  };

  /**
   * AssetDamage findFirst
   */
  export type AssetDamageFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AssetDamage
     */
    select?: AssetDamageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AssetDamage
     */
    omit?: AssetDamageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetDamageInclude<ExtArgs> | null;
    /**
     * Filter, which AssetDamage to fetch.
     */
    where?: AssetDamageWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AssetDamages to fetch.
     */
    orderBy?:
      | AssetDamageOrderByWithRelationInput
      | AssetDamageOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for AssetDamages.
     */
    cursor?: AssetDamageWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AssetDamages from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AssetDamages.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of AssetDamages.
     */
    distinct?: AssetDamageScalarFieldEnum | AssetDamageScalarFieldEnum[];
  };

  /**
   * AssetDamage findFirstOrThrow
   */
  export type AssetDamageFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AssetDamage
     */
    select?: AssetDamageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AssetDamage
     */
    omit?: AssetDamageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetDamageInclude<ExtArgs> | null;
    /**
     * Filter, which AssetDamage to fetch.
     */
    where?: AssetDamageWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AssetDamages to fetch.
     */
    orderBy?:
      | AssetDamageOrderByWithRelationInput
      | AssetDamageOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for AssetDamages.
     */
    cursor?: AssetDamageWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AssetDamages from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AssetDamages.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of AssetDamages.
     */
    distinct?: AssetDamageScalarFieldEnum | AssetDamageScalarFieldEnum[];
  };

  /**
   * AssetDamage findMany
   */
  export type AssetDamageFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AssetDamage
     */
    select?: AssetDamageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AssetDamage
     */
    omit?: AssetDamageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetDamageInclude<ExtArgs> | null;
    /**
     * Filter, which AssetDamages to fetch.
     */
    where?: AssetDamageWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AssetDamages to fetch.
     */
    orderBy?:
      | AssetDamageOrderByWithRelationInput
      | AssetDamageOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing AssetDamages.
     */
    cursor?: AssetDamageWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AssetDamages from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AssetDamages.
     */
    skip?: number;
    distinct?: AssetDamageScalarFieldEnum | AssetDamageScalarFieldEnum[];
  };

  /**
   * AssetDamage create
   */
  export type AssetDamageCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AssetDamage
     */
    select?: AssetDamageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AssetDamage
     */
    omit?: AssetDamageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetDamageInclude<ExtArgs> | null;
    /**
     * The data needed to create a AssetDamage.
     */
    data: XOR<AssetDamageCreateInput, AssetDamageUncheckedCreateInput>;
  };

  /**
   * AssetDamage createMany
   */
  export type AssetDamageCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many AssetDamages.
     */
    data: AssetDamageCreateManyInput | AssetDamageCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * AssetDamage createManyAndReturn
   */
  export type AssetDamageCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AssetDamage
     */
    select?: AssetDamageSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the AssetDamage
     */
    omit?: AssetDamageOmit<ExtArgs> | null;
    /**
     * The data used to create many AssetDamages.
     */
    data: AssetDamageCreateManyInput | AssetDamageCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetDamageIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * AssetDamage update
   */
  export type AssetDamageUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AssetDamage
     */
    select?: AssetDamageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AssetDamage
     */
    omit?: AssetDamageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetDamageInclude<ExtArgs> | null;
    /**
     * The data needed to update a AssetDamage.
     */
    data: XOR<AssetDamageUpdateInput, AssetDamageUncheckedUpdateInput>;
    /**
     * Choose, which AssetDamage to update.
     */
    where: AssetDamageWhereUniqueInput;
  };

  /**
   * AssetDamage updateMany
   */
  export type AssetDamageUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update AssetDamages.
     */
    data: XOR<
      AssetDamageUpdateManyMutationInput,
      AssetDamageUncheckedUpdateManyInput
    >;
    /**
     * Filter which AssetDamages to update
     */
    where?: AssetDamageWhereInput;
    /**
     * Limit how many AssetDamages to update.
     */
    limit?: number;
  };

  /**
   * AssetDamage updateManyAndReturn
   */
  export type AssetDamageUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AssetDamage
     */
    select?: AssetDamageSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the AssetDamage
     */
    omit?: AssetDamageOmit<ExtArgs> | null;
    /**
     * The data used to update AssetDamages.
     */
    data: XOR<
      AssetDamageUpdateManyMutationInput,
      AssetDamageUncheckedUpdateManyInput
    >;
    /**
     * Filter which AssetDamages to update
     */
    where?: AssetDamageWhereInput;
    /**
     * Limit how many AssetDamages to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetDamageIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * AssetDamage upsert
   */
  export type AssetDamageUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AssetDamage
     */
    select?: AssetDamageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AssetDamage
     */
    omit?: AssetDamageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetDamageInclude<ExtArgs> | null;
    /**
     * The filter to search for the AssetDamage to update in case it exists.
     */
    where: AssetDamageWhereUniqueInput;
    /**
     * In case the AssetDamage found by the `where` argument doesn't exist, create a new AssetDamage with this data.
     */
    create: XOR<AssetDamageCreateInput, AssetDamageUncheckedCreateInput>;
    /**
     * In case the AssetDamage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AssetDamageUpdateInput, AssetDamageUncheckedUpdateInput>;
  };

  /**
   * AssetDamage delete
   */
  export type AssetDamageDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AssetDamage
     */
    select?: AssetDamageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AssetDamage
     */
    omit?: AssetDamageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetDamageInclude<ExtArgs> | null;
    /**
     * Filter which AssetDamage to delete.
     */
    where: AssetDamageWhereUniqueInput;
  };

  /**
   * AssetDamage deleteMany
   */
  export type AssetDamageDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which AssetDamages to delete
     */
    where?: AssetDamageWhereInput;
    /**
     * Limit how many AssetDamages to delete.
     */
    limit?: number;
  };

  /**
   * AssetDamage.individualBook
   */
  export type AssetDamage$individualBookArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IndividualBook
     */
    select?: IndividualBookSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the IndividualBook
     */
    omit?: IndividualBookOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndividualBookInclude<ExtArgs> | null;
    where?: IndividualBookWhereInput;
  };

  /**
   * AssetDamage.individualComputerLabItem
   */
  export type AssetDamage$individualComputerLabItemArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IndividualComputerLabItem
     */
    select?: IndividualComputerLabItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the IndividualComputerLabItem
     */
    omit?: IndividualComputerLabItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndividualComputerLabItemInclude<ExtArgs> | null;
    where?: IndividualComputerLabItemWhereInput;
  };

  /**
   * AssetDamage.individualFoodStoreItem
   */
  export type AssetDamage$individualFoodStoreItemArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IndividualFoodStoreItem
     */
    select?: IndividualFoodStoreItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the IndividualFoodStoreItem
     */
    omit?: IndividualFoodStoreItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndividualFoodStoreItemInclude<ExtArgs> | null;
    where?: IndividualFoodStoreItemWhereInput;
  };

  /**
   * AssetDamage.individualGeneralStoreItem
   */
  export type AssetDamage$individualGeneralStoreItemArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IndividualGeneralStoreItem
     */
    select?: IndividualGeneralStoreItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the IndividualGeneralStoreItem
     */
    omit?: IndividualGeneralStoreItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndividualGeneralStoreItemInclude<ExtArgs> | null;
    where?: IndividualGeneralStoreItemWhereInput;
  };

  /**
   * AssetDamage.individualLabItem
   */
  export type AssetDamage$individualLabItemArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IndividualLabItem
     */
    select?: IndividualLabItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the IndividualLabItem
     */
    omit?: IndividualLabItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndividualLabItemInclude<ExtArgs> | null;
    where?: IndividualLabItemWhereInput;
  };

  /**
   * AssetDamage.damagedBy
   */
  export type AssetDamage$damagedByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    where?: UserWhereInput;
  };

  /**
   * AssetDamage.assetRepairPayments
   */
  export type AssetDamage$assetRepairPaymentsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AssetRepairPayment
     */
    select?: AssetRepairPaymentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AssetRepairPayment
     */
    omit?: AssetRepairPaymentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetRepairPaymentInclude<ExtArgs> | null;
    where?: AssetRepairPaymentWhereInput;
    orderBy?:
      | AssetRepairPaymentOrderByWithRelationInput
      | AssetRepairPaymentOrderByWithRelationInput[];
    cursor?: AssetRepairPaymentWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?:
      | AssetRepairPaymentScalarFieldEnum
      | AssetRepairPaymentScalarFieldEnum[];
  };

  /**
   * AssetDamage without action
   */
  export type AssetDamageDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AssetDamage
     */
    select?: AssetDamageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AssetDamage
     */
    omit?: AssetDamageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetDamageInclude<ExtArgs> | null;
  };

  /**
   * Model AssetRepairPayment
   */

  export type AggregateAssetRepairPayment = {
    _count: AssetRepairPaymentCountAggregateOutputType | null;
    _avg: AssetRepairPaymentAvgAggregateOutputType | null;
    _sum: AssetRepairPaymentSumAggregateOutputType | null;
    _min: AssetRepairPaymentMinAggregateOutputType | null;
    _max: AssetRepairPaymentMaxAggregateOutputType | null;
  };

  export type AssetRepairPaymentAvgAggregateOutputType = {
    paidAmount: number | null;
  };

  export type AssetRepairPaymentSumAggregateOutputType = {
    paidAmount: number | null;
  };

  export type AssetRepairPaymentMinAggregateOutputType = {
    id: string | null;
    paidAmount: number | null;
    paidAt: Date | null;
    updatedAt: Date | null;
    assetDamageId: string | null;
    userId: string | null;
    isSchoolCost: boolean | null;
  };

  export type AssetRepairPaymentMaxAggregateOutputType = {
    id: string | null;
    paidAmount: number | null;
    paidAt: Date | null;
    updatedAt: Date | null;
    assetDamageId: string | null;
    userId: string | null;
    isSchoolCost: boolean | null;
  };

  export type AssetRepairPaymentCountAggregateOutputType = {
    id: number;
    paidAmount: number;
    paidAt: number;
    updatedAt: number;
    assetDamageId: number;
    userId: number;
    isSchoolCost: number;
    _all: number;
  };

  export type AssetRepairPaymentAvgAggregateInputType = {
    paidAmount?: true;
  };

  export type AssetRepairPaymentSumAggregateInputType = {
    paidAmount?: true;
  };

  export type AssetRepairPaymentMinAggregateInputType = {
    id?: true;
    paidAmount?: true;
    paidAt?: true;
    updatedAt?: true;
    assetDamageId?: true;
    userId?: true;
    isSchoolCost?: true;
  };

  export type AssetRepairPaymentMaxAggregateInputType = {
    id?: true;
    paidAmount?: true;
    paidAt?: true;
    updatedAt?: true;
    assetDamageId?: true;
    userId?: true;
    isSchoolCost?: true;
  };

  export type AssetRepairPaymentCountAggregateInputType = {
    id?: true;
    paidAmount?: true;
    paidAt?: true;
    updatedAt?: true;
    assetDamageId?: true;
    userId?: true;
    isSchoolCost?: true;
    _all?: true;
  };

  export type AssetRepairPaymentAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which AssetRepairPayment to aggregate.
     */
    where?: AssetRepairPaymentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AssetRepairPayments to fetch.
     */
    orderBy?:
      | AssetRepairPaymentOrderByWithRelationInput
      | AssetRepairPaymentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: AssetRepairPaymentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AssetRepairPayments from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AssetRepairPayments.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned AssetRepairPayments
     **/
    _count?: true | AssetRepairPaymentCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: AssetRepairPaymentAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: AssetRepairPaymentSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: AssetRepairPaymentMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: AssetRepairPaymentMaxAggregateInputType;
  };

  export type GetAssetRepairPaymentAggregateType<
    T extends AssetRepairPaymentAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateAssetRepairPayment]: P extends
      | "_count"
      | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAssetRepairPayment[P]>
      : GetScalarType<T[P], AggregateAssetRepairPayment[P]>;
  };

  export type AssetRepairPaymentGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AssetRepairPaymentWhereInput;
    orderBy?:
      | AssetRepairPaymentOrderByWithAggregationInput
      | AssetRepairPaymentOrderByWithAggregationInput[];
    by: AssetRepairPaymentScalarFieldEnum[] | AssetRepairPaymentScalarFieldEnum;
    having?: AssetRepairPaymentScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: AssetRepairPaymentCountAggregateInputType | true;
    _avg?: AssetRepairPaymentAvgAggregateInputType;
    _sum?: AssetRepairPaymentSumAggregateInputType;
    _min?: AssetRepairPaymentMinAggregateInputType;
    _max?: AssetRepairPaymentMaxAggregateInputType;
  };

  export type AssetRepairPaymentGroupByOutputType = {
    id: string;
    paidAmount: number;
    paidAt: Date;
    updatedAt: Date;
    assetDamageId: string | null;
    userId: string | null;
    isSchoolCost: boolean;
    _count: AssetRepairPaymentCountAggregateOutputType | null;
    _avg: AssetRepairPaymentAvgAggregateOutputType | null;
    _sum: AssetRepairPaymentSumAggregateOutputType | null;
    _min: AssetRepairPaymentMinAggregateOutputType | null;
    _max: AssetRepairPaymentMaxAggregateOutputType | null;
  };

  type GetAssetRepairPaymentGroupByPayload<
    T extends AssetRepairPaymentGroupByArgs,
  > = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AssetRepairPaymentGroupByOutputType, T["by"]> & {
        [P in keyof T &
          keyof AssetRepairPaymentGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], AssetRepairPaymentGroupByOutputType[P]>
          : GetScalarType<T[P], AssetRepairPaymentGroupByOutputType[P]>;
      }
    >
  >;

  export type AssetRepairPaymentSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      paidAmount?: boolean;
      paidAt?: boolean;
      updatedAt?: boolean;
      assetDamageId?: boolean;
      userId?: boolean;
      isSchoolCost?: boolean;
      assetDamage?: boolean | AssetRepairPayment$assetDamageArgs<ExtArgs>;
      receivedBy?: boolean | AssetRepairPayment$receivedByArgs<ExtArgs>;
    },
    ExtArgs["result"]["assetRepairPayment"]
  >;

  export type AssetRepairPaymentSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      paidAmount?: boolean;
      paidAt?: boolean;
      updatedAt?: boolean;
      assetDamageId?: boolean;
      userId?: boolean;
      isSchoolCost?: boolean;
      assetDamage?: boolean | AssetRepairPayment$assetDamageArgs<ExtArgs>;
      receivedBy?: boolean | AssetRepairPayment$receivedByArgs<ExtArgs>;
    },
    ExtArgs["result"]["assetRepairPayment"]
  >;

  export type AssetRepairPaymentSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      paidAmount?: boolean;
      paidAt?: boolean;
      updatedAt?: boolean;
      assetDamageId?: boolean;
      userId?: boolean;
      isSchoolCost?: boolean;
      assetDamage?: boolean | AssetRepairPayment$assetDamageArgs<ExtArgs>;
      receivedBy?: boolean | AssetRepairPayment$receivedByArgs<ExtArgs>;
    },
    ExtArgs["result"]["assetRepairPayment"]
  >;

  export type AssetRepairPaymentSelectScalar = {
    id?: boolean;
    paidAmount?: boolean;
    paidAt?: boolean;
    updatedAt?: boolean;
    assetDamageId?: boolean;
    userId?: boolean;
    isSchoolCost?: boolean;
  };

  export type AssetRepairPaymentOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | "id"
    | "paidAmount"
    | "paidAt"
    | "updatedAt"
    | "assetDamageId"
    | "userId"
    | "isSchoolCost",
    ExtArgs["result"]["assetRepairPayment"]
  >;
  export type AssetRepairPaymentInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    assetDamage?: boolean | AssetRepairPayment$assetDamageArgs<ExtArgs>;
    receivedBy?: boolean | AssetRepairPayment$receivedByArgs<ExtArgs>;
  };
  export type AssetRepairPaymentIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    assetDamage?: boolean | AssetRepairPayment$assetDamageArgs<ExtArgs>;
    receivedBy?: boolean | AssetRepairPayment$receivedByArgs<ExtArgs>;
  };
  export type AssetRepairPaymentIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    assetDamage?: boolean | AssetRepairPayment$assetDamageArgs<ExtArgs>;
    receivedBy?: boolean | AssetRepairPayment$receivedByArgs<ExtArgs>;
  };

  export type $AssetRepairPaymentPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "AssetRepairPayment";
    objects: {
      assetDamage: Prisma.$AssetDamagePayload<ExtArgs> | null;
      receivedBy: Prisma.$UserPayload<ExtArgs> | null;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        paidAmount: number;
        paidAt: Date;
        updatedAt: Date;
        assetDamageId: string | null;
        userId: string | null;
        isSchoolCost: boolean;
      },
      ExtArgs["result"]["assetRepairPayment"]
    >;
    composites: {};
  };

  type AssetRepairPaymentGetPayload<
    S extends boolean | null | undefined | AssetRepairPaymentDefaultArgs,
  > = $Result.GetResult<Prisma.$AssetRepairPaymentPayload, S>;

  type AssetRepairPaymentCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    AssetRepairPaymentFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: AssetRepairPaymentCountAggregateInputType | true;
  };

  export interface AssetRepairPaymentDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["AssetRepairPayment"];
      meta: { name: "AssetRepairPayment" };
    };
    /**
     * Find zero or one AssetRepairPayment that matches the filter.
     * @param {AssetRepairPaymentFindUniqueArgs} args - Arguments to find a AssetRepairPayment
     * @example
     * // Get one AssetRepairPayment
     * const assetRepairPayment = await prisma.assetRepairPayment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AssetRepairPaymentFindUniqueArgs>(
      args: SelectSubset<T, AssetRepairPaymentFindUniqueArgs<ExtArgs>>,
    ): Prisma__AssetRepairPaymentClient<
      $Result.GetResult<
        Prisma.$AssetRepairPaymentPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one AssetRepairPayment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AssetRepairPaymentFindUniqueOrThrowArgs} args - Arguments to find a AssetRepairPayment
     * @example
     * // Get one AssetRepairPayment
     * const assetRepairPayment = await prisma.assetRepairPayment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AssetRepairPaymentFindUniqueOrThrowArgs>(
      args: SelectSubset<T, AssetRepairPaymentFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__AssetRepairPaymentClient<
      $Result.GetResult<
        Prisma.$AssetRepairPaymentPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first AssetRepairPayment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetRepairPaymentFindFirstArgs} args - Arguments to find a AssetRepairPayment
     * @example
     * // Get one AssetRepairPayment
     * const assetRepairPayment = await prisma.assetRepairPayment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AssetRepairPaymentFindFirstArgs>(
      args?: SelectSubset<T, AssetRepairPaymentFindFirstArgs<ExtArgs>>,
    ): Prisma__AssetRepairPaymentClient<
      $Result.GetResult<
        Prisma.$AssetRepairPaymentPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first AssetRepairPayment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetRepairPaymentFindFirstOrThrowArgs} args - Arguments to find a AssetRepairPayment
     * @example
     * // Get one AssetRepairPayment
     * const assetRepairPayment = await prisma.assetRepairPayment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AssetRepairPaymentFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AssetRepairPaymentFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__AssetRepairPaymentClient<
      $Result.GetResult<
        Prisma.$AssetRepairPaymentPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more AssetRepairPayments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetRepairPaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AssetRepairPayments
     * const assetRepairPayments = await prisma.assetRepairPayment.findMany()
     *
     * // Get first 10 AssetRepairPayments
     * const assetRepairPayments = await prisma.assetRepairPayment.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const assetRepairPaymentWithIdOnly = await prisma.assetRepairPayment.findMany({ select: { id: true } })
     *
     */
    findMany<T extends AssetRepairPaymentFindManyArgs>(
      args?: SelectSubset<T, AssetRepairPaymentFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$AssetRepairPaymentPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a AssetRepairPayment.
     * @param {AssetRepairPaymentCreateArgs} args - Arguments to create a AssetRepairPayment.
     * @example
     * // Create one AssetRepairPayment
     * const AssetRepairPayment = await prisma.assetRepairPayment.create({
     *   data: {
     *     // ... data to create a AssetRepairPayment
     *   }
     * })
     *
     */
    create<T extends AssetRepairPaymentCreateArgs>(
      args: SelectSubset<T, AssetRepairPaymentCreateArgs<ExtArgs>>,
    ): Prisma__AssetRepairPaymentClient<
      $Result.GetResult<
        Prisma.$AssetRepairPaymentPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many AssetRepairPayments.
     * @param {AssetRepairPaymentCreateManyArgs} args - Arguments to create many AssetRepairPayments.
     * @example
     * // Create many AssetRepairPayments
     * const assetRepairPayment = await prisma.assetRepairPayment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends AssetRepairPaymentCreateManyArgs>(
      args?: SelectSubset<T, AssetRepairPaymentCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many AssetRepairPayments and returns the data saved in the database.
     * @param {AssetRepairPaymentCreateManyAndReturnArgs} args - Arguments to create many AssetRepairPayments.
     * @example
     * // Create many AssetRepairPayments
     * const assetRepairPayment = await prisma.assetRepairPayment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many AssetRepairPayments and only return the `id`
     * const assetRepairPaymentWithIdOnly = await prisma.assetRepairPayment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends AssetRepairPaymentCreateManyAndReturnArgs>(
      args?: SelectSubset<
        T,
        AssetRepairPaymentCreateManyAndReturnArgs<ExtArgs>
      >,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$AssetRepairPaymentPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a AssetRepairPayment.
     * @param {AssetRepairPaymentDeleteArgs} args - Arguments to delete one AssetRepairPayment.
     * @example
     * // Delete one AssetRepairPayment
     * const AssetRepairPayment = await prisma.assetRepairPayment.delete({
     *   where: {
     *     // ... filter to delete one AssetRepairPayment
     *   }
     * })
     *
     */
    delete<T extends AssetRepairPaymentDeleteArgs>(
      args: SelectSubset<T, AssetRepairPaymentDeleteArgs<ExtArgs>>,
    ): Prisma__AssetRepairPaymentClient<
      $Result.GetResult<
        Prisma.$AssetRepairPaymentPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one AssetRepairPayment.
     * @param {AssetRepairPaymentUpdateArgs} args - Arguments to update one AssetRepairPayment.
     * @example
     * // Update one AssetRepairPayment
     * const assetRepairPayment = await prisma.assetRepairPayment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends AssetRepairPaymentUpdateArgs>(
      args: SelectSubset<T, AssetRepairPaymentUpdateArgs<ExtArgs>>,
    ): Prisma__AssetRepairPaymentClient<
      $Result.GetResult<
        Prisma.$AssetRepairPaymentPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more AssetRepairPayments.
     * @param {AssetRepairPaymentDeleteManyArgs} args - Arguments to filter AssetRepairPayments to delete.
     * @example
     * // Delete a few AssetRepairPayments
     * const { count } = await prisma.assetRepairPayment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends AssetRepairPaymentDeleteManyArgs>(
      args?: SelectSubset<T, AssetRepairPaymentDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more AssetRepairPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetRepairPaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AssetRepairPayments
     * const assetRepairPayment = await prisma.assetRepairPayment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends AssetRepairPaymentUpdateManyArgs>(
      args: SelectSubset<T, AssetRepairPaymentUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more AssetRepairPayments and returns the data updated in the database.
     * @param {AssetRepairPaymentUpdateManyAndReturnArgs} args - Arguments to update many AssetRepairPayments.
     * @example
     * // Update many AssetRepairPayments
     * const assetRepairPayment = await prisma.assetRepairPayment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more AssetRepairPayments and only return the `id`
     * const assetRepairPaymentWithIdOnly = await prisma.assetRepairPayment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends AssetRepairPaymentUpdateManyAndReturnArgs>(
      args: SelectSubset<T, AssetRepairPaymentUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$AssetRepairPaymentPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one AssetRepairPayment.
     * @param {AssetRepairPaymentUpsertArgs} args - Arguments to update or create a AssetRepairPayment.
     * @example
     * // Update or create a AssetRepairPayment
     * const assetRepairPayment = await prisma.assetRepairPayment.upsert({
     *   create: {
     *     // ... data to create a AssetRepairPayment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AssetRepairPayment we want to update
     *   }
     * })
     */
    upsert<T extends AssetRepairPaymentUpsertArgs>(
      args: SelectSubset<T, AssetRepairPaymentUpsertArgs<ExtArgs>>,
    ): Prisma__AssetRepairPaymentClient<
      $Result.GetResult<
        Prisma.$AssetRepairPaymentPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of AssetRepairPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetRepairPaymentCountArgs} args - Arguments to filter AssetRepairPayments to count.
     * @example
     * // Count the number of AssetRepairPayments
     * const count = await prisma.assetRepairPayment.count({
     *   where: {
     *     // ... the filter for the AssetRepairPayments we want to count
     *   }
     * })
     **/
    count<T extends AssetRepairPaymentCountArgs>(
      args?: Subset<T, AssetRepairPaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<
              T["select"],
              AssetRepairPaymentCountAggregateOutputType
            >
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a AssetRepairPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetRepairPaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends AssetRepairPaymentAggregateArgs>(
      args: Subset<T, AssetRepairPaymentAggregateArgs>,
    ): Prisma.PrismaPromise<GetAssetRepairPaymentAggregateType<T>>;

    /**
     * Group by AssetRepairPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetRepairPaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends AssetRepairPaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AssetRepairPaymentGroupByArgs["orderBy"] }
        : { orderBy?: AssetRepairPaymentGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, AssetRepairPaymentGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetAssetRepairPaymentGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the AssetRepairPayment model
     */
    readonly fields: AssetRepairPaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AssetRepairPayment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AssetRepairPaymentClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    assetDamage<T extends AssetRepairPayment$assetDamageArgs<ExtArgs> = {}>(
      args?: Subset<T, AssetRepairPayment$assetDamageArgs<ExtArgs>>,
    ): Prisma__AssetDamageClient<
      $Result.GetResult<
        Prisma.$AssetDamagePayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    receivedBy<T extends AssetRepairPayment$receivedByArgs<ExtArgs> = {}>(
      args?: Subset<T, AssetRepairPayment$receivedByArgs<ExtArgs>>,
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the AssetRepairPayment model
   */
  interface AssetRepairPaymentFieldRefs {
    readonly id: FieldRef<"AssetRepairPayment", "String">;
    readonly paidAmount: FieldRef<"AssetRepairPayment", "Float">;
    readonly paidAt: FieldRef<"AssetRepairPayment", "DateTime">;
    readonly updatedAt: FieldRef<"AssetRepairPayment", "DateTime">;
    readonly assetDamageId: FieldRef<"AssetRepairPayment", "String">;
    readonly userId: FieldRef<"AssetRepairPayment", "String">;
    readonly isSchoolCost: FieldRef<"AssetRepairPayment", "Boolean">;
  }

  // Custom InputTypes
  /**
   * AssetRepairPayment findUnique
   */
  export type AssetRepairPaymentFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AssetRepairPayment
     */
    select?: AssetRepairPaymentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AssetRepairPayment
     */
    omit?: AssetRepairPaymentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetRepairPaymentInclude<ExtArgs> | null;
    /**
     * Filter, which AssetRepairPayment to fetch.
     */
    where: AssetRepairPaymentWhereUniqueInput;
  };

  /**
   * AssetRepairPayment findUniqueOrThrow
   */
  export type AssetRepairPaymentFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AssetRepairPayment
     */
    select?: AssetRepairPaymentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AssetRepairPayment
     */
    omit?: AssetRepairPaymentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetRepairPaymentInclude<ExtArgs> | null;
    /**
     * Filter, which AssetRepairPayment to fetch.
     */
    where: AssetRepairPaymentWhereUniqueInput;
  };

  /**
   * AssetRepairPayment findFirst
   */
  export type AssetRepairPaymentFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AssetRepairPayment
     */
    select?: AssetRepairPaymentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AssetRepairPayment
     */
    omit?: AssetRepairPaymentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetRepairPaymentInclude<ExtArgs> | null;
    /**
     * Filter, which AssetRepairPayment to fetch.
     */
    where?: AssetRepairPaymentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AssetRepairPayments to fetch.
     */
    orderBy?:
      | AssetRepairPaymentOrderByWithRelationInput
      | AssetRepairPaymentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for AssetRepairPayments.
     */
    cursor?: AssetRepairPaymentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AssetRepairPayments from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AssetRepairPayments.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of AssetRepairPayments.
     */
    distinct?:
      | AssetRepairPaymentScalarFieldEnum
      | AssetRepairPaymentScalarFieldEnum[];
  };

  /**
   * AssetRepairPayment findFirstOrThrow
   */
  export type AssetRepairPaymentFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AssetRepairPayment
     */
    select?: AssetRepairPaymentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AssetRepairPayment
     */
    omit?: AssetRepairPaymentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetRepairPaymentInclude<ExtArgs> | null;
    /**
     * Filter, which AssetRepairPayment to fetch.
     */
    where?: AssetRepairPaymentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AssetRepairPayments to fetch.
     */
    orderBy?:
      | AssetRepairPaymentOrderByWithRelationInput
      | AssetRepairPaymentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for AssetRepairPayments.
     */
    cursor?: AssetRepairPaymentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AssetRepairPayments from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AssetRepairPayments.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of AssetRepairPayments.
     */
    distinct?:
      | AssetRepairPaymentScalarFieldEnum
      | AssetRepairPaymentScalarFieldEnum[];
  };

  /**
   * AssetRepairPayment findMany
   */
  export type AssetRepairPaymentFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AssetRepairPayment
     */
    select?: AssetRepairPaymentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AssetRepairPayment
     */
    omit?: AssetRepairPaymentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetRepairPaymentInclude<ExtArgs> | null;
    /**
     * Filter, which AssetRepairPayments to fetch.
     */
    where?: AssetRepairPaymentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AssetRepairPayments to fetch.
     */
    orderBy?:
      | AssetRepairPaymentOrderByWithRelationInput
      | AssetRepairPaymentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing AssetRepairPayments.
     */
    cursor?: AssetRepairPaymentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AssetRepairPayments from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AssetRepairPayments.
     */
    skip?: number;
    distinct?:
      | AssetRepairPaymentScalarFieldEnum
      | AssetRepairPaymentScalarFieldEnum[];
  };

  /**
   * AssetRepairPayment create
   */
  export type AssetRepairPaymentCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AssetRepairPayment
     */
    select?: AssetRepairPaymentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AssetRepairPayment
     */
    omit?: AssetRepairPaymentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetRepairPaymentInclude<ExtArgs> | null;
    /**
     * The data needed to create a AssetRepairPayment.
     */
    data: XOR<
      AssetRepairPaymentCreateInput,
      AssetRepairPaymentUncheckedCreateInput
    >;
  };

  /**
   * AssetRepairPayment createMany
   */
  export type AssetRepairPaymentCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many AssetRepairPayments.
     */
    data:
      | AssetRepairPaymentCreateManyInput
      | AssetRepairPaymentCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * AssetRepairPayment createManyAndReturn
   */
  export type AssetRepairPaymentCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AssetRepairPayment
     */
    select?: AssetRepairPaymentSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the AssetRepairPayment
     */
    omit?: AssetRepairPaymentOmit<ExtArgs> | null;
    /**
     * The data used to create many AssetRepairPayments.
     */
    data:
      | AssetRepairPaymentCreateManyInput
      | AssetRepairPaymentCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetRepairPaymentIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * AssetRepairPayment update
   */
  export type AssetRepairPaymentUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AssetRepairPayment
     */
    select?: AssetRepairPaymentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AssetRepairPayment
     */
    omit?: AssetRepairPaymentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetRepairPaymentInclude<ExtArgs> | null;
    /**
     * The data needed to update a AssetRepairPayment.
     */
    data: XOR<
      AssetRepairPaymentUpdateInput,
      AssetRepairPaymentUncheckedUpdateInput
    >;
    /**
     * Choose, which AssetRepairPayment to update.
     */
    where: AssetRepairPaymentWhereUniqueInput;
  };

  /**
   * AssetRepairPayment updateMany
   */
  export type AssetRepairPaymentUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update AssetRepairPayments.
     */
    data: XOR<
      AssetRepairPaymentUpdateManyMutationInput,
      AssetRepairPaymentUncheckedUpdateManyInput
    >;
    /**
     * Filter which AssetRepairPayments to update
     */
    where?: AssetRepairPaymentWhereInput;
    /**
     * Limit how many AssetRepairPayments to update.
     */
    limit?: number;
  };

  /**
   * AssetRepairPayment updateManyAndReturn
   */
  export type AssetRepairPaymentUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AssetRepairPayment
     */
    select?: AssetRepairPaymentSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the AssetRepairPayment
     */
    omit?: AssetRepairPaymentOmit<ExtArgs> | null;
    /**
     * The data used to update AssetRepairPayments.
     */
    data: XOR<
      AssetRepairPaymentUpdateManyMutationInput,
      AssetRepairPaymentUncheckedUpdateManyInput
    >;
    /**
     * Filter which AssetRepairPayments to update
     */
    where?: AssetRepairPaymentWhereInput;
    /**
     * Limit how many AssetRepairPayments to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetRepairPaymentIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * AssetRepairPayment upsert
   */
  export type AssetRepairPaymentUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AssetRepairPayment
     */
    select?: AssetRepairPaymentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AssetRepairPayment
     */
    omit?: AssetRepairPaymentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetRepairPaymentInclude<ExtArgs> | null;
    /**
     * The filter to search for the AssetRepairPayment to update in case it exists.
     */
    where: AssetRepairPaymentWhereUniqueInput;
    /**
     * In case the AssetRepairPayment found by the `where` argument doesn't exist, create a new AssetRepairPayment with this data.
     */
    create: XOR<
      AssetRepairPaymentCreateInput,
      AssetRepairPaymentUncheckedCreateInput
    >;
    /**
     * In case the AssetRepairPayment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<
      AssetRepairPaymentUpdateInput,
      AssetRepairPaymentUncheckedUpdateInput
    >;
  };

  /**
   * AssetRepairPayment delete
   */
  export type AssetRepairPaymentDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AssetRepairPayment
     */
    select?: AssetRepairPaymentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AssetRepairPayment
     */
    omit?: AssetRepairPaymentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetRepairPaymentInclude<ExtArgs> | null;
    /**
     * Filter which AssetRepairPayment to delete.
     */
    where: AssetRepairPaymentWhereUniqueInput;
  };

  /**
   * AssetRepairPayment deleteMany
   */
  export type AssetRepairPaymentDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which AssetRepairPayments to delete
     */
    where?: AssetRepairPaymentWhereInput;
    /**
     * Limit how many AssetRepairPayments to delete.
     */
    limit?: number;
  };

  /**
   * AssetRepairPayment.assetDamage
   */
  export type AssetRepairPayment$assetDamageArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AssetDamage
     */
    select?: AssetDamageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AssetDamage
     */
    omit?: AssetDamageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetDamageInclude<ExtArgs> | null;
    where?: AssetDamageWhereInput;
  };

  /**
   * AssetRepairPayment.receivedBy
   */
  export type AssetRepairPayment$receivedByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    where?: UserWhereInput;
  };

  /**
   * AssetRepairPayment without action
   */
  export type AssetRepairPaymentDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AssetRepairPayment
     */
    select?: AssetRepairPaymentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AssetRepairPayment
     */
    omit?: AssetRepairPaymentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetRepairPaymentInclude<ExtArgs> | null;
  };

  /**
   * Model ExamScore
   */

  export type AggregateExamScore = {
    _count: ExamScoreCountAggregateOutputType | null;
    _avg: ExamScoreAvgAggregateOutputType | null;
    _sum: ExamScoreSumAggregateOutputType | null;
    _min: ExamScoreMinAggregateOutputType | null;
    _max: ExamScoreMaxAggregateOutputType | null;
  };

  export type ExamScoreAvgAggregateOutputType = {
    score: number | null;
  };

  export type ExamScoreSumAggregateOutputType = {
    score: number | null;
  };

  export type ExamScoreMinAggregateOutputType = {
    id: string | null;
    score: number | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    examSubjectId: string | null;
    pupilId: string | null;
  };

  export type ExamScoreMaxAggregateOutputType = {
    id: string | null;
    score: number | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    examSubjectId: string | null;
    pupilId: string | null;
  };

  export type ExamScoreCountAggregateOutputType = {
    id: number;
    score: number;
    createdAt: number;
    updatedAt: number;
    examSubjectId: number;
    pupilId: number;
    _all: number;
  };

  export type ExamScoreAvgAggregateInputType = {
    score?: true;
  };

  export type ExamScoreSumAggregateInputType = {
    score?: true;
  };

  export type ExamScoreMinAggregateInputType = {
    id?: true;
    score?: true;
    createdAt?: true;
    updatedAt?: true;
    examSubjectId?: true;
    pupilId?: true;
  };

  export type ExamScoreMaxAggregateInputType = {
    id?: true;
    score?: true;
    createdAt?: true;
    updatedAt?: true;
    examSubjectId?: true;
    pupilId?: true;
  };

  export type ExamScoreCountAggregateInputType = {
    id?: true;
    score?: true;
    createdAt?: true;
    updatedAt?: true;
    examSubjectId?: true;
    pupilId?: true;
    _all?: true;
  };

  export type ExamScoreAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which ExamScore to aggregate.
     */
    where?: ExamScoreWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ExamScores to fetch.
     */
    orderBy?:
      | ExamScoreOrderByWithRelationInput
      | ExamScoreOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ExamScoreWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ExamScores from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ExamScores.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned ExamScores
     **/
    _count?: true | ExamScoreCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: ExamScoreAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: ExamScoreSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ExamScoreMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ExamScoreMaxAggregateInputType;
  };

  export type GetExamScoreAggregateType<T extends ExamScoreAggregateArgs> = {
    [P in keyof T & keyof AggregateExamScore]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExamScore[P]>
      : GetScalarType<T[P], AggregateExamScore[P]>;
  };

  export type ExamScoreGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ExamScoreWhereInput;
    orderBy?:
      | ExamScoreOrderByWithAggregationInput
      | ExamScoreOrderByWithAggregationInput[];
    by: ExamScoreScalarFieldEnum[] | ExamScoreScalarFieldEnum;
    having?: ExamScoreScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ExamScoreCountAggregateInputType | true;
    _avg?: ExamScoreAvgAggregateInputType;
    _sum?: ExamScoreSumAggregateInputType;
    _min?: ExamScoreMinAggregateInputType;
    _max?: ExamScoreMaxAggregateInputType;
  };

  export type ExamScoreGroupByOutputType = {
    id: string;
    score: number;
    createdAt: Date;
    updatedAt: Date;
    examSubjectId: string;
    pupilId: string;
    _count: ExamScoreCountAggregateOutputType | null;
    _avg: ExamScoreAvgAggregateOutputType | null;
    _sum: ExamScoreSumAggregateOutputType | null;
    _min: ExamScoreMinAggregateOutputType | null;
    _max: ExamScoreMaxAggregateOutputType | null;
  };

  type GetExamScoreGroupByPayload<T extends ExamScoreGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<ExamScoreGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof ExamScoreGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExamScoreGroupByOutputType[P]>
            : GetScalarType<T[P], ExamScoreGroupByOutputType[P]>;
        }
      >
    >;

  export type ExamScoreSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      score?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      examSubjectId?: boolean;
      pupilId?: boolean;
      examSubject?: boolean | ExamSubjectDefaultArgs<ExtArgs>;
      pupil?: boolean | PupilDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["examScore"]
  >;

  export type ExamScoreSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      score?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      examSubjectId?: boolean;
      pupilId?: boolean;
      examSubject?: boolean | ExamSubjectDefaultArgs<ExtArgs>;
      pupil?: boolean | PupilDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["examScore"]
  >;

  export type ExamScoreSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      score?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      examSubjectId?: boolean;
      pupilId?: boolean;
      examSubject?: boolean | ExamSubjectDefaultArgs<ExtArgs>;
      pupil?: boolean | PupilDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["examScore"]
  >;

  export type ExamScoreSelectScalar = {
    id?: boolean;
    score?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    examSubjectId?: boolean;
    pupilId?: boolean;
  };

  export type ExamScoreOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    "id" | "score" | "createdAt" | "updatedAt" | "examSubjectId" | "pupilId",
    ExtArgs["result"]["examScore"]
  >;
  export type ExamScoreInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    examSubject?: boolean | ExamSubjectDefaultArgs<ExtArgs>;
    pupil?: boolean | PupilDefaultArgs<ExtArgs>;
  };
  export type ExamScoreIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    examSubject?: boolean | ExamSubjectDefaultArgs<ExtArgs>;
    pupil?: boolean | PupilDefaultArgs<ExtArgs>;
  };
  export type ExamScoreIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    examSubject?: boolean | ExamSubjectDefaultArgs<ExtArgs>;
    pupil?: boolean | PupilDefaultArgs<ExtArgs>;
  };

  export type $ExamScorePayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "ExamScore";
    objects: {
      examSubject: Prisma.$ExamSubjectPayload<ExtArgs>;
      pupil: Prisma.$PupilPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        score: number;
        createdAt: Date;
        updatedAt: Date;
        examSubjectId: string;
        pupilId: string;
      },
      ExtArgs["result"]["examScore"]
    >;
    composites: {};
  };

  type ExamScoreGetPayload<
    S extends boolean | null | undefined | ExamScoreDefaultArgs,
  > = $Result.GetResult<Prisma.$ExamScorePayload, S>;

  type ExamScoreCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    ExamScoreFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: ExamScoreCountAggregateInputType | true;
  };

  export interface ExamScoreDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["ExamScore"];
      meta: { name: "ExamScore" };
    };
    /**
     * Find zero or one ExamScore that matches the filter.
     * @param {ExamScoreFindUniqueArgs} args - Arguments to find a ExamScore
     * @example
     * // Get one ExamScore
     * const examScore = await prisma.examScore.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExamScoreFindUniqueArgs>(
      args: SelectSubset<T, ExamScoreFindUniqueArgs<ExtArgs>>,
    ): Prisma__ExamScoreClient<
      $Result.GetResult<
        Prisma.$ExamScorePayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one ExamScore that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExamScoreFindUniqueOrThrowArgs} args - Arguments to find a ExamScore
     * @example
     * // Get one ExamScore
     * const examScore = await prisma.examScore.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExamScoreFindUniqueOrThrowArgs>(
      args: SelectSubset<T, ExamScoreFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__ExamScoreClient<
      $Result.GetResult<
        Prisma.$ExamScorePayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first ExamScore that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamScoreFindFirstArgs} args - Arguments to find a ExamScore
     * @example
     * // Get one ExamScore
     * const examScore = await prisma.examScore.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExamScoreFindFirstArgs>(
      args?: SelectSubset<T, ExamScoreFindFirstArgs<ExtArgs>>,
    ): Prisma__ExamScoreClient<
      $Result.GetResult<
        Prisma.$ExamScorePayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first ExamScore that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamScoreFindFirstOrThrowArgs} args - Arguments to find a ExamScore
     * @example
     * // Get one ExamScore
     * const examScore = await prisma.examScore.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExamScoreFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ExamScoreFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__ExamScoreClient<
      $Result.GetResult<
        Prisma.$ExamScorePayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more ExamScores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamScoreFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExamScores
     * const examScores = await prisma.examScore.findMany()
     *
     * // Get first 10 ExamScores
     * const examScores = await prisma.examScore.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const examScoreWithIdOnly = await prisma.examScore.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ExamScoreFindManyArgs>(
      args?: SelectSubset<T, ExamScoreFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ExamScorePayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a ExamScore.
     * @param {ExamScoreCreateArgs} args - Arguments to create a ExamScore.
     * @example
     * // Create one ExamScore
     * const ExamScore = await prisma.examScore.create({
     *   data: {
     *     // ... data to create a ExamScore
     *   }
     * })
     *
     */
    create<T extends ExamScoreCreateArgs>(
      args: SelectSubset<T, ExamScoreCreateArgs<ExtArgs>>,
    ): Prisma__ExamScoreClient<
      $Result.GetResult<
        Prisma.$ExamScorePayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many ExamScores.
     * @param {ExamScoreCreateManyArgs} args - Arguments to create many ExamScores.
     * @example
     * // Create many ExamScores
     * const examScore = await prisma.examScore.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ExamScoreCreateManyArgs>(
      args?: SelectSubset<T, ExamScoreCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many ExamScores and returns the data saved in the database.
     * @param {ExamScoreCreateManyAndReturnArgs} args - Arguments to create many ExamScores.
     * @example
     * // Create many ExamScores
     * const examScore = await prisma.examScore.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many ExamScores and only return the `id`
     * const examScoreWithIdOnly = await prisma.examScore.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends ExamScoreCreateManyAndReturnArgs>(
      args?: SelectSubset<T, ExamScoreCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ExamScorePayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a ExamScore.
     * @param {ExamScoreDeleteArgs} args - Arguments to delete one ExamScore.
     * @example
     * // Delete one ExamScore
     * const ExamScore = await prisma.examScore.delete({
     *   where: {
     *     // ... filter to delete one ExamScore
     *   }
     * })
     *
     */
    delete<T extends ExamScoreDeleteArgs>(
      args: SelectSubset<T, ExamScoreDeleteArgs<ExtArgs>>,
    ): Prisma__ExamScoreClient<
      $Result.GetResult<
        Prisma.$ExamScorePayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one ExamScore.
     * @param {ExamScoreUpdateArgs} args - Arguments to update one ExamScore.
     * @example
     * // Update one ExamScore
     * const examScore = await prisma.examScore.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ExamScoreUpdateArgs>(
      args: SelectSubset<T, ExamScoreUpdateArgs<ExtArgs>>,
    ): Prisma__ExamScoreClient<
      $Result.GetResult<
        Prisma.$ExamScorePayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more ExamScores.
     * @param {ExamScoreDeleteManyArgs} args - Arguments to filter ExamScores to delete.
     * @example
     * // Delete a few ExamScores
     * const { count } = await prisma.examScore.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ExamScoreDeleteManyArgs>(
      args?: SelectSubset<T, ExamScoreDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more ExamScores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamScoreUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExamScores
     * const examScore = await prisma.examScore.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ExamScoreUpdateManyArgs>(
      args: SelectSubset<T, ExamScoreUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more ExamScores and returns the data updated in the database.
     * @param {ExamScoreUpdateManyAndReturnArgs} args - Arguments to update many ExamScores.
     * @example
     * // Update many ExamScores
     * const examScore = await prisma.examScore.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more ExamScores and only return the `id`
     * const examScoreWithIdOnly = await prisma.examScore.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends ExamScoreUpdateManyAndReturnArgs>(
      args: SelectSubset<T, ExamScoreUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ExamScorePayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one ExamScore.
     * @param {ExamScoreUpsertArgs} args - Arguments to update or create a ExamScore.
     * @example
     * // Update or create a ExamScore
     * const examScore = await prisma.examScore.upsert({
     *   create: {
     *     // ... data to create a ExamScore
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExamScore we want to update
     *   }
     * })
     */
    upsert<T extends ExamScoreUpsertArgs>(
      args: SelectSubset<T, ExamScoreUpsertArgs<ExtArgs>>,
    ): Prisma__ExamScoreClient<
      $Result.GetResult<
        Prisma.$ExamScorePayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of ExamScores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamScoreCountArgs} args - Arguments to filter ExamScores to count.
     * @example
     * // Count the number of ExamScores
     * const count = await prisma.examScore.count({
     *   where: {
     *     // ... the filter for the ExamScores we want to count
     *   }
     * })
     **/
    count<T extends ExamScoreCountArgs>(
      args?: Subset<T, ExamScoreCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], ExamScoreCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a ExamScore.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamScoreAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ExamScoreAggregateArgs>(
      args: Subset<T, ExamScoreAggregateArgs>,
    ): Prisma.PrismaPromise<GetExamScoreAggregateType<T>>;

    /**
     * Group by ExamScore.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamScoreGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends ExamScoreGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExamScoreGroupByArgs["orderBy"] }
        : { orderBy?: ExamScoreGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, ExamScoreGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetExamScoreGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the ExamScore model
     */
    readonly fields: ExamScoreFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExamScore.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExamScoreClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    examSubject<T extends ExamSubjectDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, ExamSubjectDefaultArgs<ExtArgs>>,
    ): Prisma__ExamSubjectClient<
      | $Result.GetResult<
          Prisma.$ExamSubjectPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    pupil<T extends PupilDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, PupilDefaultArgs<ExtArgs>>,
    ): Prisma__PupilClient<
      | $Result.GetResult<
          Prisma.$PupilPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the ExamScore model
   */
  interface ExamScoreFieldRefs {
    readonly id: FieldRef<"ExamScore", "String">;
    readonly score: FieldRef<"ExamScore", "Float">;
    readonly createdAt: FieldRef<"ExamScore", "DateTime">;
    readonly updatedAt: FieldRef<"ExamScore", "DateTime">;
    readonly examSubjectId: FieldRef<"ExamScore", "String">;
    readonly pupilId: FieldRef<"ExamScore", "String">;
  }

  // Custom InputTypes
  /**
   * ExamScore findUnique
   */
  export type ExamScoreFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ExamScore
     */
    select?: ExamScoreSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ExamScore
     */
    omit?: ExamScoreOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamScoreInclude<ExtArgs> | null;
    /**
     * Filter, which ExamScore to fetch.
     */
    where: ExamScoreWhereUniqueInput;
  };

  /**
   * ExamScore findUniqueOrThrow
   */
  export type ExamScoreFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ExamScore
     */
    select?: ExamScoreSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ExamScore
     */
    omit?: ExamScoreOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamScoreInclude<ExtArgs> | null;
    /**
     * Filter, which ExamScore to fetch.
     */
    where: ExamScoreWhereUniqueInput;
  };

  /**
   * ExamScore findFirst
   */
  export type ExamScoreFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ExamScore
     */
    select?: ExamScoreSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ExamScore
     */
    omit?: ExamScoreOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamScoreInclude<ExtArgs> | null;
    /**
     * Filter, which ExamScore to fetch.
     */
    where?: ExamScoreWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ExamScores to fetch.
     */
    orderBy?:
      | ExamScoreOrderByWithRelationInput
      | ExamScoreOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ExamScores.
     */
    cursor?: ExamScoreWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ExamScores from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ExamScores.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ExamScores.
     */
    distinct?: ExamScoreScalarFieldEnum | ExamScoreScalarFieldEnum[];
  };

  /**
   * ExamScore findFirstOrThrow
   */
  export type ExamScoreFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ExamScore
     */
    select?: ExamScoreSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ExamScore
     */
    omit?: ExamScoreOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamScoreInclude<ExtArgs> | null;
    /**
     * Filter, which ExamScore to fetch.
     */
    where?: ExamScoreWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ExamScores to fetch.
     */
    orderBy?:
      | ExamScoreOrderByWithRelationInput
      | ExamScoreOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ExamScores.
     */
    cursor?: ExamScoreWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ExamScores from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ExamScores.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ExamScores.
     */
    distinct?: ExamScoreScalarFieldEnum | ExamScoreScalarFieldEnum[];
  };

  /**
   * ExamScore findMany
   */
  export type ExamScoreFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ExamScore
     */
    select?: ExamScoreSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ExamScore
     */
    omit?: ExamScoreOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamScoreInclude<ExtArgs> | null;
    /**
     * Filter, which ExamScores to fetch.
     */
    where?: ExamScoreWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ExamScores to fetch.
     */
    orderBy?:
      | ExamScoreOrderByWithRelationInput
      | ExamScoreOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing ExamScores.
     */
    cursor?: ExamScoreWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ExamScores from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ExamScores.
     */
    skip?: number;
    distinct?: ExamScoreScalarFieldEnum | ExamScoreScalarFieldEnum[];
  };

  /**
   * ExamScore create
   */
  export type ExamScoreCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ExamScore
     */
    select?: ExamScoreSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ExamScore
     */
    omit?: ExamScoreOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamScoreInclude<ExtArgs> | null;
    /**
     * The data needed to create a ExamScore.
     */
    data: XOR<ExamScoreCreateInput, ExamScoreUncheckedCreateInput>;
  };

  /**
   * ExamScore createMany
   */
  export type ExamScoreCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many ExamScores.
     */
    data: ExamScoreCreateManyInput | ExamScoreCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * ExamScore createManyAndReturn
   */
  export type ExamScoreCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ExamScore
     */
    select?: ExamScoreSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the ExamScore
     */
    omit?: ExamScoreOmit<ExtArgs> | null;
    /**
     * The data used to create many ExamScores.
     */
    data: ExamScoreCreateManyInput | ExamScoreCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamScoreIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * ExamScore update
   */
  export type ExamScoreUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ExamScore
     */
    select?: ExamScoreSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ExamScore
     */
    omit?: ExamScoreOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamScoreInclude<ExtArgs> | null;
    /**
     * The data needed to update a ExamScore.
     */
    data: XOR<ExamScoreUpdateInput, ExamScoreUncheckedUpdateInput>;
    /**
     * Choose, which ExamScore to update.
     */
    where: ExamScoreWhereUniqueInput;
  };

  /**
   * ExamScore updateMany
   */
  export type ExamScoreUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update ExamScores.
     */
    data: XOR<
      ExamScoreUpdateManyMutationInput,
      ExamScoreUncheckedUpdateManyInput
    >;
    /**
     * Filter which ExamScores to update
     */
    where?: ExamScoreWhereInput;
    /**
     * Limit how many ExamScores to update.
     */
    limit?: number;
  };

  /**
   * ExamScore updateManyAndReturn
   */
  export type ExamScoreUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ExamScore
     */
    select?: ExamScoreSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the ExamScore
     */
    omit?: ExamScoreOmit<ExtArgs> | null;
    /**
     * The data used to update ExamScores.
     */
    data: XOR<
      ExamScoreUpdateManyMutationInput,
      ExamScoreUncheckedUpdateManyInput
    >;
    /**
     * Filter which ExamScores to update
     */
    where?: ExamScoreWhereInput;
    /**
     * Limit how many ExamScores to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamScoreIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * ExamScore upsert
   */
  export type ExamScoreUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ExamScore
     */
    select?: ExamScoreSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ExamScore
     */
    omit?: ExamScoreOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamScoreInclude<ExtArgs> | null;
    /**
     * The filter to search for the ExamScore to update in case it exists.
     */
    where: ExamScoreWhereUniqueInput;
    /**
     * In case the ExamScore found by the `where` argument doesn't exist, create a new ExamScore with this data.
     */
    create: XOR<ExamScoreCreateInput, ExamScoreUncheckedCreateInput>;
    /**
     * In case the ExamScore was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExamScoreUpdateInput, ExamScoreUncheckedUpdateInput>;
  };

  /**
   * ExamScore delete
   */
  export type ExamScoreDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ExamScore
     */
    select?: ExamScoreSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ExamScore
     */
    omit?: ExamScoreOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamScoreInclude<ExtArgs> | null;
    /**
     * Filter which ExamScore to delete.
     */
    where: ExamScoreWhereUniqueInput;
  };

  /**
   * ExamScore deleteMany
   */
  export type ExamScoreDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which ExamScores to delete
     */
    where?: ExamScoreWhereInput;
    /**
     * Limit how many ExamScores to delete.
     */
    limit?: number;
  };

  /**
   * ExamScore without action
   */
  export type ExamScoreDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ExamScore
     */
    select?: ExamScoreSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ExamScore
     */
    omit?: ExamScoreOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamScoreInclude<ExtArgs> | null;
  };

  /**
   * Model Exam
   */

  export type AggregateExam = {
    _count: ExamCountAggregateOutputType | null;
    _min: ExamMinAggregateOutputType | null;
    _max: ExamMaxAggregateOutputType | null;
  };

  export type ExamMinAggregateOutputType = {
    id: string | null;
    examName: string | null;
    examType: $Enums.ExamType | null;
    classTermId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type ExamMaxAggregateOutputType = {
    id: string | null;
    examName: string | null;
    examType: $Enums.ExamType | null;
    classTermId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type ExamCountAggregateOutputType = {
    id: number;
    examName: number;
    examType: number;
    classTermId: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type ExamMinAggregateInputType = {
    id?: true;
    examName?: true;
    examType?: true;
    classTermId?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type ExamMaxAggregateInputType = {
    id?: true;
    examName?: true;
    examType?: true;
    classTermId?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type ExamCountAggregateInputType = {
    id?: true;
    examName?: true;
    examType?: true;
    classTermId?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type ExamAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Exam to aggregate.
     */
    where?: ExamWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Exams to fetch.
     */
    orderBy?: ExamOrderByWithRelationInput | ExamOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ExamWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Exams from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Exams.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Exams
     **/
    _count?: true | ExamCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ExamMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ExamMaxAggregateInputType;
  };

  export type GetExamAggregateType<T extends ExamAggregateArgs> = {
    [P in keyof T & keyof AggregateExam]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExam[P]>
      : GetScalarType<T[P], AggregateExam[P]>;
  };

  export type ExamGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ExamWhereInput;
    orderBy?:
      | ExamOrderByWithAggregationInput
      | ExamOrderByWithAggregationInput[];
    by: ExamScalarFieldEnum[] | ExamScalarFieldEnum;
    having?: ExamScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ExamCountAggregateInputType | true;
    _min?: ExamMinAggregateInputType;
    _max?: ExamMaxAggregateInputType;
  };

  export type ExamGroupByOutputType = {
    id: string;
    examName: string;
    examType: $Enums.ExamType;
    classTermId: string;
    createdAt: Date;
    updatedAt: Date;
    _count: ExamCountAggregateOutputType | null;
    _min: ExamMinAggregateOutputType | null;
    _max: ExamMaxAggregateOutputType | null;
  };

  type GetExamGroupByPayload<T extends ExamGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExamGroupByOutputType, T["by"]> & {
        [P in keyof T & keyof ExamGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], ExamGroupByOutputType[P]>
          : GetScalarType<T[P], ExamGroupByOutputType[P]>;
      }
    >
  >;

  export type ExamSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      examName?: boolean;
      examType?: boolean;
      classTermId?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      examSubjects?: boolean | Exam$examSubjectsArgs<ExtArgs>;
      classTerm?: boolean | ClassTermDefaultArgs<ExtArgs>;
      _count?: boolean | ExamCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["exam"]
  >;

  export type ExamSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      examName?: boolean;
      examType?: boolean;
      classTermId?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      classTerm?: boolean | ClassTermDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["exam"]
  >;

  export type ExamSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      examName?: boolean;
      examType?: boolean;
      classTermId?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      classTerm?: boolean | ClassTermDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["exam"]
  >;

  export type ExamSelectScalar = {
    id?: boolean;
    examName?: boolean;
    examType?: boolean;
    classTermId?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type ExamOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    "id" | "examName" | "examType" | "classTermId" | "createdAt" | "updatedAt",
    ExtArgs["result"]["exam"]
  >;
  export type ExamInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    examSubjects?: boolean | Exam$examSubjectsArgs<ExtArgs>;
    classTerm?: boolean | ClassTermDefaultArgs<ExtArgs>;
    _count?: boolean | ExamCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type ExamIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    classTerm?: boolean | ClassTermDefaultArgs<ExtArgs>;
  };
  export type ExamIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    classTerm?: boolean | ClassTermDefaultArgs<ExtArgs>;
  };

  export type $ExamPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "Exam";
    objects: {
      examSubjects: Prisma.$ExamSubjectPayload<ExtArgs>[];
      classTerm: Prisma.$ClassTermPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        examName: string;
        examType: $Enums.ExamType;
        classTermId: string;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs["result"]["exam"]
    >;
    composites: {};
  };

  type ExamGetPayload<S extends boolean | null | undefined | ExamDefaultArgs> =
    $Result.GetResult<Prisma.$ExamPayload, S>;

  type ExamCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<ExamFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
    select?: ExamCountAggregateInputType | true;
  };

  export interface ExamDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["Exam"];
      meta: { name: "Exam" };
    };
    /**
     * Find zero or one Exam that matches the filter.
     * @param {ExamFindUniqueArgs} args - Arguments to find a Exam
     * @example
     * // Get one Exam
     * const exam = await prisma.exam.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExamFindUniqueArgs>(
      args: SelectSubset<T, ExamFindUniqueArgs<ExtArgs>>,
    ): Prisma__ExamClient<
      $Result.GetResult<
        Prisma.$ExamPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Exam that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExamFindUniqueOrThrowArgs} args - Arguments to find a Exam
     * @example
     * // Get one Exam
     * const exam = await prisma.exam.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExamFindUniqueOrThrowArgs>(
      args: SelectSubset<T, ExamFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__ExamClient<
      $Result.GetResult<
        Prisma.$ExamPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Exam that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamFindFirstArgs} args - Arguments to find a Exam
     * @example
     * // Get one Exam
     * const exam = await prisma.exam.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExamFindFirstArgs>(
      args?: SelectSubset<T, ExamFindFirstArgs<ExtArgs>>,
    ): Prisma__ExamClient<
      $Result.GetResult<
        Prisma.$ExamPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Exam that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamFindFirstOrThrowArgs} args - Arguments to find a Exam
     * @example
     * // Get one Exam
     * const exam = await prisma.exam.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExamFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ExamFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__ExamClient<
      $Result.GetResult<
        Prisma.$ExamPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Exams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Exams
     * const exams = await prisma.exam.findMany()
     *
     * // Get first 10 Exams
     * const exams = await prisma.exam.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const examWithIdOnly = await prisma.exam.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ExamFindManyArgs>(
      args?: SelectSubset<T, ExamFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ExamPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Exam.
     * @param {ExamCreateArgs} args - Arguments to create a Exam.
     * @example
     * // Create one Exam
     * const Exam = await prisma.exam.create({
     *   data: {
     *     // ... data to create a Exam
     *   }
     * })
     *
     */
    create<T extends ExamCreateArgs>(
      args: SelectSubset<T, ExamCreateArgs<ExtArgs>>,
    ): Prisma__ExamClient<
      $Result.GetResult<
        Prisma.$ExamPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Exams.
     * @param {ExamCreateManyArgs} args - Arguments to create many Exams.
     * @example
     * // Create many Exams
     * const exam = await prisma.exam.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ExamCreateManyArgs>(
      args?: SelectSubset<T, ExamCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Exams and returns the data saved in the database.
     * @param {ExamCreateManyAndReturnArgs} args - Arguments to create many Exams.
     * @example
     * // Create many Exams
     * const exam = await prisma.exam.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Exams and only return the `id`
     * const examWithIdOnly = await prisma.exam.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends ExamCreateManyAndReturnArgs>(
      args?: SelectSubset<T, ExamCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ExamPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Exam.
     * @param {ExamDeleteArgs} args - Arguments to delete one Exam.
     * @example
     * // Delete one Exam
     * const Exam = await prisma.exam.delete({
     *   where: {
     *     // ... filter to delete one Exam
     *   }
     * })
     *
     */
    delete<T extends ExamDeleteArgs>(
      args: SelectSubset<T, ExamDeleteArgs<ExtArgs>>,
    ): Prisma__ExamClient<
      $Result.GetResult<
        Prisma.$ExamPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Exam.
     * @param {ExamUpdateArgs} args - Arguments to update one Exam.
     * @example
     * // Update one Exam
     * const exam = await prisma.exam.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ExamUpdateArgs>(
      args: SelectSubset<T, ExamUpdateArgs<ExtArgs>>,
    ): Prisma__ExamClient<
      $Result.GetResult<
        Prisma.$ExamPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Exams.
     * @param {ExamDeleteManyArgs} args - Arguments to filter Exams to delete.
     * @example
     * // Delete a few Exams
     * const { count } = await prisma.exam.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ExamDeleteManyArgs>(
      args?: SelectSubset<T, ExamDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Exams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Exams
     * const exam = await prisma.exam.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ExamUpdateManyArgs>(
      args: SelectSubset<T, ExamUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Exams and returns the data updated in the database.
     * @param {ExamUpdateManyAndReturnArgs} args - Arguments to update many Exams.
     * @example
     * // Update many Exams
     * const exam = await prisma.exam.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Exams and only return the `id`
     * const examWithIdOnly = await prisma.exam.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends ExamUpdateManyAndReturnArgs>(
      args: SelectSubset<T, ExamUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ExamPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Exam.
     * @param {ExamUpsertArgs} args - Arguments to update or create a Exam.
     * @example
     * // Update or create a Exam
     * const exam = await prisma.exam.upsert({
     *   create: {
     *     // ... data to create a Exam
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Exam we want to update
     *   }
     * })
     */
    upsert<T extends ExamUpsertArgs>(
      args: SelectSubset<T, ExamUpsertArgs<ExtArgs>>,
    ): Prisma__ExamClient<
      $Result.GetResult<
        Prisma.$ExamPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Exams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamCountArgs} args - Arguments to filter Exams to count.
     * @example
     * // Count the number of Exams
     * const count = await prisma.exam.count({
     *   where: {
     *     // ... the filter for the Exams we want to count
     *   }
     * })
     **/
    count<T extends ExamCountArgs>(
      args?: Subset<T, ExamCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], ExamCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Exam.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ExamAggregateArgs>(
      args: Subset<T, ExamAggregateArgs>,
    ): Prisma.PrismaPromise<GetExamAggregateType<T>>;

    /**
     * Group by Exam.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends ExamGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExamGroupByArgs["orderBy"] }
        : { orderBy?: ExamGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, ExamGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetExamGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Exam model
     */
    readonly fields: ExamFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Exam.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExamClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    examSubjects<T extends Exam$examSubjectsArgs<ExtArgs> = {}>(
      args?: Subset<T, Exam$examSubjectsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$ExamSubjectPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    classTerm<T extends ClassTermDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, ClassTermDefaultArgs<ExtArgs>>,
    ): Prisma__ClassTermClient<
      | $Result.GetResult<
          Prisma.$ClassTermPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Exam model
   */
  interface ExamFieldRefs {
    readonly id: FieldRef<"Exam", "String">;
    readonly examName: FieldRef<"Exam", "String">;
    readonly examType: FieldRef<"Exam", "ExamType">;
    readonly classTermId: FieldRef<"Exam", "String">;
    readonly createdAt: FieldRef<"Exam", "DateTime">;
    readonly updatedAt: FieldRef<"Exam", "DateTime">;
  }

  // Custom InputTypes
  /**
   * Exam findUnique
   */
  export type ExamFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null;
    /**
     * Filter, which Exam to fetch.
     */
    where: ExamWhereUniqueInput;
  };

  /**
   * Exam findUniqueOrThrow
   */
  export type ExamFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null;
    /**
     * Filter, which Exam to fetch.
     */
    where: ExamWhereUniqueInput;
  };

  /**
   * Exam findFirst
   */
  export type ExamFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null;
    /**
     * Filter, which Exam to fetch.
     */
    where?: ExamWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Exams to fetch.
     */
    orderBy?: ExamOrderByWithRelationInput | ExamOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Exams.
     */
    cursor?: ExamWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Exams from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Exams.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Exams.
     */
    distinct?: ExamScalarFieldEnum | ExamScalarFieldEnum[];
  };

  /**
   * Exam findFirstOrThrow
   */
  export type ExamFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null;
    /**
     * Filter, which Exam to fetch.
     */
    where?: ExamWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Exams to fetch.
     */
    orderBy?: ExamOrderByWithRelationInput | ExamOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Exams.
     */
    cursor?: ExamWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Exams from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Exams.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Exams.
     */
    distinct?: ExamScalarFieldEnum | ExamScalarFieldEnum[];
  };

  /**
   * Exam findMany
   */
  export type ExamFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null;
    /**
     * Filter, which Exams to fetch.
     */
    where?: ExamWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Exams to fetch.
     */
    orderBy?: ExamOrderByWithRelationInput | ExamOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Exams.
     */
    cursor?: ExamWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Exams from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Exams.
     */
    skip?: number;
    distinct?: ExamScalarFieldEnum | ExamScalarFieldEnum[];
  };

  /**
   * Exam create
   */
  export type ExamCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null;
    /**
     * The data needed to create a Exam.
     */
    data: XOR<ExamCreateInput, ExamUncheckedCreateInput>;
  };

  /**
   * Exam createMany
   */
  export type ExamCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Exams.
     */
    data: ExamCreateManyInput | ExamCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Exam createManyAndReturn
   */
  export type ExamCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null;
    /**
     * The data used to create many Exams.
     */
    data: ExamCreateManyInput | ExamCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Exam update
   */
  export type ExamUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null;
    /**
     * The data needed to update a Exam.
     */
    data: XOR<ExamUpdateInput, ExamUncheckedUpdateInput>;
    /**
     * Choose, which Exam to update.
     */
    where: ExamWhereUniqueInput;
  };

  /**
   * Exam updateMany
   */
  export type ExamUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Exams.
     */
    data: XOR<ExamUpdateManyMutationInput, ExamUncheckedUpdateManyInput>;
    /**
     * Filter which Exams to update
     */
    where?: ExamWhereInput;
    /**
     * Limit how many Exams to update.
     */
    limit?: number;
  };

  /**
   * Exam updateManyAndReturn
   */
  export type ExamUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null;
    /**
     * The data used to update Exams.
     */
    data: XOR<ExamUpdateManyMutationInput, ExamUncheckedUpdateManyInput>;
    /**
     * Filter which Exams to update
     */
    where?: ExamWhereInput;
    /**
     * Limit how many Exams to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Exam upsert
   */
  export type ExamUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null;
    /**
     * The filter to search for the Exam to update in case it exists.
     */
    where: ExamWhereUniqueInput;
    /**
     * In case the Exam found by the `where` argument doesn't exist, create a new Exam with this data.
     */
    create: XOR<ExamCreateInput, ExamUncheckedCreateInput>;
    /**
     * In case the Exam was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExamUpdateInput, ExamUncheckedUpdateInput>;
  };

  /**
   * Exam delete
   */
  export type ExamDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null;
    /**
     * Filter which Exam to delete.
     */
    where: ExamWhereUniqueInput;
  };

  /**
   * Exam deleteMany
   */
  export type ExamDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Exams to delete
     */
    where?: ExamWhereInput;
    /**
     * Limit how many Exams to delete.
     */
    limit?: number;
  };

  /**
   * Exam.examSubjects
   */
  export type Exam$examSubjectsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ExamSubject
     */
    select?: ExamSubjectSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ExamSubject
     */
    omit?: ExamSubjectOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamSubjectInclude<ExtArgs> | null;
    where?: ExamSubjectWhereInput;
    orderBy?:
      | ExamSubjectOrderByWithRelationInput
      | ExamSubjectOrderByWithRelationInput[];
    cursor?: ExamSubjectWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ExamSubjectScalarFieldEnum | ExamSubjectScalarFieldEnum[];
  };

  /**
   * Exam without action
   */
  export type ExamDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null;
  };

  /**
   * Model ExamSubject
   */

  export type AggregateExamSubject = {
    _count: ExamSubjectCountAggregateOutputType | null;
    _min: ExamSubjectMinAggregateOutputType | null;
    _max: ExamSubjectMaxAggregateOutputType | null;
  };

  export type ExamSubjectMinAggregateOutputType = {
    id: string | null;
    examId: string | null;
    examDate: Date | null;
    academicYearSubjectId: string | null;
  };

  export type ExamSubjectMaxAggregateOutputType = {
    id: string | null;
    examId: string | null;
    examDate: Date | null;
    academicYearSubjectId: string | null;
  };

  export type ExamSubjectCountAggregateOutputType = {
    id: number;
    examId: number;
    examDate: number;
    academicYearSubjectId: number;
    _all: number;
  };

  export type ExamSubjectMinAggregateInputType = {
    id?: true;
    examId?: true;
    examDate?: true;
    academicYearSubjectId?: true;
  };

  export type ExamSubjectMaxAggregateInputType = {
    id?: true;
    examId?: true;
    examDate?: true;
    academicYearSubjectId?: true;
  };

  export type ExamSubjectCountAggregateInputType = {
    id?: true;
    examId?: true;
    examDate?: true;
    academicYearSubjectId?: true;
    _all?: true;
  };

  export type ExamSubjectAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which ExamSubject to aggregate.
     */
    where?: ExamSubjectWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ExamSubjects to fetch.
     */
    orderBy?:
      | ExamSubjectOrderByWithRelationInput
      | ExamSubjectOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ExamSubjectWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ExamSubjects from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ExamSubjects.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned ExamSubjects
     **/
    _count?: true | ExamSubjectCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ExamSubjectMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ExamSubjectMaxAggregateInputType;
  };

  export type GetExamSubjectAggregateType<T extends ExamSubjectAggregateArgs> =
    {
      [P in keyof T & keyof AggregateExamSubject]: P extends "_count" | "count"
        ? T[P] extends true
          ? number
          : GetScalarType<T[P], AggregateExamSubject[P]>
        : GetScalarType<T[P], AggregateExamSubject[P]>;
    };

  export type ExamSubjectGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ExamSubjectWhereInput;
    orderBy?:
      | ExamSubjectOrderByWithAggregationInput
      | ExamSubjectOrderByWithAggregationInput[];
    by: ExamSubjectScalarFieldEnum[] | ExamSubjectScalarFieldEnum;
    having?: ExamSubjectScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ExamSubjectCountAggregateInputType | true;
    _min?: ExamSubjectMinAggregateInputType;
    _max?: ExamSubjectMaxAggregateInputType;
  };

  export type ExamSubjectGroupByOutputType = {
    id: string;
    examId: string;
    examDate: Date;
    academicYearSubjectId: string;
    _count: ExamSubjectCountAggregateOutputType | null;
    _min: ExamSubjectMinAggregateOutputType | null;
    _max: ExamSubjectMaxAggregateOutputType | null;
  };

  type GetExamSubjectGroupByPayload<T extends ExamSubjectGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<ExamSubjectGroupByOutputType, T["by"]> & {
          [P in keyof T &
            keyof ExamSubjectGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExamSubjectGroupByOutputType[P]>
            : GetScalarType<T[P], ExamSubjectGroupByOutputType[P]>;
        }
      >
    >;

  export type ExamSubjectSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      examId?: boolean;
      examDate?: boolean;
      academicYearSubjectId?: boolean;
      exam?: boolean | ExamDefaultArgs<ExtArgs>;
      academicYearSubject?: boolean | AcademicYearSubjectDefaultArgs<ExtArgs>;
      examScores?: boolean | ExamSubject$examScoresArgs<ExtArgs>;
      _count?: boolean | ExamSubjectCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["examSubject"]
  >;

  export type ExamSubjectSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      examId?: boolean;
      examDate?: boolean;
      academicYearSubjectId?: boolean;
      exam?: boolean | ExamDefaultArgs<ExtArgs>;
      academicYearSubject?: boolean | AcademicYearSubjectDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["examSubject"]
  >;

  export type ExamSubjectSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      examId?: boolean;
      examDate?: boolean;
      academicYearSubjectId?: boolean;
      exam?: boolean | ExamDefaultArgs<ExtArgs>;
      academicYearSubject?: boolean | AcademicYearSubjectDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["examSubject"]
  >;

  export type ExamSubjectSelectScalar = {
    id?: boolean;
    examId?: boolean;
    examDate?: boolean;
    academicYearSubjectId?: boolean;
  };

  export type ExamSubjectOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    "id" | "examId" | "examDate" | "academicYearSubjectId",
    ExtArgs["result"]["examSubject"]
  >;
  export type ExamSubjectInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    exam?: boolean | ExamDefaultArgs<ExtArgs>;
    academicYearSubject?: boolean | AcademicYearSubjectDefaultArgs<ExtArgs>;
    examScores?: boolean | ExamSubject$examScoresArgs<ExtArgs>;
    _count?: boolean | ExamSubjectCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type ExamSubjectIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    exam?: boolean | ExamDefaultArgs<ExtArgs>;
    academicYearSubject?: boolean | AcademicYearSubjectDefaultArgs<ExtArgs>;
  };
  export type ExamSubjectIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    exam?: boolean | ExamDefaultArgs<ExtArgs>;
    academicYearSubject?: boolean | AcademicYearSubjectDefaultArgs<ExtArgs>;
  };

  export type $ExamSubjectPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "ExamSubject";
    objects: {
      exam: Prisma.$ExamPayload<ExtArgs>;
      academicYearSubject: Prisma.$AcademicYearSubjectPayload<ExtArgs>;
      examScores: Prisma.$ExamScorePayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        examId: string;
        examDate: Date;
        academicYearSubjectId: string;
      },
      ExtArgs["result"]["examSubject"]
    >;
    composites: {};
  };

  type ExamSubjectGetPayload<
    S extends boolean | null | undefined | ExamSubjectDefaultArgs,
  > = $Result.GetResult<Prisma.$ExamSubjectPayload, S>;

  type ExamSubjectCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    ExamSubjectFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: ExamSubjectCountAggregateInputType | true;
  };

  export interface ExamSubjectDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["ExamSubject"];
      meta: { name: "ExamSubject" };
    };
    /**
     * Find zero or one ExamSubject that matches the filter.
     * @param {ExamSubjectFindUniqueArgs} args - Arguments to find a ExamSubject
     * @example
     * // Get one ExamSubject
     * const examSubject = await prisma.examSubject.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExamSubjectFindUniqueArgs>(
      args: SelectSubset<T, ExamSubjectFindUniqueArgs<ExtArgs>>,
    ): Prisma__ExamSubjectClient<
      $Result.GetResult<
        Prisma.$ExamSubjectPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one ExamSubject that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExamSubjectFindUniqueOrThrowArgs} args - Arguments to find a ExamSubject
     * @example
     * // Get one ExamSubject
     * const examSubject = await prisma.examSubject.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExamSubjectFindUniqueOrThrowArgs>(
      args: SelectSubset<T, ExamSubjectFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__ExamSubjectClient<
      $Result.GetResult<
        Prisma.$ExamSubjectPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first ExamSubject that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamSubjectFindFirstArgs} args - Arguments to find a ExamSubject
     * @example
     * // Get one ExamSubject
     * const examSubject = await prisma.examSubject.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExamSubjectFindFirstArgs>(
      args?: SelectSubset<T, ExamSubjectFindFirstArgs<ExtArgs>>,
    ): Prisma__ExamSubjectClient<
      $Result.GetResult<
        Prisma.$ExamSubjectPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first ExamSubject that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamSubjectFindFirstOrThrowArgs} args - Arguments to find a ExamSubject
     * @example
     * // Get one ExamSubject
     * const examSubject = await prisma.examSubject.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExamSubjectFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ExamSubjectFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__ExamSubjectClient<
      $Result.GetResult<
        Prisma.$ExamSubjectPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more ExamSubjects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamSubjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExamSubjects
     * const examSubjects = await prisma.examSubject.findMany()
     *
     * // Get first 10 ExamSubjects
     * const examSubjects = await prisma.examSubject.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const examSubjectWithIdOnly = await prisma.examSubject.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ExamSubjectFindManyArgs>(
      args?: SelectSubset<T, ExamSubjectFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ExamSubjectPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a ExamSubject.
     * @param {ExamSubjectCreateArgs} args - Arguments to create a ExamSubject.
     * @example
     * // Create one ExamSubject
     * const ExamSubject = await prisma.examSubject.create({
     *   data: {
     *     // ... data to create a ExamSubject
     *   }
     * })
     *
     */
    create<T extends ExamSubjectCreateArgs>(
      args: SelectSubset<T, ExamSubjectCreateArgs<ExtArgs>>,
    ): Prisma__ExamSubjectClient<
      $Result.GetResult<
        Prisma.$ExamSubjectPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many ExamSubjects.
     * @param {ExamSubjectCreateManyArgs} args - Arguments to create many ExamSubjects.
     * @example
     * // Create many ExamSubjects
     * const examSubject = await prisma.examSubject.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ExamSubjectCreateManyArgs>(
      args?: SelectSubset<T, ExamSubjectCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many ExamSubjects and returns the data saved in the database.
     * @param {ExamSubjectCreateManyAndReturnArgs} args - Arguments to create many ExamSubjects.
     * @example
     * // Create many ExamSubjects
     * const examSubject = await prisma.examSubject.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many ExamSubjects and only return the `id`
     * const examSubjectWithIdOnly = await prisma.examSubject.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends ExamSubjectCreateManyAndReturnArgs>(
      args?: SelectSubset<T, ExamSubjectCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ExamSubjectPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a ExamSubject.
     * @param {ExamSubjectDeleteArgs} args - Arguments to delete one ExamSubject.
     * @example
     * // Delete one ExamSubject
     * const ExamSubject = await prisma.examSubject.delete({
     *   where: {
     *     // ... filter to delete one ExamSubject
     *   }
     * })
     *
     */
    delete<T extends ExamSubjectDeleteArgs>(
      args: SelectSubset<T, ExamSubjectDeleteArgs<ExtArgs>>,
    ): Prisma__ExamSubjectClient<
      $Result.GetResult<
        Prisma.$ExamSubjectPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one ExamSubject.
     * @param {ExamSubjectUpdateArgs} args - Arguments to update one ExamSubject.
     * @example
     * // Update one ExamSubject
     * const examSubject = await prisma.examSubject.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ExamSubjectUpdateArgs>(
      args: SelectSubset<T, ExamSubjectUpdateArgs<ExtArgs>>,
    ): Prisma__ExamSubjectClient<
      $Result.GetResult<
        Prisma.$ExamSubjectPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more ExamSubjects.
     * @param {ExamSubjectDeleteManyArgs} args - Arguments to filter ExamSubjects to delete.
     * @example
     * // Delete a few ExamSubjects
     * const { count } = await prisma.examSubject.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ExamSubjectDeleteManyArgs>(
      args?: SelectSubset<T, ExamSubjectDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more ExamSubjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamSubjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExamSubjects
     * const examSubject = await prisma.examSubject.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ExamSubjectUpdateManyArgs>(
      args: SelectSubset<T, ExamSubjectUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more ExamSubjects and returns the data updated in the database.
     * @param {ExamSubjectUpdateManyAndReturnArgs} args - Arguments to update many ExamSubjects.
     * @example
     * // Update many ExamSubjects
     * const examSubject = await prisma.examSubject.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more ExamSubjects and only return the `id`
     * const examSubjectWithIdOnly = await prisma.examSubject.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends ExamSubjectUpdateManyAndReturnArgs>(
      args: SelectSubset<T, ExamSubjectUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ExamSubjectPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one ExamSubject.
     * @param {ExamSubjectUpsertArgs} args - Arguments to update or create a ExamSubject.
     * @example
     * // Update or create a ExamSubject
     * const examSubject = await prisma.examSubject.upsert({
     *   create: {
     *     // ... data to create a ExamSubject
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExamSubject we want to update
     *   }
     * })
     */
    upsert<T extends ExamSubjectUpsertArgs>(
      args: SelectSubset<T, ExamSubjectUpsertArgs<ExtArgs>>,
    ): Prisma__ExamSubjectClient<
      $Result.GetResult<
        Prisma.$ExamSubjectPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of ExamSubjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamSubjectCountArgs} args - Arguments to filter ExamSubjects to count.
     * @example
     * // Count the number of ExamSubjects
     * const count = await prisma.examSubject.count({
     *   where: {
     *     // ... the filter for the ExamSubjects we want to count
     *   }
     * })
     **/
    count<T extends ExamSubjectCountArgs>(
      args?: Subset<T, ExamSubjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], ExamSubjectCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a ExamSubject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamSubjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ExamSubjectAggregateArgs>(
      args: Subset<T, ExamSubjectAggregateArgs>,
    ): Prisma.PrismaPromise<GetExamSubjectAggregateType<T>>;

    /**
     * Group by ExamSubject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamSubjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends ExamSubjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExamSubjectGroupByArgs["orderBy"] }
        : { orderBy?: ExamSubjectGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, ExamSubjectGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetExamSubjectGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the ExamSubject model
     */
    readonly fields: ExamSubjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExamSubject.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExamSubjectClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    exam<T extends ExamDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, ExamDefaultArgs<ExtArgs>>,
    ): Prisma__ExamClient<
      | $Result.GetResult<
          Prisma.$ExamPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    academicYearSubject<T extends AcademicYearSubjectDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, AcademicYearSubjectDefaultArgs<ExtArgs>>,
    ): Prisma__AcademicYearSubjectClient<
      | $Result.GetResult<
          Prisma.$AcademicYearSubjectPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    examScores<T extends ExamSubject$examScoresArgs<ExtArgs> = {}>(
      args?: Subset<T, ExamSubject$examScoresArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$ExamScorePayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the ExamSubject model
   */
  interface ExamSubjectFieldRefs {
    readonly id: FieldRef<"ExamSubject", "String">;
    readonly examId: FieldRef<"ExamSubject", "String">;
    readonly examDate: FieldRef<"ExamSubject", "DateTime">;
    readonly academicYearSubjectId: FieldRef<"ExamSubject", "String">;
  }

  // Custom InputTypes
  /**
   * ExamSubject findUnique
   */
  export type ExamSubjectFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ExamSubject
     */
    select?: ExamSubjectSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ExamSubject
     */
    omit?: ExamSubjectOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamSubjectInclude<ExtArgs> | null;
    /**
     * Filter, which ExamSubject to fetch.
     */
    where: ExamSubjectWhereUniqueInput;
  };

  /**
   * ExamSubject findUniqueOrThrow
   */
  export type ExamSubjectFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ExamSubject
     */
    select?: ExamSubjectSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ExamSubject
     */
    omit?: ExamSubjectOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamSubjectInclude<ExtArgs> | null;
    /**
     * Filter, which ExamSubject to fetch.
     */
    where: ExamSubjectWhereUniqueInput;
  };

  /**
   * ExamSubject findFirst
   */
  export type ExamSubjectFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ExamSubject
     */
    select?: ExamSubjectSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ExamSubject
     */
    omit?: ExamSubjectOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamSubjectInclude<ExtArgs> | null;
    /**
     * Filter, which ExamSubject to fetch.
     */
    where?: ExamSubjectWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ExamSubjects to fetch.
     */
    orderBy?:
      | ExamSubjectOrderByWithRelationInput
      | ExamSubjectOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ExamSubjects.
     */
    cursor?: ExamSubjectWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ExamSubjects from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ExamSubjects.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ExamSubjects.
     */
    distinct?: ExamSubjectScalarFieldEnum | ExamSubjectScalarFieldEnum[];
  };

  /**
   * ExamSubject findFirstOrThrow
   */
  export type ExamSubjectFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ExamSubject
     */
    select?: ExamSubjectSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ExamSubject
     */
    omit?: ExamSubjectOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamSubjectInclude<ExtArgs> | null;
    /**
     * Filter, which ExamSubject to fetch.
     */
    where?: ExamSubjectWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ExamSubjects to fetch.
     */
    orderBy?:
      | ExamSubjectOrderByWithRelationInput
      | ExamSubjectOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ExamSubjects.
     */
    cursor?: ExamSubjectWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ExamSubjects from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ExamSubjects.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ExamSubjects.
     */
    distinct?: ExamSubjectScalarFieldEnum | ExamSubjectScalarFieldEnum[];
  };

  /**
   * ExamSubject findMany
   */
  export type ExamSubjectFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ExamSubject
     */
    select?: ExamSubjectSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ExamSubject
     */
    omit?: ExamSubjectOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamSubjectInclude<ExtArgs> | null;
    /**
     * Filter, which ExamSubjects to fetch.
     */
    where?: ExamSubjectWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ExamSubjects to fetch.
     */
    orderBy?:
      | ExamSubjectOrderByWithRelationInput
      | ExamSubjectOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing ExamSubjects.
     */
    cursor?: ExamSubjectWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ExamSubjects from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ExamSubjects.
     */
    skip?: number;
    distinct?: ExamSubjectScalarFieldEnum | ExamSubjectScalarFieldEnum[];
  };

  /**
   * ExamSubject create
   */
  export type ExamSubjectCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ExamSubject
     */
    select?: ExamSubjectSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ExamSubject
     */
    omit?: ExamSubjectOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamSubjectInclude<ExtArgs> | null;
    /**
     * The data needed to create a ExamSubject.
     */
    data: XOR<ExamSubjectCreateInput, ExamSubjectUncheckedCreateInput>;
  };

  /**
   * ExamSubject createMany
   */
  export type ExamSubjectCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many ExamSubjects.
     */
    data: ExamSubjectCreateManyInput | ExamSubjectCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * ExamSubject createManyAndReturn
   */
  export type ExamSubjectCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ExamSubject
     */
    select?: ExamSubjectSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the ExamSubject
     */
    omit?: ExamSubjectOmit<ExtArgs> | null;
    /**
     * The data used to create many ExamSubjects.
     */
    data: ExamSubjectCreateManyInput | ExamSubjectCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamSubjectIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * ExamSubject update
   */
  export type ExamSubjectUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ExamSubject
     */
    select?: ExamSubjectSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ExamSubject
     */
    omit?: ExamSubjectOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamSubjectInclude<ExtArgs> | null;
    /**
     * The data needed to update a ExamSubject.
     */
    data: XOR<ExamSubjectUpdateInput, ExamSubjectUncheckedUpdateInput>;
    /**
     * Choose, which ExamSubject to update.
     */
    where: ExamSubjectWhereUniqueInput;
  };

  /**
   * ExamSubject updateMany
   */
  export type ExamSubjectUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update ExamSubjects.
     */
    data: XOR<
      ExamSubjectUpdateManyMutationInput,
      ExamSubjectUncheckedUpdateManyInput
    >;
    /**
     * Filter which ExamSubjects to update
     */
    where?: ExamSubjectWhereInput;
    /**
     * Limit how many ExamSubjects to update.
     */
    limit?: number;
  };

  /**
   * ExamSubject updateManyAndReturn
   */
  export type ExamSubjectUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ExamSubject
     */
    select?: ExamSubjectSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the ExamSubject
     */
    omit?: ExamSubjectOmit<ExtArgs> | null;
    /**
     * The data used to update ExamSubjects.
     */
    data: XOR<
      ExamSubjectUpdateManyMutationInput,
      ExamSubjectUncheckedUpdateManyInput
    >;
    /**
     * Filter which ExamSubjects to update
     */
    where?: ExamSubjectWhereInput;
    /**
     * Limit how many ExamSubjects to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamSubjectIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * ExamSubject upsert
   */
  export type ExamSubjectUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ExamSubject
     */
    select?: ExamSubjectSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ExamSubject
     */
    omit?: ExamSubjectOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamSubjectInclude<ExtArgs> | null;
    /**
     * The filter to search for the ExamSubject to update in case it exists.
     */
    where: ExamSubjectWhereUniqueInput;
    /**
     * In case the ExamSubject found by the `where` argument doesn't exist, create a new ExamSubject with this data.
     */
    create: XOR<ExamSubjectCreateInput, ExamSubjectUncheckedCreateInput>;
    /**
     * In case the ExamSubject was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExamSubjectUpdateInput, ExamSubjectUncheckedUpdateInput>;
  };

  /**
   * ExamSubject delete
   */
  export type ExamSubjectDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ExamSubject
     */
    select?: ExamSubjectSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ExamSubject
     */
    omit?: ExamSubjectOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamSubjectInclude<ExtArgs> | null;
    /**
     * Filter which ExamSubject to delete.
     */
    where: ExamSubjectWhereUniqueInput;
  };

  /**
   * ExamSubject deleteMany
   */
  export type ExamSubjectDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which ExamSubjects to delete
     */
    where?: ExamSubjectWhereInput;
    /**
     * Limit how many ExamSubjects to delete.
     */
    limit?: number;
  };

  /**
   * ExamSubject.examScores
   */
  export type ExamSubject$examScoresArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ExamScore
     */
    select?: ExamScoreSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ExamScore
     */
    omit?: ExamScoreOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamScoreInclude<ExtArgs> | null;
    where?: ExamScoreWhereInput;
    orderBy?:
      | ExamScoreOrderByWithRelationInput
      | ExamScoreOrderByWithRelationInput[];
    cursor?: ExamScoreWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ExamScoreScalarFieldEnum | ExamScoreScalarFieldEnum[];
  };

  /**
   * ExamSubject without action
   */
  export type ExamSubjectDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ExamSubject
     */
    select?: ExamSubjectSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ExamSubject
     */
    omit?: ExamSubjectOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamSubjectInclude<ExtArgs> | null;
  };

  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: "ReadUncommitted";
    ReadCommitted: "ReadCommitted";
    RepeatableRead: "RepeatableRead";
    Serializable: "Serializable";
  };

  export type TransactionIsolationLevel =
    (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel];

  export const UserScalarFieldEnum: {
    id: "id";
    name: "name";
    username: "username";
    email: "email";
    avatarUrl: "avatarUrl";
    role: "role";
    createdAt: "createdAt";
    telephone: "telephone";
    passwordHash: "passwordHash";
    googleId: "googleId";
    bio: "bio";
    isWelcomed: "isWelcomed";
    isVerified: "isVerified";
    emailVerified: "emailVerified";
  };

  export type UserScalarFieldEnum =
    (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum];

  export const EmailVerificationTokenScalarFieldEnum: {
    id: "id";
    userId: "userId";
    expires: "expires";
  };

  export type EmailVerificationTokenScalarFieldEnum =
    (typeof EmailVerificationTokenScalarFieldEnum)[keyof typeof EmailVerificationTokenScalarFieldEnum];

  export const PupilScalarFieldEnum: {
    id: "id";
    userId: "userId";
    genericPassword: "genericPassword";
  };

  export type PupilScalarFieldEnum =
    (typeof PupilScalarFieldEnum)[keyof typeof PupilScalarFieldEnum];

  export const StaffScalarFieldEnum: {
    id: "id";
    staffType: "staffType";
    userId: "userId";
    genericPassword: "genericPassword";
  };

  export type StaffScalarFieldEnum =
    (typeof StaffScalarFieldEnum)[keyof typeof StaffScalarFieldEnum];

  export const LevelScalarFieldEnum: {
    id: "id";
    name: "name";
    slug: "slug";
  };

  export type LevelScalarFieldEnum =
    (typeof LevelScalarFieldEnum)[keyof typeof LevelScalarFieldEnum];

  export const StreamScalarFieldEnum: {
    id: "id";
    name: "name";
  };

  export type StreamScalarFieldEnum =
    (typeof StreamScalarFieldEnum)[keyof typeof StreamScalarFieldEnum];

  export const ClassScalarFieldEnum: {
    id: "id";
    name: "name";
    levelId: "levelId";
    createdAt: "createdAt";
    slug: "slug";
  };

  export type ClassScalarFieldEnum =
    (typeof ClassScalarFieldEnum)[keyof typeof ClassScalarFieldEnum];

  export const AcademicYearScalarFieldEnum: {
    id: "id";
    year: "year";
    startAt: "startAt";
    endAt: "endAt";
  };

  export type AcademicYearScalarFieldEnum =
    (typeof AcademicYearScalarFieldEnum)[keyof typeof AcademicYearScalarFieldEnum];

  export const AcademicYearClassScalarFieldEnum: {
    id: "id";
    academicYearId: "academicYearId";
    classId: "classId";
  };

  export type AcademicYearClassScalarFieldEnum =
    (typeof AcademicYearClassScalarFieldEnum)[keyof typeof AcademicYearClassScalarFieldEnum];

  export const SubjectScalarFieldEnum: {
    id: "id";
    subjectName: "subjectName";
    slug: "slug";
    code: "code";
    levelId: "levelId";
  };

  export type SubjectScalarFieldEnum =
    (typeof SubjectScalarFieldEnum)[keyof typeof SubjectScalarFieldEnum];

  export const GradingScalarFieldEnum: {
    id: "id";
    from: "from";
    to: "to";
    grade: "grade";
    remarks: "remarks";
  };

  export type GradingScalarFieldEnum =
    (typeof GradingScalarFieldEnum)[keyof typeof GradingScalarFieldEnum];

  export const AcademicYearSubjectScalarFieldEnum: {
    id: "id";
    academicYearClassId: "academicYearClassId";
    subjectId: "subjectId";
  };

  export type AcademicYearSubjectScalarFieldEnum =
    (typeof AcademicYearSubjectScalarFieldEnum)[keyof typeof AcademicYearSubjectScalarFieldEnum];

  export const ClassStreamScalarFieldEnum: {
    id: "id";
    staffId: "staffId";
    classId: "classId";
    streamId: "streamId";
  };

  export type ClassStreamScalarFieldEnum =
    (typeof ClassStreamScalarFieldEnum)[keyof typeof ClassStreamScalarFieldEnum];

  export const TermScalarFieldEnum: {
    id: "id";
    term: "term";
    slug: "slug";
  };

  export type TermScalarFieldEnum =
    (typeof TermScalarFieldEnum)[keyof typeof TermScalarFieldEnum];

  export const ClassTermScalarFieldEnum: {
    id: "id";
    startAt: "startAt";
    endAt: "endAt";
    termId: "termId";
    classStreamId: "classStreamId";
    feesAmount: "feesAmount";
  };

  export type ClassTermScalarFieldEnum =
    (typeof ClassTermScalarFieldEnum)[keyof typeof ClassTermScalarFieldEnum];

  export const FeesScalarFieldEnum: {
    id: "id";
    pupilId: "pupilId";
    balance: "balance";
    termId: "termId";
    status: "status";
  };

  export type FeesScalarFieldEnum =
    (typeof FeesScalarFieldEnum)[keyof typeof FeesScalarFieldEnum];

  export const FeesPaymentScalarFieldEnum: {
    id: "id";
    amountPaid: "amountPaid";
    createdAt: "createdAt";
    updatedAt: "updatedAt";
    feesId: "feesId";
    userId: "userId";
  };

  export type FeesPaymentScalarFieldEnum =
    (typeof FeesPaymentScalarFieldEnum)[keyof typeof FeesPaymentScalarFieldEnum];

  export const SessionScalarFieldEnum: {
    id: "id";
    userId: "userId";
    expiresAt: "expiresAt";
    role: "role";
  };

  export type SessionScalarFieldEnum =
    (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum];

  export const AssetScalarFieldEnum: {
    id: "id";
    name: "name";
    description: "description";
    category: "category";
    createdAt: "createdAt";
    updatedAt: "updatedAt";
  };

  export type AssetScalarFieldEnum =
    (typeof AssetScalarFieldEnum)[keyof typeof AssetScalarFieldEnum];

  export const FoodStoreItemScalarFieldEnum: {
    id: "id";
    assetId: "assetId";
    foodName: "foodName";
    unit: "unit";
    quantity: "quantity";
    createdAt: "createdAt";
    updatedAt: "updatedAt";
    supplierId: "supplierId";
    trackQuantity: "trackQuantity";
    status: "status";
    isConsumable: "isConsumable";
  };

  export type FoodStoreItemScalarFieldEnum =
    (typeof FoodStoreItemScalarFieldEnum)[keyof typeof FoodStoreItemScalarFieldEnum];

  export const IndividualFoodStoreItemScalarFieldEnum: {
    id: "id";
    foodStoreItemId: "foodStoreItemId";
    uniqueIdentifier: "uniqueIdentifier";
    status: "status";
    condition: "condition";
    createdAt: "createdAt";
    updatedAt: "updatedAt";
  };

  export type IndividualFoodStoreItemScalarFieldEnum =
    (typeof IndividualFoodStoreItemScalarFieldEnum)[keyof typeof IndividualFoodStoreItemScalarFieldEnum];

  export const FoodConsumptionScalarFieldEnum: {
    id: "id";
    quantityUsed: "quantityUsed";
    dateUsedAt: "dateUsedAt";
    usageDetails: "usageDetails";
    foodStoreItemId: "foodStoreItemId";
  };

  export type FoodConsumptionScalarFieldEnum =
    (typeof FoodConsumptionScalarFieldEnum)[keyof typeof FoodConsumptionScalarFieldEnum];

  export const SupplierScalarFieldEnum: {
    id: "id";
    name: "name";
    contactInfo: "contactInfo";
    address: "address";
    createdAt: "createdAt";
    updatedAt: "updatedAt";
  };

  export type SupplierScalarFieldEnum =
    (typeof SupplierScalarFieldEnum)[keyof typeof SupplierScalarFieldEnum];

  export const LibraryBookScalarFieldEnum: {
    id: "id";
    title: "title";
    author: "author";
    assetId: "assetId";
    libraryBookCategoryId: "libraryBookCategoryId";
    quantity: "quantity";
    trackQuantity: "trackQuantity";
    unit: "unit";
    createdAt: "createdAt";
    updatedAt: "updatedAt";
  };

  export type LibraryBookScalarFieldEnum =
    (typeof LibraryBookScalarFieldEnum)[keyof typeof LibraryBookScalarFieldEnum];

  export const IndividualBookScalarFieldEnum: {
    id: "id";
    isbn: "isbn";
    status: "status";
    createdAt: "createdAt";
    updatedAt: "updatedAt";
    libraryBookId: "libraryBookId";
    condition: "condition";
    borrowCount: "borrowCount";
  };

  export type IndividualBookScalarFieldEnum =
    (typeof IndividualBookScalarFieldEnum)[keyof typeof IndividualBookScalarFieldEnum];

  export const LibraryBookCategoryScalarFieldEnum: {
    id: "id";
    category: "category";
    description: "description";
  };

  export type LibraryBookCategoryScalarFieldEnum =
    (typeof LibraryBookCategoryScalarFieldEnum)[keyof typeof LibraryBookCategoryScalarFieldEnum];

  export const BorrowerScalarFieldEnum: {
    id: "id";
    borrowedAt: "borrowedAt";
    returnAt: "returnAt";
    status: "status";
    userId: "userId";
    individualBookId: "individualBookId";
  };

  export type BorrowerScalarFieldEnum =
    (typeof BorrowerScalarFieldEnum)[keyof typeof BorrowerScalarFieldEnum];

  export const LabItemScalarFieldEnum: {
    id: "id";
    name: "name";
    quantity: "quantity";
    unit: "unit";
    createdAt: "createdAt";
    updatedAt: "updatedAt";
    assetId: "assetId";
    trackQuantity: "trackQuantity";
    status: "status";
  };

  export type LabItemScalarFieldEnum =
    (typeof LabItemScalarFieldEnum)[keyof typeof LabItemScalarFieldEnum];

  export const IndividualLabItemScalarFieldEnum: {
    id: "id";
    labItemId: "labItemId";
    uniqueIdentifier: "uniqueIdentifier";
    status: "status";
    condition: "condition";
    createdAt: "createdAt";
    updatedAt: "updatedAt";
  };

  export type IndividualLabItemScalarFieldEnum =
    (typeof IndividualLabItemScalarFieldEnum)[keyof typeof IndividualLabItemScalarFieldEnum];

  export const ComputerLabItemScalarFieldEnum: {
    id: "id";
    name: "name";
    model: "model";
    specification: "specification";
    quantity: "quantity";
    createdAt: "createdAt";
    updatedAt: "updatedAt";
    assetId: "assetId";
    trackQuantity: "trackQuantity";
    unit: "unit";
  };

  export type ComputerLabItemScalarFieldEnum =
    (typeof ComputerLabItemScalarFieldEnum)[keyof typeof ComputerLabItemScalarFieldEnum];

  export const IndividualComputerLabItemScalarFieldEnum: {
    id: "id";
    computerLabItemId: "computerLabItemId";
    uniqueIdentifier: "uniqueIdentifier";
    status: "status";
    condition: "condition";
    createdAt: "createdAt";
    updatedAt: "updatedAt";
  };

  export type IndividualComputerLabItemScalarFieldEnum =
    (typeof IndividualComputerLabItemScalarFieldEnum)[keyof typeof IndividualComputerLabItemScalarFieldEnum];

  export const GeneralStoreItemScalarFieldEnum: {
    id: "id";
    name: "name";
    quantity: "quantity";
    createdAt: "createdAt";
    updatedAt: "updatedAt";
    assetId: "assetId";
    status: "status";
    trackQuantity: "trackQuantity";
    unit: "unit";
  };

  export type GeneralStoreItemScalarFieldEnum =
    (typeof GeneralStoreItemScalarFieldEnum)[keyof typeof GeneralStoreItemScalarFieldEnum];

  export const IndividualGeneralStoreItemScalarFieldEnum: {
    id: "id";
    generalStoreItemId: "generalStoreItemId";
    uniqueIdentifier: "uniqueIdentifier";
    status: "status";
    condition: "condition";
    createdAt: "createdAt";
    updatedAt: "updatedAt";
  };

  export type IndividualGeneralStoreItemScalarFieldEnum =
    (typeof IndividualGeneralStoreItemScalarFieldEnum)[keyof typeof IndividualGeneralStoreItemScalarFieldEnum];

  export const AssetDamageScalarFieldEnum: {
    id: "id";
    damageDetails: "damageDetails";
    condition: "condition";
    quantity: "quantity";
    userId: "userId";
    individualComputerLabItemId: "individualComputerLabItemId";
    isRepaired: "isRepaired";
    repairedAt: "repairedAt";
    createdAt: "createdAt";
    individualBookId: "individualBookId";
    individualLabItemId: "individualLabItemId";
    individualFoodStoreItemId: "individualFoodStoreItemId";
    individualGeneralStoreItemId: "individualGeneralStoreItemId";
    isSchoolCost: "isSchoolCost";
    repairBalance: "repairBalance";
    repairPrice: "repairPrice";
  };

  export type AssetDamageScalarFieldEnum =
    (typeof AssetDamageScalarFieldEnum)[keyof typeof AssetDamageScalarFieldEnum];

  export const AssetRepairPaymentScalarFieldEnum: {
    id: "id";
    paidAmount: "paidAmount";
    paidAt: "paidAt";
    updatedAt: "updatedAt";
    assetDamageId: "assetDamageId";
    userId: "userId";
    isSchoolCost: "isSchoolCost";
  };

  export type AssetRepairPaymentScalarFieldEnum =
    (typeof AssetRepairPaymentScalarFieldEnum)[keyof typeof AssetRepairPaymentScalarFieldEnum];

  export const ExamScoreScalarFieldEnum: {
    id: "id";
    score: "score";
    createdAt: "createdAt";
    updatedAt: "updatedAt";
    examSubjectId: "examSubjectId";
    pupilId: "pupilId";
  };

  export type ExamScoreScalarFieldEnum =
    (typeof ExamScoreScalarFieldEnum)[keyof typeof ExamScoreScalarFieldEnum];

  export const ExamScalarFieldEnum: {
    id: "id";
    examName: "examName";
    examType: "examType";
    classTermId: "classTermId";
    createdAt: "createdAt";
    updatedAt: "updatedAt";
  };

  export type ExamScalarFieldEnum =
    (typeof ExamScalarFieldEnum)[keyof typeof ExamScalarFieldEnum];

  export const ExamSubjectScalarFieldEnum: {
    id: "id";
    examId: "examId";
    examDate: "examDate";
    academicYearSubjectId: "academicYearSubjectId";
  };

  export type ExamSubjectScalarFieldEnum =
    (typeof ExamSubjectScalarFieldEnum)[keyof typeof ExamSubjectScalarFieldEnum];

  export const SortOrder: {
    asc: "asc";
    desc: "desc";
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder];

  export const QueryMode: {
    default: "default";
    insensitive: "insensitive";
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode];

  export const NullsOrder: {
    first: "first";
    last: "last";
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder];

  /**
   * Field references
   */

  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "String"
  >;

  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "String[]"
  >;

  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "Role"
  >;

  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "Role[]"
  >;

  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "DateTime"
  >;

  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "DateTime[]"
  >;

  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "Boolean"
  >;

  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "BigInt"
  >;

  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "BigInt[]"
  >;

  /**
   * Reference to a field of type 'StaffType'
   */
  export type EnumStaffTypeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "StaffType"
  >;

  /**
   * Reference to a field of type 'StaffType[]'
   */
  export type ListEnumStaffTypeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "StaffType[]"
  >;

  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "Float"
  >;

  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "Float[]"
  >;

  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "Int"
  >;

  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "Int[]"
  >;

  /**
   * Reference to a field of type 'FeesStatus'
   */
  export type EnumFeesStatusFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "FeesStatus"
  >;

  /**
   * Reference to a field of type 'FeesStatus[]'
   */
  export type ListEnumFeesStatusFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "FeesStatus[]"
  >;

  /**
   * Reference to a field of type 'AssetCategory'
   */
  export type EnumAssetCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "AssetCategory"
  >;

  /**
   * Reference to a field of type 'AssetCategory[]'
   */
  export type ListEnumAssetCategoryFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, "AssetCategory[]">;

  /**
   * Reference to a field of type 'AssetUnit'
   */
  export type EnumAssetUnitFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "AssetUnit"
  >;

  /**
   * Reference to a field of type 'AssetUnit[]'
   */
  export type ListEnumAssetUnitFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "AssetUnit[]"
  >;

  /**
   * Reference to a field of type 'AssetItemStatus'
   */
  export type EnumAssetItemStatusFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, "AssetItemStatus">;

  /**
   * Reference to a field of type 'AssetItemStatus[]'
   */
  export type ListEnumAssetItemStatusFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, "AssetItemStatus[]">;

  /**
   * Reference to a field of type 'AssetStatus'
   */
  export type EnumAssetStatusFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "AssetStatus"
  >;

  /**
   * Reference to a field of type 'AssetStatus[]'
   */
  export type ListEnumAssetStatusFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, "AssetStatus[]">;

  /**
   * Reference to a field of type 'AssetCondition'
   */
  export type EnumAssetConditionFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "AssetCondition"
  >;

  /**
   * Reference to a field of type 'AssetCondition[]'
   */
  export type ListEnumAssetConditionFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, "AssetCondition[]">;

  /**
   * Reference to a field of type 'BookStatus'
   */
  export type EnumBookStatusFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "BookStatus"
  >;

  /**
   * Reference to a field of type 'BookStatus[]'
   */
  export type ListEnumBookStatusFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "BookStatus[]"
  >;

  /**
   * Reference to a field of type 'BorrowStatus'
   */
  export type EnumBorrowStatusFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "BorrowStatus"
  >;

  /**
   * Reference to a field of type 'BorrowStatus[]'
   */
  export type ListEnumBorrowStatusFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, "BorrowStatus[]">;

  /**
   * Reference to a field of type 'ExamType'
   */
  export type EnumExamTypeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "ExamType"
  >;

  /**
   * Reference to a field of type 'ExamType[]'
   */
  export type ListEnumExamTypeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "ExamType[]"
  >;

  /**
   * Deep Input Types
   */

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[];
    OR?: UserWhereInput[];
    NOT?: UserWhereInput | UserWhereInput[];
    id?: StringFilter<"User"> | string;
    name?: StringNullableFilter<"User"> | string | null;
    username?: StringNullableFilter<"User"> | string | null;
    email?: StringNullableFilter<"User"> | string | null;
    avatarUrl?: StringNullableFilter<"User"> | string | null;
    role?: EnumRoleNullableFilter<"User"> | $Enums.Role | null;
    createdAt?: DateTimeFilter<"User"> | Date | string;
    telephone?: StringNullableFilter<"User"> | string | null;
    passwordHash?: StringNullableFilter<"User"> | string | null;
    googleId?: StringNullableFilter<"User"> | string | null;
    bio?: StringNullableFilter<"User"> | string | null;
    isWelcomed?: BoolFilter<"User"> | boolean;
    isVerified?: BoolFilter<"User"> | boolean;
    emailVerified?: BoolFilter<"User"> | boolean;
    assetDamages?: AssetDamageListRelationFilter;
    assetRepairPayments?: AssetRepairPaymentListRelationFilter;
    borrowers?: BorrowerListRelationFilter;
    emailVerificationTokens?: EmailVerificationTokenListRelationFilter;
    feesPayments?: FeesPaymentListRelationFilter;
    pupils?: PupilListRelationFilter;
    sessions?: SessionListRelationFilter;
    staffs?: StaffListRelationFilter;
  };

  export type UserOrderByWithRelationInput = {
    id?: SortOrder;
    name?: SortOrderInput | SortOrder;
    username?: SortOrderInput | SortOrder;
    email?: SortOrderInput | SortOrder;
    avatarUrl?: SortOrderInput | SortOrder;
    role?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    telephone?: SortOrderInput | SortOrder;
    passwordHash?: SortOrderInput | SortOrder;
    googleId?: SortOrderInput | SortOrder;
    bio?: SortOrderInput | SortOrder;
    isWelcomed?: SortOrder;
    isVerified?: SortOrder;
    emailVerified?: SortOrder;
    assetDamages?: AssetDamageOrderByRelationAggregateInput;
    assetRepairPayments?: AssetRepairPaymentOrderByRelationAggregateInput;
    borrowers?: BorrowerOrderByRelationAggregateInput;
    emailVerificationTokens?: EmailVerificationTokenOrderByRelationAggregateInput;
    feesPayments?: FeesPaymentOrderByRelationAggregateInput;
    pupils?: PupilOrderByRelationAggregateInput;
    sessions?: SessionOrderByRelationAggregateInput;
    staffs?: StaffOrderByRelationAggregateInput;
  };

  export type UserWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      username?: string;
      email?: string;
      googleId?: string;
      AND?: UserWhereInput | UserWhereInput[];
      OR?: UserWhereInput[];
      NOT?: UserWhereInput | UserWhereInput[];
      name?: StringNullableFilter<"User"> | string | null;
      avatarUrl?: StringNullableFilter<"User"> | string | null;
      role?: EnumRoleNullableFilter<"User"> | $Enums.Role | null;
      createdAt?: DateTimeFilter<"User"> | Date | string;
      telephone?: StringNullableFilter<"User"> | string | null;
      passwordHash?: StringNullableFilter<"User"> | string | null;
      bio?: StringNullableFilter<"User"> | string | null;
      isWelcomed?: BoolFilter<"User"> | boolean;
      isVerified?: BoolFilter<"User"> | boolean;
      emailVerified?: BoolFilter<"User"> | boolean;
      assetDamages?: AssetDamageListRelationFilter;
      assetRepairPayments?: AssetRepairPaymentListRelationFilter;
      borrowers?: BorrowerListRelationFilter;
      emailVerificationTokens?: EmailVerificationTokenListRelationFilter;
      feesPayments?: FeesPaymentListRelationFilter;
      pupils?: PupilListRelationFilter;
      sessions?: SessionListRelationFilter;
      staffs?: StaffListRelationFilter;
    },
    "id" | "username" | "email" | "googleId"
  >;

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder;
    name?: SortOrderInput | SortOrder;
    username?: SortOrderInput | SortOrder;
    email?: SortOrderInput | SortOrder;
    avatarUrl?: SortOrderInput | SortOrder;
    role?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    telephone?: SortOrderInput | SortOrder;
    passwordHash?: SortOrderInput | SortOrder;
    googleId?: SortOrderInput | SortOrder;
    bio?: SortOrderInput | SortOrder;
    isWelcomed?: SortOrder;
    isVerified?: SortOrder;
    emailVerified?: SortOrder;
    _count?: UserCountOrderByAggregateInput;
    _max?: UserMaxOrderByAggregateInput;
    _min?: UserMinOrderByAggregateInput;
  };

  export type UserScalarWhereWithAggregatesInput = {
    AND?:
      | UserScalarWhereWithAggregatesInput
      | UserScalarWhereWithAggregatesInput[];
    OR?: UserScalarWhereWithAggregatesInput[];
    NOT?:
      | UserScalarWhereWithAggregatesInput
      | UserScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"User"> | string;
    name?: StringNullableWithAggregatesFilter<"User"> | string | null;
    username?: StringNullableWithAggregatesFilter<"User"> | string | null;
    email?: StringNullableWithAggregatesFilter<"User"> | string | null;
    avatarUrl?: StringNullableWithAggregatesFilter<"User"> | string | null;
    role?: EnumRoleNullableWithAggregatesFilter<"User"> | $Enums.Role | null;
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string;
    telephone?: StringNullableWithAggregatesFilter<"User"> | string | null;
    passwordHash?: StringNullableWithAggregatesFilter<"User"> | string | null;
    googleId?: StringNullableWithAggregatesFilter<"User"> | string | null;
    bio?: StringNullableWithAggregatesFilter<"User"> | string | null;
    isWelcomed?: BoolWithAggregatesFilter<"User"> | boolean;
    isVerified?: BoolWithAggregatesFilter<"User"> | boolean;
    emailVerified?: BoolWithAggregatesFilter<"User"> | boolean;
  };

  export type EmailVerificationTokenWhereInput = {
    AND?: EmailVerificationTokenWhereInput | EmailVerificationTokenWhereInput[];
    OR?: EmailVerificationTokenWhereInput[];
    NOT?: EmailVerificationTokenWhereInput | EmailVerificationTokenWhereInput[];
    id?: StringFilter<"EmailVerificationToken"> | string;
    userId?: StringFilter<"EmailVerificationToken"> | string;
    expires?: BigIntFilter<"EmailVerificationToken"> | bigint | number;
    user?: XOR<UserScalarRelationFilter, UserWhereInput>;
  };

  export type EmailVerificationTokenOrderByWithRelationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    expires?: SortOrder;
    user?: UserOrderByWithRelationInput;
  };

  export type EmailVerificationTokenWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?:
        | EmailVerificationTokenWhereInput
        | EmailVerificationTokenWhereInput[];
      OR?: EmailVerificationTokenWhereInput[];
      NOT?:
        | EmailVerificationTokenWhereInput
        | EmailVerificationTokenWhereInput[];
      userId?: StringFilter<"EmailVerificationToken"> | string;
      expires?: BigIntFilter<"EmailVerificationToken"> | bigint | number;
      user?: XOR<UserScalarRelationFilter, UserWhereInput>;
    },
    "id"
  >;

  export type EmailVerificationTokenOrderByWithAggregationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    expires?: SortOrder;
    _count?: EmailVerificationTokenCountOrderByAggregateInput;
    _avg?: EmailVerificationTokenAvgOrderByAggregateInput;
    _max?: EmailVerificationTokenMaxOrderByAggregateInput;
    _min?: EmailVerificationTokenMinOrderByAggregateInput;
    _sum?: EmailVerificationTokenSumOrderByAggregateInput;
  };

  export type EmailVerificationTokenScalarWhereWithAggregatesInput = {
    AND?:
      | EmailVerificationTokenScalarWhereWithAggregatesInput
      | EmailVerificationTokenScalarWhereWithAggregatesInput[];
    OR?: EmailVerificationTokenScalarWhereWithAggregatesInput[];
    NOT?:
      | EmailVerificationTokenScalarWhereWithAggregatesInput
      | EmailVerificationTokenScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"EmailVerificationToken"> | string;
    userId?: StringWithAggregatesFilter<"EmailVerificationToken"> | string;
    expires?:
      | BigIntWithAggregatesFilter<"EmailVerificationToken">
      | bigint
      | number;
  };

  export type PupilWhereInput = {
    AND?: PupilWhereInput | PupilWhereInput[];
    OR?: PupilWhereInput[];
    NOT?: PupilWhereInput | PupilWhereInput[];
    id?: StringFilter<"Pupil"> | string;
    userId?: StringNullableFilter<"Pupil"> | string | null;
    genericPassword?: StringFilter<"Pupil"> | string;
    classStreams?: ClassStreamListRelationFilter;
    examScores?: ExamScoreListRelationFilter;
    fees?: FeesListRelationFilter;
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null;
  };

  export type PupilOrderByWithRelationInput = {
    id?: SortOrder;
    userId?: SortOrderInput | SortOrder;
    genericPassword?: SortOrder;
    classStreams?: classStreamOrderByRelationAggregateInput;
    examScores?: ExamScoreOrderByRelationAggregateInput;
    fees?: FeesOrderByRelationAggregateInput;
    user?: UserOrderByWithRelationInput;
  };

  export type PupilWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: PupilWhereInput | PupilWhereInput[];
      OR?: PupilWhereInput[];
      NOT?: PupilWhereInput | PupilWhereInput[];
      userId?: StringNullableFilter<"Pupil"> | string | null;
      genericPassword?: StringFilter<"Pupil"> | string;
      classStreams?: ClassStreamListRelationFilter;
      examScores?: ExamScoreListRelationFilter;
      fees?: FeesListRelationFilter;
      user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null;
    },
    "id"
  >;

  export type PupilOrderByWithAggregationInput = {
    id?: SortOrder;
    userId?: SortOrderInput | SortOrder;
    genericPassword?: SortOrder;
    _count?: PupilCountOrderByAggregateInput;
    _max?: PupilMaxOrderByAggregateInput;
    _min?: PupilMinOrderByAggregateInput;
  };

  export type PupilScalarWhereWithAggregatesInput = {
    AND?:
      | PupilScalarWhereWithAggregatesInput
      | PupilScalarWhereWithAggregatesInput[];
    OR?: PupilScalarWhereWithAggregatesInput[];
    NOT?:
      | PupilScalarWhereWithAggregatesInput
      | PupilScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"Pupil"> | string;
    userId?: StringNullableWithAggregatesFilter<"Pupil"> | string | null;
    genericPassword?: StringWithAggregatesFilter<"Pupil"> | string;
  };

  export type StaffWhereInput = {
    AND?: StaffWhereInput | StaffWhereInput[];
    OR?: StaffWhereInput[];
    NOT?: StaffWhereInput | StaffWhereInput[];
    id?: StringFilter<"Staff"> | string;
    staffType?: EnumStaffTypeFilter<"Staff"> | $Enums.StaffType;
    userId?: StringNullableFilter<"Staff"> | string | null;
    genericPassword?: StringFilter<"Staff"> | string;
    academicYearSubjects?: AcademicYearSubjectListRelationFilter;
    classStreams?: ClassStreamListRelationFilter;
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null;
  };

  export type StaffOrderByWithRelationInput = {
    id?: SortOrder;
    staffType?: SortOrder;
    userId?: SortOrderInput | SortOrder;
    genericPassword?: SortOrder;
    academicYearSubjects?: AcademicYearSubjectOrderByRelationAggregateInput;
    classStreams?: classStreamOrderByRelationAggregateInput;
    user?: UserOrderByWithRelationInput;
  };

  export type StaffWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: StaffWhereInput | StaffWhereInput[];
      OR?: StaffWhereInput[];
      NOT?: StaffWhereInput | StaffWhereInput[];
      staffType?: EnumStaffTypeFilter<"Staff"> | $Enums.StaffType;
      userId?: StringNullableFilter<"Staff"> | string | null;
      genericPassword?: StringFilter<"Staff"> | string;
      academicYearSubjects?: AcademicYearSubjectListRelationFilter;
      classStreams?: ClassStreamListRelationFilter;
      user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null;
    },
    "id"
  >;

  export type StaffOrderByWithAggregationInput = {
    id?: SortOrder;
    staffType?: SortOrder;
    userId?: SortOrderInput | SortOrder;
    genericPassword?: SortOrder;
    _count?: StaffCountOrderByAggregateInput;
    _max?: StaffMaxOrderByAggregateInput;
    _min?: StaffMinOrderByAggregateInput;
  };

  export type StaffScalarWhereWithAggregatesInput = {
    AND?:
      | StaffScalarWhereWithAggregatesInput
      | StaffScalarWhereWithAggregatesInput[];
    OR?: StaffScalarWhereWithAggregatesInput[];
    NOT?:
      | StaffScalarWhereWithAggregatesInput
      | StaffScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"Staff"> | string;
    staffType?: EnumStaffTypeWithAggregatesFilter<"Staff"> | $Enums.StaffType;
    userId?: StringNullableWithAggregatesFilter<"Staff"> | string | null;
    genericPassword?: StringWithAggregatesFilter<"Staff"> | string;
  };

  export type LevelWhereInput = {
    AND?: LevelWhereInput | LevelWhereInput[];
    OR?: LevelWhereInput[];
    NOT?: LevelWhereInput | LevelWhereInput[];
    id?: StringFilter<"Level"> | string;
    name?: StringFilter<"Level"> | string;
    slug?: StringFilter<"Level"> | string;
    classes?: ClassListRelationFilter;
    subjects?: SubjectListRelationFilter;
  };

  export type LevelOrderByWithRelationInput = {
    id?: SortOrder;
    name?: SortOrder;
    slug?: SortOrder;
    classes?: ClassOrderByRelationAggregateInput;
    subjects?: SubjectOrderByRelationAggregateInput;
  };

  export type LevelWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: LevelWhereInput | LevelWhereInput[];
      OR?: LevelWhereInput[];
      NOT?: LevelWhereInput | LevelWhereInput[];
      name?: StringFilter<"Level"> | string;
      slug?: StringFilter<"Level"> | string;
      classes?: ClassListRelationFilter;
      subjects?: SubjectListRelationFilter;
    },
    "id"
  >;

  export type LevelOrderByWithAggregationInput = {
    id?: SortOrder;
    name?: SortOrder;
    slug?: SortOrder;
    _count?: LevelCountOrderByAggregateInput;
    _max?: LevelMaxOrderByAggregateInput;
    _min?: LevelMinOrderByAggregateInput;
  };

  export type LevelScalarWhereWithAggregatesInput = {
    AND?:
      | LevelScalarWhereWithAggregatesInput
      | LevelScalarWhereWithAggregatesInput[];
    OR?: LevelScalarWhereWithAggregatesInput[];
    NOT?:
      | LevelScalarWhereWithAggregatesInput
      | LevelScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"Level"> | string;
    name?: StringWithAggregatesFilter<"Level"> | string;
    slug?: StringWithAggregatesFilter<"Level"> | string;
  };

  export type StreamWhereInput = {
    AND?: StreamWhereInput | StreamWhereInput[];
    OR?: StreamWhereInput[];
    NOT?: StreamWhereInput | StreamWhereInput[];
    id?: StringFilter<"Stream"> | string;
    name?: StringFilter<"Stream"> | string;
    classStreams?: ClassStreamListRelationFilter;
  };

  export type StreamOrderByWithRelationInput = {
    id?: SortOrder;
    name?: SortOrder;
    classStreams?: classStreamOrderByRelationAggregateInput;
  };

  export type StreamWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: StreamWhereInput | StreamWhereInput[];
      OR?: StreamWhereInput[];
      NOT?: StreamWhereInput | StreamWhereInput[];
      name?: StringFilter<"Stream"> | string;
      classStreams?: ClassStreamListRelationFilter;
    },
    "id"
  >;

  export type StreamOrderByWithAggregationInput = {
    id?: SortOrder;
    name?: SortOrder;
    _count?: StreamCountOrderByAggregateInput;
    _max?: StreamMaxOrderByAggregateInput;
    _min?: StreamMinOrderByAggregateInput;
  };

  export type StreamScalarWhereWithAggregatesInput = {
    AND?:
      | StreamScalarWhereWithAggregatesInput
      | StreamScalarWhereWithAggregatesInput[];
    OR?: StreamScalarWhereWithAggregatesInput[];
    NOT?:
      | StreamScalarWhereWithAggregatesInput
      | StreamScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"Stream"> | string;
    name?: StringWithAggregatesFilter<"Stream"> | string;
  };

  export type ClassWhereInput = {
    AND?: ClassWhereInput | ClassWhereInput[];
    OR?: ClassWhereInput[];
    NOT?: ClassWhereInput | ClassWhereInput[];
    id?: StringFilter<"Class"> | string;
    name?: StringFilter<"Class"> | string;
    levelId?: StringNullableFilter<"Class"> | string | null;
    createdAt?: DateTimeFilter<"Class"> | Date | string;
    slug?: StringFilter<"Class"> | string;
    academicYearClasses?: AcademicYearClassListRelationFilter;
    level?: XOR<LevelNullableScalarRelationFilter, LevelWhereInput> | null;
  };

  export type ClassOrderByWithRelationInput = {
    id?: SortOrder;
    name?: SortOrder;
    levelId?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    slug?: SortOrder;
    academicYearClasses?: AcademicYearClassOrderByRelationAggregateInput;
    level?: LevelOrderByWithRelationInput;
  };

  export type ClassWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: ClassWhereInput | ClassWhereInput[];
      OR?: ClassWhereInput[];
      NOT?: ClassWhereInput | ClassWhereInput[];
      name?: StringFilter<"Class"> | string;
      levelId?: StringNullableFilter<"Class"> | string | null;
      createdAt?: DateTimeFilter<"Class"> | Date | string;
      slug?: StringFilter<"Class"> | string;
      academicYearClasses?: AcademicYearClassListRelationFilter;
      level?: XOR<LevelNullableScalarRelationFilter, LevelWhereInput> | null;
    },
    "id"
  >;

  export type ClassOrderByWithAggregationInput = {
    id?: SortOrder;
    name?: SortOrder;
    levelId?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    slug?: SortOrder;
    _count?: ClassCountOrderByAggregateInput;
    _max?: ClassMaxOrderByAggregateInput;
    _min?: ClassMinOrderByAggregateInput;
  };

  export type ClassScalarWhereWithAggregatesInput = {
    AND?:
      | ClassScalarWhereWithAggregatesInput
      | ClassScalarWhereWithAggregatesInput[];
    OR?: ClassScalarWhereWithAggregatesInput[];
    NOT?:
      | ClassScalarWhereWithAggregatesInput
      | ClassScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"Class"> | string;
    name?: StringWithAggregatesFilter<"Class"> | string;
    levelId?: StringNullableWithAggregatesFilter<"Class"> | string | null;
    createdAt?: DateTimeWithAggregatesFilter<"Class"> | Date | string;
    slug?: StringWithAggregatesFilter<"Class"> | string;
  };

  export type AcademicYearWhereInput = {
    AND?: AcademicYearWhereInput | AcademicYearWhereInput[];
    OR?: AcademicYearWhereInput[];
    NOT?: AcademicYearWhereInput | AcademicYearWhereInput[];
    id?: StringFilter<"AcademicYear"> | string;
    year?: StringFilter<"AcademicYear"> | string;
    startAt?: DateTimeFilter<"AcademicYear"> | Date | string;
    endAt?: DateTimeFilter<"AcademicYear"> | Date | string;
    academicYearClasses?: AcademicYearClassListRelationFilter;
  };

  export type AcademicYearOrderByWithRelationInput = {
    id?: SortOrder;
    year?: SortOrder;
    startAt?: SortOrder;
    endAt?: SortOrder;
    academicYearClasses?: AcademicYearClassOrderByRelationAggregateInput;
  };

  export type AcademicYearWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: AcademicYearWhereInput | AcademicYearWhereInput[];
      OR?: AcademicYearWhereInput[];
      NOT?: AcademicYearWhereInput | AcademicYearWhereInput[];
      year?: StringFilter<"AcademicYear"> | string;
      startAt?: DateTimeFilter<"AcademicYear"> | Date | string;
      endAt?: DateTimeFilter<"AcademicYear"> | Date | string;
      academicYearClasses?: AcademicYearClassListRelationFilter;
    },
    "id"
  >;

  export type AcademicYearOrderByWithAggregationInput = {
    id?: SortOrder;
    year?: SortOrder;
    startAt?: SortOrder;
    endAt?: SortOrder;
    _count?: AcademicYearCountOrderByAggregateInput;
    _max?: AcademicYearMaxOrderByAggregateInput;
    _min?: AcademicYearMinOrderByAggregateInput;
  };

  export type AcademicYearScalarWhereWithAggregatesInput = {
    AND?:
      | AcademicYearScalarWhereWithAggregatesInput
      | AcademicYearScalarWhereWithAggregatesInput[];
    OR?: AcademicYearScalarWhereWithAggregatesInput[];
    NOT?:
      | AcademicYearScalarWhereWithAggregatesInput
      | AcademicYearScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"AcademicYear"> | string;
    year?: StringWithAggregatesFilter<"AcademicYear"> | string;
    startAt?: DateTimeWithAggregatesFilter<"AcademicYear"> | Date | string;
    endAt?: DateTimeWithAggregatesFilter<"AcademicYear"> | Date | string;
  };

  export type AcademicYearClassWhereInput = {
    AND?: AcademicYearClassWhereInput | AcademicYearClassWhereInput[];
    OR?: AcademicYearClassWhereInput[];
    NOT?: AcademicYearClassWhereInput | AcademicYearClassWhereInput[];
    id?: StringFilter<"AcademicYearClass"> | string;
    academicYearId?: StringNullableFilter<"AcademicYearClass"> | string | null;
    classId?: StringNullableFilter<"AcademicYearClass"> | string | null;
    academicYear?: XOR<
      AcademicYearNullableScalarRelationFilter,
      AcademicYearWhereInput
    > | null;
    class?: XOR<ClassNullableScalarRelationFilter, ClassWhereInput> | null;
    academicYearSubjects?: AcademicYearSubjectListRelationFilter;
    streams?: ClassStreamListRelationFilter;
  };

  export type AcademicYearClassOrderByWithRelationInput = {
    id?: SortOrder;
    academicYearId?: SortOrderInput | SortOrder;
    classId?: SortOrderInput | SortOrder;
    academicYear?: AcademicYearOrderByWithRelationInput;
    class?: ClassOrderByWithRelationInput;
    academicYearSubjects?: AcademicYearSubjectOrderByRelationAggregateInput;
    streams?: classStreamOrderByRelationAggregateInput;
  };

  export type AcademicYearClassWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      classId_academicYearId?: AcademicYearClassClassIdAcademicYearIdCompoundUniqueInput;
      AND?: AcademicYearClassWhereInput | AcademicYearClassWhereInput[];
      OR?: AcademicYearClassWhereInput[];
      NOT?: AcademicYearClassWhereInput | AcademicYearClassWhereInput[];
      academicYearId?:
        | StringNullableFilter<"AcademicYearClass">
        | string
        | null;
      classId?: StringNullableFilter<"AcademicYearClass"> | string | null;
      academicYear?: XOR<
        AcademicYearNullableScalarRelationFilter,
        AcademicYearWhereInput
      > | null;
      class?: XOR<ClassNullableScalarRelationFilter, ClassWhereInput> | null;
      academicYearSubjects?: AcademicYearSubjectListRelationFilter;
      streams?: ClassStreamListRelationFilter;
    },
    "id" | "classId_academicYearId"
  >;

  export type AcademicYearClassOrderByWithAggregationInput = {
    id?: SortOrder;
    academicYearId?: SortOrderInput | SortOrder;
    classId?: SortOrderInput | SortOrder;
    _count?: AcademicYearClassCountOrderByAggregateInput;
    _max?: AcademicYearClassMaxOrderByAggregateInput;
    _min?: AcademicYearClassMinOrderByAggregateInput;
  };

  export type AcademicYearClassScalarWhereWithAggregatesInput = {
    AND?:
      | AcademicYearClassScalarWhereWithAggregatesInput
      | AcademicYearClassScalarWhereWithAggregatesInput[];
    OR?: AcademicYearClassScalarWhereWithAggregatesInput[];
    NOT?:
      | AcademicYearClassScalarWhereWithAggregatesInput
      | AcademicYearClassScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"AcademicYearClass"> | string;
    academicYearId?:
      | StringNullableWithAggregatesFilter<"AcademicYearClass">
      | string
      | null;
    classId?:
      | StringNullableWithAggregatesFilter<"AcademicYearClass">
      | string
      | null;
  };

  export type SubjectWhereInput = {
    AND?: SubjectWhereInput | SubjectWhereInput[];
    OR?: SubjectWhereInput[];
    NOT?: SubjectWhereInput | SubjectWhereInput[];
    id?: StringFilter<"Subject"> | string;
    subjectName?: StringFilter<"Subject"> | string;
    slug?: StringFilter<"Subject"> | string;
    code?: StringFilter<"Subject"> | string;
    levelId?: StringFilter<"Subject"> | string;
    grading?: GradingListRelationFilter;
    academicYearSubjects?: AcademicYearSubjectListRelationFilter;
    level?: XOR<LevelScalarRelationFilter, LevelWhereInput>;
  };

  export type SubjectOrderByWithRelationInput = {
    id?: SortOrder;
    subjectName?: SortOrder;
    slug?: SortOrder;
    code?: SortOrder;
    levelId?: SortOrder;
    grading?: GradingOrderByRelationAggregateInput;
    academicYearSubjects?: AcademicYearSubjectOrderByRelationAggregateInput;
    level?: LevelOrderByWithRelationInput;
  };

  export type SubjectWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      code_subjectName?: SubjectCodeSubjectNameCompoundUniqueInput;
      AND?: SubjectWhereInput | SubjectWhereInput[];
      OR?: SubjectWhereInput[];
      NOT?: SubjectWhereInput | SubjectWhereInput[];
      subjectName?: StringFilter<"Subject"> | string;
      slug?: StringFilter<"Subject"> | string;
      code?: StringFilter<"Subject"> | string;
      levelId?: StringFilter<"Subject"> | string;
      grading?: GradingListRelationFilter;
      academicYearSubjects?: AcademicYearSubjectListRelationFilter;
      level?: XOR<LevelScalarRelationFilter, LevelWhereInput>;
    },
    "id" | "code_subjectName"
  >;

  export type SubjectOrderByWithAggregationInput = {
    id?: SortOrder;
    subjectName?: SortOrder;
    slug?: SortOrder;
    code?: SortOrder;
    levelId?: SortOrder;
    _count?: SubjectCountOrderByAggregateInput;
    _max?: SubjectMaxOrderByAggregateInput;
    _min?: SubjectMinOrderByAggregateInput;
  };

  export type SubjectScalarWhereWithAggregatesInput = {
    AND?:
      | SubjectScalarWhereWithAggregatesInput
      | SubjectScalarWhereWithAggregatesInput[];
    OR?: SubjectScalarWhereWithAggregatesInput[];
    NOT?:
      | SubjectScalarWhereWithAggregatesInput
      | SubjectScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"Subject"> | string;
    subjectName?: StringWithAggregatesFilter<"Subject"> | string;
    slug?: StringWithAggregatesFilter<"Subject"> | string;
    code?: StringWithAggregatesFilter<"Subject"> | string;
    levelId?: StringWithAggregatesFilter<"Subject"> | string;
  };

  export type GradingWhereInput = {
    AND?: GradingWhereInput | GradingWhereInput[];
    OR?: GradingWhereInput[];
    NOT?: GradingWhereInput | GradingWhereInput[];
    id?: StringFilter<"Grading"> | string;
    from?: FloatFilter<"Grading"> | number;
    to?: FloatFilter<"Grading"> | number;
    grade?: StringFilter<"Grading"> | string;
    remarks?: StringNullableFilter<"Grading"> | string | null;
    subjects?: SubjectListRelationFilter;
    academicYearSubjects?: AcademicYearSubjectListRelationFilter;
  };

  export type GradingOrderByWithRelationInput = {
    id?: SortOrder;
    from?: SortOrder;
    to?: SortOrder;
    grade?: SortOrder;
    remarks?: SortOrderInput | SortOrder;
    subjects?: SubjectOrderByRelationAggregateInput;
    academicYearSubjects?: AcademicYearSubjectOrderByRelationAggregateInput;
  };

  export type GradingWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      from_to_grade?: GradingFromToGradeCompoundUniqueInput;
      AND?: GradingWhereInput | GradingWhereInput[];
      OR?: GradingWhereInput[];
      NOT?: GradingWhereInput | GradingWhereInput[];
      from?: FloatFilter<"Grading"> | number;
      to?: FloatFilter<"Grading"> | number;
      grade?: StringFilter<"Grading"> | string;
      remarks?: StringNullableFilter<"Grading"> | string | null;
      subjects?: SubjectListRelationFilter;
      academicYearSubjects?: AcademicYearSubjectListRelationFilter;
    },
    "id" | "from_to_grade"
  >;

  export type GradingOrderByWithAggregationInput = {
    id?: SortOrder;
    from?: SortOrder;
    to?: SortOrder;
    grade?: SortOrder;
    remarks?: SortOrderInput | SortOrder;
    _count?: GradingCountOrderByAggregateInput;
    _avg?: GradingAvgOrderByAggregateInput;
    _max?: GradingMaxOrderByAggregateInput;
    _min?: GradingMinOrderByAggregateInput;
    _sum?: GradingSumOrderByAggregateInput;
  };

  export type GradingScalarWhereWithAggregatesInput = {
    AND?:
      | GradingScalarWhereWithAggregatesInput
      | GradingScalarWhereWithAggregatesInput[];
    OR?: GradingScalarWhereWithAggregatesInput[];
    NOT?:
      | GradingScalarWhereWithAggregatesInput
      | GradingScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"Grading"> | string;
    from?: FloatWithAggregatesFilter<"Grading"> | number;
    to?: FloatWithAggregatesFilter<"Grading"> | number;
    grade?: StringWithAggregatesFilter<"Grading"> | string;
    remarks?: StringNullableWithAggregatesFilter<"Grading"> | string | null;
  };

  export type AcademicYearSubjectWhereInput = {
    AND?: AcademicYearSubjectWhereInput | AcademicYearSubjectWhereInput[];
    OR?: AcademicYearSubjectWhereInput[];
    NOT?: AcademicYearSubjectWhereInput | AcademicYearSubjectWhereInput[];
    id?: StringFilter<"AcademicYearSubject"> | string;
    academicYearClassId?: StringFilter<"AcademicYearSubject"> | string;
    subjectId?: StringFilter<"AcademicYearSubject"> | string;
    customGrading?: GradingListRelationFilter;
    academicYearClass?: XOR<
      AcademicYearClassScalarRelationFilter,
      AcademicYearClassWhereInput
    >;
    teachers?: StaffListRelationFilter;
    subject?: XOR<SubjectScalarRelationFilter, SubjectWhereInput>;
    examSubjects?: ExamSubjectListRelationFilter;
  };

  export type AcademicYearSubjectOrderByWithRelationInput = {
    id?: SortOrder;
    academicYearClassId?: SortOrder;
    subjectId?: SortOrder;
    customGrading?: GradingOrderByRelationAggregateInput;
    academicYearClass?: AcademicYearClassOrderByWithRelationInput;
    teachers?: StaffOrderByRelationAggregateInput;
    subject?: SubjectOrderByWithRelationInput;
    examSubjects?: ExamSubjectOrderByRelationAggregateInput;
  };

  export type AcademicYearSubjectWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      academicYearClassId_subjectId?: AcademicYearSubjectAcademicYearClassIdSubjectIdCompoundUniqueInput;
      AND?: AcademicYearSubjectWhereInput | AcademicYearSubjectWhereInput[];
      OR?: AcademicYearSubjectWhereInput[];
      NOT?: AcademicYearSubjectWhereInput | AcademicYearSubjectWhereInput[];
      academicYearClassId?: StringFilter<"AcademicYearSubject"> | string;
      subjectId?: StringFilter<"AcademicYearSubject"> | string;
      customGrading?: GradingListRelationFilter;
      academicYearClass?: XOR<
        AcademicYearClassScalarRelationFilter,
        AcademicYearClassWhereInput
      >;
      teachers?: StaffListRelationFilter;
      subject?: XOR<SubjectScalarRelationFilter, SubjectWhereInput>;
      examSubjects?: ExamSubjectListRelationFilter;
    },
    "id" | "academicYearClassId_subjectId"
  >;

  export type AcademicYearSubjectOrderByWithAggregationInput = {
    id?: SortOrder;
    academicYearClassId?: SortOrder;
    subjectId?: SortOrder;
    _count?: AcademicYearSubjectCountOrderByAggregateInput;
    _max?: AcademicYearSubjectMaxOrderByAggregateInput;
    _min?: AcademicYearSubjectMinOrderByAggregateInput;
  };

  export type AcademicYearSubjectScalarWhereWithAggregatesInput = {
    AND?:
      | AcademicYearSubjectScalarWhereWithAggregatesInput
      | AcademicYearSubjectScalarWhereWithAggregatesInput[];
    OR?: AcademicYearSubjectScalarWhereWithAggregatesInput[];
    NOT?:
      | AcademicYearSubjectScalarWhereWithAggregatesInput
      | AcademicYearSubjectScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"AcademicYearSubject"> | string;
    academicYearClassId?:
      | StringWithAggregatesFilter<"AcademicYearSubject">
      | string;
    subjectId?: StringWithAggregatesFilter<"AcademicYearSubject"> | string;
  };

  export type classStreamWhereInput = {
    AND?: classStreamWhereInput | classStreamWhereInput[];
    OR?: classStreamWhereInput[];
    NOT?: classStreamWhereInput | classStreamWhereInput[];
    id?: StringFilter<"classStream"> | string;
    staffId?: StringNullableFilter<"classStream"> | string | null;
    classId?: StringNullableFilter<"classStream"> | string | null;
    streamId?: StringNullableFilter<"classStream"> | string | null;
    pupils?: PupilListRelationFilter;
    class?: XOR<
      AcademicYearClassNullableScalarRelationFilter,
      AcademicYearClassWhereInput
    > | null;
    classTeacher?: XOR<
      StaffNullableScalarRelationFilter,
      StaffWhereInput
    > | null;
    stream?: XOR<StreamNullableScalarRelationFilter, StreamWhereInput> | null;
    terms?: ClassTermListRelationFilter;
  };

  export type classStreamOrderByWithRelationInput = {
    id?: SortOrder;
    staffId?: SortOrderInput | SortOrder;
    classId?: SortOrderInput | SortOrder;
    streamId?: SortOrderInput | SortOrder;
    pupils?: PupilOrderByRelationAggregateInput;
    class?: AcademicYearClassOrderByWithRelationInput;
    classTeacher?: StaffOrderByWithRelationInput;
    stream?: StreamOrderByWithRelationInput;
    terms?: ClassTermOrderByRelationAggregateInput;
  };

  export type classStreamWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      classId_streamId?: classStreamClassIdStreamIdCompoundUniqueInput;
      AND?: classStreamWhereInput | classStreamWhereInput[];
      OR?: classStreamWhereInput[];
      NOT?: classStreamWhereInput | classStreamWhereInput[];
      staffId?: StringNullableFilter<"classStream"> | string | null;
      classId?: StringNullableFilter<"classStream"> | string | null;
      streamId?: StringNullableFilter<"classStream"> | string | null;
      pupils?: PupilListRelationFilter;
      class?: XOR<
        AcademicYearClassNullableScalarRelationFilter,
        AcademicYearClassWhereInput
      > | null;
      classTeacher?: XOR<
        StaffNullableScalarRelationFilter,
        StaffWhereInput
      > | null;
      stream?: XOR<StreamNullableScalarRelationFilter, StreamWhereInput> | null;
      terms?: ClassTermListRelationFilter;
    },
    "id" | "classId_streamId"
  >;

  export type classStreamOrderByWithAggregationInput = {
    id?: SortOrder;
    staffId?: SortOrderInput | SortOrder;
    classId?: SortOrderInput | SortOrder;
    streamId?: SortOrderInput | SortOrder;
    _count?: classStreamCountOrderByAggregateInput;
    _max?: classStreamMaxOrderByAggregateInput;
    _min?: classStreamMinOrderByAggregateInput;
  };

  export type classStreamScalarWhereWithAggregatesInput = {
    AND?:
      | classStreamScalarWhereWithAggregatesInput
      | classStreamScalarWhereWithAggregatesInput[];
    OR?: classStreamScalarWhereWithAggregatesInput[];
    NOT?:
      | classStreamScalarWhereWithAggregatesInput
      | classStreamScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"classStream"> | string;
    staffId?: StringNullableWithAggregatesFilter<"classStream"> | string | null;
    classId?: StringNullableWithAggregatesFilter<"classStream"> | string | null;
    streamId?:
      | StringNullableWithAggregatesFilter<"classStream">
      | string
      | null;
  };

  export type TermWhereInput = {
    AND?: TermWhereInput | TermWhereInput[];
    OR?: TermWhereInput[];
    NOT?: TermWhereInput | TermWhereInput[];
    id?: StringFilter<"Term"> | string;
    term?: StringFilter<"Term"> | string;
    slug?: StringFilter<"Term"> | string;
    classTerms?: ClassTermListRelationFilter;
  };

  export type TermOrderByWithRelationInput = {
    id?: SortOrder;
    term?: SortOrder;
    slug?: SortOrder;
    classTerms?: ClassTermOrderByRelationAggregateInput;
  };

  export type TermWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      term?: string;
      slug?: string;
      AND?: TermWhereInput | TermWhereInput[];
      OR?: TermWhereInput[];
      NOT?: TermWhereInput | TermWhereInput[];
      classTerms?: ClassTermListRelationFilter;
    },
    "id" | "term" | "slug"
  >;

  export type TermOrderByWithAggregationInput = {
    id?: SortOrder;
    term?: SortOrder;
    slug?: SortOrder;
    _count?: TermCountOrderByAggregateInput;
    _max?: TermMaxOrderByAggregateInput;
    _min?: TermMinOrderByAggregateInput;
  };

  export type TermScalarWhereWithAggregatesInput = {
    AND?:
      | TermScalarWhereWithAggregatesInput
      | TermScalarWhereWithAggregatesInput[];
    OR?: TermScalarWhereWithAggregatesInput[];
    NOT?:
      | TermScalarWhereWithAggregatesInput
      | TermScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"Term"> | string;
    term?: StringWithAggregatesFilter<"Term"> | string;
    slug?: StringWithAggregatesFilter<"Term"> | string;
  };

  export type ClassTermWhereInput = {
    AND?: ClassTermWhereInput | ClassTermWhereInput[];
    OR?: ClassTermWhereInput[];
    NOT?: ClassTermWhereInput | ClassTermWhereInput[];
    id?: StringFilter<"ClassTerm"> | string;
    startAt?: DateTimeFilter<"ClassTerm"> | Date | string;
    endAt?: DateTimeFilter<"ClassTerm"> | Date | string;
    termId?: StringNullableFilter<"ClassTerm"> | string | null;
    classStreamId?: StringNullableFilter<"ClassTerm"> | string | null;
    feesAmount?: IntNullableFilter<"ClassTerm"> | number | null;
    classStream?: XOR<
      ClassStreamNullableScalarRelationFilter,
      classStreamWhereInput
    > | null;
    term?: XOR<TermNullableScalarRelationFilter, TermWhereInput> | null;
    exams?: ExamListRelationFilter;
    fees?: FeesListRelationFilter;
  };

  export type ClassTermOrderByWithRelationInput = {
    id?: SortOrder;
    startAt?: SortOrder;
    endAt?: SortOrder;
    termId?: SortOrderInput | SortOrder;
    classStreamId?: SortOrderInput | SortOrder;
    feesAmount?: SortOrderInput | SortOrder;
    classStream?: classStreamOrderByWithRelationInput;
    term?: TermOrderByWithRelationInput;
    exams?: ExamOrderByRelationAggregateInput;
    fees?: FeesOrderByRelationAggregateInput;
  };

  export type ClassTermWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      classStreamId_termId?: ClassTermClassStreamIdTermIdCompoundUniqueInput;
      AND?: ClassTermWhereInput | ClassTermWhereInput[];
      OR?: ClassTermWhereInput[];
      NOT?: ClassTermWhereInput | ClassTermWhereInput[];
      startAt?: DateTimeFilter<"ClassTerm"> | Date | string;
      endAt?: DateTimeFilter<"ClassTerm"> | Date | string;
      termId?: StringNullableFilter<"ClassTerm"> | string | null;
      classStreamId?: StringNullableFilter<"ClassTerm"> | string | null;
      feesAmount?: IntNullableFilter<"ClassTerm"> | number | null;
      classStream?: XOR<
        ClassStreamNullableScalarRelationFilter,
        classStreamWhereInput
      > | null;
      term?: XOR<TermNullableScalarRelationFilter, TermWhereInput> | null;
      exams?: ExamListRelationFilter;
      fees?: FeesListRelationFilter;
    },
    "id" | "classStreamId_termId"
  >;

  export type ClassTermOrderByWithAggregationInput = {
    id?: SortOrder;
    startAt?: SortOrder;
    endAt?: SortOrder;
    termId?: SortOrderInput | SortOrder;
    classStreamId?: SortOrderInput | SortOrder;
    feesAmount?: SortOrderInput | SortOrder;
    _count?: ClassTermCountOrderByAggregateInput;
    _avg?: ClassTermAvgOrderByAggregateInput;
    _max?: ClassTermMaxOrderByAggregateInput;
    _min?: ClassTermMinOrderByAggregateInput;
    _sum?: ClassTermSumOrderByAggregateInput;
  };

  export type ClassTermScalarWhereWithAggregatesInput = {
    AND?:
      | ClassTermScalarWhereWithAggregatesInput
      | ClassTermScalarWhereWithAggregatesInput[];
    OR?: ClassTermScalarWhereWithAggregatesInput[];
    NOT?:
      | ClassTermScalarWhereWithAggregatesInput
      | ClassTermScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"ClassTerm"> | string;
    startAt?: DateTimeWithAggregatesFilter<"ClassTerm"> | Date | string;
    endAt?: DateTimeWithAggregatesFilter<"ClassTerm"> | Date | string;
    termId?: StringNullableWithAggregatesFilter<"ClassTerm"> | string | null;
    classStreamId?:
      | StringNullableWithAggregatesFilter<"ClassTerm">
      | string
      | null;
    feesAmount?: IntNullableWithAggregatesFilter<"ClassTerm"> | number | null;
  };

  export type FeesWhereInput = {
    AND?: FeesWhereInput | FeesWhereInput[];
    OR?: FeesWhereInput[];
    NOT?: FeesWhereInput | FeesWhereInput[];
    id?: StringFilter<"Fees"> | string;
    pupilId?: StringFilter<"Fees"> | string;
    balance?: IntFilter<"Fees"> | number;
    termId?: StringFilter<"Fees"> | string;
    status?: EnumFeesStatusFilter<"Fees"> | $Enums.FeesStatus;
    pupil?: XOR<PupilScalarRelationFilter, PupilWhereInput>;
    term?: XOR<ClassTermScalarRelationFilter, ClassTermWhereInput>;
    feesPayments?: FeesPaymentListRelationFilter;
  };

  export type FeesOrderByWithRelationInput = {
    id?: SortOrder;
    pupilId?: SortOrder;
    balance?: SortOrder;
    termId?: SortOrder;
    status?: SortOrder;
    pupil?: PupilOrderByWithRelationInput;
    term?: ClassTermOrderByWithRelationInput;
    feesPayments?: FeesPaymentOrderByRelationAggregateInput;
  };

  export type FeesWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: FeesWhereInput | FeesWhereInput[];
      OR?: FeesWhereInput[];
      NOT?: FeesWhereInput | FeesWhereInput[];
      pupilId?: StringFilter<"Fees"> | string;
      balance?: IntFilter<"Fees"> | number;
      termId?: StringFilter<"Fees"> | string;
      status?: EnumFeesStatusFilter<"Fees"> | $Enums.FeesStatus;
      pupil?: XOR<PupilScalarRelationFilter, PupilWhereInput>;
      term?: XOR<ClassTermScalarRelationFilter, ClassTermWhereInput>;
      feesPayments?: FeesPaymentListRelationFilter;
    },
    "id"
  >;

  export type FeesOrderByWithAggregationInput = {
    id?: SortOrder;
    pupilId?: SortOrder;
    balance?: SortOrder;
    termId?: SortOrder;
    status?: SortOrder;
    _count?: FeesCountOrderByAggregateInput;
    _avg?: FeesAvgOrderByAggregateInput;
    _max?: FeesMaxOrderByAggregateInput;
    _min?: FeesMinOrderByAggregateInput;
    _sum?: FeesSumOrderByAggregateInput;
  };

  export type FeesScalarWhereWithAggregatesInput = {
    AND?:
      | FeesScalarWhereWithAggregatesInput
      | FeesScalarWhereWithAggregatesInput[];
    OR?: FeesScalarWhereWithAggregatesInput[];
    NOT?:
      | FeesScalarWhereWithAggregatesInput
      | FeesScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"Fees"> | string;
    pupilId?: StringWithAggregatesFilter<"Fees"> | string;
    balance?: IntWithAggregatesFilter<"Fees"> | number;
    termId?: StringWithAggregatesFilter<"Fees"> | string;
    status?: EnumFeesStatusWithAggregatesFilter<"Fees"> | $Enums.FeesStatus;
  };

  export type FeesPaymentWhereInput = {
    AND?: FeesPaymentWhereInput | FeesPaymentWhereInput[];
    OR?: FeesPaymentWhereInput[];
    NOT?: FeesPaymentWhereInput | FeesPaymentWhereInput[];
    id?: StringFilter<"FeesPayment"> | string;
    amountPaid?: IntFilter<"FeesPayment"> | number;
    createdAt?: DateTimeFilter<"FeesPayment"> | Date | string;
    updatedAt?: DateTimeFilter<"FeesPayment"> | Date | string;
    feesId?: StringNullableFilter<"FeesPayment"> | string | null;
    userId?: StringFilter<"FeesPayment"> | string;
    fees?: XOR<FeesNullableScalarRelationFilter, FeesWhereInput> | null;
    paidBy?: XOR<UserScalarRelationFilter, UserWhereInput>;
  };

  export type FeesPaymentOrderByWithRelationInput = {
    id?: SortOrder;
    amountPaid?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    feesId?: SortOrderInput | SortOrder;
    userId?: SortOrder;
    fees?: FeesOrderByWithRelationInput;
    paidBy?: UserOrderByWithRelationInput;
  };

  export type FeesPaymentWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: FeesPaymentWhereInput | FeesPaymentWhereInput[];
      OR?: FeesPaymentWhereInput[];
      NOT?: FeesPaymentWhereInput | FeesPaymentWhereInput[];
      amountPaid?: IntFilter<"FeesPayment"> | number;
      createdAt?: DateTimeFilter<"FeesPayment"> | Date | string;
      updatedAt?: DateTimeFilter<"FeesPayment"> | Date | string;
      feesId?: StringNullableFilter<"FeesPayment"> | string | null;
      userId?: StringFilter<"FeesPayment"> | string;
      fees?: XOR<FeesNullableScalarRelationFilter, FeesWhereInput> | null;
      paidBy?: XOR<UserScalarRelationFilter, UserWhereInput>;
    },
    "id"
  >;

  export type FeesPaymentOrderByWithAggregationInput = {
    id?: SortOrder;
    amountPaid?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    feesId?: SortOrderInput | SortOrder;
    userId?: SortOrder;
    _count?: FeesPaymentCountOrderByAggregateInput;
    _avg?: FeesPaymentAvgOrderByAggregateInput;
    _max?: FeesPaymentMaxOrderByAggregateInput;
    _min?: FeesPaymentMinOrderByAggregateInput;
    _sum?: FeesPaymentSumOrderByAggregateInput;
  };

  export type FeesPaymentScalarWhereWithAggregatesInput = {
    AND?:
      | FeesPaymentScalarWhereWithAggregatesInput
      | FeesPaymentScalarWhereWithAggregatesInput[];
    OR?: FeesPaymentScalarWhereWithAggregatesInput[];
    NOT?:
      | FeesPaymentScalarWhereWithAggregatesInput
      | FeesPaymentScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"FeesPayment"> | string;
    amountPaid?: IntWithAggregatesFilter<"FeesPayment"> | number;
    createdAt?: DateTimeWithAggregatesFilter<"FeesPayment"> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<"FeesPayment"> | Date | string;
    feesId?: StringNullableWithAggregatesFilter<"FeesPayment"> | string | null;
    userId?: StringWithAggregatesFilter<"FeesPayment"> | string;
  };

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[];
    OR?: SessionWhereInput[];
    NOT?: SessionWhereInput | SessionWhereInput[];
    id?: StringFilter<"Session"> | string;
    userId?: StringFilter<"Session"> | string;
    expiresAt?: DateTimeFilter<"Session"> | Date | string;
    role?: EnumRoleFilter<"Session"> | $Enums.Role;
    user?: XOR<UserScalarRelationFilter, UserWhereInput>;
  };

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    expiresAt?: SortOrder;
    role?: SortOrder;
    user?: UserOrderByWithRelationInput;
  };

  export type SessionWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: SessionWhereInput | SessionWhereInput[];
      OR?: SessionWhereInput[];
      NOT?: SessionWhereInput | SessionWhereInput[];
      userId?: StringFilter<"Session"> | string;
      expiresAt?: DateTimeFilter<"Session"> | Date | string;
      role?: EnumRoleFilter<"Session"> | $Enums.Role;
      user?: XOR<UserScalarRelationFilter, UserWhereInput>;
    },
    "id"
  >;

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    expiresAt?: SortOrder;
    role?: SortOrder;
    _count?: SessionCountOrderByAggregateInput;
    _max?: SessionMaxOrderByAggregateInput;
    _min?: SessionMinOrderByAggregateInput;
  };

  export type SessionScalarWhereWithAggregatesInput = {
    AND?:
      | SessionScalarWhereWithAggregatesInput
      | SessionScalarWhereWithAggregatesInput[];
    OR?: SessionScalarWhereWithAggregatesInput[];
    NOT?:
      | SessionScalarWhereWithAggregatesInput
      | SessionScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"Session"> | string;
    userId?: StringWithAggregatesFilter<"Session"> | string;
    expiresAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string;
    role?: EnumRoleWithAggregatesFilter<"Session"> | $Enums.Role;
  };

  export type AssetWhereInput = {
    AND?: AssetWhereInput | AssetWhereInput[];
    OR?: AssetWhereInput[];
    NOT?: AssetWhereInput | AssetWhereInput[];
    id?: StringFilter<"Asset"> | string;
    name?: StringFilter<"Asset"> | string;
    description?: StringNullableFilter<"Asset"> | string | null;
    category?: EnumAssetCategoryFilter<"Asset"> | $Enums.AssetCategory;
    createdAt?: DateTimeFilter<"Asset"> | Date | string;
    updatedAt?: DateTimeFilter<"Asset"> | Date | string;
    computerLabItems?: ComputerLabItemListRelationFilter;
    foodStoreItems?: FoodStoreItemListRelationFilter;
    generalStoreItems?: GeneralStoreItemListRelationFilter;
    labItems?: LabItemListRelationFilter;
    libraryBooks?: LibraryBookListRelationFilter;
  };

  export type AssetOrderByWithRelationInput = {
    id?: SortOrder;
    name?: SortOrder;
    description?: SortOrderInput | SortOrder;
    category?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    computerLabItems?: ComputerLabItemOrderByRelationAggregateInput;
    foodStoreItems?: FoodStoreItemOrderByRelationAggregateInput;
    generalStoreItems?: GeneralStoreItemOrderByRelationAggregateInput;
    labItems?: LabItemOrderByRelationAggregateInput;
    libraryBooks?: LibraryBookOrderByRelationAggregateInput;
  };

  export type AssetWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: AssetWhereInput | AssetWhereInput[];
      OR?: AssetWhereInput[];
      NOT?: AssetWhereInput | AssetWhereInput[];
      name?: StringFilter<"Asset"> | string;
      description?: StringNullableFilter<"Asset"> | string | null;
      category?: EnumAssetCategoryFilter<"Asset"> | $Enums.AssetCategory;
      createdAt?: DateTimeFilter<"Asset"> | Date | string;
      updatedAt?: DateTimeFilter<"Asset"> | Date | string;
      computerLabItems?: ComputerLabItemListRelationFilter;
      foodStoreItems?: FoodStoreItemListRelationFilter;
      generalStoreItems?: GeneralStoreItemListRelationFilter;
      labItems?: LabItemListRelationFilter;
      libraryBooks?: LibraryBookListRelationFilter;
    },
    "id"
  >;

  export type AssetOrderByWithAggregationInput = {
    id?: SortOrder;
    name?: SortOrder;
    description?: SortOrderInput | SortOrder;
    category?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: AssetCountOrderByAggregateInput;
    _max?: AssetMaxOrderByAggregateInput;
    _min?: AssetMinOrderByAggregateInput;
  };

  export type AssetScalarWhereWithAggregatesInput = {
    AND?:
      | AssetScalarWhereWithAggregatesInput
      | AssetScalarWhereWithAggregatesInput[];
    OR?: AssetScalarWhereWithAggregatesInput[];
    NOT?:
      | AssetScalarWhereWithAggregatesInput
      | AssetScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"Asset"> | string;
    name?: StringWithAggregatesFilter<"Asset"> | string;
    description?: StringNullableWithAggregatesFilter<"Asset"> | string | null;
    category?:
      | EnumAssetCategoryWithAggregatesFilter<"Asset">
      | $Enums.AssetCategory;
    createdAt?: DateTimeWithAggregatesFilter<"Asset"> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<"Asset"> | Date | string;
  };

  export type FoodStoreItemWhereInput = {
    AND?: FoodStoreItemWhereInput | FoodStoreItemWhereInput[];
    OR?: FoodStoreItemWhereInput[];
    NOT?: FoodStoreItemWhereInput | FoodStoreItemWhereInput[];
    id?: StringFilter<"FoodStoreItem"> | string;
    assetId?: StringFilter<"FoodStoreItem"> | string;
    foodName?: StringFilter<"FoodStoreItem"> | string;
    unit?: EnumAssetUnitFilter<"FoodStoreItem"> | $Enums.AssetUnit;
    quantity?: FloatNullableFilter<"FoodStoreItem"> | number | null;
    createdAt?: DateTimeFilter<"FoodStoreItem"> | Date | string;
    updatedAt?: DateTimeFilter<"FoodStoreItem"> | Date | string;
    supplierId?: StringNullableFilter<"FoodStoreItem"> | string | null;
    trackQuantity?: BoolFilter<"FoodStoreItem"> | boolean;
    status?:
      | EnumAssetItemStatusFilter<"FoodStoreItem">
      | $Enums.AssetItemStatus;
    isConsumable?: BoolFilter<"FoodStoreItem"> | boolean;
    consumptions?: FoodConsumptionListRelationFilter;
    asset?: XOR<AssetScalarRelationFilter, AssetWhereInput>;
    supplier?: XOR<
      SupplierNullableScalarRelationFilter,
      SupplierWhereInput
    > | null;
    individualFoodStoreItems?: IndividualFoodStoreItemListRelationFilter;
  };

  export type FoodStoreItemOrderByWithRelationInput = {
    id?: SortOrder;
    assetId?: SortOrder;
    foodName?: SortOrder;
    unit?: SortOrder;
    quantity?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    supplierId?: SortOrderInput | SortOrder;
    trackQuantity?: SortOrder;
    status?: SortOrder;
    isConsumable?: SortOrder;
    consumptions?: FoodConsumptionOrderByRelationAggregateInput;
    asset?: AssetOrderByWithRelationInput;
    supplier?: SupplierOrderByWithRelationInput;
    individualFoodStoreItems?: IndividualFoodStoreItemOrderByRelationAggregateInput;
  };

  export type FoodStoreItemWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: FoodStoreItemWhereInput | FoodStoreItemWhereInput[];
      OR?: FoodStoreItemWhereInput[];
      NOT?: FoodStoreItemWhereInput | FoodStoreItemWhereInput[];
      assetId?: StringFilter<"FoodStoreItem"> | string;
      foodName?: StringFilter<"FoodStoreItem"> | string;
      unit?: EnumAssetUnitFilter<"FoodStoreItem"> | $Enums.AssetUnit;
      quantity?: FloatNullableFilter<"FoodStoreItem"> | number | null;
      createdAt?: DateTimeFilter<"FoodStoreItem"> | Date | string;
      updatedAt?: DateTimeFilter<"FoodStoreItem"> | Date | string;
      supplierId?: StringNullableFilter<"FoodStoreItem"> | string | null;
      trackQuantity?: BoolFilter<"FoodStoreItem"> | boolean;
      status?:
        | EnumAssetItemStatusFilter<"FoodStoreItem">
        | $Enums.AssetItemStatus;
      isConsumable?: BoolFilter<"FoodStoreItem"> | boolean;
      consumptions?: FoodConsumptionListRelationFilter;
      asset?: XOR<AssetScalarRelationFilter, AssetWhereInput>;
      supplier?: XOR<
        SupplierNullableScalarRelationFilter,
        SupplierWhereInput
      > | null;
      individualFoodStoreItems?: IndividualFoodStoreItemListRelationFilter;
    },
    "id"
  >;

  export type FoodStoreItemOrderByWithAggregationInput = {
    id?: SortOrder;
    assetId?: SortOrder;
    foodName?: SortOrder;
    unit?: SortOrder;
    quantity?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    supplierId?: SortOrderInput | SortOrder;
    trackQuantity?: SortOrder;
    status?: SortOrder;
    isConsumable?: SortOrder;
    _count?: FoodStoreItemCountOrderByAggregateInput;
    _avg?: FoodStoreItemAvgOrderByAggregateInput;
    _max?: FoodStoreItemMaxOrderByAggregateInput;
    _min?: FoodStoreItemMinOrderByAggregateInput;
    _sum?: FoodStoreItemSumOrderByAggregateInput;
  };

  export type FoodStoreItemScalarWhereWithAggregatesInput = {
    AND?:
      | FoodStoreItemScalarWhereWithAggregatesInput
      | FoodStoreItemScalarWhereWithAggregatesInput[];
    OR?: FoodStoreItemScalarWhereWithAggregatesInput[];
    NOT?:
      | FoodStoreItemScalarWhereWithAggregatesInput
      | FoodStoreItemScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"FoodStoreItem"> | string;
    assetId?: StringWithAggregatesFilter<"FoodStoreItem"> | string;
    foodName?: StringWithAggregatesFilter<"FoodStoreItem"> | string;
    unit?:
      | EnumAssetUnitWithAggregatesFilter<"FoodStoreItem">
      | $Enums.AssetUnit;
    quantity?:
      | FloatNullableWithAggregatesFilter<"FoodStoreItem">
      | number
      | null;
    createdAt?: DateTimeWithAggregatesFilter<"FoodStoreItem"> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<"FoodStoreItem"> | Date | string;
    supplierId?:
      | StringNullableWithAggregatesFilter<"FoodStoreItem">
      | string
      | null;
    trackQuantity?: BoolWithAggregatesFilter<"FoodStoreItem"> | boolean;
    status?:
      | EnumAssetItemStatusWithAggregatesFilter<"FoodStoreItem">
      | $Enums.AssetItemStatus;
    isConsumable?: BoolWithAggregatesFilter<"FoodStoreItem"> | boolean;
  };

  export type IndividualFoodStoreItemWhereInput = {
    AND?:
      | IndividualFoodStoreItemWhereInput
      | IndividualFoodStoreItemWhereInput[];
    OR?: IndividualFoodStoreItemWhereInput[];
    NOT?:
      | IndividualFoodStoreItemWhereInput
      | IndividualFoodStoreItemWhereInput[];
    id?: StringFilter<"IndividualFoodStoreItem"> | string;
    foodStoreItemId?: StringFilter<"IndividualFoodStoreItem"> | string;
    uniqueIdentifier?:
      | StringNullableFilter<"IndividualFoodStoreItem">
      | string
      | null;
    status?:
      | EnumAssetStatusFilter<"IndividualFoodStoreItem">
      | $Enums.AssetStatus;
    condition?:
      | EnumAssetConditionFilter<"IndividualFoodStoreItem">
      | $Enums.AssetCondition;
    createdAt?: DateTimeFilter<"IndividualFoodStoreItem"> | Date | string;
    updatedAt?: DateTimeFilter<"IndividualFoodStoreItem"> | Date | string;
    assetDamages?: AssetDamageListRelationFilter;
    foodStoreItem?: XOR<
      FoodStoreItemScalarRelationFilter,
      FoodStoreItemWhereInput
    >;
  };

  export type IndividualFoodStoreItemOrderByWithRelationInput = {
    id?: SortOrder;
    foodStoreItemId?: SortOrder;
    uniqueIdentifier?: SortOrderInput | SortOrder;
    status?: SortOrder;
    condition?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    assetDamages?: AssetDamageOrderByRelationAggregateInput;
    foodStoreItem?: FoodStoreItemOrderByWithRelationInput;
  };

  export type IndividualFoodStoreItemWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      uniqueIdentifier?: string;
      AND?:
        | IndividualFoodStoreItemWhereInput
        | IndividualFoodStoreItemWhereInput[];
      OR?: IndividualFoodStoreItemWhereInput[];
      NOT?:
        | IndividualFoodStoreItemWhereInput
        | IndividualFoodStoreItemWhereInput[];
      foodStoreItemId?: StringFilter<"IndividualFoodStoreItem"> | string;
      status?:
        | EnumAssetStatusFilter<"IndividualFoodStoreItem">
        | $Enums.AssetStatus;
      condition?:
        | EnumAssetConditionFilter<"IndividualFoodStoreItem">
        | $Enums.AssetCondition;
      createdAt?: DateTimeFilter<"IndividualFoodStoreItem"> | Date | string;
      updatedAt?: DateTimeFilter<"IndividualFoodStoreItem"> | Date | string;
      assetDamages?: AssetDamageListRelationFilter;
      foodStoreItem?: XOR<
        FoodStoreItemScalarRelationFilter,
        FoodStoreItemWhereInput
      >;
    },
    "id" | "uniqueIdentifier"
  >;

  export type IndividualFoodStoreItemOrderByWithAggregationInput = {
    id?: SortOrder;
    foodStoreItemId?: SortOrder;
    uniqueIdentifier?: SortOrderInput | SortOrder;
    status?: SortOrder;
    condition?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: IndividualFoodStoreItemCountOrderByAggregateInput;
    _max?: IndividualFoodStoreItemMaxOrderByAggregateInput;
    _min?: IndividualFoodStoreItemMinOrderByAggregateInput;
  };

  export type IndividualFoodStoreItemScalarWhereWithAggregatesInput = {
    AND?:
      | IndividualFoodStoreItemScalarWhereWithAggregatesInput
      | IndividualFoodStoreItemScalarWhereWithAggregatesInput[];
    OR?: IndividualFoodStoreItemScalarWhereWithAggregatesInput[];
    NOT?:
      | IndividualFoodStoreItemScalarWhereWithAggregatesInput
      | IndividualFoodStoreItemScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"IndividualFoodStoreItem"> | string;
    foodStoreItemId?:
      | StringWithAggregatesFilter<"IndividualFoodStoreItem">
      | string;
    uniqueIdentifier?:
      | StringNullableWithAggregatesFilter<"IndividualFoodStoreItem">
      | string
      | null;
    status?:
      | EnumAssetStatusWithAggregatesFilter<"IndividualFoodStoreItem">
      | $Enums.AssetStatus;
    condition?:
      | EnumAssetConditionWithAggregatesFilter<"IndividualFoodStoreItem">
      | $Enums.AssetCondition;
    createdAt?:
      | DateTimeWithAggregatesFilter<"IndividualFoodStoreItem">
      | Date
      | string;
    updatedAt?:
      | DateTimeWithAggregatesFilter<"IndividualFoodStoreItem">
      | Date
      | string;
  };

  export type FoodConsumptionWhereInput = {
    AND?: FoodConsumptionWhereInput | FoodConsumptionWhereInput[];
    OR?: FoodConsumptionWhereInput[];
    NOT?: FoodConsumptionWhereInput | FoodConsumptionWhereInput[];
    id?: StringFilter<"FoodConsumption"> | string;
    quantityUsed?: FloatNullableFilter<"FoodConsumption"> | number | null;
    dateUsedAt?: DateTimeFilter<"FoodConsumption"> | Date | string;
    usageDetails?: StringNullableFilter<"FoodConsumption"> | string | null;
    foodStoreItemId?: StringFilter<"FoodConsumption"> | string;
    foodItem?: XOR<FoodStoreItemScalarRelationFilter, FoodStoreItemWhereInput>;
  };

  export type FoodConsumptionOrderByWithRelationInput = {
    id?: SortOrder;
    quantityUsed?: SortOrderInput | SortOrder;
    dateUsedAt?: SortOrder;
    usageDetails?: SortOrderInput | SortOrder;
    foodStoreItemId?: SortOrder;
    foodItem?: FoodStoreItemOrderByWithRelationInput;
  };

  export type FoodConsumptionWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: FoodConsumptionWhereInput | FoodConsumptionWhereInput[];
      OR?: FoodConsumptionWhereInput[];
      NOT?: FoodConsumptionWhereInput | FoodConsumptionWhereInput[];
      quantityUsed?: FloatNullableFilter<"FoodConsumption"> | number | null;
      dateUsedAt?: DateTimeFilter<"FoodConsumption"> | Date | string;
      usageDetails?: StringNullableFilter<"FoodConsumption"> | string | null;
      foodStoreItemId?: StringFilter<"FoodConsumption"> | string;
      foodItem?: XOR<
        FoodStoreItemScalarRelationFilter,
        FoodStoreItemWhereInput
      >;
    },
    "id"
  >;

  export type FoodConsumptionOrderByWithAggregationInput = {
    id?: SortOrder;
    quantityUsed?: SortOrderInput | SortOrder;
    dateUsedAt?: SortOrder;
    usageDetails?: SortOrderInput | SortOrder;
    foodStoreItemId?: SortOrder;
    _count?: FoodConsumptionCountOrderByAggregateInput;
    _avg?: FoodConsumptionAvgOrderByAggregateInput;
    _max?: FoodConsumptionMaxOrderByAggregateInput;
    _min?: FoodConsumptionMinOrderByAggregateInput;
    _sum?: FoodConsumptionSumOrderByAggregateInput;
  };

  export type FoodConsumptionScalarWhereWithAggregatesInput = {
    AND?:
      | FoodConsumptionScalarWhereWithAggregatesInput
      | FoodConsumptionScalarWhereWithAggregatesInput[];
    OR?: FoodConsumptionScalarWhereWithAggregatesInput[];
    NOT?:
      | FoodConsumptionScalarWhereWithAggregatesInput
      | FoodConsumptionScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"FoodConsumption"> | string;
    quantityUsed?:
      | FloatNullableWithAggregatesFilter<"FoodConsumption">
      | number
      | null;
    dateUsedAt?:
      | DateTimeWithAggregatesFilter<"FoodConsumption">
      | Date
      | string;
    usageDetails?:
      | StringNullableWithAggregatesFilter<"FoodConsumption">
      | string
      | null;
    foodStoreItemId?: StringWithAggregatesFilter<"FoodConsumption"> | string;
  };

  export type SupplierWhereInput = {
    AND?: SupplierWhereInput | SupplierWhereInput[];
    OR?: SupplierWhereInput[];
    NOT?: SupplierWhereInput | SupplierWhereInput[];
    id?: StringFilter<"Supplier"> | string;
    name?: StringFilter<"Supplier"> | string;
    contactInfo?: StringNullableFilter<"Supplier"> | string | null;
    address?: StringNullableFilter<"Supplier"> | string | null;
    createdAt?: DateTimeFilter<"Supplier"> | Date | string;
    updatedAt?: DateTimeFilter<"Supplier"> | Date | string;
    foodStoreItems?: FoodStoreItemListRelationFilter;
  };

  export type SupplierOrderByWithRelationInput = {
    id?: SortOrder;
    name?: SortOrder;
    contactInfo?: SortOrderInput | SortOrder;
    address?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    foodStoreItems?: FoodStoreItemOrderByRelationAggregateInput;
  };

  export type SupplierWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: SupplierWhereInput | SupplierWhereInput[];
      OR?: SupplierWhereInput[];
      NOT?: SupplierWhereInput | SupplierWhereInput[];
      name?: StringFilter<"Supplier"> | string;
      contactInfo?: StringNullableFilter<"Supplier"> | string | null;
      address?: StringNullableFilter<"Supplier"> | string | null;
      createdAt?: DateTimeFilter<"Supplier"> | Date | string;
      updatedAt?: DateTimeFilter<"Supplier"> | Date | string;
      foodStoreItems?: FoodStoreItemListRelationFilter;
    },
    "id"
  >;

  export type SupplierOrderByWithAggregationInput = {
    id?: SortOrder;
    name?: SortOrder;
    contactInfo?: SortOrderInput | SortOrder;
    address?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: SupplierCountOrderByAggregateInput;
    _max?: SupplierMaxOrderByAggregateInput;
    _min?: SupplierMinOrderByAggregateInput;
  };

  export type SupplierScalarWhereWithAggregatesInput = {
    AND?:
      | SupplierScalarWhereWithAggregatesInput
      | SupplierScalarWhereWithAggregatesInput[];
    OR?: SupplierScalarWhereWithAggregatesInput[];
    NOT?:
      | SupplierScalarWhereWithAggregatesInput
      | SupplierScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"Supplier"> | string;
    name?: StringWithAggregatesFilter<"Supplier"> | string;
    contactInfo?:
      | StringNullableWithAggregatesFilter<"Supplier">
      | string
      | null;
    address?: StringNullableWithAggregatesFilter<"Supplier"> | string | null;
    createdAt?: DateTimeWithAggregatesFilter<"Supplier"> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<"Supplier"> | Date | string;
  };

  export type LibraryBookWhereInput = {
    AND?: LibraryBookWhereInput | LibraryBookWhereInput[];
    OR?: LibraryBookWhereInput[];
    NOT?: LibraryBookWhereInput | LibraryBookWhereInput[];
    id?: StringFilter<"LibraryBook"> | string;
    title?: StringFilter<"LibraryBook"> | string;
    author?: StringFilter<"LibraryBook"> | string;
    assetId?: StringFilter<"LibraryBook"> | string;
    libraryBookCategoryId?: StringFilter<"LibraryBook"> | string;
    quantity?: FloatNullableFilter<"LibraryBook"> | number | null;
    trackQuantity?: BoolFilter<"LibraryBook"> | boolean;
    unit?: EnumAssetUnitFilter<"LibraryBook"> | $Enums.AssetUnit;
    createdAt?: DateTimeFilter<"LibraryBook"> | Date | string;
    updatedAt?: DateTimeFilter<"LibraryBook"> | Date | string;
    individualBooks?: IndividualBookListRelationFilter;
    asset?: XOR<AssetScalarRelationFilter, AssetWhereInput>;
    category?: XOR<
      LibraryBookCategoryScalarRelationFilter,
      LibraryBookCategoryWhereInput
    >;
  };

  export type LibraryBookOrderByWithRelationInput = {
    id?: SortOrder;
    title?: SortOrder;
    author?: SortOrder;
    assetId?: SortOrder;
    libraryBookCategoryId?: SortOrder;
    quantity?: SortOrderInput | SortOrder;
    trackQuantity?: SortOrder;
    unit?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    individualBooks?: IndividualBookOrderByRelationAggregateInput;
    asset?: AssetOrderByWithRelationInput;
    category?: LibraryBookCategoryOrderByWithRelationInput;
  };

  export type LibraryBookWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      title_author?: LibraryBookTitleAuthorCompoundUniqueInput;
      AND?: LibraryBookWhereInput | LibraryBookWhereInput[];
      OR?: LibraryBookWhereInput[];
      NOT?: LibraryBookWhereInput | LibraryBookWhereInput[];
      title?: StringFilter<"LibraryBook"> | string;
      author?: StringFilter<"LibraryBook"> | string;
      assetId?: StringFilter<"LibraryBook"> | string;
      libraryBookCategoryId?: StringFilter<"LibraryBook"> | string;
      quantity?: FloatNullableFilter<"LibraryBook"> | number | null;
      trackQuantity?: BoolFilter<"LibraryBook"> | boolean;
      unit?: EnumAssetUnitFilter<"LibraryBook"> | $Enums.AssetUnit;
      createdAt?: DateTimeFilter<"LibraryBook"> | Date | string;
      updatedAt?: DateTimeFilter<"LibraryBook"> | Date | string;
      individualBooks?: IndividualBookListRelationFilter;
      asset?: XOR<AssetScalarRelationFilter, AssetWhereInput>;
      category?: XOR<
        LibraryBookCategoryScalarRelationFilter,
        LibraryBookCategoryWhereInput
      >;
    },
    "id" | "title_author"
  >;

  export type LibraryBookOrderByWithAggregationInput = {
    id?: SortOrder;
    title?: SortOrder;
    author?: SortOrder;
    assetId?: SortOrder;
    libraryBookCategoryId?: SortOrder;
    quantity?: SortOrderInput | SortOrder;
    trackQuantity?: SortOrder;
    unit?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: LibraryBookCountOrderByAggregateInput;
    _avg?: LibraryBookAvgOrderByAggregateInput;
    _max?: LibraryBookMaxOrderByAggregateInput;
    _min?: LibraryBookMinOrderByAggregateInput;
    _sum?: LibraryBookSumOrderByAggregateInput;
  };

  export type LibraryBookScalarWhereWithAggregatesInput = {
    AND?:
      | LibraryBookScalarWhereWithAggregatesInput
      | LibraryBookScalarWhereWithAggregatesInput[];
    OR?: LibraryBookScalarWhereWithAggregatesInput[];
    NOT?:
      | LibraryBookScalarWhereWithAggregatesInput
      | LibraryBookScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"LibraryBook"> | string;
    title?: StringWithAggregatesFilter<"LibraryBook"> | string;
    author?: StringWithAggregatesFilter<"LibraryBook"> | string;
    assetId?: StringWithAggregatesFilter<"LibraryBook"> | string;
    libraryBookCategoryId?: StringWithAggregatesFilter<"LibraryBook"> | string;
    quantity?: FloatNullableWithAggregatesFilter<"LibraryBook"> | number | null;
    trackQuantity?: BoolWithAggregatesFilter<"LibraryBook"> | boolean;
    unit?: EnumAssetUnitWithAggregatesFilter<"LibraryBook"> | $Enums.AssetUnit;
    createdAt?: DateTimeWithAggregatesFilter<"LibraryBook"> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<"LibraryBook"> | Date | string;
  };

  export type IndividualBookWhereInput = {
    AND?: IndividualBookWhereInput | IndividualBookWhereInput[];
    OR?: IndividualBookWhereInput[];
    NOT?: IndividualBookWhereInput | IndividualBookWhereInput[];
    id?: StringFilter<"IndividualBook"> | string;
    isbn?: StringNullableFilter<"IndividualBook"> | string | null;
    status?: EnumBookStatusFilter<"IndividualBook"> | $Enums.BookStatus;
    createdAt?: DateTimeFilter<"IndividualBook"> | Date | string;
    updatedAt?: DateTimeFilter<"IndividualBook"> | Date | string;
    libraryBookId?: StringFilter<"IndividualBook"> | string;
    condition?:
      | EnumAssetConditionFilter<"IndividualBook">
      | $Enums.AssetCondition;
    borrowCount?: IntFilter<"IndividualBook"> | number;
    bookDamages?: AssetDamageListRelationFilter;
    borrowers?: BorrowerListRelationFilter;
    libraryBook?: XOR<LibraryBookScalarRelationFilter, LibraryBookWhereInput>;
  };

  export type IndividualBookOrderByWithRelationInput = {
    id?: SortOrder;
    isbn?: SortOrderInput | SortOrder;
    status?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    libraryBookId?: SortOrder;
    condition?: SortOrder;
    borrowCount?: SortOrder;
    bookDamages?: AssetDamageOrderByRelationAggregateInput;
    borrowers?: BorrowerOrderByRelationAggregateInput;
    libraryBook?: LibraryBookOrderByWithRelationInput;
  };

  export type IndividualBookWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: IndividualBookWhereInput | IndividualBookWhereInput[];
      OR?: IndividualBookWhereInput[];
      NOT?: IndividualBookWhereInput | IndividualBookWhereInput[];
      isbn?: StringNullableFilter<"IndividualBook"> | string | null;
      status?: EnumBookStatusFilter<"IndividualBook"> | $Enums.BookStatus;
      createdAt?: DateTimeFilter<"IndividualBook"> | Date | string;
      updatedAt?: DateTimeFilter<"IndividualBook"> | Date | string;
      libraryBookId?: StringFilter<"IndividualBook"> | string;
      condition?:
        | EnumAssetConditionFilter<"IndividualBook">
        | $Enums.AssetCondition;
      borrowCount?: IntFilter<"IndividualBook"> | number;
      bookDamages?: AssetDamageListRelationFilter;
      borrowers?: BorrowerListRelationFilter;
      libraryBook?: XOR<LibraryBookScalarRelationFilter, LibraryBookWhereInput>;
    },
    "id"
  >;

  export type IndividualBookOrderByWithAggregationInput = {
    id?: SortOrder;
    isbn?: SortOrderInput | SortOrder;
    status?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    libraryBookId?: SortOrder;
    condition?: SortOrder;
    borrowCount?: SortOrder;
    _count?: IndividualBookCountOrderByAggregateInput;
    _avg?: IndividualBookAvgOrderByAggregateInput;
    _max?: IndividualBookMaxOrderByAggregateInput;
    _min?: IndividualBookMinOrderByAggregateInput;
    _sum?: IndividualBookSumOrderByAggregateInput;
  };

  export type IndividualBookScalarWhereWithAggregatesInput = {
    AND?:
      | IndividualBookScalarWhereWithAggregatesInput
      | IndividualBookScalarWhereWithAggregatesInput[];
    OR?: IndividualBookScalarWhereWithAggregatesInput[];
    NOT?:
      | IndividualBookScalarWhereWithAggregatesInput
      | IndividualBookScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"IndividualBook"> | string;
    isbn?: StringNullableWithAggregatesFilter<"IndividualBook"> | string | null;
    status?:
      | EnumBookStatusWithAggregatesFilter<"IndividualBook">
      | $Enums.BookStatus;
    createdAt?: DateTimeWithAggregatesFilter<"IndividualBook"> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<"IndividualBook"> | Date | string;
    libraryBookId?: StringWithAggregatesFilter<"IndividualBook"> | string;
    condition?:
      | EnumAssetConditionWithAggregatesFilter<"IndividualBook">
      | $Enums.AssetCondition;
    borrowCount?: IntWithAggregatesFilter<"IndividualBook"> | number;
  };

  export type LibraryBookCategoryWhereInput = {
    AND?: LibraryBookCategoryWhereInput | LibraryBookCategoryWhereInput[];
    OR?: LibraryBookCategoryWhereInput[];
    NOT?: LibraryBookCategoryWhereInput | LibraryBookCategoryWhereInput[];
    id?: StringFilter<"LibraryBookCategory"> | string;
    category?: StringFilter<"LibraryBookCategory"> | string;
    description?: StringNullableFilter<"LibraryBookCategory"> | string | null;
    libraryBooks?: LibraryBookListRelationFilter;
  };

  export type LibraryBookCategoryOrderByWithRelationInput = {
    id?: SortOrder;
    category?: SortOrder;
    description?: SortOrderInput | SortOrder;
    libraryBooks?: LibraryBookOrderByRelationAggregateInput;
  };

  export type LibraryBookCategoryWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      category?: string;
      AND?: LibraryBookCategoryWhereInput | LibraryBookCategoryWhereInput[];
      OR?: LibraryBookCategoryWhereInput[];
      NOT?: LibraryBookCategoryWhereInput | LibraryBookCategoryWhereInput[];
      description?: StringNullableFilter<"LibraryBookCategory"> | string | null;
      libraryBooks?: LibraryBookListRelationFilter;
    },
    "id" | "category"
  >;

  export type LibraryBookCategoryOrderByWithAggregationInput = {
    id?: SortOrder;
    category?: SortOrder;
    description?: SortOrderInput | SortOrder;
    _count?: LibraryBookCategoryCountOrderByAggregateInput;
    _max?: LibraryBookCategoryMaxOrderByAggregateInput;
    _min?: LibraryBookCategoryMinOrderByAggregateInput;
  };

  export type LibraryBookCategoryScalarWhereWithAggregatesInput = {
    AND?:
      | LibraryBookCategoryScalarWhereWithAggregatesInput
      | LibraryBookCategoryScalarWhereWithAggregatesInput[];
    OR?: LibraryBookCategoryScalarWhereWithAggregatesInput[];
    NOT?:
      | LibraryBookCategoryScalarWhereWithAggregatesInput
      | LibraryBookCategoryScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"LibraryBookCategory"> | string;
    category?: StringWithAggregatesFilter<"LibraryBookCategory"> | string;
    description?:
      | StringNullableWithAggregatesFilter<"LibraryBookCategory">
      | string
      | null;
  };

  export type BorrowerWhereInput = {
    AND?: BorrowerWhereInput | BorrowerWhereInput[];
    OR?: BorrowerWhereInput[];
    NOT?: BorrowerWhereInput | BorrowerWhereInput[];
    id?: StringFilter<"Borrower"> | string;
    borrowedAt?: DateTimeFilter<"Borrower"> | Date | string;
    returnAt?: DateTimeNullableFilter<"Borrower"> | Date | string | null;
    status?: EnumBorrowStatusFilter<"Borrower"> | $Enums.BorrowStatus;
    userId?: StringFilter<"Borrower"> | string;
    individualBookId?: StringNullableFilter<"Borrower"> | string | null;
    libraryBook?: XOR<
      IndividualBookNullableScalarRelationFilter,
      IndividualBookWhereInput
    > | null;
    user?: XOR<UserScalarRelationFilter, UserWhereInput>;
  };

  export type BorrowerOrderByWithRelationInput = {
    id?: SortOrder;
    borrowedAt?: SortOrder;
    returnAt?: SortOrderInput | SortOrder;
    status?: SortOrder;
    userId?: SortOrder;
    individualBookId?: SortOrderInput | SortOrder;
    libraryBook?: IndividualBookOrderByWithRelationInput;
    user?: UserOrderByWithRelationInput;
  };

  export type BorrowerWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: BorrowerWhereInput | BorrowerWhereInput[];
      OR?: BorrowerWhereInput[];
      NOT?: BorrowerWhereInput | BorrowerWhereInput[];
      borrowedAt?: DateTimeFilter<"Borrower"> | Date | string;
      returnAt?: DateTimeNullableFilter<"Borrower"> | Date | string | null;
      status?: EnumBorrowStatusFilter<"Borrower"> | $Enums.BorrowStatus;
      userId?: StringFilter<"Borrower"> | string;
      individualBookId?: StringNullableFilter<"Borrower"> | string | null;
      libraryBook?: XOR<
        IndividualBookNullableScalarRelationFilter,
        IndividualBookWhereInput
      > | null;
      user?: XOR<UserScalarRelationFilter, UserWhereInput>;
    },
    "id"
  >;

  export type BorrowerOrderByWithAggregationInput = {
    id?: SortOrder;
    borrowedAt?: SortOrder;
    returnAt?: SortOrderInput | SortOrder;
    status?: SortOrder;
    userId?: SortOrder;
    individualBookId?: SortOrderInput | SortOrder;
    _count?: BorrowerCountOrderByAggregateInput;
    _max?: BorrowerMaxOrderByAggregateInput;
    _min?: BorrowerMinOrderByAggregateInput;
  };

  export type BorrowerScalarWhereWithAggregatesInput = {
    AND?:
      | BorrowerScalarWhereWithAggregatesInput
      | BorrowerScalarWhereWithAggregatesInput[];
    OR?: BorrowerScalarWhereWithAggregatesInput[];
    NOT?:
      | BorrowerScalarWhereWithAggregatesInput
      | BorrowerScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"Borrower"> | string;
    borrowedAt?: DateTimeWithAggregatesFilter<"Borrower"> | Date | string;
    returnAt?:
      | DateTimeNullableWithAggregatesFilter<"Borrower">
      | Date
      | string
      | null;
    status?:
      | EnumBorrowStatusWithAggregatesFilter<"Borrower">
      | $Enums.BorrowStatus;
    userId?: StringWithAggregatesFilter<"Borrower"> | string;
    individualBookId?:
      | StringNullableWithAggregatesFilter<"Borrower">
      | string
      | null;
  };

  export type LabItemWhereInput = {
    AND?: LabItemWhereInput | LabItemWhereInput[];
    OR?: LabItemWhereInput[];
    NOT?: LabItemWhereInput | LabItemWhereInput[];
    id?: StringFilter<"LabItem"> | string;
    name?: StringFilter<"LabItem"> | string;
    quantity?: FloatNullableFilter<"LabItem"> | number | null;
    unit?: EnumAssetUnitFilter<"LabItem"> | $Enums.AssetUnit;
    createdAt?: DateTimeFilter<"LabItem"> | Date | string;
    updatedAt?: DateTimeFilter<"LabItem"> | Date | string;
    assetId?: StringFilter<"LabItem"> | string;
    trackQuantity?: BoolFilter<"LabItem"> | boolean;
    status?: EnumAssetStatusFilter<"LabItem"> | $Enums.AssetStatus;
    individualLabItems?: IndividualLabItemListRelationFilter;
    asset?: XOR<AssetScalarRelationFilter, AssetWhereInput>;
  };

  export type LabItemOrderByWithRelationInput = {
    id?: SortOrder;
    name?: SortOrder;
    quantity?: SortOrderInput | SortOrder;
    unit?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    assetId?: SortOrder;
    trackQuantity?: SortOrder;
    status?: SortOrder;
    individualLabItems?: IndividualLabItemOrderByRelationAggregateInput;
    asset?: AssetOrderByWithRelationInput;
  };

  export type LabItemWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: LabItemWhereInput | LabItemWhereInput[];
      OR?: LabItemWhereInput[];
      NOT?: LabItemWhereInput | LabItemWhereInput[];
      name?: StringFilter<"LabItem"> | string;
      quantity?: FloatNullableFilter<"LabItem"> | number | null;
      unit?: EnumAssetUnitFilter<"LabItem"> | $Enums.AssetUnit;
      createdAt?: DateTimeFilter<"LabItem"> | Date | string;
      updatedAt?: DateTimeFilter<"LabItem"> | Date | string;
      assetId?: StringFilter<"LabItem"> | string;
      trackQuantity?: BoolFilter<"LabItem"> | boolean;
      status?: EnumAssetStatusFilter<"LabItem"> | $Enums.AssetStatus;
      individualLabItems?: IndividualLabItemListRelationFilter;
      asset?: XOR<AssetScalarRelationFilter, AssetWhereInput>;
    },
    "id"
  >;

  export type LabItemOrderByWithAggregationInput = {
    id?: SortOrder;
    name?: SortOrder;
    quantity?: SortOrderInput | SortOrder;
    unit?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    assetId?: SortOrder;
    trackQuantity?: SortOrder;
    status?: SortOrder;
    _count?: LabItemCountOrderByAggregateInput;
    _avg?: LabItemAvgOrderByAggregateInput;
    _max?: LabItemMaxOrderByAggregateInput;
    _min?: LabItemMinOrderByAggregateInput;
    _sum?: LabItemSumOrderByAggregateInput;
  };

  export type LabItemScalarWhereWithAggregatesInput = {
    AND?:
      | LabItemScalarWhereWithAggregatesInput
      | LabItemScalarWhereWithAggregatesInput[];
    OR?: LabItemScalarWhereWithAggregatesInput[];
    NOT?:
      | LabItemScalarWhereWithAggregatesInput
      | LabItemScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"LabItem"> | string;
    name?: StringWithAggregatesFilter<"LabItem"> | string;
    quantity?: FloatNullableWithAggregatesFilter<"LabItem"> | number | null;
    unit?: EnumAssetUnitWithAggregatesFilter<"LabItem"> | $Enums.AssetUnit;
    createdAt?: DateTimeWithAggregatesFilter<"LabItem"> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<"LabItem"> | Date | string;
    assetId?: StringWithAggregatesFilter<"LabItem"> | string;
    trackQuantity?: BoolWithAggregatesFilter<"LabItem"> | boolean;
    status?:
      | EnumAssetStatusWithAggregatesFilter<"LabItem">
      | $Enums.AssetStatus;
  };

  export type IndividualLabItemWhereInput = {
    AND?: IndividualLabItemWhereInput | IndividualLabItemWhereInput[];
    OR?: IndividualLabItemWhereInput[];
    NOT?: IndividualLabItemWhereInput | IndividualLabItemWhereInput[];
    id?: StringFilter<"IndividualLabItem"> | string;
    labItemId?: StringFilter<"IndividualLabItem"> | string;
    uniqueIdentifier?:
      | StringNullableFilter<"IndividualLabItem">
      | string
      | null;
    status?: EnumAssetStatusFilter<"IndividualLabItem"> | $Enums.AssetStatus;
    condition?:
      | EnumAssetConditionFilter<"IndividualLabItem">
      | $Enums.AssetCondition;
    createdAt?: DateTimeFilter<"IndividualLabItem"> | Date | string;
    updatedAt?: DateTimeFilter<"IndividualLabItem"> | Date | string;
    assetDamages?: AssetDamageListRelationFilter;
    labItem?: XOR<LabItemScalarRelationFilter, LabItemWhereInput>;
  };

  export type IndividualLabItemOrderByWithRelationInput = {
    id?: SortOrder;
    labItemId?: SortOrder;
    uniqueIdentifier?: SortOrderInput | SortOrder;
    status?: SortOrder;
    condition?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    assetDamages?: AssetDamageOrderByRelationAggregateInput;
    labItem?: LabItemOrderByWithRelationInput;
  };

  export type IndividualLabItemWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      uniqueIdentifier?: string;
      AND?: IndividualLabItemWhereInput | IndividualLabItemWhereInput[];
      OR?: IndividualLabItemWhereInput[];
      NOT?: IndividualLabItemWhereInput | IndividualLabItemWhereInput[];
      labItemId?: StringFilter<"IndividualLabItem"> | string;
      status?: EnumAssetStatusFilter<"IndividualLabItem"> | $Enums.AssetStatus;
      condition?:
        | EnumAssetConditionFilter<"IndividualLabItem">
        | $Enums.AssetCondition;
      createdAt?: DateTimeFilter<"IndividualLabItem"> | Date | string;
      updatedAt?: DateTimeFilter<"IndividualLabItem"> | Date | string;
      assetDamages?: AssetDamageListRelationFilter;
      labItem?: XOR<LabItemScalarRelationFilter, LabItemWhereInput>;
    },
    "id" | "uniqueIdentifier"
  >;

  export type IndividualLabItemOrderByWithAggregationInput = {
    id?: SortOrder;
    labItemId?: SortOrder;
    uniqueIdentifier?: SortOrderInput | SortOrder;
    status?: SortOrder;
    condition?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: IndividualLabItemCountOrderByAggregateInput;
    _max?: IndividualLabItemMaxOrderByAggregateInput;
    _min?: IndividualLabItemMinOrderByAggregateInput;
  };

  export type IndividualLabItemScalarWhereWithAggregatesInput = {
    AND?:
      | IndividualLabItemScalarWhereWithAggregatesInput
      | IndividualLabItemScalarWhereWithAggregatesInput[];
    OR?: IndividualLabItemScalarWhereWithAggregatesInput[];
    NOT?:
      | IndividualLabItemScalarWhereWithAggregatesInput
      | IndividualLabItemScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"IndividualLabItem"> | string;
    labItemId?: StringWithAggregatesFilter<"IndividualLabItem"> | string;
    uniqueIdentifier?:
      | StringNullableWithAggregatesFilter<"IndividualLabItem">
      | string
      | null;
    status?:
      | EnumAssetStatusWithAggregatesFilter<"IndividualLabItem">
      | $Enums.AssetStatus;
    condition?:
      | EnumAssetConditionWithAggregatesFilter<"IndividualLabItem">
      | $Enums.AssetCondition;
    createdAt?:
      | DateTimeWithAggregatesFilter<"IndividualLabItem">
      | Date
      | string;
    updatedAt?:
      | DateTimeWithAggregatesFilter<"IndividualLabItem">
      | Date
      | string;
  };

  export type ComputerLabItemWhereInput = {
    AND?: ComputerLabItemWhereInput | ComputerLabItemWhereInput[];
    OR?: ComputerLabItemWhereInput[];
    NOT?: ComputerLabItemWhereInput | ComputerLabItemWhereInput[];
    id?: StringFilter<"ComputerLabItem"> | string;
    name?: StringFilter<"ComputerLabItem"> | string;
    model?: StringNullableFilter<"ComputerLabItem"> | string | null;
    specification?: StringNullableFilter<"ComputerLabItem"> | string | null;
    quantity?: FloatNullableFilter<"ComputerLabItem"> | number | null;
    createdAt?: DateTimeFilter<"ComputerLabItem"> | Date | string;
    updatedAt?: DateTimeFilter<"ComputerLabItem"> | Date | string;
    assetId?: StringFilter<"ComputerLabItem"> | string;
    trackQuantity?: BoolFilter<"ComputerLabItem"> | boolean;
    unit?: EnumAssetUnitFilter<"ComputerLabItem"> | $Enums.AssetUnit;
    asset?: XOR<AssetScalarRelationFilter, AssetWhereInput>;
    individualComputerLabItems?: IndividualComputerLabItemListRelationFilter;
  };

  export type ComputerLabItemOrderByWithRelationInput = {
    id?: SortOrder;
    name?: SortOrder;
    model?: SortOrderInput | SortOrder;
    specification?: SortOrderInput | SortOrder;
    quantity?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    assetId?: SortOrder;
    trackQuantity?: SortOrder;
    unit?: SortOrder;
    asset?: AssetOrderByWithRelationInput;
    individualComputerLabItems?: IndividualComputerLabItemOrderByRelationAggregateInput;
  };

  export type ComputerLabItemWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: ComputerLabItemWhereInput | ComputerLabItemWhereInput[];
      OR?: ComputerLabItemWhereInput[];
      NOT?: ComputerLabItemWhereInput | ComputerLabItemWhereInput[];
      name?: StringFilter<"ComputerLabItem"> | string;
      model?: StringNullableFilter<"ComputerLabItem"> | string | null;
      specification?: StringNullableFilter<"ComputerLabItem"> | string | null;
      quantity?: FloatNullableFilter<"ComputerLabItem"> | number | null;
      createdAt?: DateTimeFilter<"ComputerLabItem"> | Date | string;
      updatedAt?: DateTimeFilter<"ComputerLabItem"> | Date | string;
      assetId?: StringFilter<"ComputerLabItem"> | string;
      trackQuantity?: BoolFilter<"ComputerLabItem"> | boolean;
      unit?: EnumAssetUnitFilter<"ComputerLabItem"> | $Enums.AssetUnit;
      asset?: XOR<AssetScalarRelationFilter, AssetWhereInput>;
      individualComputerLabItems?: IndividualComputerLabItemListRelationFilter;
    },
    "id"
  >;

  export type ComputerLabItemOrderByWithAggregationInput = {
    id?: SortOrder;
    name?: SortOrder;
    model?: SortOrderInput | SortOrder;
    specification?: SortOrderInput | SortOrder;
    quantity?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    assetId?: SortOrder;
    trackQuantity?: SortOrder;
    unit?: SortOrder;
    _count?: ComputerLabItemCountOrderByAggregateInput;
    _avg?: ComputerLabItemAvgOrderByAggregateInput;
    _max?: ComputerLabItemMaxOrderByAggregateInput;
    _min?: ComputerLabItemMinOrderByAggregateInput;
    _sum?: ComputerLabItemSumOrderByAggregateInput;
  };

  export type ComputerLabItemScalarWhereWithAggregatesInput = {
    AND?:
      | ComputerLabItemScalarWhereWithAggregatesInput
      | ComputerLabItemScalarWhereWithAggregatesInput[];
    OR?: ComputerLabItemScalarWhereWithAggregatesInput[];
    NOT?:
      | ComputerLabItemScalarWhereWithAggregatesInput
      | ComputerLabItemScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"ComputerLabItem"> | string;
    name?: StringWithAggregatesFilter<"ComputerLabItem"> | string;
    model?:
      | StringNullableWithAggregatesFilter<"ComputerLabItem">
      | string
      | null;
    specification?:
      | StringNullableWithAggregatesFilter<"ComputerLabItem">
      | string
      | null;
    quantity?:
      | FloatNullableWithAggregatesFilter<"ComputerLabItem">
      | number
      | null;
    createdAt?: DateTimeWithAggregatesFilter<"ComputerLabItem"> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<"ComputerLabItem"> | Date | string;
    assetId?: StringWithAggregatesFilter<"ComputerLabItem"> | string;
    trackQuantity?: BoolWithAggregatesFilter<"ComputerLabItem"> | boolean;
    unit?:
      | EnumAssetUnitWithAggregatesFilter<"ComputerLabItem">
      | $Enums.AssetUnit;
  };

  export type IndividualComputerLabItemWhereInput = {
    AND?:
      | IndividualComputerLabItemWhereInput
      | IndividualComputerLabItemWhereInput[];
    OR?: IndividualComputerLabItemWhereInput[];
    NOT?:
      | IndividualComputerLabItemWhereInput
      | IndividualComputerLabItemWhereInput[];
    id?: StringFilter<"IndividualComputerLabItem"> | string;
    computerLabItemId?: StringFilter<"IndividualComputerLabItem"> | string;
    uniqueIdentifier?:
      | StringNullableFilter<"IndividualComputerLabItem">
      | string
      | null;
    status?:
      | EnumAssetStatusFilter<"IndividualComputerLabItem">
      | $Enums.AssetStatus;
    condition?:
      | EnumAssetConditionFilter<"IndividualComputerLabItem">
      | $Enums.AssetCondition;
    createdAt?: DateTimeFilter<"IndividualComputerLabItem"> | Date | string;
    updatedAt?: DateTimeFilter<"IndividualComputerLabItem"> | Date | string;
    assetDamages?: AssetDamageListRelationFilter;
    computerLabItem?: XOR<
      ComputerLabItemScalarRelationFilter,
      ComputerLabItemWhereInput
    >;
  };

  export type IndividualComputerLabItemOrderByWithRelationInput = {
    id?: SortOrder;
    computerLabItemId?: SortOrder;
    uniqueIdentifier?: SortOrderInput | SortOrder;
    status?: SortOrder;
    condition?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    assetDamages?: AssetDamageOrderByRelationAggregateInput;
    computerLabItem?: ComputerLabItemOrderByWithRelationInput;
  };

  export type IndividualComputerLabItemWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      uniqueIdentifier?: string;
      AND?:
        | IndividualComputerLabItemWhereInput
        | IndividualComputerLabItemWhereInput[];
      OR?: IndividualComputerLabItemWhereInput[];
      NOT?:
        | IndividualComputerLabItemWhereInput
        | IndividualComputerLabItemWhereInput[];
      computerLabItemId?: StringFilter<"IndividualComputerLabItem"> | string;
      status?:
        | EnumAssetStatusFilter<"IndividualComputerLabItem">
        | $Enums.AssetStatus;
      condition?:
        | EnumAssetConditionFilter<"IndividualComputerLabItem">
        | $Enums.AssetCondition;
      createdAt?: DateTimeFilter<"IndividualComputerLabItem"> | Date | string;
      updatedAt?: DateTimeFilter<"IndividualComputerLabItem"> | Date | string;
      assetDamages?: AssetDamageListRelationFilter;
      computerLabItem?: XOR<
        ComputerLabItemScalarRelationFilter,
        ComputerLabItemWhereInput
      >;
    },
    "id" | "uniqueIdentifier"
  >;

  export type IndividualComputerLabItemOrderByWithAggregationInput = {
    id?: SortOrder;
    computerLabItemId?: SortOrder;
    uniqueIdentifier?: SortOrderInput | SortOrder;
    status?: SortOrder;
    condition?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: IndividualComputerLabItemCountOrderByAggregateInput;
    _max?: IndividualComputerLabItemMaxOrderByAggregateInput;
    _min?: IndividualComputerLabItemMinOrderByAggregateInput;
  };

  export type IndividualComputerLabItemScalarWhereWithAggregatesInput = {
    AND?:
      | IndividualComputerLabItemScalarWhereWithAggregatesInput
      | IndividualComputerLabItemScalarWhereWithAggregatesInput[];
    OR?: IndividualComputerLabItemScalarWhereWithAggregatesInput[];
    NOT?:
      | IndividualComputerLabItemScalarWhereWithAggregatesInput
      | IndividualComputerLabItemScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"IndividualComputerLabItem"> | string;
    computerLabItemId?:
      | StringWithAggregatesFilter<"IndividualComputerLabItem">
      | string;
    uniqueIdentifier?:
      | StringNullableWithAggregatesFilter<"IndividualComputerLabItem">
      | string
      | null;
    status?:
      | EnumAssetStatusWithAggregatesFilter<"IndividualComputerLabItem">
      | $Enums.AssetStatus;
    condition?:
      | EnumAssetConditionWithAggregatesFilter<"IndividualComputerLabItem">
      | $Enums.AssetCondition;
    createdAt?:
      | DateTimeWithAggregatesFilter<"IndividualComputerLabItem">
      | Date
      | string;
    updatedAt?:
      | DateTimeWithAggregatesFilter<"IndividualComputerLabItem">
      | Date
      | string;
  };

  export type GeneralStoreItemWhereInput = {
    AND?: GeneralStoreItemWhereInput | GeneralStoreItemWhereInput[];
    OR?: GeneralStoreItemWhereInput[];
    NOT?: GeneralStoreItemWhereInput | GeneralStoreItemWhereInput[];
    id?: StringFilter<"GeneralStoreItem"> | string;
    name?: StringFilter<"GeneralStoreItem"> | string;
    quantity?: FloatNullableFilter<"GeneralStoreItem"> | number | null;
    createdAt?: DateTimeFilter<"GeneralStoreItem"> | Date | string;
    updatedAt?: DateTimeFilter<"GeneralStoreItem"> | Date | string;
    assetId?: StringFilter<"GeneralStoreItem"> | string;
    status?:
      | EnumAssetItemStatusFilter<"GeneralStoreItem">
      | $Enums.AssetItemStatus;
    trackQuantity?: BoolFilter<"GeneralStoreItem"> | boolean;
    unit?: EnumAssetUnitFilter<"GeneralStoreItem"> | $Enums.AssetUnit;
    asset?: XOR<AssetScalarRelationFilter, AssetWhereInput>;
    individualGeneralStoreItems?: IndividualGeneralStoreItemListRelationFilter;
  };

  export type GeneralStoreItemOrderByWithRelationInput = {
    id?: SortOrder;
    name?: SortOrder;
    quantity?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    assetId?: SortOrder;
    status?: SortOrder;
    trackQuantity?: SortOrder;
    unit?: SortOrder;
    asset?: AssetOrderByWithRelationInput;
    individualGeneralStoreItems?: IndividualGeneralStoreItemOrderByRelationAggregateInput;
  };

  export type GeneralStoreItemWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: GeneralStoreItemWhereInput | GeneralStoreItemWhereInput[];
      OR?: GeneralStoreItemWhereInput[];
      NOT?: GeneralStoreItemWhereInput | GeneralStoreItemWhereInput[];
      name?: StringFilter<"GeneralStoreItem"> | string;
      quantity?: FloatNullableFilter<"GeneralStoreItem"> | number | null;
      createdAt?: DateTimeFilter<"GeneralStoreItem"> | Date | string;
      updatedAt?: DateTimeFilter<"GeneralStoreItem"> | Date | string;
      assetId?: StringFilter<"GeneralStoreItem"> | string;
      status?:
        | EnumAssetItemStatusFilter<"GeneralStoreItem">
        | $Enums.AssetItemStatus;
      trackQuantity?: BoolFilter<"GeneralStoreItem"> | boolean;
      unit?: EnumAssetUnitFilter<"GeneralStoreItem"> | $Enums.AssetUnit;
      asset?: XOR<AssetScalarRelationFilter, AssetWhereInput>;
      individualGeneralStoreItems?: IndividualGeneralStoreItemListRelationFilter;
    },
    "id"
  >;

  export type GeneralStoreItemOrderByWithAggregationInput = {
    id?: SortOrder;
    name?: SortOrder;
    quantity?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    assetId?: SortOrder;
    status?: SortOrder;
    trackQuantity?: SortOrder;
    unit?: SortOrder;
    _count?: GeneralStoreItemCountOrderByAggregateInput;
    _avg?: GeneralStoreItemAvgOrderByAggregateInput;
    _max?: GeneralStoreItemMaxOrderByAggregateInput;
    _min?: GeneralStoreItemMinOrderByAggregateInput;
    _sum?: GeneralStoreItemSumOrderByAggregateInput;
  };

  export type GeneralStoreItemScalarWhereWithAggregatesInput = {
    AND?:
      | GeneralStoreItemScalarWhereWithAggregatesInput
      | GeneralStoreItemScalarWhereWithAggregatesInput[];
    OR?: GeneralStoreItemScalarWhereWithAggregatesInput[];
    NOT?:
      | GeneralStoreItemScalarWhereWithAggregatesInput
      | GeneralStoreItemScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"GeneralStoreItem"> | string;
    name?: StringWithAggregatesFilter<"GeneralStoreItem"> | string;
    quantity?:
      | FloatNullableWithAggregatesFilter<"GeneralStoreItem">
      | number
      | null;
    createdAt?:
      | DateTimeWithAggregatesFilter<"GeneralStoreItem">
      | Date
      | string;
    updatedAt?:
      | DateTimeWithAggregatesFilter<"GeneralStoreItem">
      | Date
      | string;
    assetId?: StringWithAggregatesFilter<"GeneralStoreItem"> | string;
    status?:
      | EnumAssetItemStatusWithAggregatesFilter<"GeneralStoreItem">
      | $Enums.AssetItemStatus;
    trackQuantity?: BoolWithAggregatesFilter<"GeneralStoreItem"> | boolean;
    unit?:
      | EnumAssetUnitWithAggregatesFilter<"GeneralStoreItem">
      | $Enums.AssetUnit;
  };

  export type IndividualGeneralStoreItemWhereInput = {
    AND?:
      | IndividualGeneralStoreItemWhereInput
      | IndividualGeneralStoreItemWhereInput[];
    OR?: IndividualGeneralStoreItemWhereInput[];
    NOT?:
      | IndividualGeneralStoreItemWhereInput
      | IndividualGeneralStoreItemWhereInput[];
    id?: StringFilter<"IndividualGeneralStoreItem"> | string;
    generalStoreItemId?: StringFilter<"IndividualGeneralStoreItem"> | string;
    uniqueIdentifier?:
      | StringNullableFilter<"IndividualGeneralStoreItem">
      | string
      | null;
    status?:
      | EnumAssetStatusFilter<"IndividualGeneralStoreItem">
      | $Enums.AssetStatus;
    condition?:
      | EnumAssetConditionFilter<"IndividualGeneralStoreItem">
      | $Enums.AssetCondition;
    createdAt?: DateTimeFilter<"IndividualGeneralStoreItem"> | Date | string;
    updatedAt?: DateTimeFilter<"IndividualGeneralStoreItem"> | Date | string;
    assetDamages?: AssetDamageListRelationFilter;
    generalStoreItem?: XOR<
      GeneralStoreItemScalarRelationFilter,
      GeneralStoreItemWhereInput
    >;
  };

  export type IndividualGeneralStoreItemOrderByWithRelationInput = {
    id?: SortOrder;
    generalStoreItemId?: SortOrder;
    uniqueIdentifier?: SortOrderInput | SortOrder;
    status?: SortOrder;
    condition?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    assetDamages?: AssetDamageOrderByRelationAggregateInput;
    generalStoreItem?: GeneralStoreItemOrderByWithRelationInput;
  };

  export type IndividualGeneralStoreItemWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      uniqueIdentifier?: string;
      AND?:
        | IndividualGeneralStoreItemWhereInput
        | IndividualGeneralStoreItemWhereInput[];
      OR?: IndividualGeneralStoreItemWhereInput[];
      NOT?:
        | IndividualGeneralStoreItemWhereInput
        | IndividualGeneralStoreItemWhereInput[];
      generalStoreItemId?: StringFilter<"IndividualGeneralStoreItem"> | string;
      status?:
        | EnumAssetStatusFilter<"IndividualGeneralStoreItem">
        | $Enums.AssetStatus;
      condition?:
        | EnumAssetConditionFilter<"IndividualGeneralStoreItem">
        | $Enums.AssetCondition;
      createdAt?: DateTimeFilter<"IndividualGeneralStoreItem"> | Date | string;
      updatedAt?: DateTimeFilter<"IndividualGeneralStoreItem"> | Date | string;
      assetDamages?: AssetDamageListRelationFilter;
      generalStoreItem?: XOR<
        GeneralStoreItemScalarRelationFilter,
        GeneralStoreItemWhereInput
      >;
    },
    "id" | "uniqueIdentifier"
  >;

  export type IndividualGeneralStoreItemOrderByWithAggregationInput = {
    id?: SortOrder;
    generalStoreItemId?: SortOrder;
    uniqueIdentifier?: SortOrderInput | SortOrder;
    status?: SortOrder;
    condition?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: IndividualGeneralStoreItemCountOrderByAggregateInput;
    _max?: IndividualGeneralStoreItemMaxOrderByAggregateInput;
    _min?: IndividualGeneralStoreItemMinOrderByAggregateInput;
  };

  export type IndividualGeneralStoreItemScalarWhereWithAggregatesInput = {
    AND?:
      | IndividualGeneralStoreItemScalarWhereWithAggregatesInput
      | IndividualGeneralStoreItemScalarWhereWithAggregatesInput[];
    OR?: IndividualGeneralStoreItemScalarWhereWithAggregatesInput[];
    NOT?:
      | IndividualGeneralStoreItemScalarWhereWithAggregatesInput
      | IndividualGeneralStoreItemScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"IndividualGeneralStoreItem"> | string;
    generalStoreItemId?:
      | StringWithAggregatesFilter<"IndividualGeneralStoreItem">
      | string;
    uniqueIdentifier?:
      | StringNullableWithAggregatesFilter<"IndividualGeneralStoreItem">
      | string
      | null;
    status?:
      | EnumAssetStatusWithAggregatesFilter<"IndividualGeneralStoreItem">
      | $Enums.AssetStatus;
    condition?:
      | EnumAssetConditionWithAggregatesFilter<"IndividualGeneralStoreItem">
      | $Enums.AssetCondition;
    createdAt?:
      | DateTimeWithAggregatesFilter<"IndividualGeneralStoreItem">
      | Date
      | string;
    updatedAt?:
      | DateTimeWithAggregatesFilter<"IndividualGeneralStoreItem">
      | Date
      | string;
  };

  export type AssetDamageWhereInput = {
    AND?: AssetDamageWhereInput | AssetDamageWhereInput[];
    OR?: AssetDamageWhereInput[];
    NOT?: AssetDamageWhereInput | AssetDamageWhereInput[];
    id?: StringFilter<"AssetDamage"> | string;
    damageDetails?: StringFilter<"AssetDamage"> | string;
    condition?: EnumAssetConditionFilter<"AssetDamage"> | $Enums.AssetCondition;
    quantity?: IntFilter<"AssetDamage"> | number;
    userId?: StringNullableFilter<"AssetDamage"> | string | null;
    individualComputerLabItemId?:
      | StringNullableFilter<"AssetDamage">
      | string
      | null;
    isRepaired?: BoolFilter<"AssetDamage"> | boolean;
    repairedAt?: DateTimeNullableFilter<"AssetDamage"> | Date | string | null;
    createdAt?: DateTimeFilter<"AssetDamage"> | Date | string;
    individualBookId?: StringNullableFilter<"AssetDamage"> | string | null;
    individualLabItemId?: StringNullableFilter<"AssetDamage"> | string | null;
    individualFoodStoreItemId?:
      | StringNullableFilter<"AssetDamage">
      | string
      | null;
    individualGeneralStoreItemId?:
      | StringNullableFilter<"AssetDamage">
      | string
      | null;
    isSchoolCost?: BoolFilter<"AssetDamage"> | boolean;
    repairBalance?: FloatFilter<"AssetDamage"> | number;
    repairPrice?: FloatNullableFilter<"AssetDamage"> | number | null;
    individualBook?: XOR<
      IndividualBookNullableScalarRelationFilter,
      IndividualBookWhereInput
    > | null;
    individualComputerLabItem?: XOR<
      IndividualComputerLabItemNullableScalarRelationFilter,
      IndividualComputerLabItemWhereInput
    > | null;
    individualFoodStoreItem?: XOR<
      IndividualFoodStoreItemNullableScalarRelationFilter,
      IndividualFoodStoreItemWhereInput
    > | null;
    individualGeneralStoreItem?: XOR<
      IndividualGeneralStoreItemNullableScalarRelationFilter,
      IndividualGeneralStoreItemWhereInput
    > | null;
    individualLabItem?: XOR<
      IndividualLabItemNullableScalarRelationFilter,
      IndividualLabItemWhereInput
    > | null;
    damagedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null;
    assetRepairPayments?: AssetRepairPaymentListRelationFilter;
  };

  export type AssetDamageOrderByWithRelationInput = {
    id?: SortOrder;
    damageDetails?: SortOrder;
    condition?: SortOrder;
    quantity?: SortOrder;
    userId?: SortOrderInput | SortOrder;
    individualComputerLabItemId?: SortOrderInput | SortOrder;
    isRepaired?: SortOrder;
    repairedAt?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    individualBookId?: SortOrderInput | SortOrder;
    individualLabItemId?: SortOrderInput | SortOrder;
    individualFoodStoreItemId?: SortOrderInput | SortOrder;
    individualGeneralStoreItemId?: SortOrderInput | SortOrder;
    isSchoolCost?: SortOrder;
    repairBalance?: SortOrder;
    repairPrice?: SortOrderInput | SortOrder;
    individualBook?: IndividualBookOrderByWithRelationInput;
    individualComputerLabItem?: IndividualComputerLabItemOrderByWithRelationInput;
    individualFoodStoreItem?: IndividualFoodStoreItemOrderByWithRelationInput;
    individualGeneralStoreItem?: IndividualGeneralStoreItemOrderByWithRelationInput;
    individualLabItem?: IndividualLabItemOrderByWithRelationInput;
    damagedBy?: UserOrderByWithRelationInput;
    assetRepairPayments?: AssetRepairPaymentOrderByRelationAggregateInput;
  };

  export type AssetDamageWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: AssetDamageWhereInput | AssetDamageWhereInput[];
      OR?: AssetDamageWhereInput[];
      NOT?: AssetDamageWhereInput | AssetDamageWhereInput[];
      damageDetails?: StringFilter<"AssetDamage"> | string;
      condition?:
        | EnumAssetConditionFilter<"AssetDamage">
        | $Enums.AssetCondition;
      quantity?: IntFilter<"AssetDamage"> | number;
      userId?: StringNullableFilter<"AssetDamage"> | string | null;
      individualComputerLabItemId?:
        | StringNullableFilter<"AssetDamage">
        | string
        | null;
      isRepaired?: BoolFilter<"AssetDamage"> | boolean;
      repairedAt?: DateTimeNullableFilter<"AssetDamage"> | Date | string | null;
      createdAt?: DateTimeFilter<"AssetDamage"> | Date | string;
      individualBookId?: StringNullableFilter<"AssetDamage"> | string | null;
      individualLabItemId?: StringNullableFilter<"AssetDamage"> | string | null;
      individualFoodStoreItemId?:
        | StringNullableFilter<"AssetDamage">
        | string
        | null;
      individualGeneralStoreItemId?:
        | StringNullableFilter<"AssetDamage">
        | string
        | null;
      isSchoolCost?: BoolFilter<"AssetDamage"> | boolean;
      repairBalance?: FloatFilter<"AssetDamage"> | number;
      repairPrice?: FloatNullableFilter<"AssetDamage"> | number | null;
      individualBook?: XOR<
        IndividualBookNullableScalarRelationFilter,
        IndividualBookWhereInput
      > | null;
      individualComputerLabItem?: XOR<
        IndividualComputerLabItemNullableScalarRelationFilter,
        IndividualComputerLabItemWhereInput
      > | null;
      individualFoodStoreItem?: XOR<
        IndividualFoodStoreItemNullableScalarRelationFilter,
        IndividualFoodStoreItemWhereInput
      > | null;
      individualGeneralStoreItem?: XOR<
        IndividualGeneralStoreItemNullableScalarRelationFilter,
        IndividualGeneralStoreItemWhereInput
      > | null;
      individualLabItem?: XOR<
        IndividualLabItemNullableScalarRelationFilter,
        IndividualLabItemWhereInput
      > | null;
      damagedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null;
      assetRepairPayments?: AssetRepairPaymentListRelationFilter;
    },
    "id"
  >;

  export type AssetDamageOrderByWithAggregationInput = {
    id?: SortOrder;
    damageDetails?: SortOrder;
    condition?: SortOrder;
    quantity?: SortOrder;
    userId?: SortOrderInput | SortOrder;
    individualComputerLabItemId?: SortOrderInput | SortOrder;
    isRepaired?: SortOrder;
    repairedAt?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    individualBookId?: SortOrderInput | SortOrder;
    individualLabItemId?: SortOrderInput | SortOrder;
    individualFoodStoreItemId?: SortOrderInput | SortOrder;
    individualGeneralStoreItemId?: SortOrderInput | SortOrder;
    isSchoolCost?: SortOrder;
    repairBalance?: SortOrder;
    repairPrice?: SortOrderInput | SortOrder;
    _count?: AssetDamageCountOrderByAggregateInput;
    _avg?: AssetDamageAvgOrderByAggregateInput;
    _max?: AssetDamageMaxOrderByAggregateInput;
    _min?: AssetDamageMinOrderByAggregateInput;
    _sum?: AssetDamageSumOrderByAggregateInput;
  };

  export type AssetDamageScalarWhereWithAggregatesInput = {
    AND?:
      | AssetDamageScalarWhereWithAggregatesInput
      | AssetDamageScalarWhereWithAggregatesInput[];
    OR?: AssetDamageScalarWhereWithAggregatesInput[];
    NOT?:
      | AssetDamageScalarWhereWithAggregatesInput
      | AssetDamageScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"AssetDamage"> | string;
    damageDetails?: StringWithAggregatesFilter<"AssetDamage"> | string;
    condition?:
      | EnumAssetConditionWithAggregatesFilter<"AssetDamage">
      | $Enums.AssetCondition;
    quantity?: IntWithAggregatesFilter<"AssetDamage"> | number;
    userId?: StringNullableWithAggregatesFilter<"AssetDamage"> | string | null;
    individualComputerLabItemId?:
      | StringNullableWithAggregatesFilter<"AssetDamage">
      | string
      | null;
    isRepaired?: BoolWithAggregatesFilter<"AssetDamage"> | boolean;
    repairedAt?:
      | DateTimeNullableWithAggregatesFilter<"AssetDamage">
      | Date
      | string
      | null;
    createdAt?: DateTimeWithAggregatesFilter<"AssetDamage"> | Date | string;
    individualBookId?:
      | StringNullableWithAggregatesFilter<"AssetDamage">
      | string
      | null;
    individualLabItemId?:
      | StringNullableWithAggregatesFilter<"AssetDamage">
      | string
      | null;
    individualFoodStoreItemId?:
      | StringNullableWithAggregatesFilter<"AssetDamage">
      | string
      | null;
    individualGeneralStoreItemId?:
      | StringNullableWithAggregatesFilter<"AssetDamage">
      | string
      | null;
    isSchoolCost?: BoolWithAggregatesFilter<"AssetDamage"> | boolean;
    repairBalance?: FloatWithAggregatesFilter<"AssetDamage"> | number;
    repairPrice?:
      | FloatNullableWithAggregatesFilter<"AssetDamage">
      | number
      | null;
  };

  export type AssetRepairPaymentWhereInput = {
    AND?: AssetRepairPaymentWhereInput | AssetRepairPaymentWhereInput[];
    OR?: AssetRepairPaymentWhereInput[];
    NOT?: AssetRepairPaymentWhereInput | AssetRepairPaymentWhereInput[];
    id?: StringFilter<"AssetRepairPayment"> | string;
    paidAmount?: FloatFilter<"AssetRepairPayment"> | number;
    paidAt?: DateTimeFilter<"AssetRepairPayment"> | Date | string;
    updatedAt?: DateTimeFilter<"AssetRepairPayment"> | Date | string;
    assetDamageId?: StringNullableFilter<"AssetRepairPayment"> | string | null;
    userId?: StringNullableFilter<"AssetRepairPayment"> | string | null;
    isSchoolCost?: BoolFilter<"AssetRepairPayment"> | boolean;
    assetDamage?: XOR<
      AssetDamageNullableScalarRelationFilter,
      AssetDamageWhereInput
    > | null;
    receivedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null;
  };

  export type AssetRepairPaymentOrderByWithRelationInput = {
    id?: SortOrder;
    paidAmount?: SortOrder;
    paidAt?: SortOrder;
    updatedAt?: SortOrder;
    assetDamageId?: SortOrderInput | SortOrder;
    userId?: SortOrderInput | SortOrder;
    isSchoolCost?: SortOrder;
    assetDamage?: AssetDamageOrderByWithRelationInput;
    receivedBy?: UserOrderByWithRelationInput;
  };

  export type AssetRepairPaymentWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: AssetRepairPaymentWhereInput | AssetRepairPaymentWhereInput[];
      OR?: AssetRepairPaymentWhereInput[];
      NOT?: AssetRepairPaymentWhereInput | AssetRepairPaymentWhereInput[];
      paidAmount?: FloatFilter<"AssetRepairPayment"> | number;
      paidAt?: DateTimeFilter<"AssetRepairPayment"> | Date | string;
      updatedAt?: DateTimeFilter<"AssetRepairPayment"> | Date | string;
      assetDamageId?:
        | StringNullableFilter<"AssetRepairPayment">
        | string
        | null;
      userId?: StringNullableFilter<"AssetRepairPayment"> | string | null;
      isSchoolCost?: BoolFilter<"AssetRepairPayment"> | boolean;
      assetDamage?: XOR<
        AssetDamageNullableScalarRelationFilter,
        AssetDamageWhereInput
      > | null;
      receivedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null;
    },
    "id"
  >;

  export type AssetRepairPaymentOrderByWithAggregationInput = {
    id?: SortOrder;
    paidAmount?: SortOrder;
    paidAt?: SortOrder;
    updatedAt?: SortOrder;
    assetDamageId?: SortOrderInput | SortOrder;
    userId?: SortOrderInput | SortOrder;
    isSchoolCost?: SortOrder;
    _count?: AssetRepairPaymentCountOrderByAggregateInput;
    _avg?: AssetRepairPaymentAvgOrderByAggregateInput;
    _max?: AssetRepairPaymentMaxOrderByAggregateInput;
    _min?: AssetRepairPaymentMinOrderByAggregateInput;
    _sum?: AssetRepairPaymentSumOrderByAggregateInput;
  };

  export type AssetRepairPaymentScalarWhereWithAggregatesInput = {
    AND?:
      | AssetRepairPaymentScalarWhereWithAggregatesInput
      | AssetRepairPaymentScalarWhereWithAggregatesInput[];
    OR?: AssetRepairPaymentScalarWhereWithAggregatesInput[];
    NOT?:
      | AssetRepairPaymentScalarWhereWithAggregatesInput
      | AssetRepairPaymentScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"AssetRepairPayment"> | string;
    paidAmount?: FloatWithAggregatesFilter<"AssetRepairPayment"> | number;
    paidAt?: DateTimeWithAggregatesFilter<"AssetRepairPayment"> | Date | string;
    updatedAt?:
      | DateTimeWithAggregatesFilter<"AssetRepairPayment">
      | Date
      | string;
    assetDamageId?:
      | StringNullableWithAggregatesFilter<"AssetRepairPayment">
      | string
      | null;
    userId?:
      | StringNullableWithAggregatesFilter<"AssetRepairPayment">
      | string
      | null;
    isSchoolCost?: BoolWithAggregatesFilter<"AssetRepairPayment"> | boolean;
  };

  export type ExamScoreWhereInput = {
    AND?: ExamScoreWhereInput | ExamScoreWhereInput[];
    OR?: ExamScoreWhereInput[];
    NOT?: ExamScoreWhereInput | ExamScoreWhereInput[];
    id?: StringFilter<"ExamScore"> | string;
    score?: FloatFilter<"ExamScore"> | number;
    createdAt?: DateTimeFilter<"ExamScore"> | Date | string;
    updatedAt?: DateTimeFilter<"ExamScore"> | Date | string;
    examSubjectId?: StringFilter<"ExamScore"> | string;
    pupilId?: StringFilter<"ExamScore"> | string;
    examSubject?: XOR<ExamSubjectScalarRelationFilter, ExamSubjectWhereInput>;
    pupil?: XOR<PupilScalarRelationFilter, PupilWhereInput>;
  };

  export type ExamScoreOrderByWithRelationInput = {
    id?: SortOrder;
    score?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    examSubjectId?: SortOrder;
    pupilId?: SortOrder;
    examSubject?: ExamSubjectOrderByWithRelationInput;
    pupil?: PupilOrderByWithRelationInput;
  };

  export type ExamScoreWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: ExamScoreWhereInput | ExamScoreWhereInput[];
      OR?: ExamScoreWhereInput[];
      NOT?: ExamScoreWhereInput | ExamScoreWhereInput[];
      score?: FloatFilter<"ExamScore"> | number;
      createdAt?: DateTimeFilter<"ExamScore"> | Date | string;
      updatedAt?: DateTimeFilter<"ExamScore"> | Date | string;
      examSubjectId?: StringFilter<"ExamScore"> | string;
      pupilId?: StringFilter<"ExamScore"> | string;
      examSubject?: XOR<ExamSubjectScalarRelationFilter, ExamSubjectWhereInput>;
      pupil?: XOR<PupilScalarRelationFilter, PupilWhereInput>;
    },
    "id"
  >;

  export type ExamScoreOrderByWithAggregationInput = {
    id?: SortOrder;
    score?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    examSubjectId?: SortOrder;
    pupilId?: SortOrder;
    _count?: ExamScoreCountOrderByAggregateInput;
    _avg?: ExamScoreAvgOrderByAggregateInput;
    _max?: ExamScoreMaxOrderByAggregateInput;
    _min?: ExamScoreMinOrderByAggregateInput;
    _sum?: ExamScoreSumOrderByAggregateInput;
  };

  export type ExamScoreScalarWhereWithAggregatesInput = {
    AND?:
      | ExamScoreScalarWhereWithAggregatesInput
      | ExamScoreScalarWhereWithAggregatesInput[];
    OR?: ExamScoreScalarWhereWithAggregatesInput[];
    NOT?:
      | ExamScoreScalarWhereWithAggregatesInput
      | ExamScoreScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"ExamScore"> | string;
    score?: FloatWithAggregatesFilter<"ExamScore"> | number;
    createdAt?: DateTimeWithAggregatesFilter<"ExamScore"> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<"ExamScore"> | Date | string;
    examSubjectId?: StringWithAggregatesFilter<"ExamScore"> | string;
    pupilId?: StringWithAggregatesFilter<"ExamScore"> | string;
  };

  export type ExamWhereInput = {
    AND?: ExamWhereInput | ExamWhereInput[];
    OR?: ExamWhereInput[];
    NOT?: ExamWhereInput | ExamWhereInput[];
    id?: StringFilter<"Exam"> | string;
    examName?: StringFilter<"Exam"> | string;
    examType?: EnumExamTypeFilter<"Exam"> | $Enums.ExamType;
    classTermId?: StringFilter<"Exam"> | string;
    createdAt?: DateTimeFilter<"Exam"> | Date | string;
    updatedAt?: DateTimeFilter<"Exam"> | Date | string;
    examSubjects?: ExamSubjectListRelationFilter;
    classTerm?: XOR<ClassTermScalarRelationFilter, ClassTermWhereInput>;
  };

  export type ExamOrderByWithRelationInput = {
    id?: SortOrder;
    examName?: SortOrder;
    examType?: SortOrder;
    classTermId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    examSubjects?: ExamSubjectOrderByRelationAggregateInput;
    classTerm?: ClassTermOrderByWithRelationInput;
  };

  export type ExamWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      examName_classTermId?: ExamExamNameClassTermIdCompoundUniqueInput;
      AND?: ExamWhereInput | ExamWhereInput[];
      OR?: ExamWhereInput[];
      NOT?: ExamWhereInput | ExamWhereInput[];
      examName?: StringFilter<"Exam"> | string;
      examType?: EnumExamTypeFilter<"Exam"> | $Enums.ExamType;
      classTermId?: StringFilter<"Exam"> | string;
      createdAt?: DateTimeFilter<"Exam"> | Date | string;
      updatedAt?: DateTimeFilter<"Exam"> | Date | string;
      examSubjects?: ExamSubjectListRelationFilter;
      classTerm?: XOR<ClassTermScalarRelationFilter, ClassTermWhereInput>;
    },
    "id" | "examName_classTermId"
  >;

  export type ExamOrderByWithAggregationInput = {
    id?: SortOrder;
    examName?: SortOrder;
    examType?: SortOrder;
    classTermId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: ExamCountOrderByAggregateInput;
    _max?: ExamMaxOrderByAggregateInput;
    _min?: ExamMinOrderByAggregateInput;
  };

  export type ExamScalarWhereWithAggregatesInput = {
    AND?:
      | ExamScalarWhereWithAggregatesInput
      | ExamScalarWhereWithAggregatesInput[];
    OR?: ExamScalarWhereWithAggregatesInput[];
    NOT?:
      | ExamScalarWhereWithAggregatesInput
      | ExamScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"Exam"> | string;
    examName?: StringWithAggregatesFilter<"Exam"> | string;
    examType?: EnumExamTypeWithAggregatesFilter<"Exam"> | $Enums.ExamType;
    classTermId?: StringWithAggregatesFilter<"Exam"> | string;
    createdAt?: DateTimeWithAggregatesFilter<"Exam"> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<"Exam"> | Date | string;
  };

  export type ExamSubjectWhereInput = {
    AND?: ExamSubjectWhereInput | ExamSubjectWhereInput[];
    OR?: ExamSubjectWhereInput[];
    NOT?: ExamSubjectWhereInput | ExamSubjectWhereInput[];
    id?: StringFilter<"ExamSubject"> | string;
    examId?: StringFilter<"ExamSubject"> | string;
    examDate?: DateTimeFilter<"ExamSubject"> | Date | string;
    academicYearSubjectId?: StringFilter<"ExamSubject"> | string;
    exam?: XOR<ExamScalarRelationFilter, ExamWhereInput>;
    academicYearSubject?: XOR<
      AcademicYearSubjectScalarRelationFilter,
      AcademicYearSubjectWhereInput
    >;
    examScores?: ExamScoreListRelationFilter;
  };

  export type ExamSubjectOrderByWithRelationInput = {
    id?: SortOrder;
    examId?: SortOrder;
    examDate?: SortOrder;
    academicYearSubjectId?: SortOrder;
    exam?: ExamOrderByWithRelationInput;
    academicYearSubject?: AcademicYearSubjectOrderByWithRelationInput;
    examScores?: ExamScoreOrderByRelationAggregateInput;
  };

  export type ExamSubjectWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: ExamSubjectWhereInput | ExamSubjectWhereInput[];
      OR?: ExamSubjectWhereInput[];
      NOT?: ExamSubjectWhereInput | ExamSubjectWhereInput[];
      examId?: StringFilter<"ExamSubject"> | string;
      examDate?: DateTimeFilter<"ExamSubject"> | Date | string;
      academicYearSubjectId?: StringFilter<"ExamSubject"> | string;
      exam?: XOR<ExamScalarRelationFilter, ExamWhereInput>;
      academicYearSubject?: XOR<
        AcademicYearSubjectScalarRelationFilter,
        AcademicYearSubjectWhereInput
      >;
      examScores?: ExamScoreListRelationFilter;
    },
    "id"
  >;

  export type ExamSubjectOrderByWithAggregationInput = {
    id?: SortOrder;
    examId?: SortOrder;
    examDate?: SortOrder;
    academicYearSubjectId?: SortOrder;
    _count?: ExamSubjectCountOrderByAggregateInput;
    _max?: ExamSubjectMaxOrderByAggregateInput;
    _min?: ExamSubjectMinOrderByAggregateInput;
  };

  export type ExamSubjectScalarWhereWithAggregatesInput = {
    AND?:
      | ExamSubjectScalarWhereWithAggregatesInput
      | ExamSubjectScalarWhereWithAggregatesInput[];
    OR?: ExamSubjectScalarWhereWithAggregatesInput[];
    NOT?:
      | ExamSubjectScalarWhereWithAggregatesInput
      | ExamSubjectScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"ExamSubject"> | string;
    examId?: StringWithAggregatesFilter<"ExamSubject"> | string;
    examDate?: DateTimeWithAggregatesFilter<"ExamSubject"> | Date | string;
    academicYearSubjectId?: StringWithAggregatesFilter<"ExamSubject"> | string;
  };

  export type UserCreateInput = {
    id?: string;
    name?: string | null;
    username?: string | null;
    email?: string | null;
    avatarUrl?: string | null;
    role?: $Enums.Role | null;
    createdAt?: Date | string;
    telephone?: string | null;
    passwordHash?: string | null;
    googleId?: string | null;
    bio?: string | null;
    isWelcomed?: boolean;
    isVerified?: boolean;
    emailVerified?: boolean;
    assetDamages?: AssetDamageCreateNestedManyWithoutDamagedByInput;
    assetRepairPayments?: AssetRepairPaymentCreateNestedManyWithoutReceivedByInput;
    borrowers?: BorrowerCreateNestedManyWithoutUserInput;
    emailVerificationTokens?: EmailVerificationTokenCreateNestedManyWithoutUserInput;
    feesPayments?: FeesPaymentCreateNestedManyWithoutPaidByInput;
    pupils?: PupilCreateNestedManyWithoutUserInput;
    sessions?: SessionCreateNestedManyWithoutUserInput;
    staffs?: StaffCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateInput = {
    id?: string;
    name?: string | null;
    username?: string | null;
    email?: string | null;
    avatarUrl?: string | null;
    role?: $Enums.Role | null;
    createdAt?: Date | string;
    telephone?: string | null;
    passwordHash?: string | null;
    googleId?: string | null;
    bio?: string | null;
    isWelcomed?: boolean;
    isVerified?: boolean;
    emailVerified?: boolean;
    assetDamages?: AssetDamageUncheckedCreateNestedManyWithoutDamagedByInput;
    assetRepairPayments?: AssetRepairPaymentUncheckedCreateNestedManyWithoutReceivedByInput;
    borrowers?: BorrowerUncheckedCreateNestedManyWithoutUserInput;
    emailVerificationTokens?: EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput;
    feesPayments?: FeesPaymentUncheckedCreateNestedManyWithoutPaidByInput;
    pupils?: PupilUncheckedCreateNestedManyWithoutUserInput;
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput;
    staffs?: StaffUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    telephone?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    googleId?: NullableStringFieldUpdateOperationsInput | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    isWelcomed?: BoolFieldUpdateOperationsInput | boolean;
    isVerified?: BoolFieldUpdateOperationsInput | boolean;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    assetDamages?: AssetDamageUpdateManyWithoutDamagedByNestedInput;
    assetRepairPayments?: AssetRepairPaymentUpdateManyWithoutReceivedByNestedInput;
    borrowers?: BorrowerUpdateManyWithoutUserNestedInput;
    emailVerificationTokens?: EmailVerificationTokenUpdateManyWithoutUserNestedInput;
    feesPayments?: FeesPaymentUpdateManyWithoutPaidByNestedInput;
    pupils?: PupilUpdateManyWithoutUserNestedInput;
    sessions?: SessionUpdateManyWithoutUserNestedInput;
    staffs?: StaffUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    telephone?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    googleId?: NullableStringFieldUpdateOperationsInput | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    isWelcomed?: BoolFieldUpdateOperationsInput | boolean;
    isVerified?: BoolFieldUpdateOperationsInput | boolean;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    assetDamages?: AssetDamageUncheckedUpdateManyWithoutDamagedByNestedInput;
    assetRepairPayments?: AssetRepairPaymentUncheckedUpdateManyWithoutReceivedByNestedInput;
    borrowers?: BorrowerUncheckedUpdateManyWithoutUserNestedInput;
    emailVerificationTokens?: EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput;
    feesPayments?: FeesPaymentUncheckedUpdateManyWithoutPaidByNestedInput;
    pupils?: PupilUncheckedUpdateManyWithoutUserNestedInput;
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput;
    staffs?: StaffUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type UserCreateManyInput = {
    id?: string;
    name?: string | null;
    username?: string | null;
    email?: string | null;
    avatarUrl?: string | null;
    role?: $Enums.Role | null;
    createdAt?: Date | string;
    telephone?: string | null;
    passwordHash?: string | null;
    googleId?: string | null;
    bio?: string | null;
    isWelcomed?: boolean;
    isVerified?: boolean;
    emailVerified?: boolean;
  };

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    telephone?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    googleId?: NullableStringFieldUpdateOperationsInput | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    isWelcomed?: BoolFieldUpdateOperationsInput | boolean;
    isVerified?: BoolFieldUpdateOperationsInput | boolean;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
  };

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    telephone?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    googleId?: NullableStringFieldUpdateOperationsInput | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    isWelcomed?: BoolFieldUpdateOperationsInput | boolean;
    isVerified?: BoolFieldUpdateOperationsInput | boolean;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
  };

  export type EmailVerificationTokenCreateInput = {
    id?: string;
    expires: bigint | number;
    user: UserCreateNestedOneWithoutEmailVerificationTokensInput;
  };

  export type EmailVerificationTokenUncheckedCreateInput = {
    id?: string;
    userId: string;
    expires: bigint | number;
  };

  export type EmailVerificationTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    expires?: BigIntFieldUpdateOperationsInput | bigint | number;
    user?: UserUpdateOneRequiredWithoutEmailVerificationTokensNestedInput;
  };

  export type EmailVerificationTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    expires?: BigIntFieldUpdateOperationsInput | bigint | number;
  };

  export type EmailVerificationTokenCreateManyInput = {
    id?: string;
    userId: string;
    expires: bigint | number;
  };

  export type EmailVerificationTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    expires?: BigIntFieldUpdateOperationsInput | bigint | number;
  };

  export type EmailVerificationTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    expires?: BigIntFieldUpdateOperationsInput | bigint | number;
  };

  export type PupilCreateInput = {
    id?: string;
    genericPassword: string;
    classStreams?: classStreamCreateNestedManyWithoutPupilsInput;
    examScores?: ExamScoreCreateNestedManyWithoutPupilInput;
    fees?: FeesCreateNestedManyWithoutPupilInput;
    user?: UserCreateNestedOneWithoutPupilsInput;
  };

  export type PupilUncheckedCreateInput = {
    id?: string;
    userId?: string | null;
    genericPassword: string;
    classStreams?: classStreamUncheckedCreateNestedManyWithoutPupilsInput;
    examScores?: ExamScoreUncheckedCreateNestedManyWithoutPupilInput;
    fees?: FeesUncheckedCreateNestedManyWithoutPupilInput;
  };

  export type PupilUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    genericPassword?: StringFieldUpdateOperationsInput | string;
    classStreams?: classStreamUpdateManyWithoutPupilsNestedInput;
    examScores?: ExamScoreUpdateManyWithoutPupilNestedInput;
    fees?: FeesUpdateManyWithoutPupilNestedInput;
    user?: UserUpdateOneWithoutPupilsNestedInput;
  };

  export type PupilUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: NullableStringFieldUpdateOperationsInput | string | null;
    genericPassword?: StringFieldUpdateOperationsInput | string;
    classStreams?: classStreamUncheckedUpdateManyWithoutPupilsNestedInput;
    examScores?: ExamScoreUncheckedUpdateManyWithoutPupilNestedInput;
    fees?: FeesUncheckedUpdateManyWithoutPupilNestedInput;
  };

  export type PupilCreateManyInput = {
    id?: string;
    userId?: string | null;
    genericPassword: string;
  };

  export type PupilUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    genericPassword?: StringFieldUpdateOperationsInput | string;
  };

  export type PupilUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: NullableStringFieldUpdateOperationsInput | string | null;
    genericPassword?: StringFieldUpdateOperationsInput | string;
  };

  export type StaffCreateInput = {
    id?: string;
    staffType?: $Enums.StaffType;
    genericPassword: string;
    academicYearSubjects?: AcademicYearSubjectCreateNestedManyWithoutTeachersInput;
    classStreams?: classStreamCreateNestedManyWithoutClassTeacherInput;
    user?: UserCreateNestedOneWithoutStaffsInput;
  };

  export type StaffUncheckedCreateInput = {
    id?: string;
    staffType?: $Enums.StaffType;
    userId?: string | null;
    genericPassword: string;
    academicYearSubjects?: AcademicYearSubjectUncheckedCreateNestedManyWithoutTeachersInput;
    classStreams?: classStreamUncheckedCreateNestedManyWithoutClassTeacherInput;
  };

  export type StaffUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    staffType?: EnumStaffTypeFieldUpdateOperationsInput | $Enums.StaffType;
    genericPassword?: StringFieldUpdateOperationsInput | string;
    academicYearSubjects?: AcademicYearSubjectUpdateManyWithoutTeachersNestedInput;
    classStreams?: classStreamUpdateManyWithoutClassTeacherNestedInput;
    user?: UserUpdateOneWithoutStaffsNestedInput;
  };

  export type StaffUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    staffType?: EnumStaffTypeFieldUpdateOperationsInput | $Enums.StaffType;
    userId?: NullableStringFieldUpdateOperationsInput | string | null;
    genericPassword?: StringFieldUpdateOperationsInput | string;
    academicYearSubjects?: AcademicYearSubjectUncheckedUpdateManyWithoutTeachersNestedInput;
    classStreams?: classStreamUncheckedUpdateManyWithoutClassTeacherNestedInput;
  };

  export type StaffCreateManyInput = {
    id?: string;
    staffType?: $Enums.StaffType;
    userId?: string | null;
    genericPassword: string;
  };

  export type StaffUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    staffType?: EnumStaffTypeFieldUpdateOperationsInput | $Enums.StaffType;
    genericPassword?: StringFieldUpdateOperationsInput | string;
  };

  export type StaffUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    staffType?: EnumStaffTypeFieldUpdateOperationsInput | $Enums.StaffType;
    userId?: NullableStringFieldUpdateOperationsInput | string | null;
    genericPassword?: StringFieldUpdateOperationsInput | string;
  };

  export type LevelCreateInput = {
    id?: string;
    name: string;
    slug: string;
    classes?: ClassCreateNestedManyWithoutLevelInput;
    subjects?: SubjectCreateNestedManyWithoutLevelInput;
  };

  export type LevelUncheckedCreateInput = {
    id?: string;
    name: string;
    slug: string;
    classes?: ClassUncheckedCreateNestedManyWithoutLevelInput;
    subjects?: SubjectUncheckedCreateNestedManyWithoutLevelInput;
  };

  export type LevelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    classes?: ClassUpdateManyWithoutLevelNestedInput;
    subjects?: SubjectUpdateManyWithoutLevelNestedInput;
  };

  export type LevelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    classes?: ClassUncheckedUpdateManyWithoutLevelNestedInput;
    subjects?: SubjectUncheckedUpdateManyWithoutLevelNestedInput;
  };

  export type LevelCreateManyInput = {
    id?: string;
    name: string;
    slug: string;
  };

  export type LevelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
  };

  export type LevelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
  };

  export type StreamCreateInput = {
    id?: string;
    name: string;
    classStreams?: classStreamCreateNestedManyWithoutStreamInput;
  };

  export type StreamUncheckedCreateInput = {
    id?: string;
    name: string;
    classStreams?: classStreamUncheckedCreateNestedManyWithoutStreamInput;
  };

  export type StreamUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    classStreams?: classStreamUpdateManyWithoutStreamNestedInput;
  };

  export type StreamUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    classStreams?: classStreamUncheckedUpdateManyWithoutStreamNestedInput;
  };

  export type StreamCreateManyInput = {
    id?: string;
    name: string;
  };

  export type StreamUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
  };

  export type StreamUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
  };

  export type ClassCreateInput = {
    id?: string;
    name: string;
    createdAt?: Date | string;
    slug: string;
    academicYearClasses?: AcademicYearClassCreateNestedManyWithoutClassInput;
    level?: LevelCreateNestedOneWithoutClassesInput;
  };

  export type ClassUncheckedCreateInput = {
    id?: string;
    name: string;
    levelId?: string | null;
    createdAt?: Date | string;
    slug: string;
    academicYearClasses?: AcademicYearClassUncheckedCreateNestedManyWithoutClassInput;
  };

  export type ClassUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    slug?: StringFieldUpdateOperationsInput | string;
    academicYearClasses?: AcademicYearClassUpdateManyWithoutClassNestedInput;
    level?: LevelUpdateOneWithoutClassesNestedInput;
  };

  export type ClassUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    levelId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    slug?: StringFieldUpdateOperationsInput | string;
    academicYearClasses?: AcademicYearClassUncheckedUpdateManyWithoutClassNestedInput;
  };

  export type ClassCreateManyInput = {
    id?: string;
    name: string;
    levelId?: string | null;
    createdAt?: Date | string;
    slug: string;
  };

  export type ClassUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    slug?: StringFieldUpdateOperationsInput | string;
  };

  export type ClassUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    levelId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    slug?: StringFieldUpdateOperationsInput | string;
  };

  export type AcademicYearCreateInput = {
    id?: string;
    year: string;
    startAt?: Date | string;
    endAt: Date | string;
    academicYearClasses?: AcademicYearClassCreateNestedManyWithoutAcademicYearInput;
  };

  export type AcademicYearUncheckedCreateInput = {
    id?: string;
    year: string;
    startAt?: Date | string;
    endAt: Date | string;
    academicYearClasses?: AcademicYearClassUncheckedCreateNestedManyWithoutAcademicYearInput;
  };

  export type AcademicYearUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    year?: StringFieldUpdateOperationsInput | string;
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    academicYearClasses?: AcademicYearClassUpdateManyWithoutAcademicYearNestedInput;
  };

  export type AcademicYearUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    year?: StringFieldUpdateOperationsInput | string;
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    academicYearClasses?: AcademicYearClassUncheckedUpdateManyWithoutAcademicYearNestedInput;
  };

  export type AcademicYearCreateManyInput = {
    id?: string;
    year: string;
    startAt?: Date | string;
    endAt: Date | string;
  };

  export type AcademicYearUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    year?: StringFieldUpdateOperationsInput | string;
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AcademicYearUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    year?: StringFieldUpdateOperationsInput | string;
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AcademicYearClassCreateInput = {
    id?: string;
    academicYear?: AcademicYearCreateNestedOneWithoutAcademicYearClassesInput;
    class?: ClassCreateNestedOneWithoutAcademicYearClassesInput;
    academicYearSubjects?: AcademicYearSubjectCreateNestedManyWithoutAcademicYearClassInput;
    streams?: classStreamCreateNestedManyWithoutClassInput;
  };

  export type AcademicYearClassUncheckedCreateInput = {
    id?: string;
    academicYearId?: string | null;
    classId?: string | null;
    academicYearSubjects?: AcademicYearSubjectUncheckedCreateNestedManyWithoutAcademicYearClassInput;
    streams?: classStreamUncheckedCreateNestedManyWithoutClassInput;
  };

  export type AcademicYearClassUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    academicYear?: AcademicYearUpdateOneWithoutAcademicYearClassesNestedInput;
    class?: ClassUpdateOneWithoutAcademicYearClassesNestedInput;
    academicYearSubjects?: AcademicYearSubjectUpdateManyWithoutAcademicYearClassNestedInput;
    streams?: classStreamUpdateManyWithoutClassNestedInput;
  };

  export type AcademicYearClassUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    academicYearId?: NullableStringFieldUpdateOperationsInput | string | null;
    classId?: NullableStringFieldUpdateOperationsInput | string | null;
    academicYearSubjects?: AcademicYearSubjectUncheckedUpdateManyWithoutAcademicYearClassNestedInput;
    streams?: classStreamUncheckedUpdateManyWithoutClassNestedInput;
  };

  export type AcademicYearClassCreateManyInput = {
    id?: string;
    academicYearId?: string | null;
    classId?: string | null;
  };

  export type AcademicYearClassUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
  };

  export type AcademicYearClassUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    academicYearId?: NullableStringFieldUpdateOperationsInput | string | null;
    classId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type SubjectCreateInput = {
    id?: string;
    subjectName: string;
    slug: string;
    code: string;
    grading?: GradingCreateNestedManyWithoutSubjectsInput;
    academicYearSubjects?: AcademicYearSubjectCreateNestedManyWithoutSubjectInput;
    level: LevelCreateNestedOneWithoutSubjectsInput;
  };

  export type SubjectUncheckedCreateInput = {
    id?: string;
    subjectName: string;
    slug: string;
    code: string;
    levelId: string;
    grading?: GradingUncheckedCreateNestedManyWithoutSubjectsInput;
    academicYearSubjects?: AcademicYearSubjectUncheckedCreateNestedManyWithoutSubjectInput;
  };

  export type SubjectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    subjectName?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    code?: StringFieldUpdateOperationsInput | string;
    grading?: GradingUpdateManyWithoutSubjectsNestedInput;
    academicYearSubjects?: AcademicYearSubjectUpdateManyWithoutSubjectNestedInput;
    level?: LevelUpdateOneRequiredWithoutSubjectsNestedInput;
  };

  export type SubjectUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    subjectName?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    code?: StringFieldUpdateOperationsInput | string;
    levelId?: StringFieldUpdateOperationsInput | string;
    grading?: GradingUncheckedUpdateManyWithoutSubjectsNestedInput;
    academicYearSubjects?: AcademicYearSubjectUncheckedUpdateManyWithoutSubjectNestedInput;
  };

  export type SubjectCreateManyInput = {
    id?: string;
    subjectName: string;
    slug: string;
    code: string;
    levelId: string;
  };

  export type SubjectUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    subjectName?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    code?: StringFieldUpdateOperationsInput | string;
  };

  export type SubjectUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    subjectName?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    code?: StringFieldUpdateOperationsInput | string;
    levelId?: StringFieldUpdateOperationsInput | string;
  };

  export type GradingCreateInput = {
    id?: string;
    from: number;
    to: number;
    grade: string;
    remarks?: string | null;
    subjects?: SubjectCreateNestedManyWithoutGradingInput;
    academicYearSubjects?: AcademicYearSubjectCreateNestedManyWithoutCustomGradingInput;
  };

  export type GradingUncheckedCreateInput = {
    id?: string;
    from: number;
    to: number;
    grade: string;
    remarks?: string | null;
    subjects?: SubjectUncheckedCreateNestedManyWithoutGradingInput;
    academicYearSubjects?: AcademicYearSubjectUncheckedCreateNestedManyWithoutCustomGradingInput;
  };

  export type GradingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    from?: FloatFieldUpdateOperationsInput | number;
    to?: FloatFieldUpdateOperationsInput | number;
    grade?: StringFieldUpdateOperationsInput | string;
    remarks?: NullableStringFieldUpdateOperationsInput | string | null;
    subjects?: SubjectUpdateManyWithoutGradingNestedInput;
    academicYearSubjects?: AcademicYearSubjectUpdateManyWithoutCustomGradingNestedInput;
  };

  export type GradingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    from?: FloatFieldUpdateOperationsInput | number;
    to?: FloatFieldUpdateOperationsInput | number;
    grade?: StringFieldUpdateOperationsInput | string;
    remarks?: NullableStringFieldUpdateOperationsInput | string | null;
    subjects?: SubjectUncheckedUpdateManyWithoutGradingNestedInput;
    academicYearSubjects?: AcademicYearSubjectUncheckedUpdateManyWithoutCustomGradingNestedInput;
  };

  export type GradingCreateManyInput = {
    id?: string;
    from: number;
    to: number;
    grade: string;
    remarks?: string | null;
  };

  export type GradingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    from?: FloatFieldUpdateOperationsInput | number;
    to?: FloatFieldUpdateOperationsInput | number;
    grade?: StringFieldUpdateOperationsInput | string;
    remarks?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type GradingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    from?: FloatFieldUpdateOperationsInput | number;
    to?: FloatFieldUpdateOperationsInput | number;
    grade?: StringFieldUpdateOperationsInput | string;
    remarks?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type AcademicYearSubjectCreateInput = {
    id?: string;
    customGrading?: GradingCreateNestedManyWithoutAcademicYearSubjectsInput;
    academicYearClass: AcademicYearClassCreateNestedOneWithoutAcademicYearSubjectsInput;
    teachers?: StaffCreateNestedManyWithoutAcademicYearSubjectsInput;
    subject: SubjectCreateNestedOneWithoutAcademicYearSubjectsInput;
    examSubjects?: ExamSubjectCreateNestedManyWithoutAcademicYearSubjectInput;
  };

  export type AcademicYearSubjectUncheckedCreateInput = {
    id?: string;
    academicYearClassId: string;
    subjectId: string;
    customGrading?: GradingUncheckedCreateNestedManyWithoutAcademicYearSubjectsInput;
    teachers?: StaffUncheckedCreateNestedManyWithoutAcademicYearSubjectsInput;
    examSubjects?: ExamSubjectUncheckedCreateNestedManyWithoutAcademicYearSubjectInput;
  };

  export type AcademicYearSubjectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    customGrading?: GradingUpdateManyWithoutAcademicYearSubjectsNestedInput;
    academicYearClass?: AcademicYearClassUpdateOneRequiredWithoutAcademicYearSubjectsNestedInput;
    teachers?: StaffUpdateManyWithoutAcademicYearSubjectsNestedInput;
    subject?: SubjectUpdateOneRequiredWithoutAcademicYearSubjectsNestedInput;
    examSubjects?: ExamSubjectUpdateManyWithoutAcademicYearSubjectNestedInput;
  };

  export type AcademicYearSubjectUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    academicYearClassId?: StringFieldUpdateOperationsInput | string;
    subjectId?: StringFieldUpdateOperationsInput | string;
    customGrading?: GradingUncheckedUpdateManyWithoutAcademicYearSubjectsNestedInput;
    teachers?: StaffUncheckedUpdateManyWithoutAcademicYearSubjectsNestedInput;
    examSubjects?: ExamSubjectUncheckedUpdateManyWithoutAcademicYearSubjectNestedInput;
  };

  export type AcademicYearSubjectCreateManyInput = {
    id?: string;
    academicYearClassId: string;
    subjectId: string;
  };

  export type AcademicYearSubjectUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
  };

  export type AcademicYearSubjectUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    academicYearClassId?: StringFieldUpdateOperationsInput | string;
    subjectId?: StringFieldUpdateOperationsInput | string;
  };

  export type classStreamCreateInput = {
    id?: string;
    pupils?: PupilCreateNestedManyWithoutClassStreamsInput;
    class?: AcademicYearClassCreateNestedOneWithoutStreamsInput;
    classTeacher?: StaffCreateNestedOneWithoutClassStreamsInput;
    stream?: StreamCreateNestedOneWithoutClassStreamsInput;
    terms?: ClassTermCreateNestedManyWithoutClassStreamInput;
  };

  export type classStreamUncheckedCreateInput = {
    id?: string;
    staffId?: string | null;
    classId?: string | null;
    streamId?: string | null;
    pupils?: PupilUncheckedCreateNestedManyWithoutClassStreamsInput;
    terms?: ClassTermUncheckedCreateNestedManyWithoutClassStreamInput;
  };

  export type classStreamUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    pupils?: PupilUpdateManyWithoutClassStreamsNestedInput;
    class?: AcademicYearClassUpdateOneWithoutStreamsNestedInput;
    classTeacher?: StaffUpdateOneWithoutClassStreamsNestedInput;
    stream?: StreamUpdateOneWithoutClassStreamsNestedInput;
    terms?: ClassTermUpdateManyWithoutClassStreamNestedInput;
  };

  export type classStreamUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    staffId?: NullableStringFieldUpdateOperationsInput | string | null;
    classId?: NullableStringFieldUpdateOperationsInput | string | null;
    streamId?: NullableStringFieldUpdateOperationsInput | string | null;
    pupils?: PupilUncheckedUpdateManyWithoutClassStreamsNestedInput;
    terms?: ClassTermUncheckedUpdateManyWithoutClassStreamNestedInput;
  };

  export type classStreamCreateManyInput = {
    id?: string;
    staffId?: string | null;
    classId?: string | null;
    streamId?: string | null;
  };

  export type classStreamUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
  };

  export type classStreamUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    staffId?: NullableStringFieldUpdateOperationsInput | string | null;
    classId?: NullableStringFieldUpdateOperationsInput | string | null;
    streamId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type TermCreateInput = {
    id?: string;
    term: string;
    slug: string;
    classTerms?: ClassTermCreateNestedManyWithoutTermInput;
  };

  export type TermUncheckedCreateInput = {
    id?: string;
    term: string;
    slug: string;
    classTerms?: ClassTermUncheckedCreateNestedManyWithoutTermInput;
  };

  export type TermUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    term?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    classTerms?: ClassTermUpdateManyWithoutTermNestedInput;
  };

  export type TermUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    term?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    classTerms?: ClassTermUncheckedUpdateManyWithoutTermNestedInput;
  };

  export type TermCreateManyInput = {
    id?: string;
    term: string;
    slug: string;
  };

  export type TermUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    term?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
  };

  export type TermUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    term?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
  };

  export type ClassTermCreateInput = {
    id?: string;
    startAt?: Date | string;
    endAt: Date | string;
    feesAmount?: number | null;
    classStream?: classStreamCreateNestedOneWithoutTermsInput;
    term?: TermCreateNestedOneWithoutClassTermsInput;
    exams?: ExamCreateNestedManyWithoutClassTermInput;
    fees?: FeesCreateNestedManyWithoutTermInput;
  };

  export type ClassTermUncheckedCreateInput = {
    id?: string;
    startAt?: Date | string;
    endAt: Date | string;
    termId?: string | null;
    classStreamId?: string | null;
    feesAmount?: number | null;
    exams?: ExamUncheckedCreateNestedManyWithoutClassTermInput;
    fees?: FeesUncheckedCreateNestedManyWithoutTermInput;
  };

  export type ClassTermUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    feesAmount?: NullableIntFieldUpdateOperationsInput | number | null;
    classStream?: classStreamUpdateOneWithoutTermsNestedInput;
    term?: TermUpdateOneWithoutClassTermsNestedInput;
    exams?: ExamUpdateManyWithoutClassTermNestedInput;
    fees?: FeesUpdateManyWithoutTermNestedInput;
  };

  export type ClassTermUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    termId?: NullableStringFieldUpdateOperationsInput | string | null;
    classStreamId?: NullableStringFieldUpdateOperationsInput | string | null;
    feesAmount?: NullableIntFieldUpdateOperationsInput | number | null;
    exams?: ExamUncheckedUpdateManyWithoutClassTermNestedInput;
    fees?: FeesUncheckedUpdateManyWithoutTermNestedInput;
  };

  export type ClassTermCreateManyInput = {
    id?: string;
    startAt?: Date | string;
    endAt: Date | string;
    termId?: string | null;
    classStreamId?: string | null;
    feesAmount?: number | null;
  };

  export type ClassTermUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    feesAmount?: NullableIntFieldUpdateOperationsInput | number | null;
  };

  export type ClassTermUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    termId?: NullableStringFieldUpdateOperationsInput | string | null;
    classStreamId?: NullableStringFieldUpdateOperationsInput | string | null;
    feesAmount?: NullableIntFieldUpdateOperationsInput | number | null;
  };

  export type FeesCreateInput = {
    id?: string;
    balance?: number;
    status?: $Enums.FeesStatus;
    pupil: PupilCreateNestedOneWithoutFeesInput;
    term: ClassTermCreateNestedOneWithoutFeesInput;
    feesPayments?: FeesPaymentCreateNestedManyWithoutFeesInput;
  };

  export type FeesUncheckedCreateInput = {
    id?: string;
    pupilId: string;
    balance?: number;
    termId: string;
    status?: $Enums.FeesStatus;
    feesPayments?: FeesPaymentUncheckedCreateNestedManyWithoutFeesInput;
  };

  export type FeesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    balance?: IntFieldUpdateOperationsInput | number;
    status?: EnumFeesStatusFieldUpdateOperationsInput | $Enums.FeesStatus;
    pupil?: PupilUpdateOneRequiredWithoutFeesNestedInput;
    term?: ClassTermUpdateOneRequiredWithoutFeesNestedInput;
    feesPayments?: FeesPaymentUpdateManyWithoutFeesNestedInput;
  };

  export type FeesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    pupilId?: StringFieldUpdateOperationsInput | string;
    balance?: IntFieldUpdateOperationsInput | number;
    termId?: StringFieldUpdateOperationsInput | string;
    status?: EnumFeesStatusFieldUpdateOperationsInput | $Enums.FeesStatus;
    feesPayments?: FeesPaymentUncheckedUpdateManyWithoutFeesNestedInput;
  };

  export type FeesCreateManyInput = {
    id?: string;
    pupilId: string;
    balance?: number;
    termId: string;
    status?: $Enums.FeesStatus;
  };

  export type FeesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    balance?: IntFieldUpdateOperationsInput | number;
    status?: EnumFeesStatusFieldUpdateOperationsInput | $Enums.FeesStatus;
  };

  export type FeesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    pupilId?: StringFieldUpdateOperationsInput | string;
    balance?: IntFieldUpdateOperationsInput | number;
    termId?: StringFieldUpdateOperationsInput | string;
    status?: EnumFeesStatusFieldUpdateOperationsInput | $Enums.FeesStatus;
  };

  export type FeesPaymentCreateInput = {
    id?: string;
    amountPaid: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    fees?: FeesCreateNestedOneWithoutFeesPaymentsInput;
    paidBy: UserCreateNestedOneWithoutFeesPaymentsInput;
  };

  export type FeesPaymentUncheckedCreateInput = {
    id?: string;
    amountPaid: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    feesId?: string | null;
    userId: string;
  };

  export type FeesPaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    amountPaid?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    fees?: FeesUpdateOneWithoutFeesPaymentsNestedInput;
    paidBy?: UserUpdateOneRequiredWithoutFeesPaymentsNestedInput;
  };

  export type FeesPaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    amountPaid?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    feesId?: NullableStringFieldUpdateOperationsInput | string | null;
    userId?: StringFieldUpdateOperationsInput | string;
  };

  export type FeesPaymentCreateManyInput = {
    id?: string;
    amountPaid: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    feesId?: string | null;
    userId: string;
  };

  export type FeesPaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    amountPaid?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type FeesPaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    amountPaid?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    feesId?: NullableStringFieldUpdateOperationsInput | string | null;
    userId?: StringFieldUpdateOperationsInput | string;
  };

  export type SessionCreateInput = {
    id?: string;
    expiresAt: Date | string;
    role?: $Enums.Role;
    user: UserCreateNestedOneWithoutSessionsInput;
  };

  export type SessionUncheckedCreateInput = {
    id?: string;
    userId: string;
    expiresAt: Date | string;
    role?: $Enums.Role;
  };

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role;
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput;
  };

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role;
  };

  export type SessionCreateManyInput = {
    id?: string;
    userId: string;
    expiresAt: Date | string;
    role?: $Enums.Role;
  };

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role;
  };

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role;
  };

  export type AssetCreateInput = {
    id?: string;
    name: string;
    description?: string | null;
    category: $Enums.AssetCategory;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    computerLabItems?: ComputerLabItemCreateNestedManyWithoutAssetInput;
    foodStoreItems?: FoodStoreItemCreateNestedManyWithoutAssetInput;
    generalStoreItems?: GeneralStoreItemCreateNestedManyWithoutAssetInput;
    labItems?: LabItemCreateNestedManyWithoutAssetInput;
    libraryBooks?: LibraryBookCreateNestedManyWithoutAssetInput;
  };

  export type AssetUncheckedCreateInput = {
    id?: string;
    name: string;
    description?: string | null;
    category: $Enums.AssetCategory;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    computerLabItems?: ComputerLabItemUncheckedCreateNestedManyWithoutAssetInput;
    foodStoreItems?: FoodStoreItemUncheckedCreateNestedManyWithoutAssetInput;
    generalStoreItems?: GeneralStoreItemUncheckedCreateNestedManyWithoutAssetInput;
    labItems?: LabItemUncheckedCreateNestedManyWithoutAssetInput;
    libraryBooks?: LibraryBookUncheckedCreateNestedManyWithoutAssetInput;
  };

  export type AssetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    category?:
      | EnumAssetCategoryFieldUpdateOperationsInput
      | $Enums.AssetCategory;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    computerLabItems?: ComputerLabItemUpdateManyWithoutAssetNestedInput;
    foodStoreItems?: FoodStoreItemUpdateManyWithoutAssetNestedInput;
    generalStoreItems?: GeneralStoreItemUpdateManyWithoutAssetNestedInput;
    labItems?: LabItemUpdateManyWithoutAssetNestedInput;
    libraryBooks?: LibraryBookUpdateManyWithoutAssetNestedInput;
  };

  export type AssetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    category?:
      | EnumAssetCategoryFieldUpdateOperationsInput
      | $Enums.AssetCategory;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    computerLabItems?: ComputerLabItemUncheckedUpdateManyWithoutAssetNestedInput;
    foodStoreItems?: FoodStoreItemUncheckedUpdateManyWithoutAssetNestedInput;
    generalStoreItems?: GeneralStoreItemUncheckedUpdateManyWithoutAssetNestedInput;
    labItems?: LabItemUncheckedUpdateManyWithoutAssetNestedInput;
    libraryBooks?: LibraryBookUncheckedUpdateManyWithoutAssetNestedInput;
  };

  export type AssetCreateManyInput = {
    id?: string;
    name: string;
    description?: string | null;
    category: $Enums.AssetCategory;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type AssetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    category?:
      | EnumAssetCategoryFieldUpdateOperationsInput
      | $Enums.AssetCategory;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AssetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    category?:
      | EnumAssetCategoryFieldUpdateOperationsInput
      | $Enums.AssetCategory;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type FoodStoreItemCreateInput = {
    id?: string;
    foodName: string;
    unit: $Enums.AssetUnit;
    quantity?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    trackQuantity?: boolean;
    status?: $Enums.AssetItemStatus;
    isConsumable?: boolean;
    consumptions?: FoodConsumptionCreateNestedManyWithoutFoodItemInput;
    asset: AssetCreateNestedOneWithoutFoodStoreItemsInput;
    supplier?: SupplierCreateNestedOneWithoutFoodStoreItemsInput;
    individualFoodStoreItems?: IndividualFoodStoreItemCreateNestedManyWithoutFoodStoreItemInput;
  };

  export type FoodStoreItemUncheckedCreateInput = {
    id?: string;
    assetId: string;
    foodName: string;
    unit: $Enums.AssetUnit;
    quantity?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    supplierId?: string | null;
    trackQuantity?: boolean;
    status?: $Enums.AssetItemStatus;
    isConsumable?: boolean;
    consumptions?: FoodConsumptionUncheckedCreateNestedManyWithoutFoodItemInput;
    individualFoodStoreItems?: IndividualFoodStoreItemUncheckedCreateNestedManyWithoutFoodStoreItemInput;
  };

  export type FoodStoreItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    foodName?: StringFieldUpdateOperationsInput | string;
    unit?: EnumAssetUnitFieldUpdateOperationsInput | $Enums.AssetUnit;
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    trackQuantity?: BoolFieldUpdateOperationsInput | boolean;
    status?:
      | EnumAssetItemStatusFieldUpdateOperationsInput
      | $Enums.AssetItemStatus;
    isConsumable?: BoolFieldUpdateOperationsInput | boolean;
    consumptions?: FoodConsumptionUpdateManyWithoutFoodItemNestedInput;
    asset?: AssetUpdateOneRequiredWithoutFoodStoreItemsNestedInput;
    supplier?: SupplierUpdateOneWithoutFoodStoreItemsNestedInput;
    individualFoodStoreItems?: IndividualFoodStoreItemUpdateManyWithoutFoodStoreItemNestedInput;
  };

  export type FoodStoreItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    assetId?: StringFieldUpdateOperationsInput | string;
    foodName?: StringFieldUpdateOperationsInput | string;
    unit?: EnumAssetUnitFieldUpdateOperationsInput | $Enums.AssetUnit;
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null;
    trackQuantity?: BoolFieldUpdateOperationsInput | boolean;
    status?:
      | EnumAssetItemStatusFieldUpdateOperationsInput
      | $Enums.AssetItemStatus;
    isConsumable?: BoolFieldUpdateOperationsInput | boolean;
    consumptions?: FoodConsumptionUncheckedUpdateManyWithoutFoodItemNestedInput;
    individualFoodStoreItems?: IndividualFoodStoreItemUncheckedUpdateManyWithoutFoodStoreItemNestedInput;
  };

  export type FoodStoreItemCreateManyInput = {
    id?: string;
    assetId: string;
    foodName: string;
    unit: $Enums.AssetUnit;
    quantity?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    supplierId?: string | null;
    trackQuantity?: boolean;
    status?: $Enums.AssetItemStatus;
    isConsumable?: boolean;
  };

  export type FoodStoreItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    foodName?: StringFieldUpdateOperationsInput | string;
    unit?: EnumAssetUnitFieldUpdateOperationsInput | $Enums.AssetUnit;
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    trackQuantity?: BoolFieldUpdateOperationsInput | boolean;
    status?:
      | EnumAssetItemStatusFieldUpdateOperationsInput
      | $Enums.AssetItemStatus;
    isConsumable?: BoolFieldUpdateOperationsInput | boolean;
  };

  export type FoodStoreItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    assetId?: StringFieldUpdateOperationsInput | string;
    foodName?: StringFieldUpdateOperationsInput | string;
    unit?: EnumAssetUnitFieldUpdateOperationsInput | $Enums.AssetUnit;
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null;
    trackQuantity?: BoolFieldUpdateOperationsInput | boolean;
    status?:
      | EnumAssetItemStatusFieldUpdateOperationsInput
      | $Enums.AssetItemStatus;
    isConsumable?: BoolFieldUpdateOperationsInput | boolean;
  };

  export type IndividualFoodStoreItemCreateInput = {
    id?: string;
    uniqueIdentifier?: string | null;
    status?: $Enums.AssetStatus;
    condition?: $Enums.AssetCondition;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    assetDamages?: AssetDamageCreateNestedManyWithoutIndividualFoodStoreItemInput;
    foodStoreItem: FoodStoreItemCreateNestedOneWithoutIndividualFoodStoreItemsInput;
  };

  export type IndividualFoodStoreItemUncheckedCreateInput = {
    id?: string;
    foodStoreItemId: string;
    uniqueIdentifier?: string | null;
    status?: $Enums.AssetStatus;
    condition?: $Enums.AssetCondition;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    assetDamages?: AssetDamageUncheckedCreateNestedManyWithoutIndividualFoodStoreItemInput;
  };

  export type IndividualFoodStoreItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    uniqueIdentifier?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus;
    condition?:
      | EnumAssetConditionFieldUpdateOperationsInput
      | $Enums.AssetCondition;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    assetDamages?: AssetDamageUpdateManyWithoutIndividualFoodStoreItemNestedInput;
    foodStoreItem?: FoodStoreItemUpdateOneRequiredWithoutIndividualFoodStoreItemsNestedInput;
  };

  export type IndividualFoodStoreItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    foodStoreItemId?: StringFieldUpdateOperationsInput | string;
    uniqueIdentifier?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus;
    condition?:
      | EnumAssetConditionFieldUpdateOperationsInput
      | $Enums.AssetCondition;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    assetDamages?: AssetDamageUncheckedUpdateManyWithoutIndividualFoodStoreItemNestedInput;
  };

  export type IndividualFoodStoreItemCreateManyInput = {
    id?: string;
    foodStoreItemId: string;
    uniqueIdentifier?: string | null;
    status?: $Enums.AssetStatus;
    condition?: $Enums.AssetCondition;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type IndividualFoodStoreItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    uniqueIdentifier?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus;
    condition?:
      | EnumAssetConditionFieldUpdateOperationsInput
      | $Enums.AssetCondition;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type IndividualFoodStoreItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    foodStoreItemId?: StringFieldUpdateOperationsInput | string;
    uniqueIdentifier?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus;
    condition?:
      | EnumAssetConditionFieldUpdateOperationsInput
      | $Enums.AssetCondition;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type FoodConsumptionCreateInput = {
    id?: string;
    quantityUsed?: number | null;
    dateUsedAt?: Date | string;
    usageDetails?: string | null;
    foodItem: FoodStoreItemCreateNestedOneWithoutConsumptionsInput;
  };

  export type FoodConsumptionUncheckedCreateInput = {
    id?: string;
    quantityUsed?: number | null;
    dateUsedAt?: Date | string;
    usageDetails?: string | null;
    foodStoreItemId: string;
  };

  export type FoodConsumptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    quantityUsed?: NullableFloatFieldUpdateOperationsInput | number | null;
    dateUsedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    usageDetails?: NullableStringFieldUpdateOperationsInput | string | null;
    foodItem?: FoodStoreItemUpdateOneRequiredWithoutConsumptionsNestedInput;
  };

  export type FoodConsumptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    quantityUsed?: NullableFloatFieldUpdateOperationsInput | number | null;
    dateUsedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    usageDetails?: NullableStringFieldUpdateOperationsInput | string | null;
    foodStoreItemId?: StringFieldUpdateOperationsInput | string;
  };

  export type FoodConsumptionCreateManyInput = {
    id?: string;
    quantityUsed?: number | null;
    dateUsedAt?: Date | string;
    usageDetails?: string | null;
    foodStoreItemId: string;
  };

  export type FoodConsumptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    quantityUsed?: NullableFloatFieldUpdateOperationsInput | number | null;
    dateUsedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    usageDetails?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type FoodConsumptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    quantityUsed?: NullableFloatFieldUpdateOperationsInput | number | null;
    dateUsedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    usageDetails?: NullableStringFieldUpdateOperationsInput | string | null;
    foodStoreItemId?: StringFieldUpdateOperationsInput | string;
  };

  export type SupplierCreateInput = {
    id?: string;
    name: string;
    contactInfo?: string | null;
    address?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    foodStoreItems?: FoodStoreItemCreateNestedManyWithoutSupplierInput;
  };

  export type SupplierUncheckedCreateInput = {
    id?: string;
    name: string;
    contactInfo?: string | null;
    address?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    foodStoreItems?: FoodStoreItemUncheckedCreateNestedManyWithoutSupplierInput;
  };

  export type SupplierUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    foodStoreItems?: FoodStoreItemUpdateManyWithoutSupplierNestedInput;
  };

  export type SupplierUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    foodStoreItems?: FoodStoreItemUncheckedUpdateManyWithoutSupplierNestedInput;
  };

  export type SupplierCreateManyInput = {
    id?: string;
    name: string;
    contactInfo?: string | null;
    address?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type SupplierUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type SupplierUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type LibraryBookCreateInput = {
    id?: string;
    title: string;
    author: string;
    quantity?: number | null;
    trackQuantity?: boolean;
    unit: $Enums.AssetUnit;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    individualBooks?: IndividualBookCreateNestedManyWithoutLibraryBookInput;
    asset: AssetCreateNestedOneWithoutLibraryBooksInput;
    category: LibraryBookCategoryCreateNestedOneWithoutLibraryBooksInput;
  };

  export type LibraryBookUncheckedCreateInput = {
    id?: string;
    title: string;
    author: string;
    assetId: string;
    libraryBookCategoryId: string;
    quantity?: number | null;
    trackQuantity?: boolean;
    unit: $Enums.AssetUnit;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    individualBooks?: IndividualBookUncheckedCreateNestedManyWithoutLibraryBookInput;
  };

  export type LibraryBookUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    author?: StringFieldUpdateOperationsInput | string;
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null;
    trackQuantity?: BoolFieldUpdateOperationsInput | boolean;
    unit?: EnumAssetUnitFieldUpdateOperationsInput | $Enums.AssetUnit;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    individualBooks?: IndividualBookUpdateManyWithoutLibraryBookNestedInput;
    asset?: AssetUpdateOneRequiredWithoutLibraryBooksNestedInput;
    category?: LibraryBookCategoryUpdateOneRequiredWithoutLibraryBooksNestedInput;
  };

  export type LibraryBookUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    author?: StringFieldUpdateOperationsInput | string;
    assetId?: StringFieldUpdateOperationsInput | string;
    libraryBookCategoryId?: StringFieldUpdateOperationsInput | string;
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null;
    trackQuantity?: BoolFieldUpdateOperationsInput | boolean;
    unit?: EnumAssetUnitFieldUpdateOperationsInput | $Enums.AssetUnit;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    individualBooks?: IndividualBookUncheckedUpdateManyWithoutLibraryBookNestedInput;
  };

  export type LibraryBookCreateManyInput = {
    id?: string;
    title: string;
    author: string;
    assetId: string;
    libraryBookCategoryId: string;
    quantity?: number | null;
    trackQuantity?: boolean;
    unit: $Enums.AssetUnit;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type LibraryBookUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    author?: StringFieldUpdateOperationsInput | string;
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null;
    trackQuantity?: BoolFieldUpdateOperationsInput | boolean;
    unit?: EnumAssetUnitFieldUpdateOperationsInput | $Enums.AssetUnit;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type LibraryBookUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    author?: StringFieldUpdateOperationsInput | string;
    assetId?: StringFieldUpdateOperationsInput | string;
    libraryBookCategoryId?: StringFieldUpdateOperationsInput | string;
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null;
    trackQuantity?: BoolFieldUpdateOperationsInput | boolean;
    unit?: EnumAssetUnitFieldUpdateOperationsInput | $Enums.AssetUnit;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type IndividualBookCreateInput = {
    id?: string;
    isbn?: string | null;
    status?: $Enums.BookStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    condition?: $Enums.AssetCondition;
    borrowCount?: number;
    bookDamages?: AssetDamageCreateNestedManyWithoutIndividualBookInput;
    borrowers?: BorrowerCreateNestedManyWithoutLibraryBookInput;
    libraryBook: LibraryBookCreateNestedOneWithoutIndividualBooksInput;
  };

  export type IndividualBookUncheckedCreateInput = {
    id?: string;
    isbn?: string | null;
    status?: $Enums.BookStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    libraryBookId: string;
    condition?: $Enums.AssetCondition;
    borrowCount?: number;
    bookDamages?: AssetDamageUncheckedCreateNestedManyWithoutIndividualBookInput;
    borrowers?: BorrowerUncheckedCreateNestedManyWithoutLibraryBookInput;
  };

  export type IndividualBookUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    isbn?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumBookStatusFieldUpdateOperationsInput | $Enums.BookStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    condition?:
      | EnumAssetConditionFieldUpdateOperationsInput
      | $Enums.AssetCondition;
    borrowCount?: IntFieldUpdateOperationsInput | number;
    bookDamages?: AssetDamageUpdateManyWithoutIndividualBookNestedInput;
    borrowers?: BorrowerUpdateManyWithoutLibraryBookNestedInput;
    libraryBook?: LibraryBookUpdateOneRequiredWithoutIndividualBooksNestedInput;
  };

  export type IndividualBookUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    isbn?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumBookStatusFieldUpdateOperationsInput | $Enums.BookStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    libraryBookId?: StringFieldUpdateOperationsInput | string;
    condition?:
      | EnumAssetConditionFieldUpdateOperationsInput
      | $Enums.AssetCondition;
    borrowCount?: IntFieldUpdateOperationsInput | number;
    bookDamages?: AssetDamageUncheckedUpdateManyWithoutIndividualBookNestedInput;
    borrowers?: BorrowerUncheckedUpdateManyWithoutLibraryBookNestedInput;
  };

  export type IndividualBookCreateManyInput = {
    id?: string;
    isbn?: string | null;
    status?: $Enums.BookStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    libraryBookId: string;
    condition?: $Enums.AssetCondition;
    borrowCount?: number;
  };

  export type IndividualBookUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    isbn?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumBookStatusFieldUpdateOperationsInput | $Enums.BookStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    condition?:
      | EnumAssetConditionFieldUpdateOperationsInput
      | $Enums.AssetCondition;
    borrowCount?: IntFieldUpdateOperationsInput | number;
  };

  export type IndividualBookUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    isbn?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumBookStatusFieldUpdateOperationsInput | $Enums.BookStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    libraryBookId?: StringFieldUpdateOperationsInput | string;
    condition?:
      | EnumAssetConditionFieldUpdateOperationsInput
      | $Enums.AssetCondition;
    borrowCount?: IntFieldUpdateOperationsInput | number;
  };

  export type LibraryBookCategoryCreateInput = {
    id?: string;
    category: string;
    description?: string | null;
    libraryBooks?: LibraryBookCreateNestedManyWithoutCategoryInput;
  };

  export type LibraryBookCategoryUncheckedCreateInput = {
    id?: string;
    category: string;
    description?: string | null;
    libraryBooks?: LibraryBookUncheckedCreateNestedManyWithoutCategoryInput;
  };

  export type LibraryBookCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    category?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    libraryBooks?: LibraryBookUpdateManyWithoutCategoryNestedInput;
  };

  export type LibraryBookCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    category?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    libraryBooks?: LibraryBookUncheckedUpdateManyWithoutCategoryNestedInput;
  };

  export type LibraryBookCategoryCreateManyInput = {
    id?: string;
    category: string;
    description?: string | null;
  };

  export type LibraryBookCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    category?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type LibraryBookCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    category?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type BorrowerCreateInput = {
    id?: string;
    borrowedAt?: Date | string;
    returnAt?: Date | string | null;
    status?: $Enums.BorrowStatus;
    libraryBook?: IndividualBookCreateNestedOneWithoutBorrowersInput;
    user: UserCreateNestedOneWithoutBorrowersInput;
  };

  export type BorrowerUncheckedCreateInput = {
    id?: string;
    borrowedAt?: Date | string;
    returnAt?: Date | string | null;
    status?: $Enums.BorrowStatus;
    userId: string;
    individualBookId?: string | null;
  };

  export type BorrowerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    borrowedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    returnAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    status?: EnumBorrowStatusFieldUpdateOperationsInput | $Enums.BorrowStatus;
    libraryBook?: IndividualBookUpdateOneWithoutBorrowersNestedInput;
    user?: UserUpdateOneRequiredWithoutBorrowersNestedInput;
  };

  export type BorrowerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    borrowedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    returnAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    status?: EnumBorrowStatusFieldUpdateOperationsInput | $Enums.BorrowStatus;
    userId?: StringFieldUpdateOperationsInput | string;
    individualBookId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type BorrowerCreateManyInput = {
    id?: string;
    borrowedAt?: Date | string;
    returnAt?: Date | string | null;
    status?: $Enums.BorrowStatus;
    userId: string;
    individualBookId?: string | null;
  };

  export type BorrowerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    borrowedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    returnAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    status?: EnumBorrowStatusFieldUpdateOperationsInput | $Enums.BorrowStatus;
  };

  export type BorrowerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    borrowedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    returnAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    status?: EnumBorrowStatusFieldUpdateOperationsInput | $Enums.BorrowStatus;
    userId?: StringFieldUpdateOperationsInput | string;
    individualBookId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type LabItemCreateInput = {
    id?: string;
    name: string;
    quantity?: number | null;
    unit: $Enums.AssetUnit;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    trackQuantity?: boolean;
    status?: $Enums.AssetStatus;
    individualLabItems?: IndividualLabItemCreateNestedManyWithoutLabItemInput;
    asset: AssetCreateNestedOneWithoutLabItemsInput;
  };

  export type LabItemUncheckedCreateInput = {
    id?: string;
    name: string;
    quantity?: number | null;
    unit: $Enums.AssetUnit;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    assetId: string;
    trackQuantity?: boolean;
    status?: $Enums.AssetStatus;
    individualLabItems?: IndividualLabItemUncheckedCreateNestedManyWithoutLabItemInput;
  };

  export type LabItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null;
    unit?: EnumAssetUnitFieldUpdateOperationsInput | $Enums.AssetUnit;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    trackQuantity?: BoolFieldUpdateOperationsInput | boolean;
    status?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus;
    individualLabItems?: IndividualLabItemUpdateManyWithoutLabItemNestedInput;
    asset?: AssetUpdateOneRequiredWithoutLabItemsNestedInput;
  };

  export type LabItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null;
    unit?: EnumAssetUnitFieldUpdateOperationsInput | $Enums.AssetUnit;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    assetId?: StringFieldUpdateOperationsInput | string;
    trackQuantity?: BoolFieldUpdateOperationsInput | boolean;
    status?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus;
    individualLabItems?: IndividualLabItemUncheckedUpdateManyWithoutLabItemNestedInput;
  };

  export type LabItemCreateManyInput = {
    id?: string;
    name: string;
    quantity?: number | null;
    unit: $Enums.AssetUnit;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    assetId: string;
    trackQuantity?: boolean;
    status?: $Enums.AssetStatus;
  };

  export type LabItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null;
    unit?: EnumAssetUnitFieldUpdateOperationsInput | $Enums.AssetUnit;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    trackQuantity?: BoolFieldUpdateOperationsInput | boolean;
    status?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus;
  };

  export type LabItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null;
    unit?: EnumAssetUnitFieldUpdateOperationsInput | $Enums.AssetUnit;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    assetId?: StringFieldUpdateOperationsInput | string;
    trackQuantity?: BoolFieldUpdateOperationsInput | boolean;
    status?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus;
  };

  export type IndividualLabItemCreateInput = {
    id?: string;
    uniqueIdentifier?: string | null;
    status?: $Enums.AssetStatus;
    condition?: $Enums.AssetCondition;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    assetDamages?: AssetDamageCreateNestedManyWithoutIndividualLabItemInput;
    labItem: LabItemCreateNestedOneWithoutIndividualLabItemsInput;
  };

  export type IndividualLabItemUncheckedCreateInput = {
    id?: string;
    labItemId: string;
    uniqueIdentifier?: string | null;
    status?: $Enums.AssetStatus;
    condition?: $Enums.AssetCondition;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    assetDamages?: AssetDamageUncheckedCreateNestedManyWithoutIndividualLabItemInput;
  };

  export type IndividualLabItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    uniqueIdentifier?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus;
    condition?:
      | EnumAssetConditionFieldUpdateOperationsInput
      | $Enums.AssetCondition;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    assetDamages?: AssetDamageUpdateManyWithoutIndividualLabItemNestedInput;
    labItem?: LabItemUpdateOneRequiredWithoutIndividualLabItemsNestedInput;
  };

  export type IndividualLabItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    labItemId?: StringFieldUpdateOperationsInput | string;
    uniqueIdentifier?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus;
    condition?:
      | EnumAssetConditionFieldUpdateOperationsInput
      | $Enums.AssetCondition;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    assetDamages?: AssetDamageUncheckedUpdateManyWithoutIndividualLabItemNestedInput;
  };

  export type IndividualLabItemCreateManyInput = {
    id?: string;
    labItemId: string;
    uniqueIdentifier?: string | null;
    status?: $Enums.AssetStatus;
    condition?: $Enums.AssetCondition;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type IndividualLabItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    uniqueIdentifier?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus;
    condition?:
      | EnumAssetConditionFieldUpdateOperationsInput
      | $Enums.AssetCondition;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type IndividualLabItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    labItemId?: StringFieldUpdateOperationsInput | string;
    uniqueIdentifier?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus;
    condition?:
      | EnumAssetConditionFieldUpdateOperationsInput
      | $Enums.AssetCondition;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ComputerLabItemCreateInput = {
    id?: string;
    name: string;
    model?: string | null;
    specification?: string | null;
    quantity?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    trackQuantity?: boolean;
    unit: $Enums.AssetUnit;
    asset: AssetCreateNestedOneWithoutComputerLabItemsInput;
    individualComputerLabItems?: IndividualComputerLabItemCreateNestedManyWithoutComputerLabItemInput;
  };

  export type ComputerLabItemUncheckedCreateInput = {
    id?: string;
    name: string;
    model?: string | null;
    specification?: string | null;
    quantity?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    assetId: string;
    trackQuantity?: boolean;
    unit: $Enums.AssetUnit;
    individualComputerLabItems?: IndividualComputerLabItemUncheckedCreateNestedManyWithoutComputerLabItemInput;
  };

  export type ComputerLabItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    model?: NullableStringFieldUpdateOperationsInput | string | null;
    specification?: NullableStringFieldUpdateOperationsInput | string | null;
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    trackQuantity?: BoolFieldUpdateOperationsInput | boolean;
    unit?: EnumAssetUnitFieldUpdateOperationsInput | $Enums.AssetUnit;
    asset?: AssetUpdateOneRequiredWithoutComputerLabItemsNestedInput;
    individualComputerLabItems?: IndividualComputerLabItemUpdateManyWithoutComputerLabItemNestedInput;
  };

  export type ComputerLabItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    model?: NullableStringFieldUpdateOperationsInput | string | null;
    specification?: NullableStringFieldUpdateOperationsInput | string | null;
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    assetId?: StringFieldUpdateOperationsInput | string;
    trackQuantity?: BoolFieldUpdateOperationsInput | boolean;
    unit?: EnumAssetUnitFieldUpdateOperationsInput | $Enums.AssetUnit;
    individualComputerLabItems?: IndividualComputerLabItemUncheckedUpdateManyWithoutComputerLabItemNestedInput;
  };

  export type ComputerLabItemCreateManyInput = {
    id?: string;
    name: string;
    model?: string | null;
    specification?: string | null;
    quantity?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    assetId: string;
    trackQuantity?: boolean;
    unit: $Enums.AssetUnit;
  };

  export type ComputerLabItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    model?: NullableStringFieldUpdateOperationsInput | string | null;
    specification?: NullableStringFieldUpdateOperationsInput | string | null;
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    trackQuantity?: BoolFieldUpdateOperationsInput | boolean;
    unit?: EnumAssetUnitFieldUpdateOperationsInput | $Enums.AssetUnit;
  };

  export type ComputerLabItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    model?: NullableStringFieldUpdateOperationsInput | string | null;
    specification?: NullableStringFieldUpdateOperationsInput | string | null;
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    assetId?: StringFieldUpdateOperationsInput | string;
    trackQuantity?: BoolFieldUpdateOperationsInput | boolean;
    unit?: EnumAssetUnitFieldUpdateOperationsInput | $Enums.AssetUnit;
  };

  export type IndividualComputerLabItemCreateInput = {
    id?: string;
    uniqueIdentifier?: string | null;
    status?: $Enums.AssetStatus;
    condition?: $Enums.AssetCondition;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    assetDamages?: AssetDamageCreateNestedManyWithoutIndividualComputerLabItemInput;
    computerLabItem: ComputerLabItemCreateNestedOneWithoutIndividualComputerLabItemsInput;
  };

  export type IndividualComputerLabItemUncheckedCreateInput = {
    id?: string;
    computerLabItemId: string;
    uniqueIdentifier?: string | null;
    status?: $Enums.AssetStatus;
    condition?: $Enums.AssetCondition;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    assetDamages?: AssetDamageUncheckedCreateNestedManyWithoutIndividualComputerLabItemInput;
  };

  export type IndividualComputerLabItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    uniqueIdentifier?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus;
    condition?:
      | EnumAssetConditionFieldUpdateOperationsInput
      | $Enums.AssetCondition;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    assetDamages?: AssetDamageUpdateManyWithoutIndividualComputerLabItemNestedInput;
    computerLabItem?: ComputerLabItemUpdateOneRequiredWithoutIndividualComputerLabItemsNestedInput;
  };

  export type IndividualComputerLabItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    computerLabItemId?: StringFieldUpdateOperationsInput | string;
    uniqueIdentifier?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus;
    condition?:
      | EnumAssetConditionFieldUpdateOperationsInput
      | $Enums.AssetCondition;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    assetDamages?: AssetDamageUncheckedUpdateManyWithoutIndividualComputerLabItemNestedInput;
  };

  export type IndividualComputerLabItemCreateManyInput = {
    id?: string;
    computerLabItemId: string;
    uniqueIdentifier?: string | null;
    status?: $Enums.AssetStatus;
    condition?: $Enums.AssetCondition;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type IndividualComputerLabItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    uniqueIdentifier?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus;
    condition?:
      | EnumAssetConditionFieldUpdateOperationsInput
      | $Enums.AssetCondition;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type IndividualComputerLabItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    computerLabItemId?: StringFieldUpdateOperationsInput | string;
    uniqueIdentifier?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus;
    condition?:
      | EnumAssetConditionFieldUpdateOperationsInput
      | $Enums.AssetCondition;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type GeneralStoreItemCreateInput = {
    id?: string;
    name: string;
    quantity?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    status?: $Enums.AssetItemStatus;
    trackQuantity?: boolean;
    unit: $Enums.AssetUnit;
    asset: AssetCreateNestedOneWithoutGeneralStoreItemsInput;
    individualGeneralStoreItems?: IndividualGeneralStoreItemCreateNestedManyWithoutGeneralStoreItemInput;
  };

  export type GeneralStoreItemUncheckedCreateInput = {
    id?: string;
    name: string;
    quantity?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    assetId: string;
    status?: $Enums.AssetItemStatus;
    trackQuantity?: boolean;
    unit: $Enums.AssetUnit;
    individualGeneralStoreItems?: IndividualGeneralStoreItemUncheckedCreateNestedManyWithoutGeneralStoreItemInput;
  };

  export type GeneralStoreItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    status?:
      | EnumAssetItemStatusFieldUpdateOperationsInput
      | $Enums.AssetItemStatus;
    trackQuantity?: BoolFieldUpdateOperationsInput | boolean;
    unit?: EnumAssetUnitFieldUpdateOperationsInput | $Enums.AssetUnit;
    asset?: AssetUpdateOneRequiredWithoutGeneralStoreItemsNestedInput;
    individualGeneralStoreItems?: IndividualGeneralStoreItemUpdateManyWithoutGeneralStoreItemNestedInput;
  };

  export type GeneralStoreItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    assetId?: StringFieldUpdateOperationsInput | string;
    status?:
      | EnumAssetItemStatusFieldUpdateOperationsInput
      | $Enums.AssetItemStatus;
    trackQuantity?: BoolFieldUpdateOperationsInput | boolean;
    unit?: EnumAssetUnitFieldUpdateOperationsInput | $Enums.AssetUnit;
    individualGeneralStoreItems?: IndividualGeneralStoreItemUncheckedUpdateManyWithoutGeneralStoreItemNestedInput;
  };

  export type GeneralStoreItemCreateManyInput = {
    id?: string;
    name: string;
    quantity?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    assetId: string;
    status?: $Enums.AssetItemStatus;
    trackQuantity?: boolean;
    unit: $Enums.AssetUnit;
  };

  export type GeneralStoreItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    status?:
      | EnumAssetItemStatusFieldUpdateOperationsInput
      | $Enums.AssetItemStatus;
    trackQuantity?: BoolFieldUpdateOperationsInput | boolean;
    unit?: EnumAssetUnitFieldUpdateOperationsInput | $Enums.AssetUnit;
  };

  export type GeneralStoreItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    assetId?: StringFieldUpdateOperationsInput | string;
    status?:
      | EnumAssetItemStatusFieldUpdateOperationsInput
      | $Enums.AssetItemStatus;
    trackQuantity?: BoolFieldUpdateOperationsInput | boolean;
    unit?: EnumAssetUnitFieldUpdateOperationsInput | $Enums.AssetUnit;
  };

  export type IndividualGeneralStoreItemCreateInput = {
    id?: string;
    uniqueIdentifier?: string | null;
    status?: $Enums.AssetStatus;
    condition?: $Enums.AssetCondition;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    assetDamages?: AssetDamageCreateNestedManyWithoutIndividualGeneralStoreItemInput;
    generalStoreItem: GeneralStoreItemCreateNestedOneWithoutIndividualGeneralStoreItemsInput;
  };

  export type IndividualGeneralStoreItemUncheckedCreateInput = {
    id?: string;
    generalStoreItemId: string;
    uniqueIdentifier?: string | null;
    status?: $Enums.AssetStatus;
    condition?: $Enums.AssetCondition;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    assetDamages?: AssetDamageUncheckedCreateNestedManyWithoutIndividualGeneralStoreItemInput;
  };

  export type IndividualGeneralStoreItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    uniqueIdentifier?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus;
    condition?:
      | EnumAssetConditionFieldUpdateOperationsInput
      | $Enums.AssetCondition;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    assetDamages?: AssetDamageUpdateManyWithoutIndividualGeneralStoreItemNestedInput;
    generalStoreItem?: GeneralStoreItemUpdateOneRequiredWithoutIndividualGeneralStoreItemsNestedInput;
  };

  export type IndividualGeneralStoreItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    generalStoreItemId?: StringFieldUpdateOperationsInput | string;
    uniqueIdentifier?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus;
    condition?:
      | EnumAssetConditionFieldUpdateOperationsInput
      | $Enums.AssetCondition;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    assetDamages?: AssetDamageUncheckedUpdateManyWithoutIndividualGeneralStoreItemNestedInput;
  };

  export type IndividualGeneralStoreItemCreateManyInput = {
    id?: string;
    generalStoreItemId: string;
    uniqueIdentifier?: string | null;
    status?: $Enums.AssetStatus;
    condition?: $Enums.AssetCondition;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type IndividualGeneralStoreItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    uniqueIdentifier?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus;
    condition?:
      | EnumAssetConditionFieldUpdateOperationsInput
      | $Enums.AssetCondition;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type IndividualGeneralStoreItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    generalStoreItemId?: StringFieldUpdateOperationsInput | string;
    uniqueIdentifier?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus;
    condition?:
      | EnumAssetConditionFieldUpdateOperationsInput
      | $Enums.AssetCondition;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AssetDamageCreateInput = {
    id?: string;
    damageDetails: string;
    condition: $Enums.AssetCondition;
    quantity: number;
    isRepaired?: boolean;
    repairedAt?: Date | string | null;
    createdAt?: Date | string;
    isSchoolCost?: boolean;
    repairBalance?: number;
    repairPrice?: number | null;
    individualBook?: IndividualBookCreateNestedOneWithoutBookDamagesInput;
    individualComputerLabItem?: IndividualComputerLabItemCreateNestedOneWithoutAssetDamagesInput;
    individualFoodStoreItem?: IndividualFoodStoreItemCreateNestedOneWithoutAssetDamagesInput;
    individualGeneralStoreItem?: IndividualGeneralStoreItemCreateNestedOneWithoutAssetDamagesInput;
    individualLabItem?: IndividualLabItemCreateNestedOneWithoutAssetDamagesInput;
    damagedBy?: UserCreateNestedOneWithoutAssetDamagesInput;
    assetRepairPayments?: AssetRepairPaymentCreateNestedManyWithoutAssetDamageInput;
  };

  export type AssetDamageUncheckedCreateInput = {
    id?: string;
    damageDetails: string;
    condition: $Enums.AssetCondition;
    quantity: number;
    userId?: string | null;
    individualComputerLabItemId?: string | null;
    isRepaired?: boolean;
    repairedAt?: Date | string | null;
    createdAt?: Date | string;
    individualBookId?: string | null;
    individualLabItemId?: string | null;
    individualFoodStoreItemId?: string | null;
    individualGeneralStoreItemId?: string | null;
    isSchoolCost?: boolean;
    repairBalance?: number;
    repairPrice?: number | null;
    assetRepairPayments?: AssetRepairPaymentUncheckedCreateNestedManyWithoutAssetDamageInput;
  };

  export type AssetDamageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    damageDetails?: StringFieldUpdateOperationsInput | string;
    condition?:
      | EnumAssetConditionFieldUpdateOperationsInput
      | $Enums.AssetCondition;
    quantity?: IntFieldUpdateOperationsInput | number;
    isRepaired?: BoolFieldUpdateOperationsInput | boolean;
    repairedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    isSchoolCost?: BoolFieldUpdateOperationsInput | boolean;
    repairBalance?: FloatFieldUpdateOperationsInput | number;
    repairPrice?: NullableFloatFieldUpdateOperationsInput | number | null;
    individualBook?: IndividualBookUpdateOneWithoutBookDamagesNestedInput;
    individualComputerLabItem?: IndividualComputerLabItemUpdateOneWithoutAssetDamagesNestedInput;
    individualFoodStoreItem?: IndividualFoodStoreItemUpdateOneWithoutAssetDamagesNestedInput;
    individualGeneralStoreItem?: IndividualGeneralStoreItemUpdateOneWithoutAssetDamagesNestedInput;
    individualLabItem?: IndividualLabItemUpdateOneWithoutAssetDamagesNestedInput;
    damagedBy?: UserUpdateOneWithoutAssetDamagesNestedInput;
    assetRepairPayments?: AssetRepairPaymentUpdateManyWithoutAssetDamageNestedInput;
  };

  export type AssetDamageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    damageDetails?: StringFieldUpdateOperationsInput | string;
    condition?:
      | EnumAssetConditionFieldUpdateOperationsInput
      | $Enums.AssetCondition;
    quantity?: IntFieldUpdateOperationsInput | number;
    userId?: NullableStringFieldUpdateOperationsInput | string | null;
    individualComputerLabItemId?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    isRepaired?: BoolFieldUpdateOperationsInput | boolean;
    repairedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    individualBookId?: NullableStringFieldUpdateOperationsInput | string | null;
    individualLabItemId?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    individualFoodStoreItemId?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    individualGeneralStoreItemId?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    isSchoolCost?: BoolFieldUpdateOperationsInput | boolean;
    repairBalance?: FloatFieldUpdateOperationsInput | number;
    repairPrice?: NullableFloatFieldUpdateOperationsInput | number | null;
    assetRepairPayments?: AssetRepairPaymentUncheckedUpdateManyWithoutAssetDamageNestedInput;
  };

  export type AssetDamageCreateManyInput = {
    id?: string;
    damageDetails: string;
    condition: $Enums.AssetCondition;
    quantity: number;
    userId?: string | null;
    individualComputerLabItemId?: string | null;
    isRepaired?: boolean;
    repairedAt?: Date | string | null;
    createdAt?: Date | string;
    individualBookId?: string | null;
    individualLabItemId?: string | null;
    individualFoodStoreItemId?: string | null;
    individualGeneralStoreItemId?: string | null;
    isSchoolCost?: boolean;
    repairBalance?: number;
    repairPrice?: number | null;
  };

  export type AssetDamageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    damageDetails?: StringFieldUpdateOperationsInput | string;
    condition?:
      | EnumAssetConditionFieldUpdateOperationsInput
      | $Enums.AssetCondition;
    quantity?: IntFieldUpdateOperationsInput | number;
    isRepaired?: BoolFieldUpdateOperationsInput | boolean;
    repairedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    isSchoolCost?: BoolFieldUpdateOperationsInput | boolean;
    repairBalance?: FloatFieldUpdateOperationsInput | number;
    repairPrice?: NullableFloatFieldUpdateOperationsInput | number | null;
  };

  export type AssetDamageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    damageDetails?: StringFieldUpdateOperationsInput | string;
    condition?:
      | EnumAssetConditionFieldUpdateOperationsInput
      | $Enums.AssetCondition;
    quantity?: IntFieldUpdateOperationsInput | number;
    userId?: NullableStringFieldUpdateOperationsInput | string | null;
    individualComputerLabItemId?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    isRepaired?: BoolFieldUpdateOperationsInput | boolean;
    repairedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    individualBookId?: NullableStringFieldUpdateOperationsInput | string | null;
    individualLabItemId?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    individualFoodStoreItemId?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    individualGeneralStoreItemId?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    isSchoolCost?: BoolFieldUpdateOperationsInput | boolean;
    repairBalance?: FloatFieldUpdateOperationsInput | number;
    repairPrice?: NullableFloatFieldUpdateOperationsInput | number | null;
  };

  export type AssetRepairPaymentCreateInput = {
    id?: string;
    paidAmount: number;
    paidAt?: Date | string;
    updatedAt?: Date | string;
    isSchoolCost?: boolean;
    assetDamage?: AssetDamageCreateNestedOneWithoutAssetRepairPaymentsInput;
    receivedBy?: UserCreateNestedOneWithoutAssetRepairPaymentsInput;
  };

  export type AssetRepairPaymentUncheckedCreateInput = {
    id?: string;
    paidAmount: number;
    paidAt?: Date | string;
    updatedAt?: Date | string;
    assetDamageId?: string | null;
    userId?: string | null;
    isSchoolCost?: boolean;
  };

  export type AssetRepairPaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    paidAmount?: FloatFieldUpdateOperationsInput | number;
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    isSchoolCost?: BoolFieldUpdateOperationsInput | boolean;
    assetDamage?: AssetDamageUpdateOneWithoutAssetRepairPaymentsNestedInput;
    receivedBy?: UserUpdateOneWithoutAssetRepairPaymentsNestedInput;
  };

  export type AssetRepairPaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    paidAmount?: FloatFieldUpdateOperationsInput | number;
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    assetDamageId?: NullableStringFieldUpdateOperationsInput | string | null;
    userId?: NullableStringFieldUpdateOperationsInput | string | null;
    isSchoolCost?: BoolFieldUpdateOperationsInput | boolean;
  };

  export type AssetRepairPaymentCreateManyInput = {
    id?: string;
    paidAmount: number;
    paidAt?: Date | string;
    updatedAt?: Date | string;
    assetDamageId?: string | null;
    userId?: string | null;
    isSchoolCost?: boolean;
  };

  export type AssetRepairPaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    paidAmount?: FloatFieldUpdateOperationsInput | number;
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    isSchoolCost?: BoolFieldUpdateOperationsInput | boolean;
  };

  export type AssetRepairPaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    paidAmount?: FloatFieldUpdateOperationsInput | number;
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    assetDamageId?: NullableStringFieldUpdateOperationsInput | string | null;
    userId?: NullableStringFieldUpdateOperationsInput | string | null;
    isSchoolCost?: BoolFieldUpdateOperationsInput | boolean;
  };

  export type ExamScoreCreateInput = {
    id?: string;
    score: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    examSubject: ExamSubjectCreateNestedOneWithoutExamScoresInput;
    pupil: PupilCreateNestedOneWithoutExamScoresInput;
  };

  export type ExamScoreUncheckedCreateInput = {
    id?: string;
    score: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    examSubjectId: string;
    pupilId: string;
  };

  export type ExamScoreUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    score?: FloatFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    examSubject?: ExamSubjectUpdateOneRequiredWithoutExamScoresNestedInput;
    pupil?: PupilUpdateOneRequiredWithoutExamScoresNestedInput;
  };

  export type ExamScoreUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    score?: FloatFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    examSubjectId?: StringFieldUpdateOperationsInput | string;
    pupilId?: StringFieldUpdateOperationsInput | string;
  };

  export type ExamScoreCreateManyInput = {
    id?: string;
    score: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    examSubjectId: string;
    pupilId: string;
  };

  export type ExamScoreUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    score?: FloatFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ExamScoreUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    score?: FloatFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    examSubjectId?: StringFieldUpdateOperationsInput | string;
    pupilId?: StringFieldUpdateOperationsInput | string;
  };

  export type ExamCreateInput = {
    id: string;
    examName: string;
    examType?: $Enums.ExamType;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    examSubjects?: ExamSubjectCreateNestedManyWithoutExamInput;
    classTerm: ClassTermCreateNestedOneWithoutExamsInput;
  };

  export type ExamUncheckedCreateInput = {
    id: string;
    examName: string;
    examType?: $Enums.ExamType;
    classTermId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    examSubjects?: ExamSubjectUncheckedCreateNestedManyWithoutExamInput;
  };

  export type ExamUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    examName?: StringFieldUpdateOperationsInput | string;
    examType?: EnumExamTypeFieldUpdateOperationsInput | $Enums.ExamType;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    examSubjects?: ExamSubjectUpdateManyWithoutExamNestedInput;
    classTerm?: ClassTermUpdateOneRequiredWithoutExamsNestedInput;
  };

  export type ExamUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    examName?: StringFieldUpdateOperationsInput | string;
    examType?: EnumExamTypeFieldUpdateOperationsInput | $Enums.ExamType;
    classTermId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    examSubjects?: ExamSubjectUncheckedUpdateManyWithoutExamNestedInput;
  };

  export type ExamCreateManyInput = {
    id: string;
    examName: string;
    examType?: $Enums.ExamType;
    classTermId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ExamUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    examName?: StringFieldUpdateOperationsInput | string;
    examType?: EnumExamTypeFieldUpdateOperationsInput | $Enums.ExamType;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ExamUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    examName?: StringFieldUpdateOperationsInput | string;
    examType?: EnumExamTypeFieldUpdateOperationsInput | $Enums.ExamType;
    classTermId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ExamSubjectCreateInput = {
    id?: string;
    examDate: Date | string;
    exam: ExamCreateNestedOneWithoutExamSubjectsInput;
    academicYearSubject: AcademicYearSubjectCreateNestedOneWithoutExamSubjectsInput;
    examScores?: ExamScoreCreateNestedManyWithoutExamSubjectInput;
  };

  export type ExamSubjectUncheckedCreateInput = {
    id?: string;
    examId: string;
    examDate: Date | string;
    academicYearSubjectId: string;
    examScores?: ExamScoreUncheckedCreateNestedManyWithoutExamSubjectInput;
  };

  export type ExamSubjectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    examDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    exam?: ExamUpdateOneRequiredWithoutExamSubjectsNestedInput;
    academicYearSubject?: AcademicYearSubjectUpdateOneRequiredWithoutExamSubjectsNestedInput;
    examScores?: ExamScoreUpdateManyWithoutExamSubjectNestedInput;
  };

  export type ExamSubjectUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    examId?: StringFieldUpdateOperationsInput | string;
    examDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    academicYearSubjectId?: StringFieldUpdateOperationsInput | string;
    examScores?: ExamScoreUncheckedUpdateManyWithoutExamSubjectNestedInput;
  };

  export type ExamSubjectCreateManyInput = {
    id?: string;
    examId: string;
    examDate: Date | string;
    academicYearSubjectId: string;
  };

  export type ExamSubjectUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    examDate?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ExamSubjectUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    examId?: StringFieldUpdateOperationsInput | string;
    examDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    academicYearSubjectId?: StringFieldUpdateOperationsInput | string;
  };

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedStringFilter<$PrismaModel> | string;
  };

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedStringNullableFilter<$PrismaModel> | string | null;
  };

  export type EnumRoleNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel> | null;
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null;
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null;
    not?: NestedEnumRoleNullableFilter<$PrismaModel> | $Enums.Role | null;
  };

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string;
  };

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolFilter<$PrismaModel> | boolean;
  };

  export type AssetDamageListRelationFilter = {
    every?: AssetDamageWhereInput;
    some?: AssetDamageWhereInput;
    none?: AssetDamageWhereInput;
  };

  export type AssetRepairPaymentListRelationFilter = {
    every?: AssetRepairPaymentWhereInput;
    some?: AssetRepairPaymentWhereInput;
    none?: AssetRepairPaymentWhereInput;
  };

  export type BorrowerListRelationFilter = {
    every?: BorrowerWhereInput;
    some?: BorrowerWhereInput;
    none?: BorrowerWhereInput;
  };

  export type EmailVerificationTokenListRelationFilter = {
    every?: EmailVerificationTokenWhereInput;
    some?: EmailVerificationTokenWhereInput;
    none?: EmailVerificationTokenWhereInput;
  };

  export type FeesPaymentListRelationFilter = {
    every?: FeesPaymentWhereInput;
    some?: FeesPaymentWhereInput;
    none?: FeesPaymentWhereInput;
  };

  export type PupilListRelationFilter = {
    every?: PupilWhereInput;
    some?: PupilWhereInput;
    none?: PupilWhereInput;
  };

  export type SessionListRelationFilter = {
    every?: SessionWhereInput;
    some?: SessionWhereInput;
    none?: SessionWhereInput;
  };

  export type StaffListRelationFilter = {
    every?: StaffWhereInput;
    some?: StaffWhereInput;
    none?: StaffWhereInput;
  };

  export type SortOrderInput = {
    sort: SortOrder;
    nulls?: NullsOrder;
  };

  export type AssetDamageOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type AssetRepairPaymentOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type BorrowerOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type EmailVerificationTokenOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type FeesPaymentOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type PupilOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type StaffOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    username?: SortOrder;
    email?: SortOrder;
    avatarUrl?: SortOrder;
    role?: SortOrder;
    createdAt?: SortOrder;
    telephone?: SortOrder;
    passwordHash?: SortOrder;
    googleId?: SortOrder;
    bio?: SortOrder;
    isWelcomed?: SortOrder;
    isVerified?: SortOrder;
    emailVerified?: SortOrder;
  };

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    username?: SortOrder;
    email?: SortOrder;
    avatarUrl?: SortOrder;
    role?: SortOrder;
    createdAt?: SortOrder;
    telephone?: SortOrder;
    passwordHash?: SortOrder;
    googleId?: SortOrder;
    bio?: SortOrder;
    isWelcomed?: SortOrder;
    isVerified?: SortOrder;
    emailVerified?: SortOrder;
  };

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    username?: SortOrder;
    email?: SortOrder;
    avatarUrl?: SortOrder;
    role?: SortOrder;
    createdAt?: SortOrder;
    telephone?: SortOrder;
    passwordHash?: SortOrder;
    googleId?: SortOrder;
    bio?: SortOrder;
    isWelcomed?: SortOrder;
    isVerified?: SortOrder;
    emailVerified?: SortOrder;
  };

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedStringFilter<$PrismaModel>;
    _max?: NestedStringFilter<$PrismaModel>;
  };

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?:
      | NestedStringNullableWithAggregatesFilter<$PrismaModel>
      | string
      | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedStringNullableFilter<$PrismaModel>;
    _max?: NestedStringNullableFilter<$PrismaModel>;
  };

  export type EnumRoleNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel> | null;
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null;
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null;
    not?:
      | NestedEnumRoleNullableWithAggregatesFilter<$PrismaModel>
      | $Enums.Role
      | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedEnumRoleNullableFilter<$PrismaModel>;
    _max?: NestedEnumRoleNullableFilter<$PrismaModel>;
  };

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedDateTimeFilter<$PrismaModel>;
    _max?: NestedDateTimeFilter<$PrismaModel>;
  };

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedBoolFilter<$PrismaModel>;
    _max?: NestedBoolFilter<$PrismaModel>;
  };

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>;
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>;
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>;
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>;
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>;
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>;
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>;
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number;
  };

  export type UserScalarRelationFilter = {
    is?: UserWhereInput;
    isNot?: UserWhereInput;
  };

  export type EmailVerificationTokenCountOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    expires?: SortOrder;
  };

  export type EmailVerificationTokenAvgOrderByAggregateInput = {
    expires?: SortOrder;
  };

  export type EmailVerificationTokenMaxOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    expires?: SortOrder;
  };

  export type EmailVerificationTokenMinOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    expires?: SortOrder;
  };

  export type EmailVerificationTokenSumOrderByAggregateInput = {
    expires?: SortOrder;
  };

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>;
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>;
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>;
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>;
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>;
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>;
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>;
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedBigIntFilter<$PrismaModel>;
    _min?: NestedBigIntFilter<$PrismaModel>;
    _max?: NestedBigIntFilter<$PrismaModel>;
  };

  export type ClassStreamListRelationFilter = {
    every?: classStreamWhereInput;
    some?: classStreamWhereInput;
    none?: classStreamWhereInput;
  };

  export type ExamScoreListRelationFilter = {
    every?: ExamScoreWhereInput;
    some?: ExamScoreWhereInput;
    none?: ExamScoreWhereInput;
  };

  export type FeesListRelationFilter = {
    every?: FeesWhereInput;
    some?: FeesWhereInput;
    none?: FeesWhereInput;
  };

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null;
    isNot?: UserWhereInput | null;
  };

  export type classStreamOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type ExamScoreOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type FeesOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type PupilCountOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    genericPassword?: SortOrder;
  };

  export type PupilMaxOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    genericPassword?: SortOrder;
  };

  export type PupilMinOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    genericPassword?: SortOrder;
  };

  export type EnumStaffTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.StaffType | EnumStaffTypeFieldRefInput<$PrismaModel>;
    in?: $Enums.StaffType[] | ListEnumStaffTypeFieldRefInput<$PrismaModel>;
    notIn?: $Enums.StaffType[] | ListEnumStaffTypeFieldRefInput<$PrismaModel>;
    not?: NestedEnumStaffTypeFilter<$PrismaModel> | $Enums.StaffType;
  };

  export type AcademicYearSubjectListRelationFilter = {
    every?: AcademicYearSubjectWhereInput;
    some?: AcademicYearSubjectWhereInput;
    none?: AcademicYearSubjectWhereInput;
  };

  export type AcademicYearSubjectOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type StaffCountOrderByAggregateInput = {
    id?: SortOrder;
    staffType?: SortOrder;
    userId?: SortOrder;
    genericPassword?: SortOrder;
  };

  export type StaffMaxOrderByAggregateInput = {
    id?: SortOrder;
    staffType?: SortOrder;
    userId?: SortOrder;
    genericPassword?: SortOrder;
  };

  export type StaffMinOrderByAggregateInput = {
    id?: SortOrder;
    staffType?: SortOrder;
    userId?: SortOrder;
    genericPassword?: SortOrder;
  };

  export type EnumStaffTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StaffType | EnumStaffTypeFieldRefInput<$PrismaModel>;
    in?: $Enums.StaffType[] | ListEnumStaffTypeFieldRefInput<$PrismaModel>;
    notIn?: $Enums.StaffType[] | ListEnumStaffTypeFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumStaffTypeWithAggregatesFilter<$PrismaModel>
      | $Enums.StaffType;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumStaffTypeFilter<$PrismaModel>;
    _max?: NestedEnumStaffTypeFilter<$PrismaModel>;
  };

  export type ClassListRelationFilter = {
    every?: ClassWhereInput;
    some?: ClassWhereInput;
    none?: ClassWhereInput;
  };

  export type SubjectListRelationFilter = {
    every?: SubjectWhereInput;
    some?: SubjectWhereInput;
    none?: SubjectWhereInput;
  };

  export type ClassOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type SubjectOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type LevelCountOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    slug?: SortOrder;
  };

  export type LevelMaxOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    slug?: SortOrder;
  };

  export type LevelMinOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    slug?: SortOrder;
  };

  export type StreamCountOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
  };

  export type StreamMaxOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
  };

  export type StreamMinOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
  };

  export type AcademicYearClassListRelationFilter = {
    every?: AcademicYearClassWhereInput;
    some?: AcademicYearClassWhereInput;
    none?: AcademicYearClassWhereInput;
  };

  export type LevelNullableScalarRelationFilter = {
    is?: LevelWhereInput | null;
    isNot?: LevelWhereInput | null;
  };

  export type AcademicYearClassOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type ClassCountOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    levelId?: SortOrder;
    createdAt?: SortOrder;
    slug?: SortOrder;
  };

  export type ClassMaxOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    levelId?: SortOrder;
    createdAt?: SortOrder;
    slug?: SortOrder;
  };

  export type ClassMinOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    levelId?: SortOrder;
    createdAt?: SortOrder;
    slug?: SortOrder;
  };

  export type AcademicYearCountOrderByAggregateInput = {
    id?: SortOrder;
    year?: SortOrder;
    startAt?: SortOrder;
    endAt?: SortOrder;
  };

  export type AcademicYearMaxOrderByAggregateInput = {
    id?: SortOrder;
    year?: SortOrder;
    startAt?: SortOrder;
    endAt?: SortOrder;
  };

  export type AcademicYearMinOrderByAggregateInput = {
    id?: SortOrder;
    year?: SortOrder;
    startAt?: SortOrder;
    endAt?: SortOrder;
  };

  export type AcademicYearNullableScalarRelationFilter = {
    is?: AcademicYearWhereInput | null;
    isNot?: AcademicYearWhereInput | null;
  };

  export type ClassNullableScalarRelationFilter = {
    is?: ClassWhereInput | null;
    isNot?: ClassWhereInput | null;
  };

  export type AcademicYearClassClassIdAcademicYearIdCompoundUniqueInput = {
    classId: string;
    academicYearId: string;
  };

  export type AcademicYearClassCountOrderByAggregateInput = {
    id?: SortOrder;
    academicYearId?: SortOrder;
    classId?: SortOrder;
  };

  export type AcademicYearClassMaxOrderByAggregateInput = {
    id?: SortOrder;
    academicYearId?: SortOrder;
    classId?: SortOrder;
  };

  export type AcademicYearClassMinOrderByAggregateInput = {
    id?: SortOrder;
    academicYearId?: SortOrder;
    classId?: SortOrder;
  };

  export type GradingListRelationFilter = {
    every?: GradingWhereInput;
    some?: GradingWhereInput;
    none?: GradingWhereInput;
  };

  export type LevelScalarRelationFilter = {
    is?: LevelWhereInput;
    isNot?: LevelWhereInput;
  };

  export type GradingOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type SubjectCodeSubjectNameCompoundUniqueInput = {
    code: string;
    subjectName: string;
  };

  export type SubjectCountOrderByAggregateInput = {
    id?: SortOrder;
    subjectName?: SortOrder;
    slug?: SortOrder;
    code?: SortOrder;
    levelId?: SortOrder;
  };

  export type SubjectMaxOrderByAggregateInput = {
    id?: SortOrder;
    subjectName?: SortOrder;
    slug?: SortOrder;
    code?: SortOrder;
    levelId?: SortOrder;
  };

  export type SubjectMinOrderByAggregateInput = {
    id?: SortOrder;
    subjectName?: SortOrder;
    slug?: SortOrder;
    code?: SortOrder;
    levelId?: SortOrder;
  };

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatFilter<$PrismaModel> | number;
  };

  export type GradingFromToGradeCompoundUniqueInput = {
    from: number;
    to: number;
    grade: string;
  };

  export type GradingCountOrderByAggregateInput = {
    id?: SortOrder;
    from?: SortOrder;
    to?: SortOrder;
    grade?: SortOrder;
    remarks?: SortOrder;
  };

  export type GradingAvgOrderByAggregateInput = {
    from?: SortOrder;
    to?: SortOrder;
  };

  export type GradingMaxOrderByAggregateInput = {
    id?: SortOrder;
    from?: SortOrder;
    to?: SortOrder;
    grade?: SortOrder;
    remarks?: SortOrder;
  };

  export type GradingMinOrderByAggregateInput = {
    id?: SortOrder;
    from?: SortOrder;
    to?: SortOrder;
    grade?: SortOrder;
    remarks?: SortOrder;
  };

  export type GradingSumOrderByAggregateInput = {
    from?: SortOrder;
    to?: SortOrder;
  };

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedFloatFilter<$PrismaModel>;
    _min?: NestedFloatFilter<$PrismaModel>;
    _max?: NestedFloatFilter<$PrismaModel>;
  };

  export type AcademicYearClassScalarRelationFilter = {
    is?: AcademicYearClassWhereInput;
    isNot?: AcademicYearClassWhereInput;
  };

  export type SubjectScalarRelationFilter = {
    is?: SubjectWhereInput;
    isNot?: SubjectWhereInput;
  };

  export type ExamSubjectListRelationFilter = {
    every?: ExamSubjectWhereInput;
    some?: ExamSubjectWhereInput;
    none?: ExamSubjectWhereInput;
  };

  export type ExamSubjectOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type AcademicYearSubjectAcademicYearClassIdSubjectIdCompoundUniqueInput =
    {
      academicYearClassId: string;
      subjectId: string;
    };

  export type AcademicYearSubjectCountOrderByAggregateInput = {
    id?: SortOrder;
    academicYearClassId?: SortOrder;
    subjectId?: SortOrder;
  };

  export type AcademicYearSubjectMaxOrderByAggregateInput = {
    id?: SortOrder;
    academicYearClassId?: SortOrder;
    subjectId?: SortOrder;
  };

  export type AcademicYearSubjectMinOrderByAggregateInput = {
    id?: SortOrder;
    academicYearClassId?: SortOrder;
    subjectId?: SortOrder;
  };

  export type AcademicYearClassNullableScalarRelationFilter = {
    is?: AcademicYearClassWhereInput | null;
    isNot?: AcademicYearClassWhereInput | null;
  };

  export type StaffNullableScalarRelationFilter = {
    is?: StaffWhereInput | null;
    isNot?: StaffWhereInput | null;
  };

  export type StreamNullableScalarRelationFilter = {
    is?: StreamWhereInput | null;
    isNot?: StreamWhereInput | null;
  };

  export type ClassTermListRelationFilter = {
    every?: ClassTermWhereInput;
    some?: ClassTermWhereInput;
    none?: ClassTermWhereInput;
  };

  export type ClassTermOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type classStreamClassIdStreamIdCompoundUniqueInput = {
    classId: string;
    streamId: string;
  };

  export type classStreamCountOrderByAggregateInput = {
    id?: SortOrder;
    staffId?: SortOrder;
    classId?: SortOrder;
    streamId?: SortOrder;
  };

  export type classStreamMaxOrderByAggregateInput = {
    id?: SortOrder;
    staffId?: SortOrder;
    classId?: SortOrder;
    streamId?: SortOrder;
  };

  export type classStreamMinOrderByAggregateInput = {
    id?: SortOrder;
    staffId?: SortOrder;
    classId?: SortOrder;
    streamId?: SortOrder;
  };

  export type TermCountOrderByAggregateInput = {
    id?: SortOrder;
    term?: SortOrder;
    slug?: SortOrder;
  };

  export type TermMaxOrderByAggregateInput = {
    id?: SortOrder;
    term?: SortOrder;
    slug?: SortOrder;
  };

  export type TermMinOrderByAggregateInput = {
    id?: SortOrder;
    term?: SortOrder;
    slug?: SortOrder;
  };

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableFilter<$PrismaModel> | number | null;
  };

  export type ClassStreamNullableScalarRelationFilter = {
    is?: classStreamWhereInput | null;
    isNot?: classStreamWhereInput | null;
  };

  export type TermNullableScalarRelationFilter = {
    is?: TermWhereInput | null;
    isNot?: TermWhereInput | null;
  };

  export type ExamListRelationFilter = {
    every?: ExamWhereInput;
    some?: ExamWhereInput;
    none?: ExamWhereInput;
  };

  export type ExamOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type ClassTermClassStreamIdTermIdCompoundUniqueInput = {
    classStreamId: string;
    termId: string;
  };

  export type ClassTermCountOrderByAggregateInput = {
    id?: SortOrder;
    startAt?: SortOrder;
    endAt?: SortOrder;
    termId?: SortOrder;
    classStreamId?: SortOrder;
    feesAmount?: SortOrder;
  };

  export type ClassTermAvgOrderByAggregateInput = {
    feesAmount?: SortOrder;
  };

  export type ClassTermMaxOrderByAggregateInput = {
    id?: SortOrder;
    startAt?: SortOrder;
    endAt?: SortOrder;
    termId?: SortOrder;
    classStreamId?: SortOrder;
    feesAmount?: SortOrder;
  };

  export type ClassTermMinOrderByAggregateInput = {
    id?: SortOrder;
    startAt?: SortOrder;
    endAt?: SortOrder;
    termId?: SortOrder;
    classStreamId?: SortOrder;
    feesAmount?: SortOrder;
  };

  export type ClassTermSumOrderByAggregateInput = {
    feesAmount?: SortOrder;
  };

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedFloatNullableFilter<$PrismaModel>;
    _sum?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedIntNullableFilter<$PrismaModel>;
    _max?: NestedIntNullableFilter<$PrismaModel>;
  };

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntFilter<$PrismaModel> | number;
  };

  export type EnumFeesStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.FeesStatus | EnumFeesStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.FeesStatus[] | ListEnumFeesStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.FeesStatus[] | ListEnumFeesStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumFeesStatusFilter<$PrismaModel> | $Enums.FeesStatus;
  };

  export type PupilScalarRelationFilter = {
    is?: PupilWhereInput;
    isNot?: PupilWhereInput;
  };

  export type ClassTermScalarRelationFilter = {
    is?: ClassTermWhereInput;
    isNot?: ClassTermWhereInput;
  };

  export type FeesCountOrderByAggregateInput = {
    id?: SortOrder;
    pupilId?: SortOrder;
    balance?: SortOrder;
    termId?: SortOrder;
    status?: SortOrder;
  };

  export type FeesAvgOrderByAggregateInput = {
    balance?: SortOrder;
  };

  export type FeesMaxOrderByAggregateInput = {
    id?: SortOrder;
    pupilId?: SortOrder;
    balance?: SortOrder;
    termId?: SortOrder;
    status?: SortOrder;
  };

  export type FeesMinOrderByAggregateInput = {
    id?: SortOrder;
    pupilId?: SortOrder;
    balance?: SortOrder;
    termId?: SortOrder;
    status?: SortOrder;
  };

  export type FeesSumOrderByAggregateInput = {
    balance?: SortOrder;
  };

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedIntFilter<$PrismaModel>;
    _min?: NestedIntFilter<$PrismaModel>;
    _max?: NestedIntFilter<$PrismaModel>;
  };

  export type EnumFeesStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FeesStatus | EnumFeesStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.FeesStatus[] | ListEnumFeesStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.FeesStatus[] | ListEnumFeesStatusFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumFeesStatusWithAggregatesFilter<$PrismaModel>
      | $Enums.FeesStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumFeesStatusFilter<$PrismaModel>;
    _max?: NestedEnumFeesStatusFilter<$PrismaModel>;
  };

  export type FeesNullableScalarRelationFilter = {
    is?: FeesWhereInput | null;
    isNot?: FeesWhereInput | null;
  };

  export type FeesPaymentCountOrderByAggregateInput = {
    id?: SortOrder;
    amountPaid?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    feesId?: SortOrder;
    userId?: SortOrder;
  };

  export type FeesPaymentAvgOrderByAggregateInput = {
    amountPaid?: SortOrder;
  };

  export type FeesPaymentMaxOrderByAggregateInput = {
    id?: SortOrder;
    amountPaid?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    feesId?: SortOrder;
    userId?: SortOrder;
  };

  export type FeesPaymentMinOrderByAggregateInput = {
    id?: SortOrder;
    amountPaid?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    feesId?: SortOrder;
    userId?: SortOrder;
  };

  export type FeesPaymentSumOrderByAggregateInput = {
    amountPaid?: SortOrder;
  };

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>;
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>;
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>;
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role;
  };

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    expiresAt?: SortOrder;
    role?: SortOrder;
  };

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    expiresAt?: SortOrder;
    role?: SortOrder;
  };

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    expiresAt?: SortOrder;
    role?: SortOrder;
  };

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>;
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>;
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>;
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumRoleFilter<$PrismaModel>;
    _max?: NestedEnumRoleFilter<$PrismaModel>;
  };

  export type EnumAssetCategoryFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.AssetCategory
      | EnumAssetCategoryFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.AssetCategory[]
      | ListEnumAssetCategoryFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.AssetCategory[]
      | ListEnumAssetCategoryFieldRefInput<$PrismaModel>;
    not?: NestedEnumAssetCategoryFilter<$PrismaModel> | $Enums.AssetCategory;
  };

  export type ComputerLabItemListRelationFilter = {
    every?: ComputerLabItemWhereInput;
    some?: ComputerLabItemWhereInput;
    none?: ComputerLabItemWhereInput;
  };

  export type FoodStoreItemListRelationFilter = {
    every?: FoodStoreItemWhereInput;
    some?: FoodStoreItemWhereInput;
    none?: FoodStoreItemWhereInput;
  };

  export type GeneralStoreItemListRelationFilter = {
    every?: GeneralStoreItemWhereInput;
    some?: GeneralStoreItemWhereInput;
    none?: GeneralStoreItemWhereInput;
  };

  export type LabItemListRelationFilter = {
    every?: LabItemWhereInput;
    some?: LabItemWhereInput;
    none?: LabItemWhereInput;
  };

  export type LibraryBookListRelationFilter = {
    every?: LibraryBookWhereInput;
    some?: LibraryBookWhereInput;
    none?: LibraryBookWhereInput;
  };

  export type ComputerLabItemOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type FoodStoreItemOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type GeneralStoreItemOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type LabItemOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type LibraryBookOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type AssetCountOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    description?: SortOrder;
    category?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type AssetMaxOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    description?: SortOrder;
    category?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type AssetMinOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    description?: SortOrder;
    category?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type EnumAssetCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.AssetCategory
      | EnumAssetCategoryFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.AssetCategory[]
      | ListEnumAssetCategoryFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.AssetCategory[]
      | ListEnumAssetCategoryFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumAssetCategoryWithAggregatesFilter<$PrismaModel>
      | $Enums.AssetCategory;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumAssetCategoryFilter<$PrismaModel>;
    _max?: NestedEnumAssetCategoryFilter<$PrismaModel>;
  };

  export type EnumAssetUnitFilter<$PrismaModel = never> = {
    equals?: $Enums.AssetUnit | EnumAssetUnitFieldRefInput<$PrismaModel>;
    in?: $Enums.AssetUnit[] | ListEnumAssetUnitFieldRefInput<$PrismaModel>;
    notIn?: $Enums.AssetUnit[] | ListEnumAssetUnitFieldRefInput<$PrismaModel>;
    not?: NestedEnumAssetUnitFilter<$PrismaModel> | $Enums.AssetUnit;
  };

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null;
  };

  export type EnumAssetItemStatusFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.AssetItemStatus
      | EnumAssetItemStatusFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.AssetItemStatus[]
      | ListEnumAssetItemStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.AssetItemStatus[]
      | ListEnumAssetItemStatusFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumAssetItemStatusFilter<$PrismaModel>
      | $Enums.AssetItemStatus;
  };

  export type FoodConsumptionListRelationFilter = {
    every?: FoodConsumptionWhereInput;
    some?: FoodConsumptionWhereInput;
    none?: FoodConsumptionWhereInput;
  };

  export type AssetScalarRelationFilter = {
    is?: AssetWhereInput;
    isNot?: AssetWhereInput;
  };

  export type SupplierNullableScalarRelationFilter = {
    is?: SupplierWhereInput | null;
    isNot?: SupplierWhereInput | null;
  };

  export type IndividualFoodStoreItemListRelationFilter = {
    every?: IndividualFoodStoreItemWhereInput;
    some?: IndividualFoodStoreItemWhereInput;
    none?: IndividualFoodStoreItemWhereInput;
  };

  export type FoodConsumptionOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type IndividualFoodStoreItemOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type FoodStoreItemCountOrderByAggregateInput = {
    id?: SortOrder;
    assetId?: SortOrder;
    foodName?: SortOrder;
    unit?: SortOrder;
    quantity?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    supplierId?: SortOrder;
    trackQuantity?: SortOrder;
    status?: SortOrder;
    isConsumable?: SortOrder;
  };

  export type FoodStoreItemAvgOrderByAggregateInput = {
    quantity?: SortOrder;
  };

  export type FoodStoreItemMaxOrderByAggregateInput = {
    id?: SortOrder;
    assetId?: SortOrder;
    foodName?: SortOrder;
    unit?: SortOrder;
    quantity?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    supplierId?: SortOrder;
    trackQuantity?: SortOrder;
    status?: SortOrder;
    isConsumable?: SortOrder;
  };

  export type FoodStoreItemMinOrderByAggregateInput = {
    id?: SortOrder;
    assetId?: SortOrder;
    foodName?: SortOrder;
    unit?: SortOrder;
    quantity?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    supplierId?: SortOrder;
    trackQuantity?: SortOrder;
    status?: SortOrder;
    isConsumable?: SortOrder;
  };

  export type FoodStoreItemSumOrderByAggregateInput = {
    quantity?: SortOrder;
  };

  export type EnumAssetUnitWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AssetUnit | EnumAssetUnitFieldRefInput<$PrismaModel>;
    in?: $Enums.AssetUnit[] | ListEnumAssetUnitFieldRefInput<$PrismaModel>;
    notIn?: $Enums.AssetUnit[] | ListEnumAssetUnitFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumAssetUnitWithAggregatesFilter<$PrismaModel>
      | $Enums.AssetUnit;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumAssetUnitFilter<$PrismaModel>;
    _max?: NestedEnumAssetUnitFilter<$PrismaModel>;
  };

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedFloatNullableFilter<$PrismaModel>;
    _sum?: NestedFloatNullableFilter<$PrismaModel>;
    _min?: NestedFloatNullableFilter<$PrismaModel>;
    _max?: NestedFloatNullableFilter<$PrismaModel>;
  };

  export type EnumAssetItemStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.AssetItemStatus
      | EnumAssetItemStatusFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.AssetItemStatus[]
      | ListEnumAssetItemStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.AssetItemStatus[]
      | ListEnumAssetItemStatusFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumAssetItemStatusWithAggregatesFilter<$PrismaModel>
      | $Enums.AssetItemStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumAssetItemStatusFilter<$PrismaModel>;
    _max?: NestedEnumAssetItemStatusFilter<$PrismaModel>;
  };

  export type EnumAssetStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AssetStatus | EnumAssetStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.AssetStatus[] | ListEnumAssetStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.AssetStatus[]
      | ListEnumAssetStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumAssetStatusFilter<$PrismaModel> | $Enums.AssetStatus;
  };

  export type EnumAssetConditionFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.AssetCondition
      | EnumAssetConditionFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.AssetCondition[]
      | ListEnumAssetConditionFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.AssetCondition[]
      | ListEnumAssetConditionFieldRefInput<$PrismaModel>;
    not?: NestedEnumAssetConditionFilter<$PrismaModel> | $Enums.AssetCondition;
  };

  export type FoodStoreItemScalarRelationFilter = {
    is?: FoodStoreItemWhereInput;
    isNot?: FoodStoreItemWhereInput;
  };

  export type IndividualFoodStoreItemCountOrderByAggregateInput = {
    id?: SortOrder;
    foodStoreItemId?: SortOrder;
    uniqueIdentifier?: SortOrder;
    status?: SortOrder;
    condition?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type IndividualFoodStoreItemMaxOrderByAggregateInput = {
    id?: SortOrder;
    foodStoreItemId?: SortOrder;
    uniqueIdentifier?: SortOrder;
    status?: SortOrder;
    condition?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type IndividualFoodStoreItemMinOrderByAggregateInput = {
    id?: SortOrder;
    foodStoreItemId?: SortOrder;
    uniqueIdentifier?: SortOrder;
    status?: SortOrder;
    condition?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type EnumAssetStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AssetStatus | EnumAssetStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.AssetStatus[] | ListEnumAssetStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.AssetStatus[]
      | ListEnumAssetStatusFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumAssetStatusWithAggregatesFilter<$PrismaModel>
      | $Enums.AssetStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumAssetStatusFilter<$PrismaModel>;
    _max?: NestedEnumAssetStatusFilter<$PrismaModel>;
  };

  export type EnumAssetConditionWithAggregatesFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.AssetCondition
      | EnumAssetConditionFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.AssetCondition[]
      | ListEnumAssetConditionFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.AssetCondition[]
      | ListEnumAssetConditionFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumAssetConditionWithAggregatesFilter<$PrismaModel>
      | $Enums.AssetCondition;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumAssetConditionFilter<$PrismaModel>;
    _max?: NestedEnumAssetConditionFilter<$PrismaModel>;
  };

  export type FoodConsumptionCountOrderByAggregateInput = {
    id?: SortOrder;
    quantityUsed?: SortOrder;
    dateUsedAt?: SortOrder;
    usageDetails?: SortOrder;
    foodStoreItemId?: SortOrder;
  };

  export type FoodConsumptionAvgOrderByAggregateInput = {
    quantityUsed?: SortOrder;
  };

  export type FoodConsumptionMaxOrderByAggregateInput = {
    id?: SortOrder;
    quantityUsed?: SortOrder;
    dateUsedAt?: SortOrder;
    usageDetails?: SortOrder;
    foodStoreItemId?: SortOrder;
  };

  export type FoodConsumptionMinOrderByAggregateInput = {
    id?: SortOrder;
    quantityUsed?: SortOrder;
    dateUsedAt?: SortOrder;
    usageDetails?: SortOrder;
    foodStoreItemId?: SortOrder;
  };

  export type FoodConsumptionSumOrderByAggregateInput = {
    quantityUsed?: SortOrder;
  };

  export type SupplierCountOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    contactInfo?: SortOrder;
    address?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type SupplierMaxOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    contactInfo?: SortOrder;
    address?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type SupplierMinOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    contactInfo?: SortOrder;
    address?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type IndividualBookListRelationFilter = {
    every?: IndividualBookWhereInput;
    some?: IndividualBookWhereInput;
    none?: IndividualBookWhereInput;
  };

  export type LibraryBookCategoryScalarRelationFilter = {
    is?: LibraryBookCategoryWhereInput;
    isNot?: LibraryBookCategoryWhereInput;
  };

  export type IndividualBookOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type LibraryBookTitleAuthorCompoundUniqueInput = {
    title: string;
    author: string;
  };

  export type LibraryBookCountOrderByAggregateInput = {
    id?: SortOrder;
    title?: SortOrder;
    author?: SortOrder;
    assetId?: SortOrder;
    libraryBookCategoryId?: SortOrder;
    quantity?: SortOrder;
    trackQuantity?: SortOrder;
    unit?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type LibraryBookAvgOrderByAggregateInput = {
    quantity?: SortOrder;
  };

  export type LibraryBookMaxOrderByAggregateInput = {
    id?: SortOrder;
    title?: SortOrder;
    author?: SortOrder;
    assetId?: SortOrder;
    libraryBookCategoryId?: SortOrder;
    quantity?: SortOrder;
    trackQuantity?: SortOrder;
    unit?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type LibraryBookMinOrderByAggregateInput = {
    id?: SortOrder;
    title?: SortOrder;
    author?: SortOrder;
    assetId?: SortOrder;
    libraryBookCategoryId?: SortOrder;
    quantity?: SortOrder;
    trackQuantity?: SortOrder;
    unit?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type LibraryBookSumOrderByAggregateInput = {
    quantity?: SortOrder;
  };

  export type EnumBookStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BookStatus | EnumBookStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.BookStatus[] | ListEnumBookStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.BookStatus[] | ListEnumBookStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumBookStatusFilter<$PrismaModel> | $Enums.BookStatus;
  };

  export type LibraryBookScalarRelationFilter = {
    is?: LibraryBookWhereInput;
    isNot?: LibraryBookWhereInput;
  };

  export type IndividualBookCountOrderByAggregateInput = {
    id?: SortOrder;
    isbn?: SortOrder;
    status?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    libraryBookId?: SortOrder;
    condition?: SortOrder;
    borrowCount?: SortOrder;
  };

  export type IndividualBookAvgOrderByAggregateInput = {
    borrowCount?: SortOrder;
  };

  export type IndividualBookMaxOrderByAggregateInput = {
    id?: SortOrder;
    isbn?: SortOrder;
    status?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    libraryBookId?: SortOrder;
    condition?: SortOrder;
    borrowCount?: SortOrder;
  };

  export type IndividualBookMinOrderByAggregateInput = {
    id?: SortOrder;
    isbn?: SortOrder;
    status?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    libraryBookId?: SortOrder;
    condition?: SortOrder;
    borrowCount?: SortOrder;
  };

  export type IndividualBookSumOrderByAggregateInput = {
    borrowCount?: SortOrder;
  };

  export type EnumBookStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookStatus | EnumBookStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.BookStatus[] | ListEnumBookStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.BookStatus[] | ListEnumBookStatusFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumBookStatusWithAggregatesFilter<$PrismaModel>
      | $Enums.BookStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumBookStatusFilter<$PrismaModel>;
    _max?: NestedEnumBookStatusFilter<$PrismaModel>;
  };

  export type LibraryBookCategoryCountOrderByAggregateInput = {
    id?: SortOrder;
    category?: SortOrder;
    description?: SortOrder;
  };

  export type LibraryBookCategoryMaxOrderByAggregateInput = {
    id?: SortOrder;
    category?: SortOrder;
    description?: SortOrder;
  };

  export type LibraryBookCategoryMinOrderByAggregateInput = {
    id?: SortOrder;
    category?: SortOrder;
    description?: SortOrder;
  };

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null;
  };

  export type EnumBorrowStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BorrowStatus | EnumBorrowStatusFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.BorrowStatus[]
      | ListEnumBorrowStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.BorrowStatus[]
      | ListEnumBorrowStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumBorrowStatusFilter<$PrismaModel> | $Enums.BorrowStatus;
  };

  export type IndividualBookNullableScalarRelationFilter = {
    is?: IndividualBookWhereInput | null;
    isNot?: IndividualBookWhereInput | null;
  };

  export type BorrowerCountOrderByAggregateInput = {
    id?: SortOrder;
    borrowedAt?: SortOrder;
    returnAt?: SortOrder;
    status?: SortOrder;
    userId?: SortOrder;
    individualBookId?: SortOrder;
  };

  export type BorrowerMaxOrderByAggregateInput = {
    id?: SortOrder;
    borrowedAt?: SortOrder;
    returnAt?: SortOrder;
    status?: SortOrder;
    userId?: SortOrder;
    individualBookId?: SortOrder;
  };

  export type BorrowerMinOrderByAggregateInput = {
    id?: SortOrder;
    borrowedAt?: SortOrder;
    returnAt?: SortOrder;
    status?: SortOrder;
    userId?: SortOrder;
    individualBookId?: SortOrder;
  };

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?:
      | NestedDateTimeNullableWithAggregatesFilter<$PrismaModel>
      | Date
      | string
      | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedDateTimeNullableFilter<$PrismaModel>;
    _max?: NestedDateTimeNullableFilter<$PrismaModel>;
  };

  export type EnumBorrowStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BorrowStatus | EnumBorrowStatusFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.BorrowStatus[]
      | ListEnumBorrowStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.BorrowStatus[]
      | ListEnumBorrowStatusFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumBorrowStatusWithAggregatesFilter<$PrismaModel>
      | $Enums.BorrowStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumBorrowStatusFilter<$PrismaModel>;
    _max?: NestedEnumBorrowStatusFilter<$PrismaModel>;
  };

  export type IndividualLabItemListRelationFilter = {
    every?: IndividualLabItemWhereInput;
    some?: IndividualLabItemWhereInput;
    none?: IndividualLabItemWhereInput;
  };

  export type IndividualLabItemOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type LabItemCountOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    quantity?: SortOrder;
    unit?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    assetId?: SortOrder;
    trackQuantity?: SortOrder;
    status?: SortOrder;
  };

  export type LabItemAvgOrderByAggregateInput = {
    quantity?: SortOrder;
  };

  export type LabItemMaxOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    quantity?: SortOrder;
    unit?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    assetId?: SortOrder;
    trackQuantity?: SortOrder;
    status?: SortOrder;
  };

  export type LabItemMinOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    quantity?: SortOrder;
    unit?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    assetId?: SortOrder;
    trackQuantity?: SortOrder;
    status?: SortOrder;
  };

  export type LabItemSumOrderByAggregateInput = {
    quantity?: SortOrder;
  };

  export type LabItemScalarRelationFilter = {
    is?: LabItemWhereInput;
    isNot?: LabItemWhereInput;
  };

  export type IndividualLabItemCountOrderByAggregateInput = {
    id?: SortOrder;
    labItemId?: SortOrder;
    uniqueIdentifier?: SortOrder;
    status?: SortOrder;
    condition?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type IndividualLabItemMaxOrderByAggregateInput = {
    id?: SortOrder;
    labItemId?: SortOrder;
    uniqueIdentifier?: SortOrder;
    status?: SortOrder;
    condition?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type IndividualLabItemMinOrderByAggregateInput = {
    id?: SortOrder;
    labItemId?: SortOrder;
    uniqueIdentifier?: SortOrder;
    status?: SortOrder;
    condition?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type IndividualComputerLabItemListRelationFilter = {
    every?: IndividualComputerLabItemWhereInput;
    some?: IndividualComputerLabItemWhereInput;
    none?: IndividualComputerLabItemWhereInput;
  };

  export type IndividualComputerLabItemOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type ComputerLabItemCountOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    model?: SortOrder;
    specification?: SortOrder;
    quantity?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    assetId?: SortOrder;
    trackQuantity?: SortOrder;
    unit?: SortOrder;
  };

  export type ComputerLabItemAvgOrderByAggregateInput = {
    quantity?: SortOrder;
  };

  export type ComputerLabItemMaxOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    model?: SortOrder;
    specification?: SortOrder;
    quantity?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    assetId?: SortOrder;
    trackQuantity?: SortOrder;
    unit?: SortOrder;
  };

  export type ComputerLabItemMinOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    model?: SortOrder;
    specification?: SortOrder;
    quantity?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    assetId?: SortOrder;
    trackQuantity?: SortOrder;
    unit?: SortOrder;
  };

  export type ComputerLabItemSumOrderByAggregateInput = {
    quantity?: SortOrder;
  };

  export type ComputerLabItemScalarRelationFilter = {
    is?: ComputerLabItemWhereInput;
    isNot?: ComputerLabItemWhereInput;
  };

  export type IndividualComputerLabItemCountOrderByAggregateInput = {
    id?: SortOrder;
    computerLabItemId?: SortOrder;
    uniqueIdentifier?: SortOrder;
    status?: SortOrder;
    condition?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type IndividualComputerLabItemMaxOrderByAggregateInput = {
    id?: SortOrder;
    computerLabItemId?: SortOrder;
    uniqueIdentifier?: SortOrder;
    status?: SortOrder;
    condition?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type IndividualComputerLabItemMinOrderByAggregateInput = {
    id?: SortOrder;
    computerLabItemId?: SortOrder;
    uniqueIdentifier?: SortOrder;
    status?: SortOrder;
    condition?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type IndividualGeneralStoreItemListRelationFilter = {
    every?: IndividualGeneralStoreItemWhereInput;
    some?: IndividualGeneralStoreItemWhereInput;
    none?: IndividualGeneralStoreItemWhereInput;
  };

  export type IndividualGeneralStoreItemOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type GeneralStoreItemCountOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    quantity?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    assetId?: SortOrder;
    status?: SortOrder;
    trackQuantity?: SortOrder;
    unit?: SortOrder;
  };

  export type GeneralStoreItemAvgOrderByAggregateInput = {
    quantity?: SortOrder;
  };

  export type GeneralStoreItemMaxOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    quantity?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    assetId?: SortOrder;
    status?: SortOrder;
    trackQuantity?: SortOrder;
    unit?: SortOrder;
  };

  export type GeneralStoreItemMinOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    quantity?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    assetId?: SortOrder;
    status?: SortOrder;
    trackQuantity?: SortOrder;
    unit?: SortOrder;
  };

  export type GeneralStoreItemSumOrderByAggregateInput = {
    quantity?: SortOrder;
  };

  export type GeneralStoreItemScalarRelationFilter = {
    is?: GeneralStoreItemWhereInput;
    isNot?: GeneralStoreItemWhereInput;
  };

  export type IndividualGeneralStoreItemCountOrderByAggregateInput = {
    id?: SortOrder;
    generalStoreItemId?: SortOrder;
    uniqueIdentifier?: SortOrder;
    status?: SortOrder;
    condition?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type IndividualGeneralStoreItemMaxOrderByAggregateInput = {
    id?: SortOrder;
    generalStoreItemId?: SortOrder;
    uniqueIdentifier?: SortOrder;
    status?: SortOrder;
    condition?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type IndividualGeneralStoreItemMinOrderByAggregateInput = {
    id?: SortOrder;
    generalStoreItemId?: SortOrder;
    uniqueIdentifier?: SortOrder;
    status?: SortOrder;
    condition?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type IndividualComputerLabItemNullableScalarRelationFilter = {
    is?: IndividualComputerLabItemWhereInput | null;
    isNot?: IndividualComputerLabItemWhereInput | null;
  };

  export type IndividualFoodStoreItemNullableScalarRelationFilter = {
    is?: IndividualFoodStoreItemWhereInput | null;
    isNot?: IndividualFoodStoreItemWhereInput | null;
  };

  export type IndividualGeneralStoreItemNullableScalarRelationFilter = {
    is?: IndividualGeneralStoreItemWhereInput | null;
    isNot?: IndividualGeneralStoreItemWhereInput | null;
  };

  export type IndividualLabItemNullableScalarRelationFilter = {
    is?: IndividualLabItemWhereInput | null;
    isNot?: IndividualLabItemWhereInput | null;
  };

  export type AssetDamageCountOrderByAggregateInput = {
    id?: SortOrder;
    damageDetails?: SortOrder;
    condition?: SortOrder;
    quantity?: SortOrder;
    userId?: SortOrder;
    individualComputerLabItemId?: SortOrder;
    isRepaired?: SortOrder;
    repairedAt?: SortOrder;
    createdAt?: SortOrder;
    individualBookId?: SortOrder;
    individualLabItemId?: SortOrder;
    individualFoodStoreItemId?: SortOrder;
    individualGeneralStoreItemId?: SortOrder;
    isSchoolCost?: SortOrder;
    repairBalance?: SortOrder;
    repairPrice?: SortOrder;
  };

  export type AssetDamageAvgOrderByAggregateInput = {
    quantity?: SortOrder;
    repairBalance?: SortOrder;
    repairPrice?: SortOrder;
  };

  export type AssetDamageMaxOrderByAggregateInput = {
    id?: SortOrder;
    damageDetails?: SortOrder;
    condition?: SortOrder;
    quantity?: SortOrder;
    userId?: SortOrder;
    individualComputerLabItemId?: SortOrder;
    isRepaired?: SortOrder;
    repairedAt?: SortOrder;
    createdAt?: SortOrder;
    individualBookId?: SortOrder;
    individualLabItemId?: SortOrder;
    individualFoodStoreItemId?: SortOrder;
    individualGeneralStoreItemId?: SortOrder;
    isSchoolCost?: SortOrder;
    repairBalance?: SortOrder;
    repairPrice?: SortOrder;
  };

  export type AssetDamageMinOrderByAggregateInput = {
    id?: SortOrder;
    damageDetails?: SortOrder;
    condition?: SortOrder;
    quantity?: SortOrder;
    userId?: SortOrder;
    individualComputerLabItemId?: SortOrder;
    isRepaired?: SortOrder;
    repairedAt?: SortOrder;
    createdAt?: SortOrder;
    individualBookId?: SortOrder;
    individualLabItemId?: SortOrder;
    individualFoodStoreItemId?: SortOrder;
    individualGeneralStoreItemId?: SortOrder;
    isSchoolCost?: SortOrder;
    repairBalance?: SortOrder;
    repairPrice?: SortOrder;
  };

  export type AssetDamageSumOrderByAggregateInput = {
    quantity?: SortOrder;
    repairBalance?: SortOrder;
    repairPrice?: SortOrder;
  };

  export type AssetDamageNullableScalarRelationFilter = {
    is?: AssetDamageWhereInput | null;
    isNot?: AssetDamageWhereInput | null;
  };

  export type AssetRepairPaymentCountOrderByAggregateInput = {
    id?: SortOrder;
    paidAmount?: SortOrder;
    paidAt?: SortOrder;
    updatedAt?: SortOrder;
    assetDamageId?: SortOrder;
    userId?: SortOrder;
    isSchoolCost?: SortOrder;
  };

  export type AssetRepairPaymentAvgOrderByAggregateInput = {
    paidAmount?: SortOrder;
  };

  export type AssetRepairPaymentMaxOrderByAggregateInput = {
    id?: SortOrder;
    paidAmount?: SortOrder;
    paidAt?: SortOrder;
    updatedAt?: SortOrder;
    assetDamageId?: SortOrder;
    userId?: SortOrder;
    isSchoolCost?: SortOrder;
  };

  export type AssetRepairPaymentMinOrderByAggregateInput = {
    id?: SortOrder;
    paidAmount?: SortOrder;
    paidAt?: SortOrder;
    updatedAt?: SortOrder;
    assetDamageId?: SortOrder;
    userId?: SortOrder;
    isSchoolCost?: SortOrder;
  };

  export type AssetRepairPaymentSumOrderByAggregateInput = {
    paidAmount?: SortOrder;
  };

  export type ExamSubjectScalarRelationFilter = {
    is?: ExamSubjectWhereInput;
    isNot?: ExamSubjectWhereInput;
  };

  export type ExamScoreCountOrderByAggregateInput = {
    id?: SortOrder;
    score?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    examSubjectId?: SortOrder;
    pupilId?: SortOrder;
  };

  export type ExamScoreAvgOrderByAggregateInput = {
    score?: SortOrder;
  };

  export type ExamScoreMaxOrderByAggregateInput = {
    id?: SortOrder;
    score?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    examSubjectId?: SortOrder;
    pupilId?: SortOrder;
  };

  export type ExamScoreMinOrderByAggregateInput = {
    id?: SortOrder;
    score?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    examSubjectId?: SortOrder;
    pupilId?: SortOrder;
  };

  export type ExamScoreSumOrderByAggregateInput = {
    score?: SortOrder;
  };

  export type EnumExamTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ExamType | EnumExamTypeFieldRefInput<$PrismaModel>;
    in?: $Enums.ExamType[] | ListEnumExamTypeFieldRefInput<$PrismaModel>;
    notIn?: $Enums.ExamType[] | ListEnumExamTypeFieldRefInput<$PrismaModel>;
    not?: NestedEnumExamTypeFilter<$PrismaModel> | $Enums.ExamType;
  };

  export type ExamExamNameClassTermIdCompoundUniqueInput = {
    examName: string;
    classTermId: string;
  };

  export type ExamCountOrderByAggregateInput = {
    id?: SortOrder;
    examName?: SortOrder;
    examType?: SortOrder;
    classTermId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type ExamMaxOrderByAggregateInput = {
    id?: SortOrder;
    examName?: SortOrder;
    examType?: SortOrder;
    classTermId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type ExamMinOrderByAggregateInput = {
    id?: SortOrder;
    examName?: SortOrder;
    examType?: SortOrder;
    classTermId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type EnumExamTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ExamType | EnumExamTypeFieldRefInput<$PrismaModel>;
    in?: $Enums.ExamType[] | ListEnumExamTypeFieldRefInput<$PrismaModel>;
    notIn?: $Enums.ExamType[] | ListEnumExamTypeFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumExamTypeWithAggregatesFilter<$PrismaModel>
      | $Enums.ExamType;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumExamTypeFilter<$PrismaModel>;
    _max?: NestedEnumExamTypeFilter<$PrismaModel>;
  };

  export type ExamScalarRelationFilter = {
    is?: ExamWhereInput;
    isNot?: ExamWhereInput;
  };

  export type AcademicYearSubjectScalarRelationFilter = {
    is?: AcademicYearSubjectWhereInput;
    isNot?: AcademicYearSubjectWhereInput;
  };

  export type ExamSubjectCountOrderByAggregateInput = {
    id?: SortOrder;
    examId?: SortOrder;
    examDate?: SortOrder;
    academicYearSubjectId?: SortOrder;
  };

  export type ExamSubjectMaxOrderByAggregateInput = {
    id?: SortOrder;
    examId?: SortOrder;
    examDate?: SortOrder;
    academicYearSubjectId?: SortOrder;
  };

  export type ExamSubjectMinOrderByAggregateInput = {
    id?: SortOrder;
    examId?: SortOrder;
    examDate?: SortOrder;
    academicYearSubjectId?: SortOrder;
  };

  export type AssetDamageCreateNestedManyWithoutDamagedByInput = {
    create?:
      | XOR<
          AssetDamageCreateWithoutDamagedByInput,
          AssetDamageUncheckedCreateWithoutDamagedByInput
        >
      | AssetDamageCreateWithoutDamagedByInput[]
      | AssetDamageUncheckedCreateWithoutDamagedByInput[];
    connectOrCreate?:
      | AssetDamageCreateOrConnectWithoutDamagedByInput
      | AssetDamageCreateOrConnectWithoutDamagedByInput[];
    createMany?: AssetDamageCreateManyDamagedByInputEnvelope;
    connect?: AssetDamageWhereUniqueInput | AssetDamageWhereUniqueInput[];
  };

  export type AssetRepairPaymentCreateNestedManyWithoutReceivedByInput = {
    create?:
      | XOR<
          AssetRepairPaymentCreateWithoutReceivedByInput,
          AssetRepairPaymentUncheckedCreateWithoutReceivedByInput
        >
      | AssetRepairPaymentCreateWithoutReceivedByInput[]
      | AssetRepairPaymentUncheckedCreateWithoutReceivedByInput[];
    connectOrCreate?:
      | AssetRepairPaymentCreateOrConnectWithoutReceivedByInput
      | AssetRepairPaymentCreateOrConnectWithoutReceivedByInput[];
    createMany?: AssetRepairPaymentCreateManyReceivedByInputEnvelope;
    connect?:
      | AssetRepairPaymentWhereUniqueInput
      | AssetRepairPaymentWhereUniqueInput[];
  };

  export type BorrowerCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          BorrowerCreateWithoutUserInput,
          BorrowerUncheckedCreateWithoutUserInput
        >
      | BorrowerCreateWithoutUserInput[]
      | BorrowerUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | BorrowerCreateOrConnectWithoutUserInput
      | BorrowerCreateOrConnectWithoutUserInput[];
    createMany?: BorrowerCreateManyUserInputEnvelope;
    connect?: BorrowerWhereUniqueInput | BorrowerWhereUniqueInput[];
  };

  export type EmailVerificationTokenCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          EmailVerificationTokenCreateWithoutUserInput,
          EmailVerificationTokenUncheckedCreateWithoutUserInput
        >
      | EmailVerificationTokenCreateWithoutUserInput[]
      | EmailVerificationTokenUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | EmailVerificationTokenCreateOrConnectWithoutUserInput
      | EmailVerificationTokenCreateOrConnectWithoutUserInput[];
    createMany?: EmailVerificationTokenCreateManyUserInputEnvelope;
    connect?:
      | EmailVerificationTokenWhereUniqueInput
      | EmailVerificationTokenWhereUniqueInput[];
  };

  export type FeesPaymentCreateNestedManyWithoutPaidByInput = {
    create?:
      | XOR<
          FeesPaymentCreateWithoutPaidByInput,
          FeesPaymentUncheckedCreateWithoutPaidByInput
        >
      | FeesPaymentCreateWithoutPaidByInput[]
      | FeesPaymentUncheckedCreateWithoutPaidByInput[];
    connectOrCreate?:
      | FeesPaymentCreateOrConnectWithoutPaidByInput
      | FeesPaymentCreateOrConnectWithoutPaidByInput[];
    createMany?: FeesPaymentCreateManyPaidByInputEnvelope;
    connect?: FeesPaymentWhereUniqueInput | FeesPaymentWhereUniqueInput[];
  };

  export type PupilCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<PupilCreateWithoutUserInput, PupilUncheckedCreateWithoutUserInput>
      | PupilCreateWithoutUserInput[]
      | PupilUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | PupilCreateOrConnectWithoutUserInput
      | PupilCreateOrConnectWithoutUserInput[];
    createMany?: PupilCreateManyUserInputEnvelope;
    connect?: PupilWhereUniqueInput | PupilWhereUniqueInput[];
  };

  export type SessionCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          SessionCreateWithoutUserInput,
          SessionUncheckedCreateWithoutUserInput
        >
      | SessionCreateWithoutUserInput[]
      | SessionUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | SessionCreateOrConnectWithoutUserInput
      | SessionCreateOrConnectWithoutUserInput[];
    createMany?: SessionCreateManyUserInputEnvelope;
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[];
  };

  export type StaffCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<StaffCreateWithoutUserInput, StaffUncheckedCreateWithoutUserInput>
      | StaffCreateWithoutUserInput[]
      | StaffUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | StaffCreateOrConnectWithoutUserInput
      | StaffCreateOrConnectWithoutUserInput[];
    createMany?: StaffCreateManyUserInputEnvelope;
    connect?: StaffWhereUniqueInput | StaffWhereUniqueInput[];
  };

  export type AssetDamageUncheckedCreateNestedManyWithoutDamagedByInput = {
    create?:
      | XOR<
          AssetDamageCreateWithoutDamagedByInput,
          AssetDamageUncheckedCreateWithoutDamagedByInput
        >
      | AssetDamageCreateWithoutDamagedByInput[]
      | AssetDamageUncheckedCreateWithoutDamagedByInput[];
    connectOrCreate?:
      | AssetDamageCreateOrConnectWithoutDamagedByInput
      | AssetDamageCreateOrConnectWithoutDamagedByInput[];
    createMany?: AssetDamageCreateManyDamagedByInputEnvelope;
    connect?: AssetDamageWhereUniqueInput | AssetDamageWhereUniqueInput[];
  };

  export type AssetRepairPaymentUncheckedCreateNestedManyWithoutReceivedByInput =
    {
      create?:
        | XOR<
            AssetRepairPaymentCreateWithoutReceivedByInput,
            AssetRepairPaymentUncheckedCreateWithoutReceivedByInput
          >
        | AssetRepairPaymentCreateWithoutReceivedByInput[]
        | AssetRepairPaymentUncheckedCreateWithoutReceivedByInput[];
      connectOrCreate?:
        | AssetRepairPaymentCreateOrConnectWithoutReceivedByInput
        | AssetRepairPaymentCreateOrConnectWithoutReceivedByInput[];
      createMany?: AssetRepairPaymentCreateManyReceivedByInputEnvelope;
      connect?:
        | AssetRepairPaymentWhereUniqueInput
        | AssetRepairPaymentWhereUniqueInput[];
    };

  export type BorrowerUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          BorrowerCreateWithoutUserInput,
          BorrowerUncheckedCreateWithoutUserInput
        >
      | BorrowerCreateWithoutUserInput[]
      | BorrowerUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | BorrowerCreateOrConnectWithoutUserInput
      | BorrowerCreateOrConnectWithoutUserInput[];
    createMany?: BorrowerCreateManyUserInputEnvelope;
    connect?: BorrowerWhereUniqueInput | BorrowerWhereUniqueInput[];
  };

  export type EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput =
    {
      create?:
        | XOR<
            EmailVerificationTokenCreateWithoutUserInput,
            EmailVerificationTokenUncheckedCreateWithoutUserInput
          >
        | EmailVerificationTokenCreateWithoutUserInput[]
        | EmailVerificationTokenUncheckedCreateWithoutUserInput[];
      connectOrCreate?:
        | EmailVerificationTokenCreateOrConnectWithoutUserInput
        | EmailVerificationTokenCreateOrConnectWithoutUserInput[];
      createMany?: EmailVerificationTokenCreateManyUserInputEnvelope;
      connect?:
        | EmailVerificationTokenWhereUniqueInput
        | EmailVerificationTokenWhereUniqueInput[];
    };

  export type FeesPaymentUncheckedCreateNestedManyWithoutPaidByInput = {
    create?:
      | XOR<
          FeesPaymentCreateWithoutPaidByInput,
          FeesPaymentUncheckedCreateWithoutPaidByInput
        >
      | FeesPaymentCreateWithoutPaidByInput[]
      | FeesPaymentUncheckedCreateWithoutPaidByInput[];
    connectOrCreate?:
      | FeesPaymentCreateOrConnectWithoutPaidByInput
      | FeesPaymentCreateOrConnectWithoutPaidByInput[];
    createMany?: FeesPaymentCreateManyPaidByInputEnvelope;
    connect?: FeesPaymentWhereUniqueInput | FeesPaymentWhereUniqueInput[];
  };

  export type PupilUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<PupilCreateWithoutUserInput, PupilUncheckedCreateWithoutUserInput>
      | PupilCreateWithoutUserInput[]
      | PupilUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | PupilCreateOrConnectWithoutUserInput
      | PupilCreateOrConnectWithoutUserInput[];
    createMany?: PupilCreateManyUserInputEnvelope;
    connect?: PupilWhereUniqueInput | PupilWhereUniqueInput[];
  };

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          SessionCreateWithoutUserInput,
          SessionUncheckedCreateWithoutUserInput
        >
      | SessionCreateWithoutUserInput[]
      | SessionUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | SessionCreateOrConnectWithoutUserInput
      | SessionCreateOrConnectWithoutUserInput[];
    createMany?: SessionCreateManyUserInputEnvelope;
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[];
  };

  export type StaffUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<StaffCreateWithoutUserInput, StaffUncheckedCreateWithoutUserInput>
      | StaffCreateWithoutUserInput[]
      | StaffUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | StaffCreateOrConnectWithoutUserInput
      | StaffCreateOrConnectWithoutUserInput[];
    createMany?: StaffCreateManyUserInputEnvelope;
    connect?: StaffWhereUniqueInput | StaffWhereUniqueInput[];
  };

  export type StringFieldUpdateOperationsInput = {
    set?: string;
  };

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null;
  };

  export type NullableEnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role | null;
  };

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string;
  };

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean;
  };

  export type AssetDamageUpdateManyWithoutDamagedByNestedInput = {
    create?:
      | XOR<
          AssetDamageCreateWithoutDamagedByInput,
          AssetDamageUncheckedCreateWithoutDamagedByInput
        >
      | AssetDamageCreateWithoutDamagedByInput[]
      | AssetDamageUncheckedCreateWithoutDamagedByInput[];
    connectOrCreate?:
      | AssetDamageCreateOrConnectWithoutDamagedByInput
      | AssetDamageCreateOrConnectWithoutDamagedByInput[];
    upsert?:
      | AssetDamageUpsertWithWhereUniqueWithoutDamagedByInput
      | AssetDamageUpsertWithWhereUniqueWithoutDamagedByInput[];
    createMany?: AssetDamageCreateManyDamagedByInputEnvelope;
    set?: AssetDamageWhereUniqueInput | AssetDamageWhereUniqueInput[];
    disconnect?: AssetDamageWhereUniqueInput | AssetDamageWhereUniqueInput[];
    delete?: AssetDamageWhereUniqueInput | AssetDamageWhereUniqueInput[];
    connect?: AssetDamageWhereUniqueInput | AssetDamageWhereUniqueInput[];
    update?:
      | AssetDamageUpdateWithWhereUniqueWithoutDamagedByInput
      | AssetDamageUpdateWithWhereUniqueWithoutDamagedByInput[];
    updateMany?:
      | AssetDamageUpdateManyWithWhereWithoutDamagedByInput
      | AssetDamageUpdateManyWithWhereWithoutDamagedByInput[];
    deleteMany?: AssetDamageScalarWhereInput | AssetDamageScalarWhereInput[];
  };

  export type AssetRepairPaymentUpdateManyWithoutReceivedByNestedInput = {
    create?:
      | XOR<
          AssetRepairPaymentCreateWithoutReceivedByInput,
          AssetRepairPaymentUncheckedCreateWithoutReceivedByInput
        >
      | AssetRepairPaymentCreateWithoutReceivedByInput[]
      | AssetRepairPaymentUncheckedCreateWithoutReceivedByInput[];
    connectOrCreate?:
      | AssetRepairPaymentCreateOrConnectWithoutReceivedByInput
      | AssetRepairPaymentCreateOrConnectWithoutReceivedByInput[];
    upsert?:
      | AssetRepairPaymentUpsertWithWhereUniqueWithoutReceivedByInput
      | AssetRepairPaymentUpsertWithWhereUniqueWithoutReceivedByInput[];
    createMany?: AssetRepairPaymentCreateManyReceivedByInputEnvelope;
    set?:
      | AssetRepairPaymentWhereUniqueInput
      | AssetRepairPaymentWhereUniqueInput[];
    disconnect?:
      | AssetRepairPaymentWhereUniqueInput
      | AssetRepairPaymentWhereUniqueInput[];
    delete?:
      | AssetRepairPaymentWhereUniqueInput
      | AssetRepairPaymentWhereUniqueInput[];
    connect?:
      | AssetRepairPaymentWhereUniqueInput
      | AssetRepairPaymentWhereUniqueInput[];
    update?:
      | AssetRepairPaymentUpdateWithWhereUniqueWithoutReceivedByInput
      | AssetRepairPaymentUpdateWithWhereUniqueWithoutReceivedByInput[];
    updateMany?:
      | AssetRepairPaymentUpdateManyWithWhereWithoutReceivedByInput
      | AssetRepairPaymentUpdateManyWithWhereWithoutReceivedByInput[];
    deleteMany?:
      | AssetRepairPaymentScalarWhereInput
      | AssetRepairPaymentScalarWhereInput[];
  };

  export type BorrowerUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          BorrowerCreateWithoutUserInput,
          BorrowerUncheckedCreateWithoutUserInput
        >
      | BorrowerCreateWithoutUserInput[]
      | BorrowerUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | BorrowerCreateOrConnectWithoutUserInput
      | BorrowerCreateOrConnectWithoutUserInput[];
    upsert?:
      | BorrowerUpsertWithWhereUniqueWithoutUserInput
      | BorrowerUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: BorrowerCreateManyUserInputEnvelope;
    set?: BorrowerWhereUniqueInput | BorrowerWhereUniqueInput[];
    disconnect?: BorrowerWhereUniqueInput | BorrowerWhereUniqueInput[];
    delete?: BorrowerWhereUniqueInput | BorrowerWhereUniqueInput[];
    connect?: BorrowerWhereUniqueInput | BorrowerWhereUniqueInput[];
    update?:
      | BorrowerUpdateWithWhereUniqueWithoutUserInput
      | BorrowerUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | BorrowerUpdateManyWithWhereWithoutUserInput
      | BorrowerUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: BorrowerScalarWhereInput | BorrowerScalarWhereInput[];
  };

  export type EmailVerificationTokenUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          EmailVerificationTokenCreateWithoutUserInput,
          EmailVerificationTokenUncheckedCreateWithoutUserInput
        >
      | EmailVerificationTokenCreateWithoutUserInput[]
      | EmailVerificationTokenUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | EmailVerificationTokenCreateOrConnectWithoutUserInput
      | EmailVerificationTokenCreateOrConnectWithoutUserInput[];
    upsert?:
      | EmailVerificationTokenUpsertWithWhereUniqueWithoutUserInput
      | EmailVerificationTokenUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: EmailVerificationTokenCreateManyUserInputEnvelope;
    set?:
      | EmailVerificationTokenWhereUniqueInput
      | EmailVerificationTokenWhereUniqueInput[];
    disconnect?:
      | EmailVerificationTokenWhereUniqueInput
      | EmailVerificationTokenWhereUniqueInput[];
    delete?:
      | EmailVerificationTokenWhereUniqueInput
      | EmailVerificationTokenWhereUniqueInput[];
    connect?:
      | EmailVerificationTokenWhereUniqueInput
      | EmailVerificationTokenWhereUniqueInput[];
    update?:
      | EmailVerificationTokenUpdateWithWhereUniqueWithoutUserInput
      | EmailVerificationTokenUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | EmailVerificationTokenUpdateManyWithWhereWithoutUserInput
      | EmailVerificationTokenUpdateManyWithWhereWithoutUserInput[];
    deleteMany?:
      | EmailVerificationTokenScalarWhereInput
      | EmailVerificationTokenScalarWhereInput[];
  };

  export type FeesPaymentUpdateManyWithoutPaidByNestedInput = {
    create?:
      | XOR<
          FeesPaymentCreateWithoutPaidByInput,
          FeesPaymentUncheckedCreateWithoutPaidByInput
        >
      | FeesPaymentCreateWithoutPaidByInput[]
      | FeesPaymentUncheckedCreateWithoutPaidByInput[];
    connectOrCreate?:
      | FeesPaymentCreateOrConnectWithoutPaidByInput
      | FeesPaymentCreateOrConnectWithoutPaidByInput[];
    upsert?:
      | FeesPaymentUpsertWithWhereUniqueWithoutPaidByInput
      | FeesPaymentUpsertWithWhereUniqueWithoutPaidByInput[];
    createMany?: FeesPaymentCreateManyPaidByInputEnvelope;
    set?: FeesPaymentWhereUniqueInput | FeesPaymentWhereUniqueInput[];
    disconnect?: FeesPaymentWhereUniqueInput | FeesPaymentWhereUniqueInput[];
    delete?: FeesPaymentWhereUniqueInput | FeesPaymentWhereUniqueInput[];
    connect?: FeesPaymentWhereUniqueInput | FeesPaymentWhereUniqueInput[];
    update?:
      | FeesPaymentUpdateWithWhereUniqueWithoutPaidByInput
      | FeesPaymentUpdateWithWhereUniqueWithoutPaidByInput[];
    updateMany?:
      | FeesPaymentUpdateManyWithWhereWithoutPaidByInput
      | FeesPaymentUpdateManyWithWhereWithoutPaidByInput[];
    deleteMany?: FeesPaymentScalarWhereInput | FeesPaymentScalarWhereInput[];
  };

  export type PupilUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<PupilCreateWithoutUserInput, PupilUncheckedCreateWithoutUserInput>
      | PupilCreateWithoutUserInput[]
      | PupilUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | PupilCreateOrConnectWithoutUserInput
      | PupilCreateOrConnectWithoutUserInput[];
    upsert?:
      | PupilUpsertWithWhereUniqueWithoutUserInput
      | PupilUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: PupilCreateManyUserInputEnvelope;
    set?: PupilWhereUniqueInput | PupilWhereUniqueInput[];
    disconnect?: PupilWhereUniqueInput | PupilWhereUniqueInput[];
    delete?: PupilWhereUniqueInput | PupilWhereUniqueInput[];
    connect?: PupilWhereUniqueInput | PupilWhereUniqueInput[];
    update?:
      | PupilUpdateWithWhereUniqueWithoutUserInput
      | PupilUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | PupilUpdateManyWithWhereWithoutUserInput
      | PupilUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: PupilScalarWhereInput | PupilScalarWhereInput[];
  };

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          SessionCreateWithoutUserInput,
          SessionUncheckedCreateWithoutUserInput
        >
      | SessionCreateWithoutUserInput[]
      | SessionUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | SessionCreateOrConnectWithoutUserInput
      | SessionCreateOrConnectWithoutUserInput[];
    upsert?:
      | SessionUpsertWithWhereUniqueWithoutUserInput
      | SessionUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: SessionCreateManyUserInputEnvelope;
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[];
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[];
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[];
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[];
    update?:
      | SessionUpdateWithWhereUniqueWithoutUserInput
      | SessionUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | SessionUpdateManyWithWhereWithoutUserInput
      | SessionUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[];
  };

  export type StaffUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<StaffCreateWithoutUserInput, StaffUncheckedCreateWithoutUserInput>
      | StaffCreateWithoutUserInput[]
      | StaffUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | StaffCreateOrConnectWithoutUserInput
      | StaffCreateOrConnectWithoutUserInput[];
    upsert?:
      | StaffUpsertWithWhereUniqueWithoutUserInput
      | StaffUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: StaffCreateManyUserInputEnvelope;
    set?: StaffWhereUniqueInput | StaffWhereUniqueInput[];
    disconnect?: StaffWhereUniqueInput | StaffWhereUniqueInput[];
    delete?: StaffWhereUniqueInput | StaffWhereUniqueInput[];
    connect?: StaffWhereUniqueInput | StaffWhereUniqueInput[];
    update?:
      | StaffUpdateWithWhereUniqueWithoutUserInput
      | StaffUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | StaffUpdateManyWithWhereWithoutUserInput
      | StaffUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: StaffScalarWhereInput | StaffScalarWhereInput[];
  };

  export type AssetDamageUncheckedUpdateManyWithoutDamagedByNestedInput = {
    create?:
      | XOR<
          AssetDamageCreateWithoutDamagedByInput,
          AssetDamageUncheckedCreateWithoutDamagedByInput
        >
      | AssetDamageCreateWithoutDamagedByInput[]
      | AssetDamageUncheckedCreateWithoutDamagedByInput[];
    connectOrCreate?:
      | AssetDamageCreateOrConnectWithoutDamagedByInput
      | AssetDamageCreateOrConnectWithoutDamagedByInput[];
    upsert?:
      | AssetDamageUpsertWithWhereUniqueWithoutDamagedByInput
      | AssetDamageUpsertWithWhereUniqueWithoutDamagedByInput[];
    createMany?: AssetDamageCreateManyDamagedByInputEnvelope;
    set?: AssetDamageWhereUniqueInput | AssetDamageWhereUniqueInput[];
    disconnect?: AssetDamageWhereUniqueInput | AssetDamageWhereUniqueInput[];
    delete?: AssetDamageWhereUniqueInput | AssetDamageWhereUniqueInput[];
    connect?: AssetDamageWhereUniqueInput | AssetDamageWhereUniqueInput[];
    update?:
      | AssetDamageUpdateWithWhereUniqueWithoutDamagedByInput
      | AssetDamageUpdateWithWhereUniqueWithoutDamagedByInput[];
    updateMany?:
      | AssetDamageUpdateManyWithWhereWithoutDamagedByInput
      | AssetDamageUpdateManyWithWhereWithoutDamagedByInput[];
    deleteMany?: AssetDamageScalarWhereInput | AssetDamageScalarWhereInput[];
  };

  export type AssetRepairPaymentUncheckedUpdateManyWithoutReceivedByNestedInput =
    {
      create?:
        | XOR<
            AssetRepairPaymentCreateWithoutReceivedByInput,
            AssetRepairPaymentUncheckedCreateWithoutReceivedByInput
          >
        | AssetRepairPaymentCreateWithoutReceivedByInput[]
        | AssetRepairPaymentUncheckedCreateWithoutReceivedByInput[];
      connectOrCreate?:
        | AssetRepairPaymentCreateOrConnectWithoutReceivedByInput
        | AssetRepairPaymentCreateOrConnectWithoutReceivedByInput[];
      upsert?:
        | AssetRepairPaymentUpsertWithWhereUniqueWithoutReceivedByInput
        | AssetRepairPaymentUpsertWithWhereUniqueWithoutReceivedByInput[];
      createMany?: AssetRepairPaymentCreateManyReceivedByInputEnvelope;
      set?:
        | AssetRepairPaymentWhereUniqueInput
        | AssetRepairPaymentWhereUniqueInput[];
      disconnect?:
        | AssetRepairPaymentWhereUniqueInput
        | AssetRepairPaymentWhereUniqueInput[];
      delete?:
        | AssetRepairPaymentWhereUniqueInput
        | AssetRepairPaymentWhereUniqueInput[];
      connect?:
        | AssetRepairPaymentWhereUniqueInput
        | AssetRepairPaymentWhereUniqueInput[];
      update?:
        | AssetRepairPaymentUpdateWithWhereUniqueWithoutReceivedByInput
        | AssetRepairPaymentUpdateWithWhereUniqueWithoutReceivedByInput[];
      updateMany?:
        | AssetRepairPaymentUpdateManyWithWhereWithoutReceivedByInput
        | AssetRepairPaymentUpdateManyWithWhereWithoutReceivedByInput[];
      deleteMany?:
        | AssetRepairPaymentScalarWhereInput
        | AssetRepairPaymentScalarWhereInput[];
    };

  export type BorrowerUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          BorrowerCreateWithoutUserInput,
          BorrowerUncheckedCreateWithoutUserInput
        >
      | BorrowerCreateWithoutUserInput[]
      | BorrowerUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | BorrowerCreateOrConnectWithoutUserInput
      | BorrowerCreateOrConnectWithoutUserInput[];
    upsert?:
      | BorrowerUpsertWithWhereUniqueWithoutUserInput
      | BorrowerUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: BorrowerCreateManyUserInputEnvelope;
    set?: BorrowerWhereUniqueInput | BorrowerWhereUniqueInput[];
    disconnect?: BorrowerWhereUniqueInput | BorrowerWhereUniqueInput[];
    delete?: BorrowerWhereUniqueInput | BorrowerWhereUniqueInput[];
    connect?: BorrowerWhereUniqueInput | BorrowerWhereUniqueInput[];
    update?:
      | BorrowerUpdateWithWhereUniqueWithoutUserInput
      | BorrowerUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | BorrowerUpdateManyWithWhereWithoutUserInput
      | BorrowerUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: BorrowerScalarWhereInput | BorrowerScalarWhereInput[];
  };

  export type EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput =
    {
      create?:
        | XOR<
            EmailVerificationTokenCreateWithoutUserInput,
            EmailVerificationTokenUncheckedCreateWithoutUserInput
          >
        | EmailVerificationTokenCreateWithoutUserInput[]
        | EmailVerificationTokenUncheckedCreateWithoutUserInput[];
      connectOrCreate?:
        | EmailVerificationTokenCreateOrConnectWithoutUserInput
        | EmailVerificationTokenCreateOrConnectWithoutUserInput[];
      upsert?:
        | EmailVerificationTokenUpsertWithWhereUniqueWithoutUserInput
        | EmailVerificationTokenUpsertWithWhereUniqueWithoutUserInput[];
      createMany?: EmailVerificationTokenCreateManyUserInputEnvelope;
      set?:
        | EmailVerificationTokenWhereUniqueInput
        | EmailVerificationTokenWhereUniqueInput[];
      disconnect?:
        | EmailVerificationTokenWhereUniqueInput
        | EmailVerificationTokenWhereUniqueInput[];
      delete?:
        | EmailVerificationTokenWhereUniqueInput
        | EmailVerificationTokenWhereUniqueInput[];
      connect?:
        | EmailVerificationTokenWhereUniqueInput
        | EmailVerificationTokenWhereUniqueInput[];
      update?:
        | EmailVerificationTokenUpdateWithWhereUniqueWithoutUserInput
        | EmailVerificationTokenUpdateWithWhereUniqueWithoutUserInput[];
      updateMany?:
        | EmailVerificationTokenUpdateManyWithWhereWithoutUserInput
        | EmailVerificationTokenUpdateManyWithWhereWithoutUserInput[];
      deleteMany?:
        | EmailVerificationTokenScalarWhereInput
        | EmailVerificationTokenScalarWhereInput[];
    };

  export type FeesPaymentUncheckedUpdateManyWithoutPaidByNestedInput = {
    create?:
      | XOR<
          FeesPaymentCreateWithoutPaidByInput,
          FeesPaymentUncheckedCreateWithoutPaidByInput
        >
      | FeesPaymentCreateWithoutPaidByInput[]
      | FeesPaymentUncheckedCreateWithoutPaidByInput[];
    connectOrCreate?:
      | FeesPaymentCreateOrConnectWithoutPaidByInput
      | FeesPaymentCreateOrConnectWithoutPaidByInput[];
    upsert?:
      | FeesPaymentUpsertWithWhereUniqueWithoutPaidByInput
      | FeesPaymentUpsertWithWhereUniqueWithoutPaidByInput[];
    createMany?: FeesPaymentCreateManyPaidByInputEnvelope;
    set?: FeesPaymentWhereUniqueInput | FeesPaymentWhereUniqueInput[];
    disconnect?: FeesPaymentWhereUniqueInput | FeesPaymentWhereUniqueInput[];
    delete?: FeesPaymentWhereUniqueInput | FeesPaymentWhereUniqueInput[];
    connect?: FeesPaymentWhereUniqueInput | FeesPaymentWhereUniqueInput[];
    update?:
      | FeesPaymentUpdateWithWhereUniqueWithoutPaidByInput
      | FeesPaymentUpdateWithWhereUniqueWithoutPaidByInput[];
    updateMany?:
      | FeesPaymentUpdateManyWithWhereWithoutPaidByInput
      | FeesPaymentUpdateManyWithWhereWithoutPaidByInput[];
    deleteMany?: FeesPaymentScalarWhereInput | FeesPaymentScalarWhereInput[];
  };

  export type PupilUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<PupilCreateWithoutUserInput, PupilUncheckedCreateWithoutUserInput>
      | PupilCreateWithoutUserInput[]
      | PupilUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | PupilCreateOrConnectWithoutUserInput
      | PupilCreateOrConnectWithoutUserInput[];
    upsert?:
      | PupilUpsertWithWhereUniqueWithoutUserInput
      | PupilUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: PupilCreateManyUserInputEnvelope;
    set?: PupilWhereUniqueInput | PupilWhereUniqueInput[];
    disconnect?: PupilWhereUniqueInput | PupilWhereUniqueInput[];
    delete?: PupilWhereUniqueInput | PupilWhereUniqueInput[];
    connect?: PupilWhereUniqueInput | PupilWhereUniqueInput[];
    update?:
      | PupilUpdateWithWhereUniqueWithoutUserInput
      | PupilUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | PupilUpdateManyWithWhereWithoutUserInput
      | PupilUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: PupilScalarWhereInput | PupilScalarWhereInput[];
  };

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          SessionCreateWithoutUserInput,
          SessionUncheckedCreateWithoutUserInput
        >
      | SessionCreateWithoutUserInput[]
      | SessionUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | SessionCreateOrConnectWithoutUserInput
      | SessionCreateOrConnectWithoutUserInput[];
    upsert?:
      | SessionUpsertWithWhereUniqueWithoutUserInput
      | SessionUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: SessionCreateManyUserInputEnvelope;
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[];
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[];
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[];
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[];
    update?:
      | SessionUpdateWithWhereUniqueWithoutUserInput
      | SessionUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | SessionUpdateManyWithWhereWithoutUserInput
      | SessionUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[];
  };

  export type StaffUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<StaffCreateWithoutUserInput, StaffUncheckedCreateWithoutUserInput>
      | StaffCreateWithoutUserInput[]
      | StaffUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | StaffCreateOrConnectWithoutUserInput
      | StaffCreateOrConnectWithoutUserInput[];
    upsert?:
      | StaffUpsertWithWhereUniqueWithoutUserInput
      | StaffUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: StaffCreateManyUserInputEnvelope;
    set?: StaffWhereUniqueInput | StaffWhereUniqueInput[];
    disconnect?: StaffWhereUniqueInput | StaffWhereUniqueInput[];
    delete?: StaffWhereUniqueInput | StaffWhereUniqueInput[];
    connect?: StaffWhereUniqueInput | StaffWhereUniqueInput[];
    update?:
      | StaffUpdateWithWhereUniqueWithoutUserInput
      | StaffUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | StaffUpdateManyWithWhereWithoutUserInput
      | StaffUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: StaffScalarWhereInput | StaffScalarWhereInput[];
  };

  export type UserCreateNestedOneWithoutEmailVerificationTokensInput = {
    create?: XOR<
      UserCreateWithoutEmailVerificationTokensInput,
      UserUncheckedCreateWithoutEmailVerificationTokensInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutEmailVerificationTokensInput;
    connect?: UserWhereUniqueInput;
  };

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number;
    increment?: bigint | number;
    decrement?: bigint | number;
    multiply?: bigint | number;
    divide?: bigint | number;
  };

  export type UserUpdateOneRequiredWithoutEmailVerificationTokensNestedInput = {
    create?: XOR<
      UserCreateWithoutEmailVerificationTokensInput,
      UserUncheckedCreateWithoutEmailVerificationTokensInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutEmailVerificationTokensInput;
    upsert?: UserUpsertWithoutEmailVerificationTokensInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutEmailVerificationTokensInput,
        UserUpdateWithoutEmailVerificationTokensInput
      >,
      UserUncheckedUpdateWithoutEmailVerificationTokensInput
    >;
  };

  export type classStreamCreateNestedManyWithoutPupilsInput = {
    create?:
      | XOR<
          classStreamCreateWithoutPupilsInput,
          classStreamUncheckedCreateWithoutPupilsInput
        >
      | classStreamCreateWithoutPupilsInput[]
      | classStreamUncheckedCreateWithoutPupilsInput[];
    connectOrCreate?:
      | classStreamCreateOrConnectWithoutPupilsInput
      | classStreamCreateOrConnectWithoutPupilsInput[];
    connect?: classStreamWhereUniqueInput | classStreamWhereUniqueInput[];
  };

  export type ExamScoreCreateNestedManyWithoutPupilInput = {
    create?:
      | XOR<
          ExamScoreCreateWithoutPupilInput,
          ExamScoreUncheckedCreateWithoutPupilInput
        >
      | ExamScoreCreateWithoutPupilInput[]
      | ExamScoreUncheckedCreateWithoutPupilInput[];
    connectOrCreate?:
      | ExamScoreCreateOrConnectWithoutPupilInput
      | ExamScoreCreateOrConnectWithoutPupilInput[];
    createMany?: ExamScoreCreateManyPupilInputEnvelope;
    connect?: ExamScoreWhereUniqueInput | ExamScoreWhereUniqueInput[];
  };

  export type FeesCreateNestedManyWithoutPupilInput = {
    create?:
      | XOR<FeesCreateWithoutPupilInput, FeesUncheckedCreateWithoutPupilInput>
      | FeesCreateWithoutPupilInput[]
      | FeesUncheckedCreateWithoutPupilInput[];
    connectOrCreate?:
      | FeesCreateOrConnectWithoutPupilInput
      | FeesCreateOrConnectWithoutPupilInput[];
    createMany?: FeesCreateManyPupilInputEnvelope;
    connect?: FeesWhereUniqueInput | FeesWhereUniqueInput[];
  };

  export type UserCreateNestedOneWithoutPupilsInput = {
    create?: XOR<
      UserCreateWithoutPupilsInput,
      UserUncheckedCreateWithoutPupilsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutPupilsInput;
    connect?: UserWhereUniqueInput;
  };

  export type classStreamUncheckedCreateNestedManyWithoutPupilsInput = {
    create?:
      | XOR<
          classStreamCreateWithoutPupilsInput,
          classStreamUncheckedCreateWithoutPupilsInput
        >
      | classStreamCreateWithoutPupilsInput[]
      | classStreamUncheckedCreateWithoutPupilsInput[];
    connectOrCreate?:
      | classStreamCreateOrConnectWithoutPupilsInput
      | classStreamCreateOrConnectWithoutPupilsInput[];
    connect?: classStreamWhereUniqueInput | classStreamWhereUniqueInput[];
  };

  export type ExamScoreUncheckedCreateNestedManyWithoutPupilInput = {
    create?:
      | XOR<
          ExamScoreCreateWithoutPupilInput,
          ExamScoreUncheckedCreateWithoutPupilInput
        >
      | ExamScoreCreateWithoutPupilInput[]
      | ExamScoreUncheckedCreateWithoutPupilInput[];
    connectOrCreate?:
      | ExamScoreCreateOrConnectWithoutPupilInput
      | ExamScoreCreateOrConnectWithoutPupilInput[];
    createMany?: ExamScoreCreateManyPupilInputEnvelope;
    connect?: ExamScoreWhereUniqueInput | ExamScoreWhereUniqueInput[];
  };

  export type FeesUncheckedCreateNestedManyWithoutPupilInput = {
    create?:
      | XOR<FeesCreateWithoutPupilInput, FeesUncheckedCreateWithoutPupilInput>
      | FeesCreateWithoutPupilInput[]
      | FeesUncheckedCreateWithoutPupilInput[];
    connectOrCreate?:
      | FeesCreateOrConnectWithoutPupilInput
      | FeesCreateOrConnectWithoutPupilInput[];
    createMany?: FeesCreateManyPupilInputEnvelope;
    connect?: FeesWhereUniqueInput | FeesWhereUniqueInput[];
  };

  export type classStreamUpdateManyWithoutPupilsNestedInput = {
    create?:
      | XOR<
          classStreamCreateWithoutPupilsInput,
          classStreamUncheckedCreateWithoutPupilsInput
        >
      | classStreamCreateWithoutPupilsInput[]
      | classStreamUncheckedCreateWithoutPupilsInput[];
    connectOrCreate?:
      | classStreamCreateOrConnectWithoutPupilsInput
      | classStreamCreateOrConnectWithoutPupilsInput[];
    upsert?:
      | classStreamUpsertWithWhereUniqueWithoutPupilsInput
      | classStreamUpsertWithWhereUniqueWithoutPupilsInput[];
    set?: classStreamWhereUniqueInput | classStreamWhereUniqueInput[];
    disconnect?: classStreamWhereUniqueInput | classStreamWhereUniqueInput[];
    delete?: classStreamWhereUniqueInput | classStreamWhereUniqueInput[];
    connect?: classStreamWhereUniqueInput | classStreamWhereUniqueInput[];
    update?:
      | classStreamUpdateWithWhereUniqueWithoutPupilsInput
      | classStreamUpdateWithWhereUniqueWithoutPupilsInput[];
    updateMany?:
      | classStreamUpdateManyWithWhereWithoutPupilsInput
      | classStreamUpdateManyWithWhereWithoutPupilsInput[];
    deleteMany?: classStreamScalarWhereInput | classStreamScalarWhereInput[];
  };

  export type ExamScoreUpdateManyWithoutPupilNestedInput = {
    create?:
      | XOR<
          ExamScoreCreateWithoutPupilInput,
          ExamScoreUncheckedCreateWithoutPupilInput
        >
      | ExamScoreCreateWithoutPupilInput[]
      | ExamScoreUncheckedCreateWithoutPupilInput[];
    connectOrCreate?:
      | ExamScoreCreateOrConnectWithoutPupilInput
      | ExamScoreCreateOrConnectWithoutPupilInput[];
    upsert?:
      | ExamScoreUpsertWithWhereUniqueWithoutPupilInput
      | ExamScoreUpsertWithWhereUniqueWithoutPupilInput[];
    createMany?: ExamScoreCreateManyPupilInputEnvelope;
    set?: ExamScoreWhereUniqueInput | ExamScoreWhereUniqueInput[];
    disconnect?: ExamScoreWhereUniqueInput | ExamScoreWhereUniqueInput[];
    delete?: ExamScoreWhereUniqueInput | ExamScoreWhereUniqueInput[];
    connect?: ExamScoreWhereUniqueInput | ExamScoreWhereUniqueInput[];
    update?:
      | ExamScoreUpdateWithWhereUniqueWithoutPupilInput
      | ExamScoreUpdateWithWhereUniqueWithoutPupilInput[];
    updateMany?:
      | ExamScoreUpdateManyWithWhereWithoutPupilInput
      | ExamScoreUpdateManyWithWhereWithoutPupilInput[];
    deleteMany?: ExamScoreScalarWhereInput | ExamScoreScalarWhereInput[];
  };

  export type FeesUpdateManyWithoutPupilNestedInput = {
    create?:
      | XOR<FeesCreateWithoutPupilInput, FeesUncheckedCreateWithoutPupilInput>
      | FeesCreateWithoutPupilInput[]
      | FeesUncheckedCreateWithoutPupilInput[];
    connectOrCreate?:
      | FeesCreateOrConnectWithoutPupilInput
      | FeesCreateOrConnectWithoutPupilInput[];
    upsert?:
      | FeesUpsertWithWhereUniqueWithoutPupilInput
      | FeesUpsertWithWhereUniqueWithoutPupilInput[];
    createMany?: FeesCreateManyPupilInputEnvelope;
    set?: FeesWhereUniqueInput | FeesWhereUniqueInput[];
    disconnect?: FeesWhereUniqueInput | FeesWhereUniqueInput[];
    delete?: FeesWhereUniqueInput | FeesWhereUniqueInput[];
    connect?: FeesWhereUniqueInput | FeesWhereUniqueInput[];
    update?:
      | FeesUpdateWithWhereUniqueWithoutPupilInput
      | FeesUpdateWithWhereUniqueWithoutPupilInput[];
    updateMany?:
      | FeesUpdateManyWithWhereWithoutPupilInput
      | FeesUpdateManyWithWhereWithoutPupilInput[];
    deleteMany?: FeesScalarWhereInput | FeesScalarWhereInput[];
  };

  export type UserUpdateOneWithoutPupilsNestedInput = {
    create?: XOR<
      UserCreateWithoutPupilsInput,
      UserUncheckedCreateWithoutPupilsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutPupilsInput;
    upsert?: UserUpsertWithoutPupilsInput;
    disconnect?: UserWhereInput | boolean;
    delete?: UserWhereInput | boolean;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutPupilsInput,
        UserUpdateWithoutPupilsInput
      >,
      UserUncheckedUpdateWithoutPupilsInput
    >;
  };

  export type classStreamUncheckedUpdateManyWithoutPupilsNestedInput = {
    create?:
      | XOR<
          classStreamCreateWithoutPupilsInput,
          classStreamUncheckedCreateWithoutPupilsInput
        >
      | classStreamCreateWithoutPupilsInput[]
      | classStreamUncheckedCreateWithoutPupilsInput[];
    connectOrCreate?:
      | classStreamCreateOrConnectWithoutPupilsInput
      | classStreamCreateOrConnectWithoutPupilsInput[];
    upsert?:
      | classStreamUpsertWithWhereUniqueWithoutPupilsInput
      | classStreamUpsertWithWhereUniqueWithoutPupilsInput[];
    set?: classStreamWhereUniqueInput | classStreamWhereUniqueInput[];
    disconnect?: classStreamWhereUniqueInput | classStreamWhereUniqueInput[];
    delete?: classStreamWhereUniqueInput | classStreamWhereUniqueInput[];
    connect?: classStreamWhereUniqueInput | classStreamWhereUniqueInput[];
    update?:
      | classStreamUpdateWithWhereUniqueWithoutPupilsInput
      | classStreamUpdateWithWhereUniqueWithoutPupilsInput[];
    updateMany?:
      | classStreamUpdateManyWithWhereWithoutPupilsInput
      | classStreamUpdateManyWithWhereWithoutPupilsInput[];
    deleteMany?: classStreamScalarWhereInput | classStreamScalarWhereInput[];
  };

  export type ExamScoreUncheckedUpdateManyWithoutPupilNestedInput = {
    create?:
      | XOR<
          ExamScoreCreateWithoutPupilInput,
          ExamScoreUncheckedCreateWithoutPupilInput
        >
      | ExamScoreCreateWithoutPupilInput[]
      | ExamScoreUncheckedCreateWithoutPupilInput[];
    connectOrCreate?:
      | ExamScoreCreateOrConnectWithoutPupilInput
      | ExamScoreCreateOrConnectWithoutPupilInput[];
    upsert?:
      | ExamScoreUpsertWithWhereUniqueWithoutPupilInput
      | ExamScoreUpsertWithWhereUniqueWithoutPupilInput[];
    createMany?: ExamScoreCreateManyPupilInputEnvelope;
    set?: ExamScoreWhereUniqueInput | ExamScoreWhereUniqueInput[];
    disconnect?: ExamScoreWhereUniqueInput | ExamScoreWhereUniqueInput[];
    delete?: ExamScoreWhereUniqueInput | ExamScoreWhereUniqueInput[];
    connect?: ExamScoreWhereUniqueInput | ExamScoreWhereUniqueInput[];
    update?:
      | ExamScoreUpdateWithWhereUniqueWithoutPupilInput
      | ExamScoreUpdateWithWhereUniqueWithoutPupilInput[];
    updateMany?:
      | ExamScoreUpdateManyWithWhereWithoutPupilInput
      | ExamScoreUpdateManyWithWhereWithoutPupilInput[];
    deleteMany?: ExamScoreScalarWhereInput | ExamScoreScalarWhereInput[];
  };

  export type FeesUncheckedUpdateManyWithoutPupilNestedInput = {
    create?:
      | XOR<FeesCreateWithoutPupilInput, FeesUncheckedCreateWithoutPupilInput>
      | FeesCreateWithoutPupilInput[]
      | FeesUncheckedCreateWithoutPupilInput[];
    connectOrCreate?:
      | FeesCreateOrConnectWithoutPupilInput
      | FeesCreateOrConnectWithoutPupilInput[];
    upsert?:
      | FeesUpsertWithWhereUniqueWithoutPupilInput
      | FeesUpsertWithWhereUniqueWithoutPupilInput[];
    createMany?: FeesCreateManyPupilInputEnvelope;
    set?: FeesWhereUniqueInput | FeesWhereUniqueInput[];
    disconnect?: FeesWhereUniqueInput | FeesWhereUniqueInput[];
    delete?: FeesWhereUniqueInput | FeesWhereUniqueInput[];
    connect?: FeesWhereUniqueInput | FeesWhereUniqueInput[];
    update?:
      | FeesUpdateWithWhereUniqueWithoutPupilInput
      | FeesUpdateWithWhereUniqueWithoutPupilInput[];
    updateMany?:
      | FeesUpdateManyWithWhereWithoutPupilInput
      | FeesUpdateManyWithWhereWithoutPupilInput[];
    deleteMany?: FeesScalarWhereInput | FeesScalarWhereInput[];
  };

  export type AcademicYearSubjectCreateNestedManyWithoutTeachersInput = {
    create?:
      | XOR<
          AcademicYearSubjectCreateWithoutTeachersInput,
          AcademicYearSubjectUncheckedCreateWithoutTeachersInput
        >
      | AcademicYearSubjectCreateWithoutTeachersInput[]
      | AcademicYearSubjectUncheckedCreateWithoutTeachersInput[];
    connectOrCreate?:
      | AcademicYearSubjectCreateOrConnectWithoutTeachersInput
      | AcademicYearSubjectCreateOrConnectWithoutTeachersInput[];
    connect?:
      | AcademicYearSubjectWhereUniqueInput
      | AcademicYearSubjectWhereUniqueInput[];
  };

  export type classStreamCreateNestedManyWithoutClassTeacherInput = {
    create?:
      | XOR<
          classStreamCreateWithoutClassTeacherInput,
          classStreamUncheckedCreateWithoutClassTeacherInput
        >
      | classStreamCreateWithoutClassTeacherInput[]
      | classStreamUncheckedCreateWithoutClassTeacherInput[];
    connectOrCreate?:
      | classStreamCreateOrConnectWithoutClassTeacherInput
      | classStreamCreateOrConnectWithoutClassTeacherInput[];
    createMany?: classStreamCreateManyClassTeacherInputEnvelope;
    connect?: classStreamWhereUniqueInput | classStreamWhereUniqueInput[];
  };

  export type UserCreateNestedOneWithoutStaffsInput = {
    create?: XOR<
      UserCreateWithoutStaffsInput,
      UserUncheckedCreateWithoutStaffsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutStaffsInput;
    connect?: UserWhereUniqueInput;
  };

  export type AcademicYearSubjectUncheckedCreateNestedManyWithoutTeachersInput =
    {
      create?:
        | XOR<
            AcademicYearSubjectCreateWithoutTeachersInput,
            AcademicYearSubjectUncheckedCreateWithoutTeachersInput
          >
        | AcademicYearSubjectCreateWithoutTeachersInput[]
        | AcademicYearSubjectUncheckedCreateWithoutTeachersInput[];
      connectOrCreate?:
        | AcademicYearSubjectCreateOrConnectWithoutTeachersInput
        | AcademicYearSubjectCreateOrConnectWithoutTeachersInput[];
      connect?:
        | AcademicYearSubjectWhereUniqueInput
        | AcademicYearSubjectWhereUniqueInput[];
    };

  export type classStreamUncheckedCreateNestedManyWithoutClassTeacherInput = {
    create?:
      | XOR<
          classStreamCreateWithoutClassTeacherInput,
          classStreamUncheckedCreateWithoutClassTeacherInput
        >
      | classStreamCreateWithoutClassTeacherInput[]
      | classStreamUncheckedCreateWithoutClassTeacherInput[];
    connectOrCreate?:
      | classStreamCreateOrConnectWithoutClassTeacherInput
      | classStreamCreateOrConnectWithoutClassTeacherInput[];
    createMany?: classStreamCreateManyClassTeacherInputEnvelope;
    connect?: classStreamWhereUniqueInput | classStreamWhereUniqueInput[];
  };

  export type EnumStaffTypeFieldUpdateOperationsInput = {
    set?: $Enums.StaffType;
  };

  export type AcademicYearSubjectUpdateManyWithoutTeachersNestedInput = {
    create?:
      | XOR<
          AcademicYearSubjectCreateWithoutTeachersInput,
          AcademicYearSubjectUncheckedCreateWithoutTeachersInput
        >
      | AcademicYearSubjectCreateWithoutTeachersInput[]
      | AcademicYearSubjectUncheckedCreateWithoutTeachersInput[];
    connectOrCreate?:
      | AcademicYearSubjectCreateOrConnectWithoutTeachersInput
      | AcademicYearSubjectCreateOrConnectWithoutTeachersInput[];
    upsert?:
      | AcademicYearSubjectUpsertWithWhereUniqueWithoutTeachersInput
      | AcademicYearSubjectUpsertWithWhereUniqueWithoutTeachersInput[];
    set?:
      | AcademicYearSubjectWhereUniqueInput
      | AcademicYearSubjectWhereUniqueInput[];
    disconnect?:
      | AcademicYearSubjectWhereUniqueInput
      | AcademicYearSubjectWhereUniqueInput[];
    delete?:
      | AcademicYearSubjectWhereUniqueInput
      | AcademicYearSubjectWhereUniqueInput[];
    connect?:
      | AcademicYearSubjectWhereUniqueInput
      | AcademicYearSubjectWhereUniqueInput[];
    update?:
      | AcademicYearSubjectUpdateWithWhereUniqueWithoutTeachersInput
      | AcademicYearSubjectUpdateWithWhereUniqueWithoutTeachersInput[];
    updateMany?:
      | AcademicYearSubjectUpdateManyWithWhereWithoutTeachersInput
      | AcademicYearSubjectUpdateManyWithWhereWithoutTeachersInput[];
    deleteMany?:
      | AcademicYearSubjectScalarWhereInput
      | AcademicYearSubjectScalarWhereInput[];
  };

  export type classStreamUpdateManyWithoutClassTeacherNestedInput = {
    create?:
      | XOR<
          classStreamCreateWithoutClassTeacherInput,
          classStreamUncheckedCreateWithoutClassTeacherInput
        >
      | classStreamCreateWithoutClassTeacherInput[]
      | classStreamUncheckedCreateWithoutClassTeacherInput[];
    connectOrCreate?:
      | classStreamCreateOrConnectWithoutClassTeacherInput
      | classStreamCreateOrConnectWithoutClassTeacherInput[];
    upsert?:
      | classStreamUpsertWithWhereUniqueWithoutClassTeacherInput
      | classStreamUpsertWithWhereUniqueWithoutClassTeacherInput[];
    createMany?: classStreamCreateManyClassTeacherInputEnvelope;
    set?: classStreamWhereUniqueInput | classStreamWhereUniqueInput[];
    disconnect?: classStreamWhereUniqueInput | classStreamWhereUniqueInput[];
    delete?: classStreamWhereUniqueInput | classStreamWhereUniqueInput[];
    connect?: classStreamWhereUniqueInput | classStreamWhereUniqueInput[];
    update?:
      | classStreamUpdateWithWhereUniqueWithoutClassTeacherInput
      | classStreamUpdateWithWhereUniqueWithoutClassTeacherInput[];
    updateMany?:
      | classStreamUpdateManyWithWhereWithoutClassTeacherInput
      | classStreamUpdateManyWithWhereWithoutClassTeacherInput[];
    deleteMany?: classStreamScalarWhereInput | classStreamScalarWhereInput[];
  };

  export type UserUpdateOneWithoutStaffsNestedInput = {
    create?: XOR<
      UserCreateWithoutStaffsInput,
      UserUncheckedCreateWithoutStaffsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutStaffsInput;
    upsert?: UserUpsertWithoutStaffsInput;
    disconnect?: UserWhereInput | boolean;
    delete?: UserWhereInput | boolean;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutStaffsInput,
        UserUpdateWithoutStaffsInput
      >,
      UserUncheckedUpdateWithoutStaffsInput
    >;
  };

  export type AcademicYearSubjectUncheckedUpdateManyWithoutTeachersNestedInput =
    {
      create?:
        | XOR<
            AcademicYearSubjectCreateWithoutTeachersInput,
            AcademicYearSubjectUncheckedCreateWithoutTeachersInput
          >
        | AcademicYearSubjectCreateWithoutTeachersInput[]
        | AcademicYearSubjectUncheckedCreateWithoutTeachersInput[];
      connectOrCreate?:
        | AcademicYearSubjectCreateOrConnectWithoutTeachersInput
        | AcademicYearSubjectCreateOrConnectWithoutTeachersInput[];
      upsert?:
        | AcademicYearSubjectUpsertWithWhereUniqueWithoutTeachersInput
        | AcademicYearSubjectUpsertWithWhereUniqueWithoutTeachersInput[];
      set?:
        | AcademicYearSubjectWhereUniqueInput
        | AcademicYearSubjectWhereUniqueInput[];
      disconnect?:
        | AcademicYearSubjectWhereUniqueInput
        | AcademicYearSubjectWhereUniqueInput[];
      delete?:
        | AcademicYearSubjectWhereUniqueInput
        | AcademicYearSubjectWhereUniqueInput[];
      connect?:
        | AcademicYearSubjectWhereUniqueInput
        | AcademicYearSubjectWhereUniqueInput[];
      update?:
        | AcademicYearSubjectUpdateWithWhereUniqueWithoutTeachersInput
        | AcademicYearSubjectUpdateWithWhereUniqueWithoutTeachersInput[];
      updateMany?:
        | AcademicYearSubjectUpdateManyWithWhereWithoutTeachersInput
        | AcademicYearSubjectUpdateManyWithWhereWithoutTeachersInput[];
      deleteMany?:
        | AcademicYearSubjectScalarWhereInput
        | AcademicYearSubjectScalarWhereInput[];
    };

  export type classStreamUncheckedUpdateManyWithoutClassTeacherNestedInput = {
    create?:
      | XOR<
          classStreamCreateWithoutClassTeacherInput,
          classStreamUncheckedCreateWithoutClassTeacherInput
        >
      | classStreamCreateWithoutClassTeacherInput[]
      | classStreamUncheckedCreateWithoutClassTeacherInput[];
    connectOrCreate?:
      | classStreamCreateOrConnectWithoutClassTeacherInput
      | classStreamCreateOrConnectWithoutClassTeacherInput[];
    upsert?:
      | classStreamUpsertWithWhereUniqueWithoutClassTeacherInput
      | classStreamUpsertWithWhereUniqueWithoutClassTeacherInput[];
    createMany?: classStreamCreateManyClassTeacherInputEnvelope;
    set?: classStreamWhereUniqueInput | classStreamWhereUniqueInput[];
    disconnect?: classStreamWhereUniqueInput | classStreamWhereUniqueInput[];
    delete?: classStreamWhereUniqueInput | classStreamWhereUniqueInput[];
    connect?: classStreamWhereUniqueInput | classStreamWhereUniqueInput[];
    update?:
      | classStreamUpdateWithWhereUniqueWithoutClassTeacherInput
      | classStreamUpdateWithWhereUniqueWithoutClassTeacherInput[];
    updateMany?:
      | classStreamUpdateManyWithWhereWithoutClassTeacherInput
      | classStreamUpdateManyWithWhereWithoutClassTeacherInput[];
    deleteMany?: classStreamScalarWhereInput | classStreamScalarWhereInput[];
  };

  export type ClassCreateNestedManyWithoutLevelInput = {
    create?:
      | XOR<ClassCreateWithoutLevelInput, ClassUncheckedCreateWithoutLevelInput>
      | ClassCreateWithoutLevelInput[]
      | ClassUncheckedCreateWithoutLevelInput[];
    connectOrCreate?:
      | ClassCreateOrConnectWithoutLevelInput
      | ClassCreateOrConnectWithoutLevelInput[];
    createMany?: ClassCreateManyLevelInputEnvelope;
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[];
  };

  export type SubjectCreateNestedManyWithoutLevelInput = {
    create?:
      | XOR<
          SubjectCreateWithoutLevelInput,
          SubjectUncheckedCreateWithoutLevelInput
        >
      | SubjectCreateWithoutLevelInput[]
      | SubjectUncheckedCreateWithoutLevelInput[];
    connectOrCreate?:
      | SubjectCreateOrConnectWithoutLevelInput
      | SubjectCreateOrConnectWithoutLevelInput[];
    createMany?: SubjectCreateManyLevelInputEnvelope;
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[];
  };

  export type ClassUncheckedCreateNestedManyWithoutLevelInput = {
    create?:
      | XOR<ClassCreateWithoutLevelInput, ClassUncheckedCreateWithoutLevelInput>
      | ClassCreateWithoutLevelInput[]
      | ClassUncheckedCreateWithoutLevelInput[];
    connectOrCreate?:
      | ClassCreateOrConnectWithoutLevelInput
      | ClassCreateOrConnectWithoutLevelInput[];
    createMany?: ClassCreateManyLevelInputEnvelope;
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[];
  };

  export type SubjectUncheckedCreateNestedManyWithoutLevelInput = {
    create?:
      | XOR<
          SubjectCreateWithoutLevelInput,
          SubjectUncheckedCreateWithoutLevelInput
        >
      | SubjectCreateWithoutLevelInput[]
      | SubjectUncheckedCreateWithoutLevelInput[];
    connectOrCreate?:
      | SubjectCreateOrConnectWithoutLevelInput
      | SubjectCreateOrConnectWithoutLevelInput[];
    createMany?: SubjectCreateManyLevelInputEnvelope;
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[];
  };

  export type ClassUpdateManyWithoutLevelNestedInput = {
    create?:
      | XOR<ClassCreateWithoutLevelInput, ClassUncheckedCreateWithoutLevelInput>
      | ClassCreateWithoutLevelInput[]
      | ClassUncheckedCreateWithoutLevelInput[];
    connectOrCreate?:
      | ClassCreateOrConnectWithoutLevelInput
      | ClassCreateOrConnectWithoutLevelInput[];
    upsert?:
      | ClassUpsertWithWhereUniqueWithoutLevelInput
      | ClassUpsertWithWhereUniqueWithoutLevelInput[];
    createMany?: ClassCreateManyLevelInputEnvelope;
    set?: ClassWhereUniqueInput | ClassWhereUniqueInput[];
    disconnect?: ClassWhereUniqueInput | ClassWhereUniqueInput[];
    delete?: ClassWhereUniqueInput | ClassWhereUniqueInput[];
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[];
    update?:
      | ClassUpdateWithWhereUniqueWithoutLevelInput
      | ClassUpdateWithWhereUniqueWithoutLevelInput[];
    updateMany?:
      | ClassUpdateManyWithWhereWithoutLevelInput
      | ClassUpdateManyWithWhereWithoutLevelInput[];
    deleteMany?: ClassScalarWhereInput | ClassScalarWhereInput[];
  };

  export type SubjectUpdateManyWithoutLevelNestedInput = {
    create?:
      | XOR<
          SubjectCreateWithoutLevelInput,
          SubjectUncheckedCreateWithoutLevelInput
        >
      | SubjectCreateWithoutLevelInput[]
      | SubjectUncheckedCreateWithoutLevelInput[];
    connectOrCreate?:
      | SubjectCreateOrConnectWithoutLevelInput
      | SubjectCreateOrConnectWithoutLevelInput[];
    upsert?:
      | SubjectUpsertWithWhereUniqueWithoutLevelInput
      | SubjectUpsertWithWhereUniqueWithoutLevelInput[];
    createMany?: SubjectCreateManyLevelInputEnvelope;
    set?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[];
    disconnect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[];
    delete?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[];
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[];
    update?:
      | SubjectUpdateWithWhereUniqueWithoutLevelInput
      | SubjectUpdateWithWhereUniqueWithoutLevelInput[];
    updateMany?:
      | SubjectUpdateManyWithWhereWithoutLevelInput
      | SubjectUpdateManyWithWhereWithoutLevelInput[];
    deleteMany?: SubjectScalarWhereInput | SubjectScalarWhereInput[];
  };

  export type ClassUncheckedUpdateManyWithoutLevelNestedInput = {
    create?:
      | XOR<ClassCreateWithoutLevelInput, ClassUncheckedCreateWithoutLevelInput>
      | ClassCreateWithoutLevelInput[]
      | ClassUncheckedCreateWithoutLevelInput[];
    connectOrCreate?:
      | ClassCreateOrConnectWithoutLevelInput
      | ClassCreateOrConnectWithoutLevelInput[];
    upsert?:
      | ClassUpsertWithWhereUniqueWithoutLevelInput
      | ClassUpsertWithWhereUniqueWithoutLevelInput[];
    createMany?: ClassCreateManyLevelInputEnvelope;
    set?: ClassWhereUniqueInput | ClassWhereUniqueInput[];
    disconnect?: ClassWhereUniqueInput | ClassWhereUniqueInput[];
    delete?: ClassWhereUniqueInput | ClassWhereUniqueInput[];
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[];
    update?:
      | ClassUpdateWithWhereUniqueWithoutLevelInput
      | ClassUpdateWithWhereUniqueWithoutLevelInput[];
    updateMany?:
      | ClassUpdateManyWithWhereWithoutLevelInput
      | ClassUpdateManyWithWhereWithoutLevelInput[];
    deleteMany?: ClassScalarWhereInput | ClassScalarWhereInput[];
  };

  export type SubjectUncheckedUpdateManyWithoutLevelNestedInput = {
    create?:
      | XOR<
          SubjectCreateWithoutLevelInput,
          SubjectUncheckedCreateWithoutLevelInput
        >
      | SubjectCreateWithoutLevelInput[]
      | SubjectUncheckedCreateWithoutLevelInput[];
    connectOrCreate?:
      | SubjectCreateOrConnectWithoutLevelInput
      | SubjectCreateOrConnectWithoutLevelInput[];
    upsert?:
      | SubjectUpsertWithWhereUniqueWithoutLevelInput
      | SubjectUpsertWithWhereUniqueWithoutLevelInput[];
    createMany?: SubjectCreateManyLevelInputEnvelope;
    set?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[];
    disconnect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[];
    delete?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[];
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[];
    update?:
      | SubjectUpdateWithWhereUniqueWithoutLevelInput
      | SubjectUpdateWithWhereUniqueWithoutLevelInput[];
    updateMany?:
      | SubjectUpdateManyWithWhereWithoutLevelInput
      | SubjectUpdateManyWithWhereWithoutLevelInput[];
    deleteMany?: SubjectScalarWhereInput | SubjectScalarWhereInput[];
  };

  export type classStreamCreateNestedManyWithoutStreamInput = {
    create?:
      | XOR<
          classStreamCreateWithoutStreamInput,
          classStreamUncheckedCreateWithoutStreamInput
        >
      | classStreamCreateWithoutStreamInput[]
      | classStreamUncheckedCreateWithoutStreamInput[];
    connectOrCreate?:
      | classStreamCreateOrConnectWithoutStreamInput
      | classStreamCreateOrConnectWithoutStreamInput[];
    createMany?: classStreamCreateManyStreamInputEnvelope;
    connect?: classStreamWhereUniqueInput | classStreamWhereUniqueInput[];
  };

  export type classStreamUncheckedCreateNestedManyWithoutStreamInput = {
    create?:
      | XOR<
          classStreamCreateWithoutStreamInput,
          classStreamUncheckedCreateWithoutStreamInput
        >
      | classStreamCreateWithoutStreamInput[]
      | classStreamUncheckedCreateWithoutStreamInput[];
    connectOrCreate?:
      | classStreamCreateOrConnectWithoutStreamInput
      | classStreamCreateOrConnectWithoutStreamInput[];
    createMany?: classStreamCreateManyStreamInputEnvelope;
    connect?: classStreamWhereUniqueInput | classStreamWhereUniqueInput[];
  };

  export type classStreamUpdateManyWithoutStreamNestedInput = {
    create?:
      | XOR<
          classStreamCreateWithoutStreamInput,
          classStreamUncheckedCreateWithoutStreamInput
        >
      | classStreamCreateWithoutStreamInput[]
      | classStreamUncheckedCreateWithoutStreamInput[];
    connectOrCreate?:
      | classStreamCreateOrConnectWithoutStreamInput
      | classStreamCreateOrConnectWithoutStreamInput[];
    upsert?:
      | classStreamUpsertWithWhereUniqueWithoutStreamInput
      | classStreamUpsertWithWhereUniqueWithoutStreamInput[];
    createMany?: classStreamCreateManyStreamInputEnvelope;
    set?: classStreamWhereUniqueInput | classStreamWhereUniqueInput[];
    disconnect?: classStreamWhereUniqueInput | classStreamWhereUniqueInput[];
    delete?: classStreamWhereUniqueInput | classStreamWhereUniqueInput[];
    connect?: classStreamWhereUniqueInput | classStreamWhereUniqueInput[];
    update?:
      | classStreamUpdateWithWhereUniqueWithoutStreamInput
      | classStreamUpdateWithWhereUniqueWithoutStreamInput[];
    updateMany?:
      | classStreamUpdateManyWithWhereWithoutStreamInput
      | classStreamUpdateManyWithWhereWithoutStreamInput[];
    deleteMany?: classStreamScalarWhereInput | classStreamScalarWhereInput[];
  };

  export type classStreamUncheckedUpdateManyWithoutStreamNestedInput = {
    create?:
      | XOR<
          classStreamCreateWithoutStreamInput,
          classStreamUncheckedCreateWithoutStreamInput
        >
      | classStreamCreateWithoutStreamInput[]
      | classStreamUncheckedCreateWithoutStreamInput[];
    connectOrCreate?:
      | classStreamCreateOrConnectWithoutStreamInput
      | classStreamCreateOrConnectWithoutStreamInput[];
    upsert?:
      | classStreamUpsertWithWhereUniqueWithoutStreamInput
      | classStreamUpsertWithWhereUniqueWithoutStreamInput[];
    createMany?: classStreamCreateManyStreamInputEnvelope;
    set?: classStreamWhereUniqueInput | classStreamWhereUniqueInput[];
    disconnect?: classStreamWhereUniqueInput | classStreamWhereUniqueInput[];
    delete?: classStreamWhereUniqueInput | classStreamWhereUniqueInput[];
    connect?: classStreamWhereUniqueInput | classStreamWhereUniqueInput[];
    update?:
      | classStreamUpdateWithWhereUniqueWithoutStreamInput
      | classStreamUpdateWithWhereUniqueWithoutStreamInput[];
    updateMany?:
      | classStreamUpdateManyWithWhereWithoutStreamInput
      | classStreamUpdateManyWithWhereWithoutStreamInput[];
    deleteMany?: classStreamScalarWhereInput | classStreamScalarWhereInput[];
  };

  export type AcademicYearClassCreateNestedManyWithoutClassInput = {
    create?:
      | XOR<
          AcademicYearClassCreateWithoutClassInput,
          AcademicYearClassUncheckedCreateWithoutClassInput
        >
      | AcademicYearClassCreateWithoutClassInput[]
      | AcademicYearClassUncheckedCreateWithoutClassInput[];
    connectOrCreate?:
      | AcademicYearClassCreateOrConnectWithoutClassInput
      | AcademicYearClassCreateOrConnectWithoutClassInput[];
    createMany?: AcademicYearClassCreateManyClassInputEnvelope;
    connect?:
      | AcademicYearClassWhereUniqueInput
      | AcademicYearClassWhereUniqueInput[];
  };

  export type LevelCreateNestedOneWithoutClassesInput = {
    create?: XOR<
      LevelCreateWithoutClassesInput,
      LevelUncheckedCreateWithoutClassesInput
    >;
    connectOrCreate?: LevelCreateOrConnectWithoutClassesInput;
    connect?: LevelWhereUniqueInput;
  };

  export type AcademicYearClassUncheckedCreateNestedManyWithoutClassInput = {
    create?:
      | XOR<
          AcademicYearClassCreateWithoutClassInput,
          AcademicYearClassUncheckedCreateWithoutClassInput
        >
      | AcademicYearClassCreateWithoutClassInput[]
      | AcademicYearClassUncheckedCreateWithoutClassInput[];
    connectOrCreate?:
      | AcademicYearClassCreateOrConnectWithoutClassInput
      | AcademicYearClassCreateOrConnectWithoutClassInput[];
    createMany?: AcademicYearClassCreateManyClassInputEnvelope;
    connect?:
      | AcademicYearClassWhereUniqueInput
      | AcademicYearClassWhereUniqueInput[];
  };

  export type AcademicYearClassUpdateManyWithoutClassNestedInput = {
    create?:
      | XOR<
          AcademicYearClassCreateWithoutClassInput,
          AcademicYearClassUncheckedCreateWithoutClassInput
        >
      | AcademicYearClassCreateWithoutClassInput[]
      | AcademicYearClassUncheckedCreateWithoutClassInput[];
    connectOrCreate?:
      | AcademicYearClassCreateOrConnectWithoutClassInput
      | AcademicYearClassCreateOrConnectWithoutClassInput[];
    upsert?:
      | AcademicYearClassUpsertWithWhereUniqueWithoutClassInput
      | AcademicYearClassUpsertWithWhereUniqueWithoutClassInput[];
    createMany?: AcademicYearClassCreateManyClassInputEnvelope;
    set?:
      | AcademicYearClassWhereUniqueInput
      | AcademicYearClassWhereUniqueInput[];
    disconnect?:
      | AcademicYearClassWhereUniqueInput
      | AcademicYearClassWhereUniqueInput[];
    delete?:
      | AcademicYearClassWhereUniqueInput
      | AcademicYearClassWhereUniqueInput[];
    connect?:
      | AcademicYearClassWhereUniqueInput
      | AcademicYearClassWhereUniqueInput[];
    update?:
      | AcademicYearClassUpdateWithWhereUniqueWithoutClassInput
      | AcademicYearClassUpdateWithWhereUniqueWithoutClassInput[];
    updateMany?:
      | AcademicYearClassUpdateManyWithWhereWithoutClassInput
      | AcademicYearClassUpdateManyWithWhereWithoutClassInput[];
    deleteMany?:
      | AcademicYearClassScalarWhereInput
      | AcademicYearClassScalarWhereInput[];
  };

  export type LevelUpdateOneWithoutClassesNestedInput = {
    create?: XOR<
      LevelCreateWithoutClassesInput,
      LevelUncheckedCreateWithoutClassesInput
    >;
    connectOrCreate?: LevelCreateOrConnectWithoutClassesInput;
    upsert?: LevelUpsertWithoutClassesInput;
    disconnect?: LevelWhereInput | boolean;
    delete?: LevelWhereInput | boolean;
    connect?: LevelWhereUniqueInput;
    update?: XOR<
      XOR<
        LevelUpdateToOneWithWhereWithoutClassesInput,
        LevelUpdateWithoutClassesInput
      >,
      LevelUncheckedUpdateWithoutClassesInput
    >;
  };

  export type AcademicYearClassUncheckedUpdateManyWithoutClassNestedInput = {
    create?:
      | XOR<
          AcademicYearClassCreateWithoutClassInput,
          AcademicYearClassUncheckedCreateWithoutClassInput
        >
      | AcademicYearClassCreateWithoutClassInput[]
      | AcademicYearClassUncheckedCreateWithoutClassInput[];
    connectOrCreate?:
      | AcademicYearClassCreateOrConnectWithoutClassInput
      | AcademicYearClassCreateOrConnectWithoutClassInput[];
    upsert?:
      | AcademicYearClassUpsertWithWhereUniqueWithoutClassInput
      | AcademicYearClassUpsertWithWhereUniqueWithoutClassInput[];
    createMany?: AcademicYearClassCreateManyClassInputEnvelope;
    set?:
      | AcademicYearClassWhereUniqueInput
      | AcademicYearClassWhereUniqueInput[];
    disconnect?:
      | AcademicYearClassWhereUniqueInput
      | AcademicYearClassWhereUniqueInput[];
    delete?:
      | AcademicYearClassWhereUniqueInput
      | AcademicYearClassWhereUniqueInput[];
    connect?:
      | AcademicYearClassWhereUniqueInput
      | AcademicYearClassWhereUniqueInput[];
    update?:
      | AcademicYearClassUpdateWithWhereUniqueWithoutClassInput
      | AcademicYearClassUpdateWithWhereUniqueWithoutClassInput[];
    updateMany?:
      | AcademicYearClassUpdateManyWithWhereWithoutClassInput
      | AcademicYearClassUpdateManyWithWhereWithoutClassInput[];
    deleteMany?:
      | AcademicYearClassScalarWhereInput
      | AcademicYearClassScalarWhereInput[];
  };

  export type AcademicYearClassCreateNestedManyWithoutAcademicYearInput = {
    create?:
      | XOR<
          AcademicYearClassCreateWithoutAcademicYearInput,
          AcademicYearClassUncheckedCreateWithoutAcademicYearInput
        >
      | AcademicYearClassCreateWithoutAcademicYearInput[]
      | AcademicYearClassUncheckedCreateWithoutAcademicYearInput[];
    connectOrCreate?:
      | AcademicYearClassCreateOrConnectWithoutAcademicYearInput
      | AcademicYearClassCreateOrConnectWithoutAcademicYearInput[];
    createMany?: AcademicYearClassCreateManyAcademicYearInputEnvelope;
    connect?:
      | AcademicYearClassWhereUniqueInput
      | AcademicYearClassWhereUniqueInput[];
  };

  export type AcademicYearClassUncheckedCreateNestedManyWithoutAcademicYearInput =
    {
      create?:
        | XOR<
            AcademicYearClassCreateWithoutAcademicYearInput,
            AcademicYearClassUncheckedCreateWithoutAcademicYearInput
          >
        | AcademicYearClassCreateWithoutAcademicYearInput[]
        | AcademicYearClassUncheckedCreateWithoutAcademicYearInput[];
      connectOrCreate?:
        | AcademicYearClassCreateOrConnectWithoutAcademicYearInput
        | AcademicYearClassCreateOrConnectWithoutAcademicYearInput[];
      createMany?: AcademicYearClassCreateManyAcademicYearInputEnvelope;
      connect?:
        | AcademicYearClassWhereUniqueInput
        | AcademicYearClassWhereUniqueInput[];
    };

  export type AcademicYearClassUpdateManyWithoutAcademicYearNestedInput = {
    create?:
      | XOR<
          AcademicYearClassCreateWithoutAcademicYearInput,
          AcademicYearClassUncheckedCreateWithoutAcademicYearInput
        >
      | AcademicYearClassCreateWithoutAcademicYearInput[]
      | AcademicYearClassUncheckedCreateWithoutAcademicYearInput[];
    connectOrCreate?:
      | AcademicYearClassCreateOrConnectWithoutAcademicYearInput
      | AcademicYearClassCreateOrConnectWithoutAcademicYearInput[];
    upsert?:
      | AcademicYearClassUpsertWithWhereUniqueWithoutAcademicYearInput
      | AcademicYearClassUpsertWithWhereUniqueWithoutAcademicYearInput[];
    createMany?: AcademicYearClassCreateManyAcademicYearInputEnvelope;
    set?:
      | AcademicYearClassWhereUniqueInput
      | AcademicYearClassWhereUniqueInput[];
    disconnect?:
      | AcademicYearClassWhereUniqueInput
      | AcademicYearClassWhereUniqueInput[];
    delete?:
      | AcademicYearClassWhereUniqueInput
      | AcademicYearClassWhereUniqueInput[];
    connect?:
      | AcademicYearClassWhereUniqueInput
      | AcademicYearClassWhereUniqueInput[];
    update?:
      | AcademicYearClassUpdateWithWhereUniqueWithoutAcademicYearInput
      | AcademicYearClassUpdateWithWhereUniqueWithoutAcademicYearInput[];
    updateMany?:
      | AcademicYearClassUpdateManyWithWhereWithoutAcademicYearInput
      | AcademicYearClassUpdateManyWithWhereWithoutAcademicYearInput[];
    deleteMany?:
      | AcademicYearClassScalarWhereInput
      | AcademicYearClassScalarWhereInput[];
  };

  export type AcademicYearClassUncheckedUpdateManyWithoutAcademicYearNestedInput =
    {
      create?:
        | XOR<
            AcademicYearClassCreateWithoutAcademicYearInput,
            AcademicYearClassUncheckedCreateWithoutAcademicYearInput
          >
        | AcademicYearClassCreateWithoutAcademicYearInput[]
        | AcademicYearClassUncheckedCreateWithoutAcademicYearInput[];
      connectOrCreate?:
        | AcademicYearClassCreateOrConnectWithoutAcademicYearInput
        | AcademicYearClassCreateOrConnectWithoutAcademicYearInput[];
      upsert?:
        | AcademicYearClassUpsertWithWhereUniqueWithoutAcademicYearInput
        | AcademicYearClassUpsertWithWhereUniqueWithoutAcademicYearInput[];
      createMany?: AcademicYearClassCreateManyAcademicYearInputEnvelope;
      set?:
        | AcademicYearClassWhereUniqueInput
        | AcademicYearClassWhereUniqueInput[];
      disconnect?:
        | AcademicYearClassWhereUniqueInput
        | AcademicYearClassWhereUniqueInput[];
      delete?:
        | AcademicYearClassWhereUniqueInput
        | AcademicYearClassWhereUniqueInput[];
      connect?:
        | AcademicYearClassWhereUniqueInput
        | AcademicYearClassWhereUniqueInput[];
      update?:
        | AcademicYearClassUpdateWithWhereUniqueWithoutAcademicYearInput
        | AcademicYearClassUpdateWithWhereUniqueWithoutAcademicYearInput[];
      updateMany?:
        | AcademicYearClassUpdateManyWithWhereWithoutAcademicYearInput
        | AcademicYearClassUpdateManyWithWhereWithoutAcademicYearInput[];
      deleteMany?:
        | AcademicYearClassScalarWhereInput
        | AcademicYearClassScalarWhereInput[];
    };

  export type AcademicYearCreateNestedOneWithoutAcademicYearClassesInput = {
    create?: XOR<
      AcademicYearCreateWithoutAcademicYearClassesInput,
      AcademicYearUncheckedCreateWithoutAcademicYearClassesInput
    >;
    connectOrCreate?: AcademicYearCreateOrConnectWithoutAcademicYearClassesInput;
    connect?: AcademicYearWhereUniqueInput;
  };

  export type ClassCreateNestedOneWithoutAcademicYearClassesInput = {
    create?: XOR<
      ClassCreateWithoutAcademicYearClassesInput,
      ClassUncheckedCreateWithoutAcademicYearClassesInput
    >;
    connectOrCreate?: ClassCreateOrConnectWithoutAcademicYearClassesInput;
    connect?: ClassWhereUniqueInput;
  };

  export type AcademicYearSubjectCreateNestedManyWithoutAcademicYearClassInput =
    {
      create?:
        | XOR<
            AcademicYearSubjectCreateWithoutAcademicYearClassInput,
            AcademicYearSubjectUncheckedCreateWithoutAcademicYearClassInput
          >
        | AcademicYearSubjectCreateWithoutAcademicYearClassInput[]
        | AcademicYearSubjectUncheckedCreateWithoutAcademicYearClassInput[];
      connectOrCreate?:
        | AcademicYearSubjectCreateOrConnectWithoutAcademicYearClassInput
        | AcademicYearSubjectCreateOrConnectWithoutAcademicYearClassInput[];
      createMany?: AcademicYearSubjectCreateManyAcademicYearClassInputEnvelope;
      connect?:
        | AcademicYearSubjectWhereUniqueInput
        | AcademicYearSubjectWhereUniqueInput[];
    };

  export type classStreamCreateNestedManyWithoutClassInput = {
    create?:
      | XOR<
          classStreamCreateWithoutClassInput,
          classStreamUncheckedCreateWithoutClassInput
        >
      | classStreamCreateWithoutClassInput[]
      | classStreamUncheckedCreateWithoutClassInput[];
    connectOrCreate?:
      | classStreamCreateOrConnectWithoutClassInput
      | classStreamCreateOrConnectWithoutClassInput[];
    createMany?: classStreamCreateManyClassInputEnvelope;
    connect?: classStreamWhereUniqueInput | classStreamWhereUniqueInput[];
  };

  export type AcademicYearSubjectUncheckedCreateNestedManyWithoutAcademicYearClassInput =
    {
      create?:
        | XOR<
            AcademicYearSubjectCreateWithoutAcademicYearClassInput,
            AcademicYearSubjectUncheckedCreateWithoutAcademicYearClassInput
          >
        | AcademicYearSubjectCreateWithoutAcademicYearClassInput[]
        | AcademicYearSubjectUncheckedCreateWithoutAcademicYearClassInput[];
      connectOrCreate?:
        | AcademicYearSubjectCreateOrConnectWithoutAcademicYearClassInput
        | AcademicYearSubjectCreateOrConnectWithoutAcademicYearClassInput[];
      createMany?: AcademicYearSubjectCreateManyAcademicYearClassInputEnvelope;
      connect?:
        | AcademicYearSubjectWhereUniqueInput
        | AcademicYearSubjectWhereUniqueInput[];
    };

  export type classStreamUncheckedCreateNestedManyWithoutClassInput = {
    create?:
      | XOR<
          classStreamCreateWithoutClassInput,
          classStreamUncheckedCreateWithoutClassInput
        >
      | classStreamCreateWithoutClassInput[]
      | classStreamUncheckedCreateWithoutClassInput[];
    connectOrCreate?:
      | classStreamCreateOrConnectWithoutClassInput
      | classStreamCreateOrConnectWithoutClassInput[];
    createMany?: classStreamCreateManyClassInputEnvelope;
    connect?: classStreamWhereUniqueInput | classStreamWhereUniqueInput[];
  };

  export type AcademicYearUpdateOneWithoutAcademicYearClassesNestedInput = {
    create?: XOR<
      AcademicYearCreateWithoutAcademicYearClassesInput,
      AcademicYearUncheckedCreateWithoutAcademicYearClassesInput
    >;
    connectOrCreate?: AcademicYearCreateOrConnectWithoutAcademicYearClassesInput;
    upsert?: AcademicYearUpsertWithoutAcademicYearClassesInput;
    disconnect?: AcademicYearWhereInput | boolean;
    delete?: AcademicYearWhereInput | boolean;
    connect?: AcademicYearWhereUniqueInput;
    update?: XOR<
      XOR<
        AcademicYearUpdateToOneWithWhereWithoutAcademicYearClassesInput,
        AcademicYearUpdateWithoutAcademicYearClassesInput
      >,
      AcademicYearUncheckedUpdateWithoutAcademicYearClassesInput
    >;
  };

  export type ClassUpdateOneWithoutAcademicYearClassesNestedInput = {
    create?: XOR<
      ClassCreateWithoutAcademicYearClassesInput,
      ClassUncheckedCreateWithoutAcademicYearClassesInput
    >;
    connectOrCreate?: ClassCreateOrConnectWithoutAcademicYearClassesInput;
    upsert?: ClassUpsertWithoutAcademicYearClassesInput;
    disconnect?: ClassWhereInput | boolean;
    delete?: ClassWhereInput | boolean;
    connect?: ClassWhereUniqueInput;
    update?: XOR<
      XOR<
        ClassUpdateToOneWithWhereWithoutAcademicYearClassesInput,
        ClassUpdateWithoutAcademicYearClassesInput
      >,
      ClassUncheckedUpdateWithoutAcademicYearClassesInput
    >;
  };

  export type AcademicYearSubjectUpdateManyWithoutAcademicYearClassNestedInput =
    {
      create?:
        | XOR<
            AcademicYearSubjectCreateWithoutAcademicYearClassInput,
            AcademicYearSubjectUncheckedCreateWithoutAcademicYearClassInput
          >
        | AcademicYearSubjectCreateWithoutAcademicYearClassInput[]
        | AcademicYearSubjectUncheckedCreateWithoutAcademicYearClassInput[];
      connectOrCreate?:
        | AcademicYearSubjectCreateOrConnectWithoutAcademicYearClassInput
        | AcademicYearSubjectCreateOrConnectWithoutAcademicYearClassInput[];
      upsert?:
        | AcademicYearSubjectUpsertWithWhereUniqueWithoutAcademicYearClassInput
        | AcademicYearSubjectUpsertWithWhereUniqueWithoutAcademicYearClassInput[];
      createMany?: AcademicYearSubjectCreateManyAcademicYearClassInputEnvelope;
      set?:
        | AcademicYearSubjectWhereUniqueInput
        | AcademicYearSubjectWhereUniqueInput[];
      disconnect?:
        | AcademicYearSubjectWhereUniqueInput
        | AcademicYearSubjectWhereUniqueInput[];
      delete?:
        | AcademicYearSubjectWhereUniqueInput
        | AcademicYearSubjectWhereUniqueInput[];
      connect?:
        | AcademicYearSubjectWhereUniqueInput
        | AcademicYearSubjectWhereUniqueInput[];
      update?:
        | AcademicYearSubjectUpdateWithWhereUniqueWithoutAcademicYearClassInput
        | AcademicYearSubjectUpdateWithWhereUniqueWithoutAcademicYearClassInput[];
      updateMany?:
        | AcademicYearSubjectUpdateManyWithWhereWithoutAcademicYearClassInput
        | AcademicYearSubjectUpdateManyWithWhereWithoutAcademicYearClassInput[];
      deleteMany?:
        | AcademicYearSubjectScalarWhereInput
        | AcademicYearSubjectScalarWhereInput[];
    };

  export type classStreamUpdateManyWithoutClassNestedInput = {
    create?:
      | XOR<
          classStreamCreateWithoutClassInput,
          classStreamUncheckedCreateWithoutClassInput
        >
      | classStreamCreateWithoutClassInput[]
      | classStreamUncheckedCreateWithoutClassInput[];
    connectOrCreate?:
      | classStreamCreateOrConnectWithoutClassInput
      | classStreamCreateOrConnectWithoutClassInput[];
    upsert?:
      | classStreamUpsertWithWhereUniqueWithoutClassInput
      | classStreamUpsertWithWhereUniqueWithoutClassInput[];
    createMany?: classStreamCreateManyClassInputEnvelope;
    set?: classStreamWhereUniqueInput | classStreamWhereUniqueInput[];
    disconnect?: classStreamWhereUniqueInput | classStreamWhereUniqueInput[];
    delete?: classStreamWhereUniqueInput | classStreamWhereUniqueInput[];
    connect?: classStreamWhereUniqueInput | classStreamWhereUniqueInput[];
    update?:
      | classStreamUpdateWithWhereUniqueWithoutClassInput
      | classStreamUpdateWithWhereUniqueWithoutClassInput[];
    updateMany?:
      | classStreamUpdateManyWithWhereWithoutClassInput
      | classStreamUpdateManyWithWhereWithoutClassInput[];
    deleteMany?: classStreamScalarWhereInput | classStreamScalarWhereInput[];
  };

  export type AcademicYearSubjectUncheckedUpdateManyWithoutAcademicYearClassNestedInput =
    {
      create?:
        | XOR<
            AcademicYearSubjectCreateWithoutAcademicYearClassInput,
            AcademicYearSubjectUncheckedCreateWithoutAcademicYearClassInput
          >
        | AcademicYearSubjectCreateWithoutAcademicYearClassInput[]
        | AcademicYearSubjectUncheckedCreateWithoutAcademicYearClassInput[];
      connectOrCreate?:
        | AcademicYearSubjectCreateOrConnectWithoutAcademicYearClassInput
        | AcademicYearSubjectCreateOrConnectWithoutAcademicYearClassInput[];
      upsert?:
        | AcademicYearSubjectUpsertWithWhereUniqueWithoutAcademicYearClassInput
        | AcademicYearSubjectUpsertWithWhereUniqueWithoutAcademicYearClassInput[];
      createMany?: AcademicYearSubjectCreateManyAcademicYearClassInputEnvelope;
      set?:
        | AcademicYearSubjectWhereUniqueInput
        | AcademicYearSubjectWhereUniqueInput[];
      disconnect?:
        | AcademicYearSubjectWhereUniqueInput
        | AcademicYearSubjectWhereUniqueInput[];
      delete?:
        | AcademicYearSubjectWhereUniqueInput
        | AcademicYearSubjectWhereUniqueInput[];
      connect?:
        | AcademicYearSubjectWhereUniqueInput
        | AcademicYearSubjectWhereUniqueInput[];
      update?:
        | AcademicYearSubjectUpdateWithWhereUniqueWithoutAcademicYearClassInput
        | AcademicYearSubjectUpdateWithWhereUniqueWithoutAcademicYearClassInput[];
      updateMany?:
        | AcademicYearSubjectUpdateManyWithWhereWithoutAcademicYearClassInput
        | AcademicYearSubjectUpdateManyWithWhereWithoutAcademicYearClassInput[];
      deleteMany?:
        | AcademicYearSubjectScalarWhereInput
        | AcademicYearSubjectScalarWhereInput[];
    };

  export type classStreamUncheckedUpdateManyWithoutClassNestedInput = {
    create?:
      | XOR<
          classStreamCreateWithoutClassInput,
          classStreamUncheckedCreateWithoutClassInput
        >
      | classStreamCreateWithoutClassInput[]
      | classStreamUncheckedCreateWithoutClassInput[];
    connectOrCreate?:
      | classStreamCreateOrConnectWithoutClassInput
      | classStreamCreateOrConnectWithoutClassInput[];
    upsert?:
      | classStreamUpsertWithWhereUniqueWithoutClassInput
      | classStreamUpsertWithWhereUniqueWithoutClassInput[];
    createMany?: classStreamCreateManyClassInputEnvelope;
    set?: classStreamWhereUniqueInput | classStreamWhereUniqueInput[];
    disconnect?: classStreamWhereUniqueInput | classStreamWhereUniqueInput[];
    delete?: classStreamWhereUniqueInput | classStreamWhereUniqueInput[];
    connect?: classStreamWhereUniqueInput | classStreamWhereUniqueInput[];
    update?:
      | classStreamUpdateWithWhereUniqueWithoutClassInput
      | classStreamUpdateWithWhereUniqueWithoutClassInput[];
    updateMany?:
      | classStreamUpdateManyWithWhereWithoutClassInput
      | classStreamUpdateManyWithWhereWithoutClassInput[];
    deleteMany?: classStreamScalarWhereInput | classStreamScalarWhereInput[];
  };

  export type GradingCreateNestedManyWithoutSubjectsInput = {
    create?:
      | XOR<
          GradingCreateWithoutSubjectsInput,
          GradingUncheckedCreateWithoutSubjectsInput
        >
      | GradingCreateWithoutSubjectsInput[]
      | GradingUncheckedCreateWithoutSubjectsInput[];
    connectOrCreate?:
      | GradingCreateOrConnectWithoutSubjectsInput
      | GradingCreateOrConnectWithoutSubjectsInput[];
    connect?: GradingWhereUniqueInput | GradingWhereUniqueInput[];
  };

  export type AcademicYearSubjectCreateNestedManyWithoutSubjectInput = {
    create?:
      | XOR<
          AcademicYearSubjectCreateWithoutSubjectInput,
          AcademicYearSubjectUncheckedCreateWithoutSubjectInput
        >
      | AcademicYearSubjectCreateWithoutSubjectInput[]
      | AcademicYearSubjectUncheckedCreateWithoutSubjectInput[];
    connectOrCreate?:
      | AcademicYearSubjectCreateOrConnectWithoutSubjectInput
      | AcademicYearSubjectCreateOrConnectWithoutSubjectInput[];
    createMany?: AcademicYearSubjectCreateManySubjectInputEnvelope;
    connect?:
      | AcademicYearSubjectWhereUniqueInput
      | AcademicYearSubjectWhereUniqueInput[];
  };

  export type LevelCreateNestedOneWithoutSubjectsInput = {
    create?: XOR<
      LevelCreateWithoutSubjectsInput,
      LevelUncheckedCreateWithoutSubjectsInput
    >;
    connectOrCreate?: LevelCreateOrConnectWithoutSubjectsInput;
    connect?: LevelWhereUniqueInput;
  };

  export type GradingUncheckedCreateNestedManyWithoutSubjectsInput = {
    create?:
      | XOR<
          GradingCreateWithoutSubjectsInput,
          GradingUncheckedCreateWithoutSubjectsInput
        >
      | GradingCreateWithoutSubjectsInput[]
      | GradingUncheckedCreateWithoutSubjectsInput[];
    connectOrCreate?:
      | GradingCreateOrConnectWithoutSubjectsInput
      | GradingCreateOrConnectWithoutSubjectsInput[];
    connect?: GradingWhereUniqueInput | GradingWhereUniqueInput[];
  };

  export type AcademicYearSubjectUncheckedCreateNestedManyWithoutSubjectInput =
    {
      create?:
        | XOR<
            AcademicYearSubjectCreateWithoutSubjectInput,
            AcademicYearSubjectUncheckedCreateWithoutSubjectInput
          >
        | AcademicYearSubjectCreateWithoutSubjectInput[]
        | AcademicYearSubjectUncheckedCreateWithoutSubjectInput[];
      connectOrCreate?:
        | AcademicYearSubjectCreateOrConnectWithoutSubjectInput
        | AcademicYearSubjectCreateOrConnectWithoutSubjectInput[];
      createMany?: AcademicYearSubjectCreateManySubjectInputEnvelope;
      connect?:
        | AcademicYearSubjectWhereUniqueInput
        | AcademicYearSubjectWhereUniqueInput[];
    };

  export type GradingUpdateManyWithoutSubjectsNestedInput = {
    create?:
      | XOR<
          GradingCreateWithoutSubjectsInput,
          GradingUncheckedCreateWithoutSubjectsInput
        >
      | GradingCreateWithoutSubjectsInput[]
      | GradingUncheckedCreateWithoutSubjectsInput[];
    connectOrCreate?:
      | GradingCreateOrConnectWithoutSubjectsInput
      | GradingCreateOrConnectWithoutSubjectsInput[];
    upsert?:
      | GradingUpsertWithWhereUniqueWithoutSubjectsInput
      | GradingUpsertWithWhereUniqueWithoutSubjectsInput[];
    set?: GradingWhereUniqueInput | GradingWhereUniqueInput[];
    disconnect?: GradingWhereUniqueInput | GradingWhereUniqueInput[];
    delete?: GradingWhereUniqueInput | GradingWhereUniqueInput[];
    connect?: GradingWhereUniqueInput | GradingWhereUniqueInput[];
    update?:
      | GradingUpdateWithWhereUniqueWithoutSubjectsInput
      | GradingUpdateWithWhereUniqueWithoutSubjectsInput[];
    updateMany?:
      | GradingUpdateManyWithWhereWithoutSubjectsInput
      | GradingUpdateManyWithWhereWithoutSubjectsInput[];
    deleteMany?: GradingScalarWhereInput | GradingScalarWhereInput[];
  };

  export type AcademicYearSubjectUpdateManyWithoutSubjectNestedInput = {
    create?:
      | XOR<
          AcademicYearSubjectCreateWithoutSubjectInput,
          AcademicYearSubjectUncheckedCreateWithoutSubjectInput
        >
      | AcademicYearSubjectCreateWithoutSubjectInput[]
      | AcademicYearSubjectUncheckedCreateWithoutSubjectInput[];
    connectOrCreate?:
      | AcademicYearSubjectCreateOrConnectWithoutSubjectInput
      | AcademicYearSubjectCreateOrConnectWithoutSubjectInput[];
    upsert?:
      | AcademicYearSubjectUpsertWithWhereUniqueWithoutSubjectInput
      | AcademicYearSubjectUpsertWithWhereUniqueWithoutSubjectInput[];
    createMany?: AcademicYearSubjectCreateManySubjectInputEnvelope;
    set?:
      | AcademicYearSubjectWhereUniqueInput
      | AcademicYearSubjectWhereUniqueInput[];
    disconnect?:
      | AcademicYearSubjectWhereUniqueInput
      | AcademicYearSubjectWhereUniqueInput[];
    delete?:
      | AcademicYearSubjectWhereUniqueInput
      | AcademicYearSubjectWhereUniqueInput[];
    connect?:
      | AcademicYearSubjectWhereUniqueInput
      | AcademicYearSubjectWhereUniqueInput[];
    update?:
      | AcademicYearSubjectUpdateWithWhereUniqueWithoutSubjectInput
      | AcademicYearSubjectUpdateWithWhereUniqueWithoutSubjectInput[];
    updateMany?:
      | AcademicYearSubjectUpdateManyWithWhereWithoutSubjectInput
      | AcademicYearSubjectUpdateManyWithWhereWithoutSubjectInput[];
    deleteMany?:
      | AcademicYearSubjectScalarWhereInput
      | AcademicYearSubjectScalarWhereInput[];
  };

  export type LevelUpdateOneRequiredWithoutSubjectsNestedInput = {
    create?: XOR<
      LevelCreateWithoutSubjectsInput,
      LevelUncheckedCreateWithoutSubjectsInput
    >;
    connectOrCreate?: LevelCreateOrConnectWithoutSubjectsInput;
    upsert?: LevelUpsertWithoutSubjectsInput;
    connect?: LevelWhereUniqueInput;
    update?: XOR<
      XOR<
        LevelUpdateToOneWithWhereWithoutSubjectsInput,
        LevelUpdateWithoutSubjectsInput
      >,
      LevelUncheckedUpdateWithoutSubjectsInput
    >;
  };

  export type GradingUncheckedUpdateManyWithoutSubjectsNestedInput = {
    create?:
      | XOR<
          GradingCreateWithoutSubjectsInput,
          GradingUncheckedCreateWithoutSubjectsInput
        >
      | GradingCreateWithoutSubjectsInput[]
      | GradingUncheckedCreateWithoutSubjectsInput[];
    connectOrCreate?:
      | GradingCreateOrConnectWithoutSubjectsInput
      | GradingCreateOrConnectWithoutSubjectsInput[];
    upsert?:
      | GradingUpsertWithWhereUniqueWithoutSubjectsInput
      | GradingUpsertWithWhereUniqueWithoutSubjectsInput[];
    set?: GradingWhereUniqueInput | GradingWhereUniqueInput[];
    disconnect?: GradingWhereUniqueInput | GradingWhereUniqueInput[];
    delete?: GradingWhereUniqueInput | GradingWhereUniqueInput[];
    connect?: GradingWhereUniqueInput | GradingWhereUniqueInput[];
    update?:
      | GradingUpdateWithWhereUniqueWithoutSubjectsInput
      | GradingUpdateWithWhereUniqueWithoutSubjectsInput[];
    updateMany?:
      | GradingUpdateManyWithWhereWithoutSubjectsInput
      | GradingUpdateManyWithWhereWithoutSubjectsInput[];
    deleteMany?: GradingScalarWhereInput | GradingScalarWhereInput[];
  };

  export type AcademicYearSubjectUncheckedUpdateManyWithoutSubjectNestedInput =
    {
      create?:
        | XOR<
            AcademicYearSubjectCreateWithoutSubjectInput,
            AcademicYearSubjectUncheckedCreateWithoutSubjectInput
          >
        | AcademicYearSubjectCreateWithoutSubjectInput[]
        | AcademicYearSubjectUncheckedCreateWithoutSubjectInput[];
      connectOrCreate?:
        | AcademicYearSubjectCreateOrConnectWithoutSubjectInput
        | AcademicYearSubjectCreateOrConnectWithoutSubjectInput[];
      upsert?:
        | AcademicYearSubjectUpsertWithWhereUniqueWithoutSubjectInput
        | AcademicYearSubjectUpsertWithWhereUniqueWithoutSubjectInput[];
      createMany?: AcademicYearSubjectCreateManySubjectInputEnvelope;
      set?:
        | AcademicYearSubjectWhereUniqueInput
        | AcademicYearSubjectWhereUniqueInput[];
      disconnect?:
        | AcademicYearSubjectWhereUniqueInput
        | AcademicYearSubjectWhereUniqueInput[];
      delete?:
        | AcademicYearSubjectWhereUniqueInput
        | AcademicYearSubjectWhereUniqueInput[];
      connect?:
        | AcademicYearSubjectWhereUniqueInput
        | AcademicYearSubjectWhereUniqueInput[];
      update?:
        | AcademicYearSubjectUpdateWithWhereUniqueWithoutSubjectInput
        | AcademicYearSubjectUpdateWithWhereUniqueWithoutSubjectInput[];
      updateMany?:
        | AcademicYearSubjectUpdateManyWithWhereWithoutSubjectInput
        | AcademicYearSubjectUpdateManyWithWhereWithoutSubjectInput[];
      deleteMany?:
        | AcademicYearSubjectScalarWhereInput
        | AcademicYearSubjectScalarWhereInput[];
    };

  export type SubjectCreateNestedManyWithoutGradingInput = {
    create?:
      | XOR<
          SubjectCreateWithoutGradingInput,
          SubjectUncheckedCreateWithoutGradingInput
        >
      | SubjectCreateWithoutGradingInput[]
      | SubjectUncheckedCreateWithoutGradingInput[];
    connectOrCreate?:
      | SubjectCreateOrConnectWithoutGradingInput
      | SubjectCreateOrConnectWithoutGradingInput[];
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[];
  };

  export type AcademicYearSubjectCreateNestedManyWithoutCustomGradingInput = {
    create?:
      | XOR<
          AcademicYearSubjectCreateWithoutCustomGradingInput,
          AcademicYearSubjectUncheckedCreateWithoutCustomGradingInput
        >
      | AcademicYearSubjectCreateWithoutCustomGradingInput[]
      | AcademicYearSubjectUncheckedCreateWithoutCustomGradingInput[];
    connectOrCreate?:
      | AcademicYearSubjectCreateOrConnectWithoutCustomGradingInput
      | AcademicYearSubjectCreateOrConnectWithoutCustomGradingInput[];
    connect?:
      | AcademicYearSubjectWhereUniqueInput
      | AcademicYearSubjectWhereUniqueInput[];
  };

  export type SubjectUncheckedCreateNestedManyWithoutGradingInput = {
    create?:
      | XOR<
          SubjectCreateWithoutGradingInput,
          SubjectUncheckedCreateWithoutGradingInput
        >
      | SubjectCreateWithoutGradingInput[]
      | SubjectUncheckedCreateWithoutGradingInput[];
    connectOrCreate?:
      | SubjectCreateOrConnectWithoutGradingInput
      | SubjectCreateOrConnectWithoutGradingInput[];
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[];
  };

  export type AcademicYearSubjectUncheckedCreateNestedManyWithoutCustomGradingInput =
    {
      create?:
        | XOR<
            AcademicYearSubjectCreateWithoutCustomGradingInput,
            AcademicYearSubjectUncheckedCreateWithoutCustomGradingInput
          >
        | AcademicYearSubjectCreateWithoutCustomGradingInput[]
        | AcademicYearSubjectUncheckedCreateWithoutCustomGradingInput[];
      connectOrCreate?:
        | AcademicYearSubjectCreateOrConnectWithoutCustomGradingInput
        | AcademicYearSubjectCreateOrConnectWithoutCustomGradingInput[];
      connect?:
        | AcademicYearSubjectWhereUniqueInput
        | AcademicYearSubjectWhereUniqueInput[];
    };

  export type FloatFieldUpdateOperationsInput = {
    set?: number;
    increment?: number;
    decrement?: number;
    multiply?: number;
    divide?: number;
  };

  export type SubjectUpdateManyWithoutGradingNestedInput = {
    create?:
      | XOR<
          SubjectCreateWithoutGradingInput,
          SubjectUncheckedCreateWithoutGradingInput
        >
      | SubjectCreateWithoutGradingInput[]
      | SubjectUncheckedCreateWithoutGradingInput[];
    connectOrCreate?:
      | SubjectCreateOrConnectWithoutGradingInput
      | SubjectCreateOrConnectWithoutGradingInput[];
    upsert?:
      | SubjectUpsertWithWhereUniqueWithoutGradingInput
      | SubjectUpsertWithWhereUniqueWithoutGradingInput[];
    set?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[];
    disconnect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[];
    delete?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[];
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[];
    update?:
      | SubjectUpdateWithWhereUniqueWithoutGradingInput
      | SubjectUpdateWithWhereUniqueWithoutGradingInput[];
    updateMany?:
      | SubjectUpdateManyWithWhereWithoutGradingInput
      | SubjectUpdateManyWithWhereWithoutGradingInput[];
    deleteMany?: SubjectScalarWhereInput | SubjectScalarWhereInput[];
  };

  export type AcademicYearSubjectUpdateManyWithoutCustomGradingNestedInput = {
    create?:
      | XOR<
          AcademicYearSubjectCreateWithoutCustomGradingInput,
          AcademicYearSubjectUncheckedCreateWithoutCustomGradingInput
        >
      | AcademicYearSubjectCreateWithoutCustomGradingInput[]
      | AcademicYearSubjectUncheckedCreateWithoutCustomGradingInput[];
    connectOrCreate?:
      | AcademicYearSubjectCreateOrConnectWithoutCustomGradingInput
      | AcademicYearSubjectCreateOrConnectWithoutCustomGradingInput[];
    upsert?:
      | AcademicYearSubjectUpsertWithWhereUniqueWithoutCustomGradingInput
      | AcademicYearSubjectUpsertWithWhereUniqueWithoutCustomGradingInput[];
    set?:
      | AcademicYearSubjectWhereUniqueInput
      | AcademicYearSubjectWhereUniqueInput[];
    disconnect?:
      | AcademicYearSubjectWhereUniqueInput
      | AcademicYearSubjectWhereUniqueInput[];
    delete?:
      | AcademicYearSubjectWhereUniqueInput
      | AcademicYearSubjectWhereUniqueInput[];
    connect?:
      | AcademicYearSubjectWhereUniqueInput
      | AcademicYearSubjectWhereUniqueInput[];
    update?:
      | AcademicYearSubjectUpdateWithWhereUniqueWithoutCustomGradingInput
      | AcademicYearSubjectUpdateWithWhereUniqueWithoutCustomGradingInput[];
    updateMany?:
      | AcademicYearSubjectUpdateManyWithWhereWithoutCustomGradingInput
      | AcademicYearSubjectUpdateManyWithWhereWithoutCustomGradingInput[];
    deleteMany?:
      | AcademicYearSubjectScalarWhereInput
      | AcademicYearSubjectScalarWhereInput[];
  };

  export type SubjectUncheckedUpdateManyWithoutGradingNestedInput = {
    create?:
      | XOR<
          SubjectCreateWithoutGradingInput,
          SubjectUncheckedCreateWithoutGradingInput
        >
      | SubjectCreateWithoutGradingInput[]
      | SubjectUncheckedCreateWithoutGradingInput[];
    connectOrCreate?:
      | SubjectCreateOrConnectWithoutGradingInput
      | SubjectCreateOrConnectWithoutGradingInput[];
    upsert?:
      | SubjectUpsertWithWhereUniqueWithoutGradingInput
      | SubjectUpsertWithWhereUniqueWithoutGradingInput[];
    set?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[];
    disconnect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[];
    delete?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[];
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[];
    update?:
      | SubjectUpdateWithWhereUniqueWithoutGradingInput
      | SubjectUpdateWithWhereUniqueWithoutGradingInput[];
    updateMany?:
      | SubjectUpdateManyWithWhereWithoutGradingInput
      | SubjectUpdateManyWithWhereWithoutGradingInput[];
    deleteMany?: SubjectScalarWhereInput | SubjectScalarWhereInput[];
  };

  export type AcademicYearSubjectUncheckedUpdateManyWithoutCustomGradingNestedInput =
    {
      create?:
        | XOR<
            AcademicYearSubjectCreateWithoutCustomGradingInput,
            AcademicYearSubjectUncheckedCreateWithoutCustomGradingInput
          >
        | AcademicYearSubjectCreateWithoutCustomGradingInput[]
        | AcademicYearSubjectUncheckedCreateWithoutCustomGradingInput[];
      connectOrCreate?:
        | AcademicYearSubjectCreateOrConnectWithoutCustomGradingInput
        | AcademicYearSubjectCreateOrConnectWithoutCustomGradingInput[];
      upsert?:
        | AcademicYearSubjectUpsertWithWhereUniqueWithoutCustomGradingInput
        | AcademicYearSubjectUpsertWithWhereUniqueWithoutCustomGradingInput[];
      set?:
        | AcademicYearSubjectWhereUniqueInput
        | AcademicYearSubjectWhereUniqueInput[];
      disconnect?:
        | AcademicYearSubjectWhereUniqueInput
        | AcademicYearSubjectWhereUniqueInput[];
      delete?:
        | AcademicYearSubjectWhereUniqueInput
        | AcademicYearSubjectWhereUniqueInput[];
      connect?:
        | AcademicYearSubjectWhereUniqueInput
        | AcademicYearSubjectWhereUniqueInput[];
      update?:
        | AcademicYearSubjectUpdateWithWhereUniqueWithoutCustomGradingInput
        | AcademicYearSubjectUpdateWithWhereUniqueWithoutCustomGradingInput[];
      updateMany?:
        | AcademicYearSubjectUpdateManyWithWhereWithoutCustomGradingInput
        | AcademicYearSubjectUpdateManyWithWhereWithoutCustomGradingInput[];
      deleteMany?:
        | AcademicYearSubjectScalarWhereInput
        | AcademicYearSubjectScalarWhereInput[];
    };

  export type GradingCreateNestedManyWithoutAcademicYearSubjectsInput = {
    create?:
      | XOR<
          GradingCreateWithoutAcademicYearSubjectsInput,
          GradingUncheckedCreateWithoutAcademicYearSubjectsInput
        >
      | GradingCreateWithoutAcademicYearSubjectsInput[]
      | GradingUncheckedCreateWithoutAcademicYearSubjectsInput[];
    connectOrCreate?:
      | GradingCreateOrConnectWithoutAcademicYearSubjectsInput
      | GradingCreateOrConnectWithoutAcademicYearSubjectsInput[];
    connect?: GradingWhereUniqueInput | GradingWhereUniqueInput[];
  };

  export type AcademicYearClassCreateNestedOneWithoutAcademicYearSubjectsInput =
    {
      create?: XOR<
        AcademicYearClassCreateWithoutAcademicYearSubjectsInput,
        AcademicYearClassUncheckedCreateWithoutAcademicYearSubjectsInput
      >;
      connectOrCreate?: AcademicYearClassCreateOrConnectWithoutAcademicYearSubjectsInput;
      connect?: AcademicYearClassWhereUniqueInput;
    };

  export type StaffCreateNestedManyWithoutAcademicYearSubjectsInput = {
    create?:
      | XOR<
          StaffCreateWithoutAcademicYearSubjectsInput,
          StaffUncheckedCreateWithoutAcademicYearSubjectsInput
        >
      | StaffCreateWithoutAcademicYearSubjectsInput[]
      | StaffUncheckedCreateWithoutAcademicYearSubjectsInput[];
    connectOrCreate?:
      | StaffCreateOrConnectWithoutAcademicYearSubjectsInput
      | StaffCreateOrConnectWithoutAcademicYearSubjectsInput[];
    connect?: StaffWhereUniqueInput | StaffWhereUniqueInput[];
  };

  export type SubjectCreateNestedOneWithoutAcademicYearSubjectsInput = {
    create?: XOR<
      SubjectCreateWithoutAcademicYearSubjectsInput,
      SubjectUncheckedCreateWithoutAcademicYearSubjectsInput
    >;
    connectOrCreate?: SubjectCreateOrConnectWithoutAcademicYearSubjectsInput;
    connect?: SubjectWhereUniqueInput;
  };

  export type ExamSubjectCreateNestedManyWithoutAcademicYearSubjectInput = {
    create?:
      | XOR<
          ExamSubjectCreateWithoutAcademicYearSubjectInput,
          ExamSubjectUncheckedCreateWithoutAcademicYearSubjectInput
        >
      | ExamSubjectCreateWithoutAcademicYearSubjectInput[]
      | ExamSubjectUncheckedCreateWithoutAcademicYearSubjectInput[];
    connectOrCreate?:
      | ExamSubjectCreateOrConnectWithoutAcademicYearSubjectInput
      | ExamSubjectCreateOrConnectWithoutAcademicYearSubjectInput[];
    createMany?: ExamSubjectCreateManyAcademicYearSubjectInputEnvelope;
    connect?: ExamSubjectWhereUniqueInput | ExamSubjectWhereUniqueInput[];
  };

  export type GradingUncheckedCreateNestedManyWithoutAcademicYearSubjectsInput =
    {
      create?:
        | XOR<
            GradingCreateWithoutAcademicYearSubjectsInput,
            GradingUncheckedCreateWithoutAcademicYearSubjectsInput
          >
        | GradingCreateWithoutAcademicYearSubjectsInput[]
        | GradingUncheckedCreateWithoutAcademicYearSubjectsInput[];
      connectOrCreate?:
        | GradingCreateOrConnectWithoutAcademicYearSubjectsInput
        | GradingCreateOrConnectWithoutAcademicYearSubjectsInput[];
      connect?: GradingWhereUniqueInput | GradingWhereUniqueInput[];
    };

  export type StaffUncheckedCreateNestedManyWithoutAcademicYearSubjectsInput = {
    create?:
      | XOR<
          StaffCreateWithoutAcademicYearSubjectsInput,
          StaffUncheckedCreateWithoutAcademicYearSubjectsInput
        >
      | StaffCreateWithoutAcademicYearSubjectsInput[]
      | StaffUncheckedCreateWithoutAcademicYearSubjectsInput[];
    connectOrCreate?:
      | StaffCreateOrConnectWithoutAcademicYearSubjectsInput
      | StaffCreateOrConnectWithoutAcademicYearSubjectsInput[];
    connect?: StaffWhereUniqueInput | StaffWhereUniqueInput[];
  };

  export type ExamSubjectUncheckedCreateNestedManyWithoutAcademicYearSubjectInput =
    {
      create?:
        | XOR<
            ExamSubjectCreateWithoutAcademicYearSubjectInput,
            ExamSubjectUncheckedCreateWithoutAcademicYearSubjectInput
          >
        | ExamSubjectCreateWithoutAcademicYearSubjectInput[]
        | ExamSubjectUncheckedCreateWithoutAcademicYearSubjectInput[];
      connectOrCreate?:
        | ExamSubjectCreateOrConnectWithoutAcademicYearSubjectInput
        | ExamSubjectCreateOrConnectWithoutAcademicYearSubjectInput[];
      createMany?: ExamSubjectCreateManyAcademicYearSubjectInputEnvelope;
      connect?: ExamSubjectWhereUniqueInput | ExamSubjectWhereUniqueInput[];
    };

  export type GradingUpdateManyWithoutAcademicYearSubjectsNestedInput = {
    create?:
      | XOR<
          GradingCreateWithoutAcademicYearSubjectsInput,
          GradingUncheckedCreateWithoutAcademicYearSubjectsInput
        >
      | GradingCreateWithoutAcademicYearSubjectsInput[]
      | GradingUncheckedCreateWithoutAcademicYearSubjectsInput[];
    connectOrCreate?:
      | GradingCreateOrConnectWithoutAcademicYearSubjectsInput
      | GradingCreateOrConnectWithoutAcademicYearSubjectsInput[];
    upsert?:
      | GradingUpsertWithWhereUniqueWithoutAcademicYearSubjectsInput
      | GradingUpsertWithWhereUniqueWithoutAcademicYearSubjectsInput[];
    set?: GradingWhereUniqueInput | GradingWhereUniqueInput[];
    disconnect?: GradingWhereUniqueInput | GradingWhereUniqueInput[];
    delete?: GradingWhereUniqueInput | GradingWhereUniqueInput[];
    connect?: GradingWhereUniqueInput | GradingWhereUniqueInput[];
    update?:
      | GradingUpdateWithWhereUniqueWithoutAcademicYearSubjectsInput
      | GradingUpdateWithWhereUniqueWithoutAcademicYearSubjectsInput[];
    updateMany?:
      | GradingUpdateManyWithWhereWithoutAcademicYearSubjectsInput
      | GradingUpdateManyWithWhereWithoutAcademicYearSubjectsInput[];
    deleteMany?: GradingScalarWhereInput | GradingScalarWhereInput[];
  };

  export type AcademicYearClassUpdateOneRequiredWithoutAcademicYearSubjectsNestedInput =
    {
      create?: XOR<
        AcademicYearClassCreateWithoutAcademicYearSubjectsInput,
        AcademicYearClassUncheckedCreateWithoutAcademicYearSubjectsInput
      >;
      connectOrCreate?: AcademicYearClassCreateOrConnectWithoutAcademicYearSubjectsInput;
      upsert?: AcademicYearClassUpsertWithoutAcademicYearSubjectsInput;
      connect?: AcademicYearClassWhereUniqueInput;
      update?: XOR<
        XOR<
          AcademicYearClassUpdateToOneWithWhereWithoutAcademicYearSubjectsInput,
          AcademicYearClassUpdateWithoutAcademicYearSubjectsInput
        >,
        AcademicYearClassUncheckedUpdateWithoutAcademicYearSubjectsInput
      >;
    };

  export type StaffUpdateManyWithoutAcademicYearSubjectsNestedInput = {
    create?:
      | XOR<
          StaffCreateWithoutAcademicYearSubjectsInput,
          StaffUncheckedCreateWithoutAcademicYearSubjectsInput
        >
      | StaffCreateWithoutAcademicYearSubjectsInput[]
      | StaffUncheckedCreateWithoutAcademicYearSubjectsInput[];
    connectOrCreate?:
      | StaffCreateOrConnectWithoutAcademicYearSubjectsInput
      | StaffCreateOrConnectWithoutAcademicYearSubjectsInput[];
    upsert?:
      | StaffUpsertWithWhereUniqueWithoutAcademicYearSubjectsInput
      | StaffUpsertWithWhereUniqueWithoutAcademicYearSubjectsInput[];
    set?: StaffWhereUniqueInput | StaffWhereUniqueInput[];
    disconnect?: StaffWhereUniqueInput | StaffWhereUniqueInput[];
    delete?: StaffWhereUniqueInput | StaffWhereUniqueInput[];
    connect?: StaffWhereUniqueInput | StaffWhereUniqueInput[];
    update?:
      | StaffUpdateWithWhereUniqueWithoutAcademicYearSubjectsInput
      | StaffUpdateWithWhereUniqueWithoutAcademicYearSubjectsInput[];
    updateMany?:
      | StaffUpdateManyWithWhereWithoutAcademicYearSubjectsInput
      | StaffUpdateManyWithWhereWithoutAcademicYearSubjectsInput[];
    deleteMany?: StaffScalarWhereInput | StaffScalarWhereInput[];
  };

  export type SubjectUpdateOneRequiredWithoutAcademicYearSubjectsNestedInput = {
    create?: XOR<
      SubjectCreateWithoutAcademicYearSubjectsInput,
      SubjectUncheckedCreateWithoutAcademicYearSubjectsInput
    >;
    connectOrCreate?: SubjectCreateOrConnectWithoutAcademicYearSubjectsInput;
    upsert?: SubjectUpsertWithoutAcademicYearSubjectsInput;
    connect?: SubjectWhereUniqueInput;
    update?: XOR<
      XOR<
        SubjectUpdateToOneWithWhereWithoutAcademicYearSubjectsInput,
        SubjectUpdateWithoutAcademicYearSubjectsInput
      >,
      SubjectUncheckedUpdateWithoutAcademicYearSubjectsInput
    >;
  };

  export type ExamSubjectUpdateManyWithoutAcademicYearSubjectNestedInput = {
    create?:
      | XOR<
          ExamSubjectCreateWithoutAcademicYearSubjectInput,
          ExamSubjectUncheckedCreateWithoutAcademicYearSubjectInput
        >
      | ExamSubjectCreateWithoutAcademicYearSubjectInput[]
      | ExamSubjectUncheckedCreateWithoutAcademicYearSubjectInput[];
    connectOrCreate?:
      | ExamSubjectCreateOrConnectWithoutAcademicYearSubjectInput
      | ExamSubjectCreateOrConnectWithoutAcademicYearSubjectInput[];
    upsert?:
      | ExamSubjectUpsertWithWhereUniqueWithoutAcademicYearSubjectInput
      | ExamSubjectUpsertWithWhereUniqueWithoutAcademicYearSubjectInput[];
    createMany?: ExamSubjectCreateManyAcademicYearSubjectInputEnvelope;
    set?: ExamSubjectWhereUniqueInput | ExamSubjectWhereUniqueInput[];
    disconnect?: ExamSubjectWhereUniqueInput | ExamSubjectWhereUniqueInput[];
    delete?: ExamSubjectWhereUniqueInput | ExamSubjectWhereUniqueInput[];
    connect?: ExamSubjectWhereUniqueInput | ExamSubjectWhereUniqueInput[];
    update?:
      | ExamSubjectUpdateWithWhereUniqueWithoutAcademicYearSubjectInput
      | ExamSubjectUpdateWithWhereUniqueWithoutAcademicYearSubjectInput[];
    updateMany?:
      | ExamSubjectUpdateManyWithWhereWithoutAcademicYearSubjectInput
      | ExamSubjectUpdateManyWithWhereWithoutAcademicYearSubjectInput[];
    deleteMany?: ExamSubjectScalarWhereInput | ExamSubjectScalarWhereInput[];
  };

  export type GradingUncheckedUpdateManyWithoutAcademicYearSubjectsNestedInput =
    {
      create?:
        | XOR<
            GradingCreateWithoutAcademicYearSubjectsInput,
            GradingUncheckedCreateWithoutAcademicYearSubjectsInput
          >
        | GradingCreateWithoutAcademicYearSubjectsInput[]
        | GradingUncheckedCreateWithoutAcademicYearSubjectsInput[];
      connectOrCreate?:
        | GradingCreateOrConnectWithoutAcademicYearSubjectsInput
        | GradingCreateOrConnectWithoutAcademicYearSubjectsInput[];
      upsert?:
        | GradingUpsertWithWhereUniqueWithoutAcademicYearSubjectsInput
        | GradingUpsertWithWhereUniqueWithoutAcademicYearSubjectsInput[];
      set?: GradingWhereUniqueInput | GradingWhereUniqueInput[];
      disconnect?: GradingWhereUniqueInput | GradingWhereUniqueInput[];
      delete?: GradingWhereUniqueInput | GradingWhereUniqueInput[];
      connect?: GradingWhereUniqueInput | GradingWhereUniqueInput[];
      update?:
        | GradingUpdateWithWhereUniqueWithoutAcademicYearSubjectsInput
        | GradingUpdateWithWhereUniqueWithoutAcademicYearSubjectsInput[];
      updateMany?:
        | GradingUpdateManyWithWhereWithoutAcademicYearSubjectsInput
        | GradingUpdateManyWithWhereWithoutAcademicYearSubjectsInput[];
      deleteMany?: GradingScalarWhereInput | GradingScalarWhereInput[];
    };

  export type StaffUncheckedUpdateManyWithoutAcademicYearSubjectsNestedInput = {
    create?:
      | XOR<
          StaffCreateWithoutAcademicYearSubjectsInput,
          StaffUncheckedCreateWithoutAcademicYearSubjectsInput
        >
      | StaffCreateWithoutAcademicYearSubjectsInput[]
      | StaffUncheckedCreateWithoutAcademicYearSubjectsInput[];
    connectOrCreate?:
      | StaffCreateOrConnectWithoutAcademicYearSubjectsInput
      | StaffCreateOrConnectWithoutAcademicYearSubjectsInput[];
    upsert?:
      | StaffUpsertWithWhereUniqueWithoutAcademicYearSubjectsInput
      | StaffUpsertWithWhereUniqueWithoutAcademicYearSubjectsInput[];
    set?: StaffWhereUniqueInput | StaffWhereUniqueInput[];
    disconnect?: StaffWhereUniqueInput | StaffWhereUniqueInput[];
    delete?: StaffWhereUniqueInput | StaffWhereUniqueInput[];
    connect?: StaffWhereUniqueInput | StaffWhereUniqueInput[];
    update?:
      | StaffUpdateWithWhereUniqueWithoutAcademicYearSubjectsInput
      | StaffUpdateWithWhereUniqueWithoutAcademicYearSubjectsInput[];
    updateMany?:
      | StaffUpdateManyWithWhereWithoutAcademicYearSubjectsInput
      | StaffUpdateManyWithWhereWithoutAcademicYearSubjectsInput[];
    deleteMany?: StaffScalarWhereInput | StaffScalarWhereInput[];
  };

  export type ExamSubjectUncheckedUpdateManyWithoutAcademicYearSubjectNestedInput =
    {
      create?:
        | XOR<
            ExamSubjectCreateWithoutAcademicYearSubjectInput,
            ExamSubjectUncheckedCreateWithoutAcademicYearSubjectInput
          >
        | ExamSubjectCreateWithoutAcademicYearSubjectInput[]
        | ExamSubjectUncheckedCreateWithoutAcademicYearSubjectInput[];
      connectOrCreate?:
        | ExamSubjectCreateOrConnectWithoutAcademicYearSubjectInput
        | ExamSubjectCreateOrConnectWithoutAcademicYearSubjectInput[];
      upsert?:
        | ExamSubjectUpsertWithWhereUniqueWithoutAcademicYearSubjectInput
        | ExamSubjectUpsertWithWhereUniqueWithoutAcademicYearSubjectInput[];
      createMany?: ExamSubjectCreateManyAcademicYearSubjectInputEnvelope;
      set?: ExamSubjectWhereUniqueInput | ExamSubjectWhereUniqueInput[];
      disconnect?: ExamSubjectWhereUniqueInput | ExamSubjectWhereUniqueInput[];
      delete?: ExamSubjectWhereUniqueInput | ExamSubjectWhereUniqueInput[];
      connect?: ExamSubjectWhereUniqueInput | ExamSubjectWhereUniqueInput[];
      update?:
        | ExamSubjectUpdateWithWhereUniqueWithoutAcademicYearSubjectInput
        | ExamSubjectUpdateWithWhereUniqueWithoutAcademicYearSubjectInput[];
      updateMany?:
        | ExamSubjectUpdateManyWithWhereWithoutAcademicYearSubjectInput
        | ExamSubjectUpdateManyWithWhereWithoutAcademicYearSubjectInput[];
      deleteMany?: ExamSubjectScalarWhereInput | ExamSubjectScalarWhereInput[];
    };

  export type PupilCreateNestedManyWithoutClassStreamsInput = {
    create?:
      | XOR<
          PupilCreateWithoutClassStreamsInput,
          PupilUncheckedCreateWithoutClassStreamsInput
        >
      | PupilCreateWithoutClassStreamsInput[]
      | PupilUncheckedCreateWithoutClassStreamsInput[];
    connectOrCreate?:
      | PupilCreateOrConnectWithoutClassStreamsInput
      | PupilCreateOrConnectWithoutClassStreamsInput[];
    connect?: PupilWhereUniqueInput | PupilWhereUniqueInput[];
  };

  export type AcademicYearClassCreateNestedOneWithoutStreamsInput = {
    create?: XOR<
      AcademicYearClassCreateWithoutStreamsInput,
      AcademicYearClassUncheckedCreateWithoutStreamsInput
    >;
    connectOrCreate?: AcademicYearClassCreateOrConnectWithoutStreamsInput;
    connect?: AcademicYearClassWhereUniqueInput;
  };

  export type StaffCreateNestedOneWithoutClassStreamsInput = {
    create?: XOR<
      StaffCreateWithoutClassStreamsInput,
      StaffUncheckedCreateWithoutClassStreamsInput
    >;
    connectOrCreate?: StaffCreateOrConnectWithoutClassStreamsInput;
    connect?: StaffWhereUniqueInput;
  };

  export type StreamCreateNestedOneWithoutClassStreamsInput = {
    create?: XOR<
      StreamCreateWithoutClassStreamsInput,
      StreamUncheckedCreateWithoutClassStreamsInput
    >;
    connectOrCreate?: StreamCreateOrConnectWithoutClassStreamsInput;
    connect?: StreamWhereUniqueInput;
  };

  export type ClassTermCreateNestedManyWithoutClassStreamInput = {
    create?:
      | XOR<
          ClassTermCreateWithoutClassStreamInput,
          ClassTermUncheckedCreateWithoutClassStreamInput
        >
      | ClassTermCreateWithoutClassStreamInput[]
      | ClassTermUncheckedCreateWithoutClassStreamInput[];
    connectOrCreate?:
      | ClassTermCreateOrConnectWithoutClassStreamInput
      | ClassTermCreateOrConnectWithoutClassStreamInput[];
    createMany?: ClassTermCreateManyClassStreamInputEnvelope;
    connect?: ClassTermWhereUniqueInput | ClassTermWhereUniqueInput[];
  };

  export type PupilUncheckedCreateNestedManyWithoutClassStreamsInput = {
    create?:
      | XOR<
          PupilCreateWithoutClassStreamsInput,
          PupilUncheckedCreateWithoutClassStreamsInput
        >
      | PupilCreateWithoutClassStreamsInput[]
      | PupilUncheckedCreateWithoutClassStreamsInput[];
    connectOrCreate?:
      | PupilCreateOrConnectWithoutClassStreamsInput
      | PupilCreateOrConnectWithoutClassStreamsInput[];
    connect?: PupilWhereUniqueInput | PupilWhereUniqueInput[];
  };

  export type ClassTermUncheckedCreateNestedManyWithoutClassStreamInput = {
    create?:
      | XOR<
          ClassTermCreateWithoutClassStreamInput,
          ClassTermUncheckedCreateWithoutClassStreamInput
        >
      | ClassTermCreateWithoutClassStreamInput[]
      | ClassTermUncheckedCreateWithoutClassStreamInput[];
    connectOrCreate?:
      | ClassTermCreateOrConnectWithoutClassStreamInput
      | ClassTermCreateOrConnectWithoutClassStreamInput[];
    createMany?: ClassTermCreateManyClassStreamInputEnvelope;
    connect?: ClassTermWhereUniqueInput | ClassTermWhereUniqueInput[];
  };

  export type PupilUpdateManyWithoutClassStreamsNestedInput = {
    create?:
      | XOR<
          PupilCreateWithoutClassStreamsInput,
          PupilUncheckedCreateWithoutClassStreamsInput
        >
      | PupilCreateWithoutClassStreamsInput[]
      | PupilUncheckedCreateWithoutClassStreamsInput[];
    connectOrCreate?:
      | PupilCreateOrConnectWithoutClassStreamsInput
      | PupilCreateOrConnectWithoutClassStreamsInput[];
    upsert?:
      | PupilUpsertWithWhereUniqueWithoutClassStreamsInput
      | PupilUpsertWithWhereUniqueWithoutClassStreamsInput[];
    set?: PupilWhereUniqueInput | PupilWhereUniqueInput[];
    disconnect?: PupilWhereUniqueInput | PupilWhereUniqueInput[];
    delete?: PupilWhereUniqueInput | PupilWhereUniqueInput[];
    connect?: PupilWhereUniqueInput | PupilWhereUniqueInput[];
    update?:
      | PupilUpdateWithWhereUniqueWithoutClassStreamsInput
      | PupilUpdateWithWhereUniqueWithoutClassStreamsInput[];
    updateMany?:
      | PupilUpdateManyWithWhereWithoutClassStreamsInput
      | PupilUpdateManyWithWhereWithoutClassStreamsInput[];
    deleteMany?: PupilScalarWhereInput | PupilScalarWhereInput[];
  };

  export type AcademicYearClassUpdateOneWithoutStreamsNestedInput = {
    create?: XOR<
      AcademicYearClassCreateWithoutStreamsInput,
      AcademicYearClassUncheckedCreateWithoutStreamsInput
    >;
    connectOrCreate?: AcademicYearClassCreateOrConnectWithoutStreamsInput;
    upsert?: AcademicYearClassUpsertWithoutStreamsInput;
    disconnect?: AcademicYearClassWhereInput | boolean;
    delete?: AcademicYearClassWhereInput | boolean;
    connect?: AcademicYearClassWhereUniqueInput;
    update?: XOR<
      XOR<
        AcademicYearClassUpdateToOneWithWhereWithoutStreamsInput,
        AcademicYearClassUpdateWithoutStreamsInput
      >,
      AcademicYearClassUncheckedUpdateWithoutStreamsInput
    >;
  };

  export type StaffUpdateOneWithoutClassStreamsNestedInput = {
    create?: XOR<
      StaffCreateWithoutClassStreamsInput,
      StaffUncheckedCreateWithoutClassStreamsInput
    >;
    connectOrCreate?: StaffCreateOrConnectWithoutClassStreamsInput;
    upsert?: StaffUpsertWithoutClassStreamsInput;
    disconnect?: StaffWhereInput | boolean;
    delete?: StaffWhereInput | boolean;
    connect?: StaffWhereUniqueInput;
    update?: XOR<
      XOR<
        StaffUpdateToOneWithWhereWithoutClassStreamsInput,
        StaffUpdateWithoutClassStreamsInput
      >,
      StaffUncheckedUpdateWithoutClassStreamsInput
    >;
  };

  export type StreamUpdateOneWithoutClassStreamsNestedInput = {
    create?: XOR<
      StreamCreateWithoutClassStreamsInput,
      StreamUncheckedCreateWithoutClassStreamsInput
    >;
    connectOrCreate?: StreamCreateOrConnectWithoutClassStreamsInput;
    upsert?: StreamUpsertWithoutClassStreamsInput;
    disconnect?: StreamWhereInput | boolean;
    delete?: StreamWhereInput | boolean;
    connect?: StreamWhereUniqueInput;
    update?: XOR<
      XOR<
        StreamUpdateToOneWithWhereWithoutClassStreamsInput,
        StreamUpdateWithoutClassStreamsInput
      >,
      StreamUncheckedUpdateWithoutClassStreamsInput
    >;
  };

  export type ClassTermUpdateManyWithoutClassStreamNestedInput = {
    create?:
      | XOR<
          ClassTermCreateWithoutClassStreamInput,
          ClassTermUncheckedCreateWithoutClassStreamInput
        >
      | ClassTermCreateWithoutClassStreamInput[]
      | ClassTermUncheckedCreateWithoutClassStreamInput[];
    connectOrCreate?:
      | ClassTermCreateOrConnectWithoutClassStreamInput
      | ClassTermCreateOrConnectWithoutClassStreamInput[];
    upsert?:
      | ClassTermUpsertWithWhereUniqueWithoutClassStreamInput
      | ClassTermUpsertWithWhereUniqueWithoutClassStreamInput[];
    createMany?: ClassTermCreateManyClassStreamInputEnvelope;
    set?: ClassTermWhereUniqueInput | ClassTermWhereUniqueInput[];
    disconnect?: ClassTermWhereUniqueInput | ClassTermWhereUniqueInput[];
    delete?: ClassTermWhereUniqueInput | ClassTermWhereUniqueInput[];
    connect?: ClassTermWhereUniqueInput | ClassTermWhereUniqueInput[];
    update?:
      | ClassTermUpdateWithWhereUniqueWithoutClassStreamInput
      | ClassTermUpdateWithWhereUniqueWithoutClassStreamInput[];
    updateMany?:
      | ClassTermUpdateManyWithWhereWithoutClassStreamInput
      | ClassTermUpdateManyWithWhereWithoutClassStreamInput[];
    deleteMany?: ClassTermScalarWhereInput | ClassTermScalarWhereInput[];
  };

  export type PupilUncheckedUpdateManyWithoutClassStreamsNestedInput = {
    create?:
      | XOR<
          PupilCreateWithoutClassStreamsInput,
          PupilUncheckedCreateWithoutClassStreamsInput
        >
      | PupilCreateWithoutClassStreamsInput[]
      | PupilUncheckedCreateWithoutClassStreamsInput[];
    connectOrCreate?:
      | PupilCreateOrConnectWithoutClassStreamsInput
      | PupilCreateOrConnectWithoutClassStreamsInput[];
    upsert?:
      | PupilUpsertWithWhereUniqueWithoutClassStreamsInput
      | PupilUpsertWithWhereUniqueWithoutClassStreamsInput[];
    set?: PupilWhereUniqueInput | PupilWhereUniqueInput[];
    disconnect?: PupilWhereUniqueInput | PupilWhereUniqueInput[];
    delete?: PupilWhereUniqueInput | PupilWhereUniqueInput[];
    connect?: PupilWhereUniqueInput | PupilWhereUniqueInput[];
    update?:
      | PupilUpdateWithWhereUniqueWithoutClassStreamsInput
      | PupilUpdateWithWhereUniqueWithoutClassStreamsInput[];
    updateMany?:
      | PupilUpdateManyWithWhereWithoutClassStreamsInput
      | PupilUpdateManyWithWhereWithoutClassStreamsInput[];
    deleteMany?: PupilScalarWhereInput | PupilScalarWhereInput[];
  };

  export type ClassTermUncheckedUpdateManyWithoutClassStreamNestedInput = {
    create?:
      | XOR<
          ClassTermCreateWithoutClassStreamInput,
          ClassTermUncheckedCreateWithoutClassStreamInput
        >
      | ClassTermCreateWithoutClassStreamInput[]
      | ClassTermUncheckedCreateWithoutClassStreamInput[];
    connectOrCreate?:
      | ClassTermCreateOrConnectWithoutClassStreamInput
      | ClassTermCreateOrConnectWithoutClassStreamInput[];
    upsert?:
      | ClassTermUpsertWithWhereUniqueWithoutClassStreamInput
      | ClassTermUpsertWithWhereUniqueWithoutClassStreamInput[];
    createMany?: ClassTermCreateManyClassStreamInputEnvelope;
    set?: ClassTermWhereUniqueInput | ClassTermWhereUniqueInput[];
    disconnect?: ClassTermWhereUniqueInput | ClassTermWhereUniqueInput[];
    delete?: ClassTermWhereUniqueInput | ClassTermWhereUniqueInput[];
    connect?: ClassTermWhereUniqueInput | ClassTermWhereUniqueInput[];
    update?:
      | ClassTermUpdateWithWhereUniqueWithoutClassStreamInput
      | ClassTermUpdateWithWhereUniqueWithoutClassStreamInput[];
    updateMany?:
      | ClassTermUpdateManyWithWhereWithoutClassStreamInput
      | ClassTermUpdateManyWithWhereWithoutClassStreamInput[];
    deleteMany?: ClassTermScalarWhereInput | ClassTermScalarWhereInput[];
  };

  export type ClassTermCreateNestedManyWithoutTermInput = {
    create?:
      | XOR<
          ClassTermCreateWithoutTermInput,
          ClassTermUncheckedCreateWithoutTermInput
        >
      | ClassTermCreateWithoutTermInput[]
      | ClassTermUncheckedCreateWithoutTermInput[];
    connectOrCreate?:
      | ClassTermCreateOrConnectWithoutTermInput
      | ClassTermCreateOrConnectWithoutTermInput[];
    createMany?: ClassTermCreateManyTermInputEnvelope;
    connect?: ClassTermWhereUniqueInput | ClassTermWhereUniqueInput[];
  };

  export type ClassTermUncheckedCreateNestedManyWithoutTermInput = {
    create?:
      | XOR<
          ClassTermCreateWithoutTermInput,
          ClassTermUncheckedCreateWithoutTermInput
        >
      | ClassTermCreateWithoutTermInput[]
      | ClassTermUncheckedCreateWithoutTermInput[];
    connectOrCreate?:
      | ClassTermCreateOrConnectWithoutTermInput
      | ClassTermCreateOrConnectWithoutTermInput[];
    createMany?: ClassTermCreateManyTermInputEnvelope;
    connect?: ClassTermWhereUniqueInput | ClassTermWhereUniqueInput[];
  };

  export type ClassTermUpdateManyWithoutTermNestedInput = {
    create?:
      | XOR<
          ClassTermCreateWithoutTermInput,
          ClassTermUncheckedCreateWithoutTermInput
        >
      | ClassTermCreateWithoutTermInput[]
      | ClassTermUncheckedCreateWithoutTermInput[];
    connectOrCreate?:
      | ClassTermCreateOrConnectWithoutTermInput
      | ClassTermCreateOrConnectWithoutTermInput[];
    upsert?:
      | ClassTermUpsertWithWhereUniqueWithoutTermInput
      | ClassTermUpsertWithWhereUniqueWithoutTermInput[];
    createMany?: ClassTermCreateManyTermInputEnvelope;
    set?: ClassTermWhereUniqueInput | ClassTermWhereUniqueInput[];
    disconnect?: ClassTermWhereUniqueInput | ClassTermWhereUniqueInput[];
    delete?: ClassTermWhereUniqueInput | ClassTermWhereUniqueInput[];
    connect?: ClassTermWhereUniqueInput | ClassTermWhereUniqueInput[];
    update?:
      | ClassTermUpdateWithWhereUniqueWithoutTermInput
      | ClassTermUpdateWithWhereUniqueWithoutTermInput[];
    updateMany?:
      | ClassTermUpdateManyWithWhereWithoutTermInput
      | ClassTermUpdateManyWithWhereWithoutTermInput[];
    deleteMany?: ClassTermScalarWhereInput | ClassTermScalarWhereInput[];
  };

  export type ClassTermUncheckedUpdateManyWithoutTermNestedInput = {
    create?:
      | XOR<
          ClassTermCreateWithoutTermInput,
          ClassTermUncheckedCreateWithoutTermInput
        >
      | ClassTermCreateWithoutTermInput[]
      | ClassTermUncheckedCreateWithoutTermInput[];
    connectOrCreate?:
      | ClassTermCreateOrConnectWithoutTermInput
      | ClassTermCreateOrConnectWithoutTermInput[];
    upsert?:
      | ClassTermUpsertWithWhereUniqueWithoutTermInput
      | ClassTermUpsertWithWhereUniqueWithoutTermInput[];
    createMany?: ClassTermCreateManyTermInputEnvelope;
    set?: ClassTermWhereUniqueInput | ClassTermWhereUniqueInput[];
    disconnect?: ClassTermWhereUniqueInput | ClassTermWhereUniqueInput[];
    delete?: ClassTermWhereUniqueInput | ClassTermWhereUniqueInput[];
    connect?: ClassTermWhereUniqueInput | ClassTermWhereUniqueInput[];
    update?:
      | ClassTermUpdateWithWhereUniqueWithoutTermInput
      | ClassTermUpdateWithWhereUniqueWithoutTermInput[];
    updateMany?:
      | ClassTermUpdateManyWithWhereWithoutTermInput
      | ClassTermUpdateManyWithWhereWithoutTermInput[];
    deleteMany?: ClassTermScalarWhereInput | ClassTermScalarWhereInput[];
  };

  export type classStreamCreateNestedOneWithoutTermsInput = {
    create?: XOR<
      classStreamCreateWithoutTermsInput,
      classStreamUncheckedCreateWithoutTermsInput
    >;
    connectOrCreate?: classStreamCreateOrConnectWithoutTermsInput;
    connect?: classStreamWhereUniqueInput;
  };

  export type TermCreateNestedOneWithoutClassTermsInput = {
    create?: XOR<
      TermCreateWithoutClassTermsInput,
      TermUncheckedCreateWithoutClassTermsInput
    >;
    connectOrCreate?: TermCreateOrConnectWithoutClassTermsInput;
    connect?: TermWhereUniqueInput;
  };

  export type ExamCreateNestedManyWithoutClassTermInput = {
    create?:
      | XOR<
          ExamCreateWithoutClassTermInput,
          ExamUncheckedCreateWithoutClassTermInput
        >
      | ExamCreateWithoutClassTermInput[]
      | ExamUncheckedCreateWithoutClassTermInput[];
    connectOrCreate?:
      | ExamCreateOrConnectWithoutClassTermInput
      | ExamCreateOrConnectWithoutClassTermInput[];
    createMany?: ExamCreateManyClassTermInputEnvelope;
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[];
  };

  export type FeesCreateNestedManyWithoutTermInput = {
    create?:
      | XOR<FeesCreateWithoutTermInput, FeesUncheckedCreateWithoutTermInput>
      | FeesCreateWithoutTermInput[]
      | FeesUncheckedCreateWithoutTermInput[];
    connectOrCreate?:
      | FeesCreateOrConnectWithoutTermInput
      | FeesCreateOrConnectWithoutTermInput[];
    createMany?: FeesCreateManyTermInputEnvelope;
    connect?: FeesWhereUniqueInput | FeesWhereUniqueInput[];
  };

  export type ExamUncheckedCreateNestedManyWithoutClassTermInput = {
    create?:
      | XOR<
          ExamCreateWithoutClassTermInput,
          ExamUncheckedCreateWithoutClassTermInput
        >
      | ExamCreateWithoutClassTermInput[]
      | ExamUncheckedCreateWithoutClassTermInput[];
    connectOrCreate?:
      | ExamCreateOrConnectWithoutClassTermInput
      | ExamCreateOrConnectWithoutClassTermInput[];
    createMany?: ExamCreateManyClassTermInputEnvelope;
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[];
  };

  export type FeesUncheckedCreateNestedManyWithoutTermInput = {
    create?:
      | XOR<FeesCreateWithoutTermInput, FeesUncheckedCreateWithoutTermInput>
      | FeesCreateWithoutTermInput[]
      | FeesUncheckedCreateWithoutTermInput[];
    connectOrCreate?:
      | FeesCreateOrConnectWithoutTermInput
      | FeesCreateOrConnectWithoutTermInput[];
    createMany?: FeesCreateManyTermInputEnvelope;
    connect?: FeesWhereUniqueInput | FeesWhereUniqueInput[];
  };

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null;
    increment?: number;
    decrement?: number;
    multiply?: number;
    divide?: number;
  };

  export type classStreamUpdateOneWithoutTermsNestedInput = {
    create?: XOR<
      classStreamCreateWithoutTermsInput,
      classStreamUncheckedCreateWithoutTermsInput
    >;
    connectOrCreate?: classStreamCreateOrConnectWithoutTermsInput;
    upsert?: classStreamUpsertWithoutTermsInput;
    disconnect?: classStreamWhereInput | boolean;
    delete?: classStreamWhereInput | boolean;
    connect?: classStreamWhereUniqueInput;
    update?: XOR<
      XOR<
        classStreamUpdateToOneWithWhereWithoutTermsInput,
        classStreamUpdateWithoutTermsInput
      >,
      classStreamUncheckedUpdateWithoutTermsInput
    >;
  };

  export type TermUpdateOneWithoutClassTermsNestedInput = {
    create?: XOR<
      TermCreateWithoutClassTermsInput,
      TermUncheckedCreateWithoutClassTermsInput
    >;
    connectOrCreate?: TermCreateOrConnectWithoutClassTermsInput;
    upsert?: TermUpsertWithoutClassTermsInput;
    disconnect?: TermWhereInput | boolean;
    delete?: TermWhereInput | boolean;
    connect?: TermWhereUniqueInput;
    update?: XOR<
      XOR<
        TermUpdateToOneWithWhereWithoutClassTermsInput,
        TermUpdateWithoutClassTermsInput
      >,
      TermUncheckedUpdateWithoutClassTermsInput
    >;
  };

  export type ExamUpdateManyWithoutClassTermNestedInput = {
    create?:
      | XOR<
          ExamCreateWithoutClassTermInput,
          ExamUncheckedCreateWithoutClassTermInput
        >
      | ExamCreateWithoutClassTermInput[]
      | ExamUncheckedCreateWithoutClassTermInput[];
    connectOrCreate?:
      | ExamCreateOrConnectWithoutClassTermInput
      | ExamCreateOrConnectWithoutClassTermInput[];
    upsert?:
      | ExamUpsertWithWhereUniqueWithoutClassTermInput
      | ExamUpsertWithWhereUniqueWithoutClassTermInput[];
    createMany?: ExamCreateManyClassTermInputEnvelope;
    set?: ExamWhereUniqueInput | ExamWhereUniqueInput[];
    disconnect?: ExamWhereUniqueInput | ExamWhereUniqueInput[];
    delete?: ExamWhereUniqueInput | ExamWhereUniqueInput[];
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[];
    update?:
      | ExamUpdateWithWhereUniqueWithoutClassTermInput
      | ExamUpdateWithWhereUniqueWithoutClassTermInput[];
    updateMany?:
      | ExamUpdateManyWithWhereWithoutClassTermInput
      | ExamUpdateManyWithWhereWithoutClassTermInput[];
    deleteMany?: ExamScalarWhereInput | ExamScalarWhereInput[];
  };

  export type FeesUpdateManyWithoutTermNestedInput = {
    create?:
      | XOR<FeesCreateWithoutTermInput, FeesUncheckedCreateWithoutTermInput>
      | FeesCreateWithoutTermInput[]
      | FeesUncheckedCreateWithoutTermInput[];
    connectOrCreate?:
      | FeesCreateOrConnectWithoutTermInput
      | FeesCreateOrConnectWithoutTermInput[];
    upsert?:
      | FeesUpsertWithWhereUniqueWithoutTermInput
      | FeesUpsertWithWhereUniqueWithoutTermInput[];
    createMany?: FeesCreateManyTermInputEnvelope;
    set?: FeesWhereUniqueInput | FeesWhereUniqueInput[];
    disconnect?: FeesWhereUniqueInput | FeesWhereUniqueInput[];
    delete?: FeesWhereUniqueInput | FeesWhereUniqueInput[];
    connect?: FeesWhereUniqueInput | FeesWhereUniqueInput[];
    update?:
      | FeesUpdateWithWhereUniqueWithoutTermInput
      | FeesUpdateWithWhereUniqueWithoutTermInput[];
    updateMany?:
      | FeesUpdateManyWithWhereWithoutTermInput
      | FeesUpdateManyWithWhereWithoutTermInput[];
    deleteMany?: FeesScalarWhereInput | FeesScalarWhereInput[];
  };

  export type ExamUncheckedUpdateManyWithoutClassTermNestedInput = {
    create?:
      | XOR<
          ExamCreateWithoutClassTermInput,
          ExamUncheckedCreateWithoutClassTermInput
        >
      | ExamCreateWithoutClassTermInput[]
      | ExamUncheckedCreateWithoutClassTermInput[];
    connectOrCreate?:
      | ExamCreateOrConnectWithoutClassTermInput
      | ExamCreateOrConnectWithoutClassTermInput[];
    upsert?:
      | ExamUpsertWithWhereUniqueWithoutClassTermInput
      | ExamUpsertWithWhereUniqueWithoutClassTermInput[];
    createMany?: ExamCreateManyClassTermInputEnvelope;
    set?: ExamWhereUniqueInput | ExamWhereUniqueInput[];
    disconnect?: ExamWhereUniqueInput | ExamWhereUniqueInput[];
    delete?: ExamWhereUniqueInput | ExamWhereUniqueInput[];
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[];
    update?:
      | ExamUpdateWithWhereUniqueWithoutClassTermInput
      | ExamUpdateWithWhereUniqueWithoutClassTermInput[];
    updateMany?:
      | ExamUpdateManyWithWhereWithoutClassTermInput
      | ExamUpdateManyWithWhereWithoutClassTermInput[];
    deleteMany?: ExamScalarWhereInput | ExamScalarWhereInput[];
  };

  export type FeesUncheckedUpdateManyWithoutTermNestedInput = {
    create?:
      | XOR<FeesCreateWithoutTermInput, FeesUncheckedCreateWithoutTermInput>
      | FeesCreateWithoutTermInput[]
      | FeesUncheckedCreateWithoutTermInput[];
    connectOrCreate?:
      | FeesCreateOrConnectWithoutTermInput
      | FeesCreateOrConnectWithoutTermInput[];
    upsert?:
      | FeesUpsertWithWhereUniqueWithoutTermInput
      | FeesUpsertWithWhereUniqueWithoutTermInput[];
    createMany?: FeesCreateManyTermInputEnvelope;
    set?: FeesWhereUniqueInput | FeesWhereUniqueInput[];
    disconnect?: FeesWhereUniqueInput | FeesWhereUniqueInput[];
    delete?: FeesWhereUniqueInput | FeesWhereUniqueInput[];
    connect?: FeesWhereUniqueInput | FeesWhereUniqueInput[];
    update?:
      | FeesUpdateWithWhereUniqueWithoutTermInput
      | FeesUpdateWithWhereUniqueWithoutTermInput[];
    updateMany?:
      | FeesUpdateManyWithWhereWithoutTermInput
      | FeesUpdateManyWithWhereWithoutTermInput[];
    deleteMany?: FeesScalarWhereInput | FeesScalarWhereInput[];
  };

  export type PupilCreateNestedOneWithoutFeesInput = {
    create?: XOR<
      PupilCreateWithoutFeesInput,
      PupilUncheckedCreateWithoutFeesInput
    >;
    connectOrCreate?: PupilCreateOrConnectWithoutFeesInput;
    connect?: PupilWhereUniqueInput;
  };

  export type ClassTermCreateNestedOneWithoutFeesInput = {
    create?: XOR<
      ClassTermCreateWithoutFeesInput,
      ClassTermUncheckedCreateWithoutFeesInput
    >;
    connectOrCreate?: ClassTermCreateOrConnectWithoutFeesInput;
    connect?: ClassTermWhereUniqueInput;
  };

  export type FeesPaymentCreateNestedManyWithoutFeesInput = {
    create?:
      | XOR<
          FeesPaymentCreateWithoutFeesInput,
          FeesPaymentUncheckedCreateWithoutFeesInput
        >
      | FeesPaymentCreateWithoutFeesInput[]
      | FeesPaymentUncheckedCreateWithoutFeesInput[];
    connectOrCreate?:
      | FeesPaymentCreateOrConnectWithoutFeesInput
      | FeesPaymentCreateOrConnectWithoutFeesInput[];
    createMany?: FeesPaymentCreateManyFeesInputEnvelope;
    connect?: FeesPaymentWhereUniqueInput | FeesPaymentWhereUniqueInput[];
  };

  export type FeesPaymentUncheckedCreateNestedManyWithoutFeesInput = {
    create?:
      | XOR<
          FeesPaymentCreateWithoutFeesInput,
          FeesPaymentUncheckedCreateWithoutFeesInput
        >
      | FeesPaymentCreateWithoutFeesInput[]
      | FeesPaymentUncheckedCreateWithoutFeesInput[];
    connectOrCreate?:
      | FeesPaymentCreateOrConnectWithoutFeesInput
      | FeesPaymentCreateOrConnectWithoutFeesInput[];
    createMany?: FeesPaymentCreateManyFeesInputEnvelope;
    connect?: FeesPaymentWhereUniqueInput | FeesPaymentWhereUniqueInput[];
  };

  export type IntFieldUpdateOperationsInput = {
    set?: number;
    increment?: number;
    decrement?: number;
    multiply?: number;
    divide?: number;
  };

  export type EnumFeesStatusFieldUpdateOperationsInput = {
    set?: $Enums.FeesStatus;
  };

  export type PupilUpdateOneRequiredWithoutFeesNestedInput = {
    create?: XOR<
      PupilCreateWithoutFeesInput,
      PupilUncheckedCreateWithoutFeesInput
    >;
    connectOrCreate?: PupilCreateOrConnectWithoutFeesInput;
    upsert?: PupilUpsertWithoutFeesInput;
    connect?: PupilWhereUniqueInput;
    update?: XOR<
      XOR<
        PupilUpdateToOneWithWhereWithoutFeesInput,
        PupilUpdateWithoutFeesInput
      >,
      PupilUncheckedUpdateWithoutFeesInput
    >;
  };

  export type ClassTermUpdateOneRequiredWithoutFeesNestedInput = {
    create?: XOR<
      ClassTermCreateWithoutFeesInput,
      ClassTermUncheckedCreateWithoutFeesInput
    >;
    connectOrCreate?: ClassTermCreateOrConnectWithoutFeesInput;
    upsert?: ClassTermUpsertWithoutFeesInput;
    connect?: ClassTermWhereUniqueInput;
    update?: XOR<
      XOR<
        ClassTermUpdateToOneWithWhereWithoutFeesInput,
        ClassTermUpdateWithoutFeesInput
      >,
      ClassTermUncheckedUpdateWithoutFeesInput
    >;
  };

  export type FeesPaymentUpdateManyWithoutFeesNestedInput = {
    create?:
      | XOR<
          FeesPaymentCreateWithoutFeesInput,
          FeesPaymentUncheckedCreateWithoutFeesInput
        >
      | FeesPaymentCreateWithoutFeesInput[]
      | FeesPaymentUncheckedCreateWithoutFeesInput[];
    connectOrCreate?:
      | FeesPaymentCreateOrConnectWithoutFeesInput
      | FeesPaymentCreateOrConnectWithoutFeesInput[];
    upsert?:
      | FeesPaymentUpsertWithWhereUniqueWithoutFeesInput
      | FeesPaymentUpsertWithWhereUniqueWithoutFeesInput[];
    createMany?: FeesPaymentCreateManyFeesInputEnvelope;
    set?: FeesPaymentWhereUniqueInput | FeesPaymentWhereUniqueInput[];
    disconnect?: FeesPaymentWhereUniqueInput | FeesPaymentWhereUniqueInput[];
    delete?: FeesPaymentWhereUniqueInput | FeesPaymentWhereUniqueInput[];
    connect?: FeesPaymentWhereUniqueInput | FeesPaymentWhereUniqueInput[];
    update?:
      | FeesPaymentUpdateWithWhereUniqueWithoutFeesInput
      | FeesPaymentUpdateWithWhereUniqueWithoutFeesInput[];
    updateMany?:
      | FeesPaymentUpdateManyWithWhereWithoutFeesInput
      | FeesPaymentUpdateManyWithWhereWithoutFeesInput[];
    deleteMany?: FeesPaymentScalarWhereInput | FeesPaymentScalarWhereInput[];
  };

  export type FeesPaymentUncheckedUpdateManyWithoutFeesNestedInput = {
    create?:
      | XOR<
          FeesPaymentCreateWithoutFeesInput,
          FeesPaymentUncheckedCreateWithoutFeesInput
        >
      | FeesPaymentCreateWithoutFeesInput[]
      | FeesPaymentUncheckedCreateWithoutFeesInput[];
    connectOrCreate?:
      | FeesPaymentCreateOrConnectWithoutFeesInput
      | FeesPaymentCreateOrConnectWithoutFeesInput[];
    upsert?:
      | FeesPaymentUpsertWithWhereUniqueWithoutFeesInput
      | FeesPaymentUpsertWithWhereUniqueWithoutFeesInput[];
    createMany?: FeesPaymentCreateManyFeesInputEnvelope;
    set?: FeesPaymentWhereUniqueInput | FeesPaymentWhereUniqueInput[];
    disconnect?: FeesPaymentWhereUniqueInput | FeesPaymentWhereUniqueInput[];
    delete?: FeesPaymentWhereUniqueInput | FeesPaymentWhereUniqueInput[];
    connect?: FeesPaymentWhereUniqueInput | FeesPaymentWhereUniqueInput[];
    update?:
      | FeesPaymentUpdateWithWhereUniqueWithoutFeesInput
      | FeesPaymentUpdateWithWhereUniqueWithoutFeesInput[];
    updateMany?:
      | FeesPaymentUpdateManyWithWhereWithoutFeesInput
      | FeesPaymentUpdateManyWithWhereWithoutFeesInput[];
    deleteMany?: FeesPaymentScalarWhereInput | FeesPaymentScalarWhereInput[];
  };

  export type FeesCreateNestedOneWithoutFeesPaymentsInput = {
    create?: XOR<
      FeesCreateWithoutFeesPaymentsInput,
      FeesUncheckedCreateWithoutFeesPaymentsInput
    >;
    connectOrCreate?: FeesCreateOrConnectWithoutFeesPaymentsInput;
    connect?: FeesWhereUniqueInput;
  };

  export type UserCreateNestedOneWithoutFeesPaymentsInput = {
    create?: XOR<
      UserCreateWithoutFeesPaymentsInput,
      UserUncheckedCreateWithoutFeesPaymentsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutFeesPaymentsInput;
    connect?: UserWhereUniqueInput;
  };

  export type FeesUpdateOneWithoutFeesPaymentsNestedInput = {
    create?: XOR<
      FeesCreateWithoutFeesPaymentsInput,
      FeesUncheckedCreateWithoutFeesPaymentsInput
    >;
    connectOrCreate?: FeesCreateOrConnectWithoutFeesPaymentsInput;
    upsert?: FeesUpsertWithoutFeesPaymentsInput;
    disconnect?: FeesWhereInput | boolean;
    delete?: FeesWhereInput | boolean;
    connect?: FeesWhereUniqueInput;
    update?: XOR<
      XOR<
        FeesUpdateToOneWithWhereWithoutFeesPaymentsInput,
        FeesUpdateWithoutFeesPaymentsInput
      >,
      FeesUncheckedUpdateWithoutFeesPaymentsInput
    >;
  };

  export type UserUpdateOneRequiredWithoutFeesPaymentsNestedInput = {
    create?: XOR<
      UserCreateWithoutFeesPaymentsInput,
      UserUncheckedCreateWithoutFeesPaymentsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutFeesPaymentsInput;
    upsert?: UserUpsertWithoutFeesPaymentsInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutFeesPaymentsInput,
        UserUpdateWithoutFeesPaymentsInput
      >,
      UserUncheckedUpdateWithoutFeesPaymentsInput
    >;
  };

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<
      UserCreateWithoutSessionsInput,
      UserUncheckedCreateWithoutSessionsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput;
    connect?: UserWhereUniqueInput;
  };

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role;
  };

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<
      UserCreateWithoutSessionsInput,
      UserUncheckedCreateWithoutSessionsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput;
    upsert?: UserUpsertWithoutSessionsInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutSessionsInput,
        UserUpdateWithoutSessionsInput
      >,
      UserUncheckedUpdateWithoutSessionsInput
    >;
  };

  export type ComputerLabItemCreateNestedManyWithoutAssetInput = {
    create?:
      | XOR<
          ComputerLabItemCreateWithoutAssetInput,
          ComputerLabItemUncheckedCreateWithoutAssetInput
        >
      | ComputerLabItemCreateWithoutAssetInput[]
      | ComputerLabItemUncheckedCreateWithoutAssetInput[];
    connectOrCreate?:
      | ComputerLabItemCreateOrConnectWithoutAssetInput
      | ComputerLabItemCreateOrConnectWithoutAssetInput[];
    createMany?: ComputerLabItemCreateManyAssetInputEnvelope;
    connect?:
      | ComputerLabItemWhereUniqueInput
      | ComputerLabItemWhereUniqueInput[];
  };

  export type FoodStoreItemCreateNestedManyWithoutAssetInput = {
    create?:
      | XOR<
          FoodStoreItemCreateWithoutAssetInput,
          FoodStoreItemUncheckedCreateWithoutAssetInput
        >
      | FoodStoreItemCreateWithoutAssetInput[]
      | FoodStoreItemUncheckedCreateWithoutAssetInput[];
    connectOrCreate?:
      | FoodStoreItemCreateOrConnectWithoutAssetInput
      | FoodStoreItemCreateOrConnectWithoutAssetInput[];
    createMany?: FoodStoreItemCreateManyAssetInputEnvelope;
    connect?: FoodStoreItemWhereUniqueInput | FoodStoreItemWhereUniqueInput[];
  };

  export type GeneralStoreItemCreateNestedManyWithoutAssetInput = {
    create?:
      | XOR<
          GeneralStoreItemCreateWithoutAssetInput,
          GeneralStoreItemUncheckedCreateWithoutAssetInput
        >
      | GeneralStoreItemCreateWithoutAssetInput[]
      | GeneralStoreItemUncheckedCreateWithoutAssetInput[];
    connectOrCreate?:
      | GeneralStoreItemCreateOrConnectWithoutAssetInput
      | GeneralStoreItemCreateOrConnectWithoutAssetInput[];
    createMany?: GeneralStoreItemCreateManyAssetInputEnvelope;
    connect?:
      | GeneralStoreItemWhereUniqueInput
      | GeneralStoreItemWhereUniqueInput[];
  };

  export type LabItemCreateNestedManyWithoutAssetInput = {
    create?:
      | XOR<
          LabItemCreateWithoutAssetInput,
          LabItemUncheckedCreateWithoutAssetInput
        >
      | LabItemCreateWithoutAssetInput[]
      | LabItemUncheckedCreateWithoutAssetInput[];
    connectOrCreate?:
      | LabItemCreateOrConnectWithoutAssetInput
      | LabItemCreateOrConnectWithoutAssetInput[];
    createMany?: LabItemCreateManyAssetInputEnvelope;
    connect?: LabItemWhereUniqueInput | LabItemWhereUniqueInput[];
  };

  export type LibraryBookCreateNestedManyWithoutAssetInput = {
    create?:
      | XOR<
          LibraryBookCreateWithoutAssetInput,
          LibraryBookUncheckedCreateWithoutAssetInput
        >
      | LibraryBookCreateWithoutAssetInput[]
      | LibraryBookUncheckedCreateWithoutAssetInput[];
    connectOrCreate?:
      | LibraryBookCreateOrConnectWithoutAssetInput
      | LibraryBookCreateOrConnectWithoutAssetInput[];
    createMany?: LibraryBookCreateManyAssetInputEnvelope;
    connect?: LibraryBookWhereUniqueInput | LibraryBookWhereUniqueInput[];
  };

  export type ComputerLabItemUncheckedCreateNestedManyWithoutAssetInput = {
    create?:
      | XOR<
          ComputerLabItemCreateWithoutAssetInput,
          ComputerLabItemUncheckedCreateWithoutAssetInput
        >
      | ComputerLabItemCreateWithoutAssetInput[]
      | ComputerLabItemUncheckedCreateWithoutAssetInput[];
    connectOrCreate?:
      | ComputerLabItemCreateOrConnectWithoutAssetInput
      | ComputerLabItemCreateOrConnectWithoutAssetInput[];
    createMany?: ComputerLabItemCreateManyAssetInputEnvelope;
    connect?:
      | ComputerLabItemWhereUniqueInput
      | ComputerLabItemWhereUniqueInput[];
  };

  export type FoodStoreItemUncheckedCreateNestedManyWithoutAssetInput = {
    create?:
      | XOR<
          FoodStoreItemCreateWithoutAssetInput,
          FoodStoreItemUncheckedCreateWithoutAssetInput
        >
      | FoodStoreItemCreateWithoutAssetInput[]
      | FoodStoreItemUncheckedCreateWithoutAssetInput[];
    connectOrCreate?:
      | FoodStoreItemCreateOrConnectWithoutAssetInput
      | FoodStoreItemCreateOrConnectWithoutAssetInput[];
    createMany?: FoodStoreItemCreateManyAssetInputEnvelope;
    connect?: FoodStoreItemWhereUniqueInput | FoodStoreItemWhereUniqueInput[];
  };

  export type GeneralStoreItemUncheckedCreateNestedManyWithoutAssetInput = {
    create?:
      | XOR<
          GeneralStoreItemCreateWithoutAssetInput,
          GeneralStoreItemUncheckedCreateWithoutAssetInput
        >
      | GeneralStoreItemCreateWithoutAssetInput[]
      | GeneralStoreItemUncheckedCreateWithoutAssetInput[];
    connectOrCreate?:
      | GeneralStoreItemCreateOrConnectWithoutAssetInput
      | GeneralStoreItemCreateOrConnectWithoutAssetInput[];
    createMany?: GeneralStoreItemCreateManyAssetInputEnvelope;
    connect?:
      | GeneralStoreItemWhereUniqueInput
      | GeneralStoreItemWhereUniqueInput[];
  };

  export type LabItemUncheckedCreateNestedManyWithoutAssetInput = {
    create?:
      | XOR<
          LabItemCreateWithoutAssetInput,
          LabItemUncheckedCreateWithoutAssetInput
        >
      | LabItemCreateWithoutAssetInput[]
      | LabItemUncheckedCreateWithoutAssetInput[];
    connectOrCreate?:
      | LabItemCreateOrConnectWithoutAssetInput
      | LabItemCreateOrConnectWithoutAssetInput[];
    createMany?: LabItemCreateManyAssetInputEnvelope;
    connect?: LabItemWhereUniqueInput | LabItemWhereUniqueInput[];
  };

  export type LibraryBookUncheckedCreateNestedManyWithoutAssetInput = {
    create?:
      | XOR<
          LibraryBookCreateWithoutAssetInput,
          LibraryBookUncheckedCreateWithoutAssetInput
        >
      | LibraryBookCreateWithoutAssetInput[]
      | LibraryBookUncheckedCreateWithoutAssetInput[];
    connectOrCreate?:
      | LibraryBookCreateOrConnectWithoutAssetInput
      | LibraryBookCreateOrConnectWithoutAssetInput[];
    createMany?: LibraryBookCreateManyAssetInputEnvelope;
    connect?: LibraryBookWhereUniqueInput | LibraryBookWhereUniqueInput[];
  };

  export type EnumAssetCategoryFieldUpdateOperationsInput = {
    set?: $Enums.AssetCategory;
  };

  export type ComputerLabItemUpdateManyWithoutAssetNestedInput = {
    create?:
      | XOR<
          ComputerLabItemCreateWithoutAssetInput,
          ComputerLabItemUncheckedCreateWithoutAssetInput
        >
      | ComputerLabItemCreateWithoutAssetInput[]
      | ComputerLabItemUncheckedCreateWithoutAssetInput[];
    connectOrCreate?:
      | ComputerLabItemCreateOrConnectWithoutAssetInput
      | ComputerLabItemCreateOrConnectWithoutAssetInput[];
    upsert?:
      | ComputerLabItemUpsertWithWhereUniqueWithoutAssetInput
      | ComputerLabItemUpsertWithWhereUniqueWithoutAssetInput[];
    createMany?: ComputerLabItemCreateManyAssetInputEnvelope;
    set?: ComputerLabItemWhereUniqueInput | ComputerLabItemWhereUniqueInput[];
    disconnect?:
      | ComputerLabItemWhereUniqueInput
      | ComputerLabItemWhereUniqueInput[];
    delete?:
      | ComputerLabItemWhereUniqueInput
      | ComputerLabItemWhereUniqueInput[];
    connect?:
      | ComputerLabItemWhereUniqueInput
      | ComputerLabItemWhereUniqueInput[];
    update?:
      | ComputerLabItemUpdateWithWhereUniqueWithoutAssetInput
      | ComputerLabItemUpdateWithWhereUniqueWithoutAssetInput[];
    updateMany?:
      | ComputerLabItemUpdateManyWithWhereWithoutAssetInput
      | ComputerLabItemUpdateManyWithWhereWithoutAssetInput[];
    deleteMany?:
      | ComputerLabItemScalarWhereInput
      | ComputerLabItemScalarWhereInput[];
  };

  export type FoodStoreItemUpdateManyWithoutAssetNestedInput = {
    create?:
      | XOR<
          FoodStoreItemCreateWithoutAssetInput,
          FoodStoreItemUncheckedCreateWithoutAssetInput
        >
      | FoodStoreItemCreateWithoutAssetInput[]
      | FoodStoreItemUncheckedCreateWithoutAssetInput[];
    connectOrCreate?:
      | FoodStoreItemCreateOrConnectWithoutAssetInput
      | FoodStoreItemCreateOrConnectWithoutAssetInput[];
    upsert?:
      | FoodStoreItemUpsertWithWhereUniqueWithoutAssetInput
      | FoodStoreItemUpsertWithWhereUniqueWithoutAssetInput[];
    createMany?: FoodStoreItemCreateManyAssetInputEnvelope;
    set?: FoodStoreItemWhereUniqueInput | FoodStoreItemWhereUniqueInput[];
    disconnect?:
      | FoodStoreItemWhereUniqueInput
      | FoodStoreItemWhereUniqueInput[];
    delete?: FoodStoreItemWhereUniqueInput | FoodStoreItemWhereUniqueInput[];
    connect?: FoodStoreItemWhereUniqueInput | FoodStoreItemWhereUniqueInput[];
    update?:
      | FoodStoreItemUpdateWithWhereUniqueWithoutAssetInput
      | FoodStoreItemUpdateWithWhereUniqueWithoutAssetInput[];
    updateMany?:
      | FoodStoreItemUpdateManyWithWhereWithoutAssetInput
      | FoodStoreItemUpdateManyWithWhereWithoutAssetInput[];
    deleteMany?:
      | FoodStoreItemScalarWhereInput
      | FoodStoreItemScalarWhereInput[];
  };

  export type GeneralStoreItemUpdateManyWithoutAssetNestedInput = {
    create?:
      | XOR<
          GeneralStoreItemCreateWithoutAssetInput,
          GeneralStoreItemUncheckedCreateWithoutAssetInput
        >
      | GeneralStoreItemCreateWithoutAssetInput[]
      | GeneralStoreItemUncheckedCreateWithoutAssetInput[];
    connectOrCreate?:
      | GeneralStoreItemCreateOrConnectWithoutAssetInput
      | GeneralStoreItemCreateOrConnectWithoutAssetInput[];
    upsert?:
      | GeneralStoreItemUpsertWithWhereUniqueWithoutAssetInput
      | GeneralStoreItemUpsertWithWhereUniqueWithoutAssetInput[];
    createMany?: GeneralStoreItemCreateManyAssetInputEnvelope;
    set?: GeneralStoreItemWhereUniqueInput | GeneralStoreItemWhereUniqueInput[];
    disconnect?:
      | GeneralStoreItemWhereUniqueInput
      | GeneralStoreItemWhereUniqueInput[];
    delete?:
      | GeneralStoreItemWhereUniqueInput
      | GeneralStoreItemWhereUniqueInput[];
    connect?:
      | GeneralStoreItemWhereUniqueInput
      | GeneralStoreItemWhereUniqueInput[];
    update?:
      | GeneralStoreItemUpdateWithWhereUniqueWithoutAssetInput
      | GeneralStoreItemUpdateWithWhereUniqueWithoutAssetInput[];
    updateMany?:
      | GeneralStoreItemUpdateManyWithWhereWithoutAssetInput
      | GeneralStoreItemUpdateManyWithWhereWithoutAssetInput[];
    deleteMany?:
      | GeneralStoreItemScalarWhereInput
      | GeneralStoreItemScalarWhereInput[];
  };

  export type LabItemUpdateManyWithoutAssetNestedInput = {
    create?:
      | XOR<
          LabItemCreateWithoutAssetInput,
          LabItemUncheckedCreateWithoutAssetInput
        >
      | LabItemCreateWithoutAssetInput[]
      | LabItemUncheckedCreateWithoutAssetInput[];
    connectOrCreate?:
      | LabItemCreateOrConnectWithoutAssetInput
      | LabItemCreateOrConnectWithoutAssetInput[];
    upsert?:
      | LabItemUpsertWithWhereUniqueWithoutAssetInput
      | LabItemUpsertWithWhereUniqueWithoutAssetInput[];
    createMany?: LabItemCreateManyAssetInputEnvelope;
    set?: LabItemWhereUniqueInput | LabItemWhereUniqueInput[];
    disconnect?: LabItemWhereUniqueInput | LabItemWhereUniqueInput[];
    delete?: LabItemWhereUniqueInput | LabItemWhereUniqueInput[];
    connect?: LabItemWhereUniqueInput | LabItemWhereUniqueInput[];
    update?:
      | LabItemUpdateWithWhereUniqueWithoutAssetInput
      | LabItemUpdateWithWhereUniqueWithoutAssetInput[];
    updateMany?:
      | LabItemUpdateManyWithWhereWithoutAssetInput
      | LabItemUpdateManyWithWhereWithoutAssetInput[];
    deleteMany?: LabItemScalarWhereInput | LabItemScalarWhereInput[];
  };

  export type LibraryBookUpdateManyWithoutAssetNestedInput = {
    create?:
      | XOR<
          LibraryBookCreateWithoutAssetInput,
          LibraryBookUncheckedCreateWithoutAssetInput
        >
      | LibraryBookCreateWithoutAssetInput[]
      | LibraryBookUncheckedCreateWithoutAssetInput[];
    connectOrCreate?:
      | LibraryBookCreateOrConnectWithoutAssetInput
      | LibraryBookCreateOrConnectWithoutAssetInput[];
    upsert?:
      | LibraryBookUpsertWithWhereUniqueWithoutAssetInput
      | LibraryBookUpsertWithWhereUniqueWithoutAssetInput[];
    createMany?: LibraryBookCreateManyAssetInputEnvelope;
    set?: LibraryBookWhereUniqueInput | LibraryBookWhereUniqueInput[];
    disconnect?: LibraryBookWhereUniqueInput | LibraryBookWhereUniqueInput[];
    delete?: LibraryBookWhereUniqueInput | LibraryBookWhereUniqueInput[];
    connect?: LibraryBookWhereUniqueInput | LibraryBookWhereUniqueInput[];
    update?:
      | LibraryBookUpdateWithWhereUniqueWithoutAssetInput
      | LibraryBookUpdateWithWhereUniqueWithoutAssetInput[];
    updateMany?:
      | LibraryBookUpdateManyWithWhereWithoutAssetInput
      | LibraryBookUpdateManyWithWhereWithoutAssetInput[];
    deleteMany?: LibraryBookScalarWhereInput | LibraryBookScalarWhereInput[];
  };

  export type ComputerLabItemUncheckedUpdateManyWithoutAssetNestedInput = {
    create?:
      | XOR<
          ComputerLabItemCreateWithoutAssetInput,
          ComputerLabItemUncheckedCreateWithoutAssetInput
        >
      | ComputerLabItemCreateWithoutAssetInput[]
      | ComputerLabItemUncheckedCreateWithoutAssetInput[];
    connectOrCreate?:
      | ComputerLabItemCreateOrConnectWithoutAssetInput
      | ComputerLabItemCreateOrConnectWithoutAssetInput[];
    upsert?:
      | ComputerLabItemUpsertWithWhereUniqueWithoutAssetInput
      | ComputerLabItemUpsertWithWhereUniqueWithoutAssetInput[];
    createMany?: ComputerLabItemCreateManyAssetInputEnvelope;
    set?: ComputerLabItemWhereUniqueInput | ComputerLabItemWhereUniqueInput[];
    disconnect?:
      | ComputerLabItemWhereUniqueInput
      | ComputerLabItemWhereUniqueInput[];
    delete?:
      | ComputerLabItemWhereUniqueInput
      | ComputerLabItemWhereUniqueInput[];
    connect?:
      | ComputerLabItemWhereUniqueInput
      | ComputerLabItemWhereUniqueInput[];
    update?:
      | ComputerLabItemUpdateWithWhereUniqueWithoutAssetInput
      | ComputerLabItemUpdateWithWhereUniqueWithoutAssetInput[];
    updateMany?:
      | ComputerLabItemUpdateManyWithWhereWithoutAssetInput
      | ComputerLabItemUpdateManyWithWhereWithoutAssetInput[];
    deleteMany?:
      | ComputerLabItemScalarWhereInput
      | ComputerLabItemScalarWhereInput[];
  };

  export type FoodStoreItemUncheckedUpdateManyWithoutAssetNestedInput = {
    create?:
      | XOR<
          FoodStoreItemCreateWithoutAssetInput,
          FoodStoreItemUncheckedCreateWithoutAssetInput
        >
      | FoodStoreItemCreateWithoutAssetInput[]
      | FoodStoreItemUncheckedCreateWithoutAssetInput[];
    connectOrCreate?:
      | FoodStoreItemCreateOrConnectWithoutAssetInput
      | FoodStoreItemCreateOrConnectWithoutAssetInput[];
    upsert?:
      | FoodStoreItemUpsertWithWhereUniqueWithoutAssetInput
      | FoodStoreItemUpsertWithWhereUniqueWithoutAssetInput[];
    createMany?: FoodStoreItemCreateManyAssetInputEnvelope;
    set?: FoodStoreItemWhereUniqueInput | FoodStoreItemWhereUniqueInput[];
    disconnect?:
      | FoodStoreItemWhereUniqueInput
      | FoodStoreItemWhereUniqueInput[];
    delete?: FoodStoreItemWhereUniqueInput | FoodStoreItemWhereUniqueInput[];
    connect?: FoodStoreItemWhereUniqueInput | FoodStoreItemWhereUniqueInput[];
    update?:
      | FoodStoreItemUpdateWithWhereUniqueWithoutAssetInput
      | FoodStoreItemUpdateWithWhereUniqueWithoutAssetInput[];
    updateMany?:
      | FoodStoreItemUpdateManyWithWhereWithoutAssetInput
      | FoodStoreItemUpdateManyWithWhereWithoutAssetInput[];
    deleteMany?:
      | FoodStoreItemScalarWhereInput
      | FoodStoreItemScalarWhereInput[];
  };

  export type GeneralStoreItemUncheckedUpdateManyWithoutAssetNestedInput = {
    create?:
      | XOR<
          GeneralStoreItemCreateWithoutAssetInput,
          GeneralStoreItemUncheckedCreateWithoutAssetInput
        >
      | GeneralStoreItemCreateWithoutAssetInput[]
      | GeneralStoreItemUncheckedCreateWithoutAssetInput[];
    connectOrCreate?:
      | GeneralStoreItemCreateOrConnectWithoutAssetInput
      | GeneralStoreItemCreateOrConnectWithoutAssetInput[];
    upsert?:
      | GeneralStoreItemUpsertWithWhereUniqueWithoutAssetInput
      | GeneralStoreItemUpsertWithWhereUniqueWithoutAssetInput[];
    createMany?: GeneralStoreItemCreateManyAssetInputEnvelope;
    set?: GeneralStoreItemWhereUniqueInput | GeneralStoreItemWhereUniqueInput[];
    disconnect?:
      | GeneralStoreItemWhereUniqueInput
      | GeneralStoreItemWhereUniqueInput[];
    delete?:
      | GeneralStoreItemWhereUniqueInput
      | GeneralStoreItemWhereUniqueInput[];
    connect?:
      | GeneralStoreItemWhereUniqueInput
      | GeneralStoreItemWhereUniqueInput[];
    update?:
      | GeneralStoreItemUpdateWithWhereUniqueWithoutAssetInput
      | GeneralStoreItemUpdateWithWhereUniqueWithoutAssetInput[];
    updateMany?:
      | GeneralStoreItemUpdateManyWithWhereWithoutAssetInput
      | GeneralStoreItemUpdateManyWithWhereWithoutAssetInput[];
    deleteMany?:
      | GeneralStoreItemScalarWhereInput
      | GeneralStoreItemScalarWhereInput[];
  };

  export type LabItemUncheckedUpdateManyWithoutAssetNestedInput = {
    create?:
      | XOR<
          LabItemCreateWithoutAssetInput,
          LabItemUncheckedCreateWithoutAssetInput
        >
      | LabItemCreateWithoutAssetInput[]
      | LabItemUncheckedCreateWithoutAssetInput[];
    connectOrCreate?:
      | LabItemCreateOrConnectWithoutAssetInput
      | LabItemCreateOrConnectWithoutAssetInput[];
    upsert?:
      | LabItemUpsertWithWhereUniqueWithoutAssetInput
      | LabItemUpsertWithWhereUniqueWithoutAssetInput[];
    createMany?: LabItemCreateManyAssetInputEnvelope;
    set?: LabItemWhereUniqueInput | LabItemWhereUniqueInput[];
    disconnect?: LabItemWhereUniqueInput | LabItemWhereUniqueInput[];
    delete?: LabItemWhereUniqueInput | LabItemWhereUniqueInput[];
    connect?: LabItemWhereUniqueInput | LabItemWhereUniqueInput[];
    update?:
      | LabItemUpdateWithWhereUniqueWithoutAssetInput
      | LabItemUpdateWithWhereUniqueWithoutAssetInput[];
    updateMany?:
      | LabItemUpdateManyWithWhereWithoutAssetInput
      | LabItemUpdateManyWithWhereWithoutAssetInput[];
    deleteMany?: LabItemScalarWhereInput | LabItemScalarWhereInput[];
  };

  export type LibraryBookUncheckedUpdateManyWithoutAssetNestedInput = {
    create?:
      | XOR<
          LibraryBookCreateWithoutAssetInput,
          LibraryBookUncheckedCreateWithoutAssetInput
        >
      | LibraryBookCreateWithoutAssetInput[]
      | LibraryBookUncheckedCreateWithoutAssetInput[];
    connectOrCreate?:
      | LibraryBookCreateOrConnectWithoutAssetInput
      | LibraryBookCreateOrConnectWithoutAssetInput[];
    upsert?:
      | LibraryBookUpsertWithWhereUniqueWithoutAssetInput
      | LibraryBookUpsertWithWhereUniqueWithoutAssetInput[];
    createMany?: LibraryBookCreateManyAssetInputEnvelope;
    set?: LibraryBookWhereUniqueInput | LibraryBookWhereUniqueInput[];
    disconnect?: LibraryBookWhereUniqueInput | LibraryBookWhereUniqueInput[];
    delete?: LibraryBookWhereUniqueInput | LibraryBookWhereUniqueInput[];
    connect?: LibraryBookWhereUniqueInput | LibraryBookWhereUniqueInput[];
    update?:
      | LibraryBookUpdateWithWhereUniqueWithoutAssetInput
      | LibraryBookUpdateWithWhereUniqueWithoutAssetInput[];
    updateMany?:
      | LibraryBookUpdateManyWithWhereWithoutAssetInput
      | LibraryBookUpdateManyWithWhereWithoutAssetInput[];
    deleteMany?: LibraryBookScalarWhereInput | LibraryBookScalarWhereInput[];
  };

  export type FoodConsumptionCreateNestedManyWithoutFoodItemInput = {
    create?:
      | XOR<
          FoodConsumptionCreateWithoutFoodItemInput,
          FoodConsumptionUncheckedCreateWithoutFoodItemInput
        >
      | FoodConsumptionCreateWithoutFoodItemInput[]
      | FoodConsumptionUncheckedCreateWithoutFoodItemInput[];
    connectOrCreate?:
      | FoodConsumptionCreateOrConnectWithoutFoodItemInput
      | FoodConsumptionCreateOrConnectWithoutFoodItemInput[];
    createMany?: FoodConsumptionCreateManyFoodItemInputEnvelope;
    connect?:
      | FoodConsumptionWhereUniqueInput
      | FoodConsumptionWhereUniqueInput[];
  };

  export type AssetCreateNestedOneWithoutFoodStoreItemsInput = {
    create?: XOR<
      AssetCreateWithoutFoodStoreItemsInput,
      AssetUncheckedCreateWithoutFoodStoreItemsInput
    >;
    connectOrCreate?: AssetCreateOrConnectWithoutFoodStoreItemsInput;
    connect?: AssetWhereUniqueInput;
  };

  export type SupplierCreateNestedOneWithoutFoodStoreItemsInput = {
    create?: XOR<
      SupplierCreateWithoutFoodStoreItemsInput,
      SupplierUncheckedCreateWithoutFoodStoreItemsInput
    >;
    connectOrCreate?: SupplierCreateOrConnectWithoutFoodStoreItemsInput;
    connect?: SupplierWhereUniqueInput;
  };

  export type IndividualFoodStoreItemCreateNestedManyWithoutFoodStoreItemInput =
    {
      create?:
        | XOR<
            IndividualFoodStoreItemCreateWithoutFoodStoreItemInput,
            IndividualFoodStoreItemUncheckedCreateWithoutFoodStoreItemInput
          >
        | IndividualFoodStoreItemCreateWithoutFoodStoreItemInput[]
        | IndividualFoodStoreItemUncheckedCreateWithoutFoodStoreItemInput[];
      connectOrCreate?:
        | IndividualFoodStoreItemCreateOrConnectWithoutFoodStoreItemInput
        | IndividualFoodStoreItemCreateOrConnectWithoutFoodStoreItemInput[];
      createMany?: IndividualFoodStoreItemCreateManyFoodStoreItemInputEnvelope;
      connect?:
        | IndividualFoodStoreItemWhereUniqueInput
        | IndividualFoodStoreItemWhereUniqueInput[];
    };

  export type FoodConsumptionUncheckedCreateNestedManyWithoutFoodItemInput = {
    create?:
      | XOR<
          FoodConsumptionCreateWithoutFoodItemInput,
          FoodConsumptionUncheckedCreateWithoutFoodItemInput
        >
      | FoodConsumptionCreateWithoutFoodItemInput[]
      | FoodConsumptionUncheckedCreateWithoutFoodItemInput[];
    connectOrCreate?:
      | FoodConsumptionCreateOrConnectWithoutFoodItemInput
      | FoodConsumptionCreateOrConnectWithoutFoodItemInput[];
    createMany?: FoodConsumptionCreateManyFoodItemInputEnvelope;
    connect?:
      | FoodConsumptionWhereUniqueInput
      | FoodConsumptionWhereUniqueInput[];
  };

  export type IndividualFoodStoreItemUncheckedCreateNestedManyWithoutFoodStoreItemInput =
    {
      create?:
        | XOR<
            IndividualFoodStoreItemCreateWithoutFoodStoreItemInput,
            IndividualFoodStoreItemUncheckedCreateWithoutFoodStoreItemInput
          >
        | IndividualFoodStoreItemCreateWithoutFoodStoreItemInput[]
        | IndividualFoodStoreItemUncheckedCreateWithoutFoodStoreItemInput[];
      connectOrCreate?:
        | IndividualFoodStoreItemCreateOrConnectWithoutFoodStoreItemInput
        | IndividualFoodStoreItemCreateOrConnectWithoutFoodStoreItemInput[];
      createMany?: IndividualFoodStoreItemCreateManyFoodStoreItemInputEnvelope;
      connect?:
        | IndividualFoodStoreItemWhereUniqueInput
        | IndividualFoodStoreItemWhereUniqueInput[];
    };

  export type EnumAssetUnitFieldUpdateOperationsInput = {
    set?: $Enums.AssetUnit;
  };

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null;
    increment?: number;
    decrement?: number;
    multiply?: number;
    divide?: number;
  };

  export type EnumAssetItemStatusFieldUpdateOperationsInput = {
    set?: $Enums.AssetItemStatus;
  };

  export type FoodConsumptionUpdateManyWithoutFoodItemNestedInput = {
    create?:
      | XOR<
          FoodConsumptionCreateWithoutFoodItemInput,
          FoodConsumptionUncheckedCreateWithoutFoodItemInput
        >
      | FoodConsumptionCreateWithoutFoodItemInput[]
      | FoodConsumptionUncheckedCreateWithoutFoodItemInput[];
    connectOrCreate?:
      | FoodConsumptionCreateOrConnectWithoutFoodItemInput
      | FoodConsumptionCreateOrConnectWithoutFoodItemInput[];
    upsert?:
      | FoodConsumptionUpsertWithWhereUniqueWithoutFoodItemInput
      | FoodConsumptionUpsertWithWhereUniqueWithoutFoodItemInput[];
    createMany?: FoodConsumptionCreateManyFoodItemInputEnvelope;
    set?: FoodConsumptionWhereUniqueInput | FoodConsumptionWhereUniqueInput[];
    disconnect?:
      | FoodConsumptionWhereUniqueInput
      | FoodConsumptionWhereUniqueInput[];
    delete?:
      | FoodConsumptionWhereUniqueInput
      | FoodConsumptionWhereUniqueInput[];
    connect?:
      | FoodConsumptionWhereUniqueInput
      | FoodConsumptionWhereUniqueInput[];
    update?:
      | FoodConsumptionUpdateWithWhereUniqueWithoutFoodItemInput
      | FoodConsumptionUpdateWithWhereUniqueWithoutFoodItemInput[];
    updateMany?:
      | FoodConsumptionUpdateManyWithWhereWithoutFoodItemInput
      | FoodConsumptionUpdateManyWithWhereWithoutFoodItemInput[];
    deleteMany?:
      | FoodConsumptionScalarWhereInput
      | FoodConsumptionScalarWhereInput[];
  };

  export type AssetUpdateOneRequiredWithoutFoodStoreItemsNestedInput = {
    create?: XOR<
      AssetCreateWithoutFoodStoreItemsInput,
      AssetUncheckedCreateWithoutFoodStoreItemsInput
    >;
    connectOrCreate?: AssetCreateOrConnectWithoutFoodStoreItemsInput;
    upsert?: AssetUpsertWithoutFoodStoreItemsInput;
    connect?: AssetWhereUniqueInput;
    update?: XOR<
      XOR<
        AssetUpdateToOneWithWhereWithoutFoodStoreItemsInput,
        AssetUpdateWithoutFoodStoreItemsInput
      >,
      AssetUncheckedUpdateWithoutFoodStoreItemsInput
    >;
  };

  export type SupplierUpdateOneWithoutFoodStoreItemsNestedInput = {
    create?: XOR<
      SupplierCreateWithoutFoodStoreItemsInput,
      SupplierUncheckedCreateWithoutFoodStoreItemsInput
    >;
    connectOrCreate?: SupplierCreateOrConnectWithoutFoodStoreItemsInput;
    upsert?: SupplierUpsertWithoutFoodStoreItemsInput;
    disconnect?: SupplierWhereInput | boolean;
    delete?: SupplierWhereInput | boolean;
    connect?: SupplierWhereUniqueInput;
    update?: XOR<
      XOR<
        SupplierUpdateToOneWithWhereWithoutFoodStoreItemsInput,
        SupplierUpdateWithoutFoodStoreItemsInput
      >,
      SupplierUncheckedUpdateWithoutFoodStoreItemsInput
    >;
  };

  export type IndividualFoodStoreItemUpdateManyWithoutFoodStoreItemNestedInput =
    {
      create?:
        | XOR<
            IndividualFoodStoreItemCreateWithoutFoodStoreItemInput,
            IndividualFoodStoreItemUncheckedCreateWithoutFoodStoreItemInput
          >
        | IndividualFoodStoreItemCreateWithoutFoodStoreItemInput[]
        | IndividualFoodStoreItemUncheckedCreateWithoutFoodStoreItemInput[];
      connectOrCreate?:
        | IndividualFoodStoreItemCreateOrConnectWithoutFoodStoreItemInput
        | IndividualFoodStoreItemCreateOrConnectWithoutFoodStoreItemInput[];
      upsert?:
        | IndividualFoodStoreItemUpsertWithWhereUniqueWithoutFoodStoreItemInput
        | IndividualFoodStoreItemUpsertWithWhereUniqueWithoutFoodStoreItemInput[];
      createMany?: IndividualFoodStoreItemCreateManyFoodStoreItemInputEnvelope;
      set?:
        | IndividualFoodStoreItemWhereUniqueInput
        | IndividualFoodStoreItemWhereUniqueInput[];
      disconnect?:
        | IndividualFoodStoreItemWhereUniqueInput
        | IndividualFoodStoreItemWhereUniqueInput[];
      delete?:
        | IndividualFoodStoreItemWhereUniqueInput
        | IndividualFoodStoreItemWhereUniqueInput[];
      connect?:
        | IndividualFoodStoreItemWhereUniqueInput
        | IndividualFoodStoreItemWhereUniqueInput[];
      update?:
        | IndividualFoodStoreItemUpdateWithWhereUniqueWithoutFoodStoreItemInput
        | IndividualFoodStoreItemUpdateWithWhereUniqueWithoutFoodStoreItemInput[];
      updateMany?:
        | IndividualFoodStoreItemUpdateManyWithWhereWithoutFoodStoreItemInput
        | IndividualFoodStoreItemUpdateManyWithWhereWithoutFoodStoreItemInput[];
      deleteMany?:
        | IndividualFoodStoreItemScalarWhereInput
        | IndividualFoodStoreItemScalarWhereInput[];
    };

  export type FoodConsumptionUncheckedUpdateManyWithoutFoodItemNestedInput = {
    create?:
      | XOR<
          FoodConsumptionCreateWithoutFoodItemInput,
          FoodConsumptionUncheckedCreateWithoutFoodItemInput
        >
      | FoodConsumptionCreateWithoutFoodItemInput[]
      | FoodConsumptionUncheckedCreateWithoutFoodItemInput[];
    connectOrCreate?:
      | FoodConsumptionCreateOrConnectWithoutFoodItemInput
      | FoodConsumptionCreateOrConnectWithoutFoodItemInput[];
    upsert?:
      | FoodConsumptionUpsertWithWhereUniqueWithoutFoodItemInput
      | FoodConsumptionUpsertWithWhereUniqueWithoutFoodItemInput[];
    createMany?: FoodConsumptionCreateManyFoodItemInputEnvelope;
    set?: FoodConsumptionWhereUniqueInput | FoodConsumptionWhereUniqueInput[];
    disconnect?:
      | FoodConsumptionWhereUniqueInput
      | FoodConsumptionWhereUniqueInput[];
    delete?:
      | FoodConsumptionWhereUniqueInput
      | FoodConsumptionWhereUniqueInput[];
    connect?:
      | FoodConsumptionWhereUniqueInput
      | FoodConsumptionWhereUniqueInput[];
    update?:
      | FoodConsumptionUpdateWithWhereUniqueWithoutFoodItemInput
      | FoodConsumptionUpdateWithWhereUniqueWithoutFoodItemInput[];
    updateMany?:
      | FoodConsumptionUpdateManyWithWhereWithoutFoodItemInput
      | FoodConsumptionUpdateManyWithWhereWithoutFoodItemInput[];
    deleteMany?:
      | FoodConsumptionScalarWhereInput
      | FoodConsumptionScalarWhereInput[];
  };

  export type IndividualFoodStoreItemUncheckedUpdateManyWithoutFoodStoreItemNestedInput =
    {
      create?:
        | XOR<
            IndividualFoodStoreItemCreateWithoutFoodStoreItemInput,
            IndividualFoodStoreItemUncheckedCreateWithoutFoodStoreItemInput
          >
        | IndividualFoodStoreItemCreateWithoutFoodStoreItemInput[]
        | IndividualFoodStoreItemUncheckedCreateWithoutFoodStoreItemInput[];
      connectOrCreate?:
        | IndividualFoodStoreItemCreateOrConnectWithoutFoodStoreItemInput
        | IndividualFoodStoreItemCreateOrConnectWithoutFoodStoreItemInput[];
      upsert?:
        | IndividualFoodStoreItemUpsertWithWhereUniqueWithoutFoodStoreItemInput
        | IndividualFoodStoreItemUpsertWithWhereUniqueWithoutFoodStoreItemInput[];
      createMany?: IndividualFoodStoreItemCreateManyFoodStoreItemInputEnvelope;
      set?:
        | IndividualFoodStoreItemWhereUniqueInput
        | IndividualFoodStoreItemWhereUniqueInput[];
      disconnect?:
        | IndividualFoodStoreItemWhereUniqueInput
        | IndividualFoodStoreItemWhereUniqueInput[];
      delete?:
        | IndividualFoodStoreItemWhereUniqueInput
        | IndividualFoodStoreItemWhereUniqueInput[];
      connect?:
        | IndividualFoodStoreItemWhereUniqueInput
        | IndividualFoodStoreItemWhereUniqueInput[];
      update?:
        | IndividualFoodStoreItemUpdateWithWhereUniqueWithoutFoodStoreItemInput
        | IndividualFoodStoreItemUpdateWithWhereUniqueWithoutFoodStoreItemInput[];
      updateMany?:
        | IndividualFoodStoreItemUpdateManyWithWhereWithoutFoodStoreItemInput
        | IndividualFoodStoreItemUpdateManyWithWhereWithoutFoodStoreItemInput[];
      deleteMany?:
        | IndividualFoodStoreItemScalarWhereInput
        | IndividualFoodStoreItemScalarWhereInput[];
    };

  export type AssetDamageCreateNestedManyWithoutIndividualFoodStoreItemInput = {
    create?:
      | XOR<
          AssetDamageCreateWithoutIndividualFoodStoreItemInput,
          AssetDamageUncheckedCreateWithoutIndividualFoodStoreItemInput
        >
      | AssetDamageCreateWithoutIndividualFoodStoreItemInput[]
      | AssetDamageUncheckedCreateWithoutIndividualFoodStoreItemInput[];
    connectOrCreate?:
      | AssetDamageCreateOrConnectWithoutIndividualFoodStoreItemInput
      | AssetDamageCreateOrConnectWithoutIndividualFoodStoreItemInput[];
    createMany?: AssetDamageCreateManyIndividualFoodStoreItemInputEnvelope;
    connect?: AssetDamageWhereUniqueInput | AssetDamageWhereUniqueInput[];
  };

  export type FoodStoreItemCreateNestedOneWithoutIndividualFoodStoreItemsInput =
    {
      create?: XOR<
        FoodStoreItemCreateWithoutIndividualFoodStoreItemsInput,
        FoodStoreItemUncheckedCreateWithoutIndividualFoodStoreItemsInput
      >;
      connectOrCreate?: FoodStoreItemCreateOrConnectWithoutIndividualFoodStoreItemsInput;
      connect?: FoodStoreItemWhereUniqueInput;
    };

  export type AssetDamageUncheckedCreateNestedManyWithoutIndividualFoodStoreItemInput =
    {
      create?:
        | XOR<
            AssetDamageCreateWithoutIndividualFoodStoreItemInput,
            AssetDamageUncheckedCreateWithoutIndividualFoodStoreItemInput
          >
        | AssetDamageCreateWithoutIndividualFoodStoreItemInput[]
        | AssetDamageUncheckedCreateWithoutIndividualFoodStoreItemInput[];
      connectOrCreate?:
        | AssetDamageCreateOrConnectWithoutIndividualFoodStoreItemInput
        | AssetDamageCreateOrConnectWithoutIndividualFoodStoreItemInput[];
      createMany?: AssetDamageCreateManyIndividualFoodStoreItemInputEnvelope;
      connect?: AssetDamageWhereUniqueInput | AssetDamageWhereUniqueInput[];
    };

  export type EnumAssetStatusFieldUpdateOperationsInput = {
    set?: $Enums.AssetStatus;
  };

  export type EnumAssetConditionFieldUpdateOperationsInput = {
    set?: $Enums.AssetCondition;
  };

  export type AssetDamageUpdateManyWithoutIndividualFoodStoreItemNestedInput = {
    create?:
      | XOR<
          AssetDamageCreateWithoutIndividualFoodStoreItemInput,
          AssetDamageUncheckedCreateWithoutIndividualFoodStoreItemInput
        >
      | AssetDamageCreateWithoutIndividualFoodStoreItemInput[]
      | AssetDamageUncheckedCreateWithoutIndividualFoodStoreItemInput[];
    connectOrCreate?:
      | AssetDamageCreateOrConnectWithoutIndividualFoodStoreItemInput
      | AssetDamageCreateOrConnectWithoutIndividualFoodStoreItemInput[];
    upsert?:
      | AssetDamageUpsertWithWhereUniqueWithoutIndividualFoodStoreItemInput
      | AssetDamageUpsertWithWhereUniqueWithoutIndividualFoodStoreItemInput[];
    createMany?: AssetDamageCreateManyIndividualFoodStoreItemInputEnvelope;
    set?: AssetDamageWhereUniqueInput | AssetDamageWhereUniqueInput[];
    disconnect?: AssetDamageWhereUniqueInput | AssetDamageWhereUniqueInput[];
    delete?: AssetDamageWhereUniqueInput | AssetDamageWhereUniqueInput[];
    connect?: AssetDamageWhereUniqueInput | AssetDamageWhereUniqueInput[];
    update?:
      | AssetDamageUpdateWithWhereUniqueWithoutIndividualFoodStoreItemInput
      | AssetDamageUpdateWithWhereUniqueWithoutIndividualFoodStoreItemInput[];
    updateMany?:
      | AssetDamageUpdateManyWithWhereWithoutIndividualFoodStoreItemInput
      | AssetDamageUpdateManyWithWhereWithoutIndividualFoodStoreItemInput[];
    deleteMany?: AssetDamageScalarWhereInput | AssetDamageScalarWhereInput[];
  };

  export type FoodStoreItemUpdateOneRequiredWithoutIndividualFoodStoreItemsNestedInput =
    {
      create?: XOR<
        FoodStoreItemCreateWithoutIndividualFoodStoreItemsInput,
        FoodStoreItemUncheckedCreateWithoutIndividualFoodStoreItemsInput
      >;
      connectOrCreate?: FoodStoreItemCreateOrConnectWithoutIndividualFoodStoreItemsInput;
      upsert?: FoodStoreItemUpsertWithoutIndividualFoodStoreItemsInput;
      connect?: FoodStoreItemWhereUniqueInput;
      update?: XOR<
        XOR<
          FoodStoreItemUpdateToOneWithWhereWithoutIndividualFoodStoreItemsInput,
          FoodStoreItemUpdateWithoutIndividualFoodStoreItemsInput
        >,
        FoodStoreItemUncheckedUpdateWithoutIndividualFoodStoreItemsInput
      >;
    };

  export type AssetDamageUncheckedUpdateManyWithoutIndividualFoodStoreItemNestedInput =
    {
      create?:
        | XOR<
            AssetDamageCreateWithoutIndividualFoodStoreItemInput,
            AssetDamageUncheckedCreateWithoutIndividualFoodStoreItemInput
          >
        | AssetDamageCreateWithoutIndividualFoodStoreItemInput[]
        | AssetDamageUncheckedCreateWithoutIndividualFoodStoreItemInput[];
      connectOrCreate?:
        | AssetDamageCreateOrConnectWithoutIndividualFoodStoreItemInput
        | AssetDamageCreateOrConnectWithoutIndividualFoodStoreItemInput[];
      upsert?:
        | AssetDamageUpsertWithWhereUniqueWithoutIndividualFoodStoreItemInput
        | AssetDamageUpsertWithWhereUniqueWithoutIndividualFoodStoreItemInput[];
      createMany?: AssetDamageCreateManyIndividualFoodStoreItemInputEnvelope;
      set?: AssetDamageWhereUniqueInput | AssetDamageWhereUniqueInput[];
      disconnect?: AssetDamageWhereUniqueInput | AssetDamageWhereUniqueInput[];
      delete?: AssetDamageWhereUniqueInput | AssetDamageWhereUniqueInput[];
      connect?: AssetDamageWhereUniqueInput | AssetDamageWhereUniqueInput[];
      update?:
        | AssetDamageUpdateWithWhereUniqueWithoutIndividualFoodStoreItemInput
        | AssetDamageUpdateWithWhereUniqueWithoutIndividualFoodStoreItemInput[];
      updateMany?:
        | AssetDamageUpdateManyWithWhereWithoutIndividualFoodStoreItemInput
        | AssetDamageUpdateManyWithWhereWithoutIndividualFoodStoreItemInput[];
      deleteMany?: AssetDamageScalarWhereInput | AssetDamageScalarWhereInput[];
    };

  export type FoodStoreItemCreateNestedOneWithoutConsumptionsInput = {
    create?: XOR<
      FoodStoreItemCreateWithoutConsumptionsInput,
      FoodStoreItemUncheckedCreateWithoutConsumptionsInput
    >;
    connectOrCreate?: FoodStoreItemCreateOrConnectWithoutConsumptionsInput;
    connect?: FoodStoreItemWhereUniqueInput;
  };

  export type FoodStoreItemUpdateOneRequiredWithoutConsumptionsNestedInput = {
    create?: XOR<
      FoodStoreItemCreateWithoutConsumptionsInput,
      FoodStoreItemUncheckedCreateWithoutConsumptionsInput
    >;
    connectOrCreate?: FoodStoreItemCreateOrConnectWithoutConsumptionsInput;
    upsert?: FoodStoreItemUpsertWithoutConsumptionsInput;
    connect?: FoodStoreItemWhereUniqueInput;
    update?: XOR<
      XOR<
        FoodStoreItemUpdateToOneWithWhereWithoutConsumptionsInput,
        FoodStoreItemUpdateWithoutConsumptionsInput
      >,
      FoodStoreItemUncheckedUpdateWithoutConsumptionsInput
    >;
  };

  export type FoodStoreItemCreateNestedManyWithoutSupplierInput = {
    create?:
      | XOR<
          FoodStoreItemCreateWithoutSupplierInput,
          FoodStoreItemUncheckedCreateWithoutSupplierInput
        >
      | FoodStoreItemCreateWithoutSupplierInput[]
      | FoodStoreItemUncheckedCreateWithoutSupplierInput[];
    connectOrCreate?:
      | FoodStoreItemCreateOrConnectWithoutSupplierInput
      | FoodStoreItemCreateOrConnectWithoutSupplierInput[];
    createMany?: FoodStoreItemCreateManySupplierInputEnvelope;
    connect?: FoodStoreItemWhereUniqueInput | FoodStoreItemWhereUniqueInput[];
  };

  export type FoodStoreItemUncheckedCreateNestedManyWithoutSupplierInput = {
    create?:
      | XOR<
          FoodStoreItemCreateWithoutSupplierInput,
          FoodStoreItemUncheckedCreateWithoutSupplierInput
        >
      | FoodStoreItemCreateWithoutSupplierInput[]
      | FoodStoreItemUncheckedCreateWithoutSupplierInput[];
    connectOrCreate?:
      | FoodStoreItemCreateOrConnectWithoutSupplierInput
      | FoodStoreItemCreateOrConnectWithoutSupplierInput[];
    createMany?: FoodStoreItemCreateManySupplierInputEnvelope;
    connect?: FoodStoreItemWhereUniqueInput | FoodStoreItemWhereUniqueInput[];
  };

  export type FoodStoreItemUpdateManyWithoutSupplierNestedInput = {
    create?:
      | XOR<
          FoodStoreItemCreateWithoutSupplierInput,
          FoodStoreItemUncheckedCreateWithoutSupplierInput
        >
      | FoodStoreItemCreateWithoutSupplierInput[]
      | FoodStoreItemUncheckedCreateWithoutSupplierInput[];
    connectOrCreate?:
      | FoodStoreItemCreateOrConnectWithoutSupplierInput
      | FoodStoreItemCreateOrConnectWithoutSupplierInput[];
    upsert?:
      | FoodStoreItemUpsertWithWhereUniqueWithoutSupplierInput
      | FoodStoreItemUpsertWithWhereUniqueWithoutSupplierInput[];
    createMany?: FoodStoreItemCreateManySupplierInputEnvelope;
    set?: FoodStoreItemWhereUniqueInput | FoodStoreItemWhereUniqueInput[];
    disconnect?:
      | FoodStoreItemWhereUniqueInput
      | FoodStoreItemWhereUniqueInput[];
    delete?: FoodStoreItemWhereUniqueInput | FoodStoreItemWhereUniqueInput[];
    connect?: FoodStoreItemWhereUniqueInput | FoodStoreItemWhereUniqueInput[];
    update?:
      | FoodStoreItemUpdateWithWhereUniqueWithoutSupplierInput
      | FoodStoreItemUpdateWithWhereUniqueWithoutSupplierInput[];
    updateMany?:
      | FoodStoreItemUpdateManyWithWhereWithoutSupplierInput
      | FoodStoreItemUpdateManyWithWhereWithoutSupplierInput[];
    deleteMany?:
      | FoodStoreItemScalarWhereInput
      | FoodStoreItemScalarWhereInput[];
  };

  export type FoodStoreItemUncheckedUpdateManyWithoutSupplierNestedInput = {
    create?:
      | XOR<
          FoodStoreItemCreateWithoutSupplierInput,
          FoodStoreItemUncheckedCreateWithoutSupplierInput
        >
      | FoodStoreItemCreateWithoutSupplierInput[]
      | FoodStoreItemUncheckedCreateWithoutSupplierInput[];
    connectOrCreate?:
      | FoodStoreItemCreateOrConnectWithoutSupplierInput
      | FoodStoreItemCreateOrConnectWithoutSupplierInput[];
    upsert?:
      | FoodStoreItemUpsertWithWhereUniqueWithoutSupplierInput
      | FoodStoreItemUpsertWithWhereUniqueWithoutSupplierInput[];
    createMany?: FoodStoreItemCreateManySupplierInputEnvelope;
    set?: FoodStoreItemWhereUniqueInput | FoodStoreItemWhereUniqueInput[];
    disconnect?:
      | FoodStoreItemWhereUniqueInput
      | FoodStoreItemWhereUniqueInput[];
    delete?: FoodStoreItemWhereUniqueInput | FoodStoreItemWhereUniqueInput[];
    connect?: FoodStoreItemWhereUniqueInput | FoodStoreItemWhereUniqueInput[];
    update?:
      | FoodStoreItemUpdateWithWhereUniqueWithoutSupplierInput
      | FoodStoreItemUpdateWithWhereUniqueWithoutSupplierInput[];
    updateMany?:
      | FoodStoreItemUpdateManyWithWhereWithoutSupplierInput
      | FoodStoreItemUpdateManyWithWhereWithoutSupplierInput[];
    deleteMany?:
      | FoodStoreItemScalarWhereInput
      | FoodStoreItemScalarWhereInput[];
  };

  export type IndividualBookCreateNestedManyWithoutLibraryBookInput = {
    create?:
      | XOR<
          IndividualBookCreateWithoutLibraryBookInput,
          IndividualBookUncheckedCreateWithoutLibraryBookInput
        >
      | IndividualBookCreateWithoutLibraryBookInput[]
      | IndividualBookUncheckedCreateWithoutLibraryBookInput[];
    connectOrCreate?:
      | IndividualBookCreateOrConnectWithoutLibraryBookInput
      | IndividualBookCreateOrConnectWithoutLibraryBookInput[];
    createMany?: IndividualBookCreateManyLibraryBookInputEnvelope;
    connect?: IndividualBookWhereUniqueInput | IndividualBookWhereUniqueInput[];
  };

  export type AssetCreateNestedOneWithoutLibraryBooksInput = {
    create?: XOR<
      AssetCreateWithoutLibraryBooksInput,
      AssetUncheckedCreateWithoutLibraryBooksInput
    >;
    connectOrCreate?: AssetCreateOrConnectWithoutLibraryBooksInput;
    connect?: AssetWhereUniqueInput;
  };

  export type LibraryBookCategoryCreateNestedOneWithoutLibraryBooksInput = {
    create?: XOR<
      LibraryBookCategoryCreateWithoutLibraryBooksInput,
      LibraryBookCategoryUncheckedCreateWithoutLibraryBooksInput
    >;
    connectOrCreate?: LibraryBookCategoryCreateOrConnectWithoutLibraryBooksInput;
    connect?: LibraryBookCategoryWhereUniqueInput;
  };

  export type IndividualBookUncheckedCreateNestedManyWithoutLibraryBookInput = {
    create?:
      | XOR<
          IndividualBookCreateWithoutLibraryBookInput,
          IndividualBookUncheckedCreateWithoutLibraryBookInput
        >
      | IndividualBookCreateWithoutLibraryBookInput[]
      | IndividualBookUncheckedCreateWithoutLibraryBookInput[];
    connectOrCreate?:
      | IndividualBookCreateOrConnectWithoutLibraryBookInput
      | IndividualBookCreateOrConnectWithoutLibraryBookInput[];
    createMany?: IndividualBookCreateManyLibraryBookInputEnvelope;
    connect?: IndividualBookWhereUniqueInput | IndividualBookWhereUniqueInput[];
  };

  export type IndividualBookUpdateManyWithoutLibraryBookNestedInput = {
    create?:
      | XOR<
          IndividualBookCreateWithoutLibraryBookInput,
          IndividualBookUncheckedCreateWithoutLibraryBookInput
        >
      | IndividualBookCreateWithoutLibraryBookInput[]
      | IndividualBookUncheckedCreateWithoutLibraryBookInput[];
    connectOrCreate?:
      | IndividualBookCreateOrConnectWithoutLibraryBookInput
      | IndividualBookCreateOrConnectWithoutLibraryBookInput[];
    upsert?:
      | IndividualBookUpsertWithWhereUniqueWithoutLibraryBookInput
      | IndividualBookUpsertWithWhereUniqueWithoutLibraryBookInput[];
    createMany?: IndividualBookCreateManyLibraryBookInputEnvelope;
    set?: IndividualBookWhereUniqueInput | IndividualBookWhereUniqueInput[];
    disconnect?:
      | IndividualBookWhereUniqueInput
      | IndividualBookWhereUniqueInput[];
    delete?: IndividualBookWhereUniqueInput | IndividualBookWhereUniqueInput[];
    connect?: IndividualBookWhereUniqueInput | IndividualBookWhereUniqueInput[];
    update?:
      | IndividualBookUpdateWithWhereUniqueWithoutLibraryBookInput
      | IndividualBookUpdateWithWhereUniqueWithoutLibraryBookInput[];
    updateMany?:
      | IndividualBookUpdateManyWithWhereWithoutLibraryBookInput
      | IndividualBookUpdateManyWithWhereWithoutLibraryBookInput[];
    deleteMany?:
      | IndividualBookScalarWhereInput
      | IndividualBookScalarWhereInput[];
  };

  export type AssetUpdateOneRequiredWithoutLibraryBooksNestedInput = {
    create?: XOR<
      AssetCreateWithoutLibraryBooksInput,
      AssetUncheckedCreateWithoutLibraryBooksInput
    >;
    connectOrCreate?: AssetCreateOrConnectWithoutLibraryBooksInput;
    upsert?: AssetUpsertWithoutLibraryBooksInput;
    connect?: AssetWhereUniqueInput;
    update?: XOR<
      XOR<
        AssetUpdateToOneWithWhereWithoutLibraryBooksInput,
        AssetUpdateWithoutLibraryBooksInput
      >,
      AssetUncheckedUpdateWithoutLibraryBooksInput
    >;
  };

  export type LibraryBookCategoryUpdateOneRequiredWithoutLibraryBooksNestedInput =
    {
      create?: XOR<
        LibraryBookCategoryCreateWithoutLibraryBooksInput,
        LibraryBookCategoryUncheckedCreateWithoutLibraryBooksInput
      >;
      connectOrCreate?: LibraryBookCategoryCreateOrConnectWithoutLibraryBooksInput;
      upsert?: LibraryBookCategoryUpsertWithoutLibraryBooksInput;
      connect?: LibraryBookCategoryWhereUniqueInput;
      update?: XOR<
        XOR<
          LibraryBookCategoryUpdateToOneWithWhereWithoutLibraryBooksInput,
          LibraryBookCategoryUpdateWithoutLibraryBooksInput
        >,
        LibraryBookCategoryUncheckedUpdateWithoutLibraryBooksInput
      >;
    };

  export type IndividualBookUncheckedUpdateManyWithoutLibraryBookNestedInput = {
    create?:
      | XOR<
          IndividualBookCreateWithoutLibraryBookInput,
          IndividualBookUncheckedCreateWithoutLibraryBookInput
        >
      | IndividualBookCreateWithoutLibraryBookInput[]
      | IndividualBookUncheckedCreateWithoutLibraryBookInput[];
    connectOrCreate?:
      | IndividualBookCreateOrConnectWithoutLibraryBookInput
      | IndividualBookCreateOrConnectWithoutLibraryBookInput[];
    upsert?:
      | IndividualBookUpsertWithWhereUniqueWithoutLibraryBookInput
      | IndividualBookUpsertWithWhereUniqueWithoutLibraryBookInput[];
    createMany?: IndividualBookCreateManyLibraryBookInputEnvelope;
    set?: IndividualBookWhereUniqueInput | IndividualBookWhereUniqueInput[];
    disconnect?:
      | IndividualBookWhereUniqueInput
      | IndividualBookWhereUniqueInput[];
    delete?: IndividualBookWhereUniqueInput | IndividualBookWhereUniqueInput[];
    connect?: IndividualBookWhereUniqueInput | IndividualBookWhereUniqueInput[];
    update?:
      | IndividualBookUpdateWithWhereUniqueWithoutLibraryBookInput
      | IndividualBookUpdateWithWhereUniqueWithoutLibraryBookInput[];
    updateMany?:
      | IndividualBookUpdateManyWithWhereWithoutLibraryBookInput
      | IndividualBookUpdateManyWithWhereWithoutLibraryBookInput[];
    deleteMany?:
      | IndividualBookScalarWhereInput
      | IndividualBookScalarWhereInput[];
  };

  export type AssetDamageCreateNestedManyWithoutIndividualBookInput = {
    create?:
      | XOR<
          AssetDamageCreateWithoutIndividualBookInput,
          AssetDamageUncheckedCreateWithoutIndividualBookInput
        >
      | AssetDamageCreateWithoutIndividualBookInput[]
      | AssetDamageUncheckedCreateWithoutIndividualBookInput[];
    connectOrCreate?:
      | AssetDamageCreateOrConnectWithoutIndividualBookInput
      | AssetDamageCreateOrConnectWithoutIndividualBookInput[];
    createMany?: AssetDamageCreateManyIndividualBookInputEnvelope;
    connect?: AssetDamageWhereUniqueInput | AssetDamageWhereUniqueInput[];
  };

  export type BorrowerCreateNestedManyWithoutLibraryBookInput = {
    create?:
      | XOR<
          BorrowerCreateWithoutLibraryBookInput,
          BorrowerUncheckedCreateWithoutLibraryBookInput
        >
      | BorrowerCreateWithoutLibraryBookInput[]
      | BorrowerUncheckedCreateWithoutLibraryBookInput[];
    connectOrCreate?:
      | BorrowerCreateOrConnectWithoutLibraryBookInput
      | BorrowerCreateOrConnectWithoutLibraryBookInput[];
    createMany?: BorrowerCreateManyLibraryBookInputEnvelope;
    connect?: BorrowerWhereUniqueInput | BorrowerWhereUniqueInput[];
  };

  export type LibraryBookCreateNestedOneWithoutIndividualBooksInput = {
    create?: XOR<
      LibraryBookCreateWithoutIndividualBooksInput,
      LibraryBookUncheckedCreateWithoutIndividualBooksInput
    >;
    connectOrCreate?: LibraryBookCreateOrConnectWithoutIndividualBooksInput;
    connect?: LibraryBookWhereUniqueInput;
  };

  export type AssetDamageUncheckedCreateNestedManyWithoutIndividualBookInput = {
    create?:
      | XOR<
          AssetDamageCreateWithoutIndividualBookInput,
          AssetDamageUncheckedCreateWithoutIndividualBookInput
        >
      | AssetDamageCreateWithoutIndividualBookInput[]
      | AssetDamageUncheckedCreateWithoutIndividualBookInput[];
    connectOrCreate?:
      | AssetDamageCreateOrConnectWithoutIndividualBookInput
      | AssetDamageCreateOrConnectWithoutIndividualBookInput[];
    createMany?: AssetDamageCreateManyIndividualBookInputEnvelope;
    connect?: AssetDamageWhereUniqueInput | AssetDamageWhereUniqueInput[];
  };

  export type BorrowerUncheckedCreateNestedManyWithoutLibraryBookInput = {
    create?:
      | XOR<
          BorrowerCreateWithoutLibraryBookInput,
          BorrowerUncheckedCreateWithoutLibraryBookInput
        >
      | BorrowerCreateWithoutLibraryBookInput[]
      | BorrowerUncheckedCreateWithoutLibraryBookInput[];
    connectOrCreate?:
      | BorrowerCreateOrConnectWithoutLibraryBookInput
      | BorrowerCreateOrConnectWithoutLibraryBookInput[];
    createMany?: BorrowerCreateManyLibraryBookInputEnvelope;
    connect?: BorrowerWhereUniqueInput | BorrowerWhereUniqueInput[];
  };

  export type EnumBookStatusFieldUpdateOperationsInput = {
    set?: $Enums.BookStatus;
  };

  export type AssetDamageUpdateManyWithoutIndividualBookNestedInput = {
    create?:
      | XOR<
          AssetDamageCreateWithoutIndividualBookInput,
          AssetDamageUncheckedCreateWithoutIndividualBookInput
        >
      | AssetDamageCreateWithoutIndividualBookInput[]
      | AssetDamageUncheckedCreateWithoutIndividualBookInput[];
    connectOrCreate?:
      | AssetDamageCreateOrConnectWithoutIndividualBookInput
      | AssetDamageCreateOrConnectWithoutIndividualBookInput[];
    upsert?:
      | AssetDamageUpsertWithWhereUniqueWithoutIndividualBookInput
      | AssetDamageUpsertWithWhereUniqueWithoutIndividualBookInput[];
    createMany?: AssetDamageCreateManyIndividualBookInputEnvelope;
    set?: AssetDamageWhereUniqueInput | AssetDamageWhereUniqueInput[];
    disconnect?: AssetDamageWhereUniqueInput | AssetDamageWhereUniqueInput[];
    delete?: AssetDamageWhereUniqueInput | AssetDamageWhereUniqueInput[];
    connect?: AssetDamageWhereUniqueInput | AssetDamageWhereUniqueInput[];
    update?:
      | AssetDamageUpdateWithWhereUniqueWithoutIndividualBookInput
      | AssetDamageUpdateWithWhereUniqueWithoutIndividualBookInput[];
    updateMany?:
      | AssetDamageUpdateManyWithWhereWithoutIndividualBookInput
      | AssetDamageUpdateManyWithWhereWithoutIndividualBookInput[];
    deleteMany?: AssetDamageScalarWhereInput | AssetDamageScalarWhereInput[];
  };

  export type BorrowerUpdateManyWithoutLibraryBookNestedInput = {
    create?:
      | XOR<
          BorrowerCreateWithoutLibraryBookInput,
          BorrowerUncheckedCreateWithoutLibraryBookInput
        >
      | BorrowerCreateWithoutLibraryBookInput[]
      | BorrowerUncheckedCreateWithoutLibraryBookInput[];
    connectOrCreate?:
      | BorrowerCreateOrConnectWithoutLibraryBookInput
      | BorrowerCreateOrConnectWithoutLibraryBookInput[];
    upsert?:
      | BorrowerUpsertWithWhereUniqueWithoutLibraryBookInput
      | BorrowerUpsertWithWhereUniqueWithoutLibraryBookInput[];
    createMany?: BorrowerCreateManyLibraryBookInputEnvelope;
    set?: BorrowerWhereUniqueInput | BorrowerWhereUniqueInput[];
    disconnect?: BorrowerWhereUniqueInput | BorrowerWhereUniqueInput[];
    delete?: BorrowerWhereUniqueInput | BorrowerWhereUniqueInput[];
    connect?: BorrowerWhereUniqueInput | BorrowerWhereUniqueInput[];
    update?:
      | BorrowerUpdateWithWhereUniqueWithoutLibraryBookInput
      | BorrowerUpdateWithWhereUniqueWithoutLibraryBookInput[];
    updateMany?:
      | BorrowerUpdateManyWithWhereWithoutLibraryBookInput
      | BorrowerUpdateManyWithWhereWithoutLibraryBookInput[];
    deleteMany?: BorrowerScalarWhereInput | BorrowerScalarWhereInput[];
  };

  export type LibraryBookUpdateOneRequiredWithoutIndividualBooksNestedInput = {
    create?: XOR<
      LibraryBookCreateWithoutIndividualBooksInput,
      LibraryBookUncheckedCreateWithoutIndividualBooksInput
    >;
    connectOrCreate?: LibraryBookCreateOrConnectWithoutIndividualBooksInput;
    upsert?: LibraryBookUpsertWithoutIndividualBooksInput;
    connect?: LibraryBookWhereUniqueInput;
    update?: XOR<
      XOR<
        LibraryBookUpdateToOneWithWhereWithoutIndividualBooksInput,
        LibraryBookUpdateWithoutIndividualBooksInput
      >,
      LibraryBookUncheckedUpdateWithoutIndividualBooksInput
    >;
  };

  export type AssetDamageUncheckedUpdateManyWithoutIndividualBookNestedInput = {
    create?:
      | XOR<
          AssetDamageCreateWithoutIndividualBookInput,
          AssetDamageUncheckedCreateWithoutIndividualBookInput
        >
      | AssetDamageCreateWithoutIndividualBookInput[]
      | AssetDamageUncheckedCreateWithoutIndividualBookInput[];
    connectOrCreate?:
      | AssetDamageCreateOrConnectWithoutIndividualBookInput
      | AssetDamageCreateOrConnectWithoutIndividualBookInput[];
    upsert?:
      | AssetDamageUpsertWithWhereUniqueWithoutIndividualBookInput
      | AssetDamageUpsertWithWhereUniqueWithoutIndividualBookInput[];
    createMany?: AssetDamageCreateManyIndividualBookInputEnvelope;
    set?: AssetDamageWhereUniqueInput | AssetDamageWhereUniqueInput[];
    disconnect?: AssetDamageWhereUniqueInput | AssetDamageWhereUniqueInput[];
    delete?: AssetDamageWhereUniqueInput | AssetDamageWhereUniqueInput[];
    connect?: AssetDamageWhereUniqueInput | AssetDamageWhereUniqueInput[];
    update?:
      | AssetDamageUpdateWithWhereUniqueWithoutIndividualBookInput
      | AssetDamageUpdateWithWhereUniqueWithoutIndividualBookInput[];
    updateMany?:
      | AssetDamageUpdateManyWithWhereWithoutIndividualBookInput
      | AssetDamageUpdateManyWithWhereWithoutIndividualBookInput[];
    deleteMany?: AssetDamageScalarWhereInput | AssetDamageScalarWhereInput[];
  };

  export type BorrowerUncheckedUpdateManyWithoutLibraryBookNestedInput = {
    create?:
      | XOR<
          BorrowerCreateWithoutLibraryBookInput,
          BorrowerUncheckedCreateWithoutLibraryBookInput
        >
      | BorrowerCreateWithoutLibraryBookInput[]
      | BorrowerUncheckedCreateWithoutLibraryBookInput[];
    connectOrCreate?:
      | BorrowerCreateOrConnectWithoutLibraryBookInput
      | BorrowerCreateOrConnectWithoutLibraryBookInput[];
    upsert?:
      | BorrowerUpsertWithWhereUniqueWithoutLibraryBookInput
      | BorrowerUpsertWithWhereUniqueWithoutLibraryBookInput[];
    createMany?: BorrowerCreateManyLibraryBookInputEnvelope;
    set?: BorrowerWhereUniqueInput | BorrowerWhereUniqueInput[];
    disconnect?: BorrowerWhereUniqueInput | BorrowerWhereUniqueInput[];
    delete?: BorrowerWhereUniqueInput | BorrowerWhereUniqueInput[];
    connect?: BorrowerWhereUniqueInput | BorrowerWhereUniqueInput[];
    update?:
      | BorrowerUpdateWithWhereUniqueWithoutLibraryBookInput
      | BorrowerUpdateWithWhereUniqueWithoutLibraryBookInput[];
    updateMany?:
      | BorrowerUpdateManyWithWhereWithoutLibraryBookInput
      | BorrowerUpdateManyWithWhereWithoutLibraryBookInput[];
    deleteMany?: BorrowerScalarWhereInput | BorrowerScalarWhereInput[];
  };

  export type LibraryBookCreateNestedManyWithoutCategoryInput = {
    create?:
      | XOR<
          LibraryBookCreateWithoutCategoryInput,
          LibraryBookUncheckedCreateWithoutCategoryInput
        >
      | LibraryBookCreateWithoutCategoryInput[]
      | LibraryBookUncheckedCreateWithoutCategoryInput[];
    connectOrCreate?:
      | LibraryBookCreateOrConnectWithoutCategoryInput
      | LibraryBookCreateOrConnectWithoutCategoryInput[];
    createMany?: LibraryBookCreateManyCategoryInputEnvelope;
    connect?: LibraryBookWhereUniqueInput | LibraryBookWhereUniqueInput[];
  };

  export type LibraryBookUncheckedCreateNestedManyWithoutCategoryInput = {
    create?:
      | XOR<
          LibraryBookCreateWithoutCategoryInput,
          LibraryBookUncheckedCreateWithoutCategoryInput
        >
      | LibraryBookCreateWithoutCategoryInput[]
      | LibraryBookUncheckedCreateWithoutCategoryInput[];
    connectOrCreate?:
      | LibraryBookCreateOrConnectWithoutCategoryInput
      | LibraryBookCreateOrConnectWithoutCategoryInput[];
    createMany?: LibraryBookCreateManyCategoryInputEnvelope;
    connect?: LibraryBookWhereUniqueInput | LibraryBookWhereUniqueInput[];
  };

  export type LibraryBookUpdateManyWithoutCategoryNestedInput = {
    create?:
      | XOR<
          LibraryBookCreateWithoutCategoryInput,
          LibraryBookUncheckedCreateWithoutCategoryInput
        >
      | LibraryBookCreateWithoutCategoryInput[]
      | LibraryBookUncheckedCreateWithoutCategoryInput[];
    connectOrCreate?:
      | LibraryBookCreateOrConnectWithoutCategoryInput
      | LibraryBookCreateOrConnectWithoutCategoryInput[];
    upsert?:
      | LibraryBookUpsertWithWhereUniqueWithoutCategoryInput
      | LibraryBookUpsertWithWhereUniqueWithoutCategoryInput[];
    createMany?: LibraryBookCreateManyCategoryInputEnvelope;
    set?: LibraryBookWhereUniqueInput | LibraryBookWhereUniqueInput[];
    disconnect?: LibraryBookWhereUniqueInput | LibraryBookWhereUniqueInput[];
    delete?: LibraryBookWhereUniqueInput | LibraryBookWhereUniqueInput[];
    connect?: LibraryBookWhereUniqueInput | LibraryBookWhereUniqueInput[];
    update?:
      | LibraryBookUpdateWithWhereUniqueWithoutCategoryInput
      | LibraryBookUpdateWithWhereUniqueWithoutCategoryInput[];
    updateMany?:
      | LibraryBookUpdateManyWithWhereWithoutCategoryInput
      | LibraryBookUpdateManyWithWhereWithoutCategoryInput[];
    deleteMany?: LibraryBookScalarWhereInput | LibraryBookScalarWhereInput[];
  };

  export type LibraryBookUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?:
      | XOR<
          LibraryBookCreateWithoutCategoryInput,
          LibraryBookUncheckedCreateWithoutCategoryInput
        >
      | LibraryBookCreateWithoutCategoryInput[]
      | LibraryBookUncheckedCreateWithoutCategoryInput[];
    connectOrCreate?:
      | LibraryBookCreateOrConnectWithoutCategoryInput
      | LibraryBookCreateOrConnectWithoutCategoryInput[];
    upsert?:
      | LibraryBookUpsertWithWhereUniqueWithoutCategoryInput
      | LibraryBookUpsertWithWhereUniqueWithoutCategoryInput[];
    createMany?: LibraryBookCreateManyCategoryInputEnvelope;
    set?: LibraryBookWhereUniqueInput | LibraryBookWhereUniqueInput[];
    disconnect?: LibraryBookWhereUniqueInput | LibraryBookWhereUniqueInput[];
    delete?: LibraryBookWhereUniqueInput | LibraryBookWhereUniqueInput[];
    connect?: LibraryBookWhereUniqueInput | LibraryBookWhereUniqueInput[];
    update?:
      | LibraryBookUpdateWithWhereUniqueWithoutCategoryInput
      | LibraryBookUpdateWithWhereUniqueWithoutCategoryInput[];
    updateMany?:
      | LibraryBookUpdateManyWithWhereWithoutCategoryInput
      | LibraryBookUpdateManyWithWhereWithoutCategoryInput[];
    deleteMany?: LibraryBookScalarWhereInput | LibraryBookScalarWhereInput[];
  };

  export type IndividualBookCreateNestedOneWithoutBorrowersInput = {
    create?: XOR<
      IndividualBookCreateWithoutBorrowersInput,
      IndividualBookUncheckedCreateWithoutBorrowersInput
    >;
    connectOrCreate?: IndividualBookCreateOrConnectWithoutBorrowersInput;
    connect?: IndividualBookWhereUniqueInput;
  };

  export type UserCreateNestedOneWithoutBorrowersInput = {
    create?: XOR<
      UserCreateWithoutBorrowersInput,
      UserUncheckedCreateWithoutBorrowersInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutBorrowersInput;
    connect?: UserWhereUniqueInput;
  };

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null;
  };

  export type EnumBorrowStatusFieldUpdateOperationsInput = {
    set?: $Enums.BorrowStatus;
  };

  export type IndividualBookUpdateOneWithoutBorrowersNestedInput = {
    create?: XOR<
      IndividualBookCreateWithoutBorrowersInput,
      IndividualBookUncheckedCreateWithoutBorrowersInput
    >;
    connectOrCreate?: IndividualBookCreateOrConnectWithoutBorrowersInput;
    upsert?: IndividualBookUpsertWithoutBorrowersInput;
    disconnect?: IndividualBookWhereInput | boolean;
    delete?: IndividualBookWhereInput | boolean;
    connect?: IndividualBookWhereUniqueInput;
    update?: XOR<
      XOR<
        IndividualBookUpdateToOneWithWhereWithoutBorrowersInput,
        IndividualBookUpdateWithoutBorrowersInput
      >,
      IndividualBookUncheckedUpdateWithoutBorrowersInput
    >;
  };

  export type UserUpdateOneRequiredWithoutBorrowersNestedInput = {
    create?: XOR<
      UserCreateWithoutBorrowersInput,
      UserUncheckedCreateWithoutBorrowersInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutBorrowersInput;
    upsert?: UserUpsertWithoutBorrowersInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutBorrowersInput,
        UserUpdateWithoutBorrowersInput
      >,
      UserUncheckedUpdateWithoutBorrowersInput
    >;
  };

  export type IndividualLabItemCreateNestedManyWithoutLabItemInput = {
    create?:
      | XOR<
          IndividualLabItemCreateWithoutLabItemInput,
          IndividualLabItemUncheckedCreateWithoutLabItemInput
        >
      | IndividualLabItemCreateWithoutLabItemInput[]
      | IndividualLabItemUncheckedCreateWithoutLabItemInput[];
    connectOrCreate?:
      | IndividualLabItemCreateOrConnectWithoutLabItemInput
      | IndividualLabItemCreateOrConnectWithoutLabItemInput[];
    createMany?: IndividualLabItemCreateManyLabItemInputEnvelope;
    connect?:
      | IndividualLabItemWhereUniqueInput
      | IndividualLabItemWhereUniqueInput[];
  };

  export type AssetCreateNestedOneWithoutLabItemsInput = {
    create?: XOR<
      AssetCreateWithoutLabItemsInput,
      AssetUncheckedCreateWithoutLabItemsInput
    >;
    connectOrCreate?: AssetCreateOrConnectWithoutLabItemsInput;
    connect?: AssetWhereUniqueInput;
  };

  export type IndividualLabItemUncheckedCreateNestedManyWithoutLabItemInput = {
    create?:
      | XOR<
          IndividualLabItemCreateWithoutLabItemInput,
          IndividualLabItemUncheckedCreateWithoutLabItemInput
        >
      | IndividualLabItemCreateWithoutLabItemInput[]
      | IndividualLabItemUncheckedCreateWithoutLabItemInput[];
    connectOrCreate?:
      | IndividualLabItemCreateOrConnectWithoutLabItemInput
      | IndividualLabItemCreateOrConnectWithoutLabItemInput[];
    createMany?: IndividualLabItemCreateManyLabItemInputEnvelope;
    connect?:
      | IndividualLabItemWhereUniqueInput
      | IndividualLabItemWhereUniqueInput[];
  };

  export type IndividualLabItemUpdateManyWithoutLabItemNestedInput = {
    create?:
      | XOR<
          IndividualLabItemCreateWithoutLabItemInput,
          IndividualLabItemUncheckedCreateWithoutLabItemInput
        >
      | IndividualLabItemCreateWithoutLabItemInput[]
      | IndividualLabItemUncheckedCreateWithoutLabItemInput[];
    connectOrCreate?:
      | IndividualLabItemCreateOrConnectWithoutLabItemInput
      | IndividualLabItemCreateOrConnectWithoutLabItemInput[];
    upsert?:
      | IndividualLabItemUpsertWithWhereUniqueWithoutLabItemInput
      | IndividualLabItemUpsertWithWhereUniqueWithoutLabItemInput[];
    createMany?: IndividualLabItemCreateManyLabItemInputEnvelope;
    set?:
      | IndividualLabItemWhereUniqueInput
      | IndividualLabItemWhereUniqueInput[];
    disconnect?:
      | IndividualLabItemWhereUniqueInput
      | IndividualLabItemWhereUniqueInput[];
    delete?:
      | IndividualLabItemWhereUniqueInput
      | IndividualLabItemWhereUniqueInput[];
    connect?:
      | IndividualLabItemWhereUniqueInput
      | IndividualLabItemWhereUniqueInput[];
    update?:
      | IndividualLabItemUpdateWithWhereUniqueWithoutLabItemInput
      | IndividualLabItemUpdateWithWhereUniqueWithoutLabItemInput[];
    updateMany?:
      | IndividualLabItemUpdateManyWithWhereWithoutLabItemInput
      | IndividualLabItemUpdateManyWithWhereWithoutLabItemInput[];
    deleteMany?:
      | IndividualLabItemScalarWhereInput
      | IndividualLabItemScalarWhereInput[];
  };

  export type AssetUpdateOneRequiredWithoutLabItemsNestedInput = {
    create?: XOR<
      AssetCreateWithoutLabItemsInput,
      AssetUncheckedCreateWithoutLabItemsInput
    >;
    connectOrCreate?: AssetCreateOrConnectWithoutLabItemsInput;
    upsert?: AssetUpsertWithoutLabItemsInput;
    connect?: AssetWhereUniqueInput;
    update?: XOR<
      XOR<
        AssetUpdateToOneWithWhereWithoutLabItemsInput,
        AssetUpdateWithoutLabItemsInput
      >,
      AssetUncheckedUpdateWithoutLabItemsInput
    >;
  };

  export type IndividualLabItemUncheckedUpdateManyWithoutLabItemNestedInput = {
    create?:
      | XOR<
          IndividualLabItemCreateWithoutLabItemInput,
          IndividualLabItemUncheckedCreateWithoutLabItemInput
        >
      | IndividualLabItemCreateWithoutLabItemInput[]
      | IndividualLabItemUncheckedCreateWithoutLabItemInput[];
    connectOrCreate?:
      | IndividualLabItemCreateOrConnectWithoutLabItemInput
      | IndividualLabItemCreateOrConnectWithoutLabItemInput[];
    upsert?:
      | IndividualLabItemUpsertWithWhereUniqueWithoutLabItemInput
      | IndividualLabItemUpsertWithWhereUniqueWithoutLabItemInput[];
    createMany?: IndividualLabItemCreateManyLabItemInputEnvelope;
    set?:
      | IndividualLabItemWhereUniqueInput
      | IndividualLabItemWhereUniqueInput[];
    disconnect?:
      | IndividualLabItemWhereUniqueInput
      | IndividualLabItemWhereUniqueInput[];
    delete?:
      | IndividualLabItemWhereUniqueInput
      | IndividualLabItemWhereUniqueInput[];
    connect?:
      | IndividualLabItemWhereUniqueInput
      | IndividualLabItemWhereUniqueInput[];
    update?:
      | IndividualLabItemUpdateWithWhereUniqueWithoutLabItemInput
      | IndividualLabItemUpdateWithWhereUniqueWithoutLabItemInput[];
    updateMany?:
      | IndividualLabItemUpdateManyWithWhereWithoutLabItemInput
      | IndividualLabItemUpdateManyWithWhereWithoutLabItemInput[];
    deleteMany?:
      | IndividualLabItemScalarWhereInput
      | IndividualLabItemScalarWhereInput[];
  };

  export type AssetDamageCreateNestedManyWithoutIndividualLabItemInput = {
    create?:
      | XOR<
          AssetDamageCreateWithoutIndividualLabItemInput,
          AssetDamageUncheckedCreateWithoutIndividualLabItemInput
        >
      | AssetDamageCreateWithoutIndividualLabItemInput[]
      | AssetDamageUncheckedCreateWithoutIndividualLabItemInput[];
    connectOrCreate?:
      | AssetDamageCreateOrConnectWithoutIndividualLabItemInput
      | AssetDamageCreateOrConnectWithoutIndividualLabItemInput[];
    createMany?: AssetDamageCreateManyIndividualLabItemInputEnvelope;
    connect?: AssetDamageWhereUniqueInput | AssetDamageWhereUniqueInput[];
  };

  export type LabItemCreateNestedOneWithoutIndividualLabItemsInput = {
    create?: XOR<
      LabItemCreateWithoutIndividualLabItemsInput,
      LabItemUncheckedCreateWithoutIndividualLabItemsInput
    >;
    connectOrCreate?: LabItemCreateOrConnectWithoutIndividualLabItemsInput;
    connect?: LabItemWhereUniqueInput;
  };

  export type AssetDamageUncheckedCreateNestedManyWithoutIndividualLabItemInput =
    {
      create?:
        | XOR<
            AssetDamageCreateWithoutIndividualLabItemInput,
            AssetDamageUncheckedCreateWithoutIndividualLabItemInput
          >
        | AssetDamageCreateWithoutIndividualLabItemInput[]
        | AssetDamageUncheckedCreateWithoutIndividualLabItemInput[];
      connectOrCreate?:
        | AssetDamageCreateOrConnectWithoutIndividualLabItemInput
        | AssetDamageCreateOrConnectWithoutIndividualLabItemInput[];
      createMany?: AssetDamageCreateManyIndividualLabItemInputEnvelope;
      connect?: AssetDamageWhereUniqueInput | AssetDamageWhereUniqueInput[];
    };

  export type AssetDamageUpdateManyWithoutIndividualLabItemNestedInput = {
    create?:
      | XOR<
          AssetDamageCreateWithoutIndividualLabItemInput,
          AssetDamageUncheckedCreateWithoutIndividualLabItemInput
        >
      | AssetDamageCreateWithoutIndividualLabItemInput[]
      | AssetDamageUncheckedCreateWithoutIndividualLabItemInput[];
    connectOrCreate?:
      | AssetDamageCreateOrConnectWithoutIndividualLabItemInput
      | AssetDamageCreateOrConnectWithoutIndividualLabItemInput[];
    upsert?:
      | AssetDamageUpsertWithWhereUniqueWithoutIndividualLabItemInput
      | AssetDamageUpsertWithWhereUniqueWithoutIndividualLabItemInput[];
    createMany?: AssetDamageCreateManyIndividualLabItemInputEnvelope;
    set?: AssetDamageWhereUniqueInput | AssetDamageWhereUniqueInput[];
    disconnect?: AssetDamageWhereUniqueInput | AssetDamageWhereUniqueInput[];
    delete?: AssetDamageWhereUniqueInput | AssetDamageWhereUniqueInput[];
    connect?: AssetDamageWhereUniqueInput | AssetDamageWhereUniqueInput[];
    update?:
      | AssetDamageUpdateWithWhereUniqueWithoutIndividualLabItemInput
      | AssetDamageUpdateWithWhereUniqueWithoutIndividualLabItemInput[];
    updateMany?:
      | AssetDamageUpdateManyWithWhereWithoutIndividualLabItemInput
      | AssetDamageUpdateManyWithWhereWithoutIndividualLabItemInput[];
    deleteMany?: AssetDamageScalarWhereInput | AssetDamageScalarWhereInput[];
  };

  export type LabItemUpdateOneRequiredWithoutIndividualLabItemsNestedInput = {
    create?: XOR<
      LabItemCreateWithoutIndividualLabItemsInput,
      LabItemUncheckedCreateWithoutIndividualLabItemsInput
    >;
    connectOrCreate?: LabItemCreateOrConnectWithoutIndividualLabItemsInput;
    upsert?: LabItemUpsertWithoutIndividualLabItemsInput;
    connect?: LabItemWhereUniqueInput;
    update?: XOR<
      XOR<
        LabItemUpdateToOneWithWhereWithoutIndividualLabItemsInput,
        LabItemUpdateWithoutIndividualLabItemsInput
      >,
      LabItemUncheckedUpdateWithoutIndividualLabItemsInput
    >;
  };

  export type AssetDamageUncheckedUpdateManyWithoutIndividualLabItemNestedInput =
    {
      create?:
        | XOR<
            AssetDamageCreateWithoutIndividualLabItemInput,
            AssetDamageUncheckedCreateWithoutIndividualLabItemInput
          >
        | AssetDamageCreateWithoutIndividualLabItemInput[]
        | AssetDamageUncheckedCreateWithoutIndividualLabItemInput[];
      connectOrCreate?:
        | AssetDamageCreateOrConnectWithoutIndividualLabItemInput
        | AssetDamageCreateOrConnectWithoutIndividualLabItemInput[];
      upsert?:
        | AssetDamageUpsertWithWhereUniqueWithoutIndividualLabItemInput
        | AssetDamageUpsertWithWhereUniqueWithoutIndividualLabItemInput[];
      createMany?: AssetDamageCreateManyIndividualLabItemInputEnvelope;
      set?: AssetDamageWhereUniqueInput | AssetDamageWhereUniqueInput[];
      disconnect?: AssetDamageWhereUniqueInput | AssetDamageWhereUniqueInput[];
      delete?: AssetDamageWhereUniqueInput | AssetDamageWhereUniqueInput[];
      connect?: AssetDamageWhereUniqueInput | AssetDamageWhereUniqueInput[];
      update?:
        | AssetDamageUpdateWithWhereUniqueWithoutIndividualLabItemInput
        | AssetDamageUpdateWithWhereUniqueWithoutIndividualLabItemInput[];
      updateMany?:
        | AssetDamageUpdateManyWithWhereWithoutIndividualLabItemInput
        | AssetDamageUpdateManyWithWhereWithoutIndividualLabItemInput[];
      deleteMany?: AssetDamageScalarWhereInput | AssetDamageScalarWhereInput[];
    };

  export type AssetCreateNestedOneWithoutComputerLabItemsInput = {
    create?: XOR<
      AssetCreateWithoutComputerLabItemsInput,
      AssetUncheckedCreateWithoutComputerLabItemsInput
    >;
    connectOrCreate?: AssetCreateOrConnectWithoutComputerLabItemsInput;
    connect?: AssetWhereUniqueInput;
  };

  export type IndividualComputerLabItemCreateNestedManyWithoutComputerLabItemInput =
    {
      create?:
        | XOR<
            IndividualComputerLabItemCreateWithoutComputerLabItemInput,
            IndividualComputerLabItemUncheckedCreateWithoutComputerLabItemInput
          >
        | IndividualComputerLabItemCreateWithoutComputerLabItemInput[]
        | IndividualComputerLabItemUncheckedCreateWithoutComputerLabItemInput[];
      connectOrCreate?:
        | IndividualComputerLabItemCreateOrConnectWithoutComputerLabItemInput
        | IndividualComputerLabItemCreateOrConnectWithoutComputerLabItemInput[];
      createMany?: IndividualComputerLabItemCreateManyComputerLabItemInputEnvelope;
      connect?:
        | IndividualComputerLabItemWhereUniqueInput
        | IndividualComputerLabItemWhereUniqueInput[];
    };

  export type IndividualComputerLabItemUncheckedCreateNestedManyWithoutComputerLabItemInput =
    {
      create?:
        | XOR<
            IndividualComputerLabItemCreateWithoutComputerLabItemInput,
            IndividualComputerLabItemUncheckedCreateWithoutComputerLabItemInput
          >
        | IndividualComputerLabItemCreateWithoutComputerLabItemInput[]
        | IndividualComputerLabItemUncheckedCreateWithoutComputerLabItemInput[];
      connectOrCreate?:
        | IndividualComputerLabItemCreateOrConnectWithoutComputerLabItemInput
        | IndividualComputerLabItemCreateOrConnectWithoutComputerLabItemInput[];
      createMany?: IndividualComputerLabItemCreateManyComputerLabItemInputEnvelope;
      connect?:
        | IndividualComputerLabItemWhereUniqueInput
        | IndividualComputerLabItemWhereUniqueInput[];
    };

  export type AssetUpdateOneRequiredWithoutComputerLabItemsNestedInput = {
    create?: XOR<
      AssetCreateWithoutComputerLabItemsInput,
      AssetUncheckedCreateWithoutComputerLabItemsInput
    >;
    connectOrCreate?: AssetCreateOrConnectWithoutComputerLabItemsInput;
    upsert?: AssetUpsertWithoutComputerLabItemsInput;
    connect?: AssetWhereUniqueInput;
    update?: XOR<
      XOR<
        AssetUpdateToOneWithWhereWithoutComputerLabItemsInput,
        AssetUpdateWithoutComputerLabItemsInput
      >,
      AssetUncheckedUpdateWithoutComputerLabItemsInput
    >;
  };

  export type IndividualComputerLabItemUpdateManyWithoutComputerLabItemNestedInput =
    {
      create?:
        | XOR<
            IndividualComputerLabItemCreateWithoutComputerLabItemInput,
            IndividualComputerLabItemUncheckedCreateWithoutComputerLabItemInput
          >
        | IndividualComputerLabItemCreateWithoutComputerLabItemInput[]
        | IndividualComputerLabItemUncheckedCreateWithoutComputerLabItemInput[];
      connectOrCreate?:
        | IndividualComputerLabItemCreateOrConnectWithoutComputerLabItemInput
        | IndividualComputerLabItemCreateOrConnectWithoutComputerLabItemInput[];
      upsert?:
        | IndividualComputerLabItemUpsertWithWhereUniqueWithoutComputerLabItemInput
        | IndividualComputerLabItemUpsertWithWhereUniqueWithoutComputerLabItemInput[];
      createMany?: IndividualComputerLabItemCreateManyComputerLabItemInputEnvelope;
      set?:
        | IndividualComputerLabItemWhereUniqueInput
        | IndividualComputerLabItemWhereUniqueInput[];
      disconnect?:
        | IndividualComputerLabItemWhereUniqueInput
        | IndividualComputerLabItemWhereUniqueInput[];
      delete?:
        | IndividualComputerLabItemWhereUniqueInput
        | IndividualComputerLabItemWhereUniqueInput[];
      connect?:
        | IndividualComputerLabItemWhereUniqueInput
        | IndividualComputerLabItemWhereUniqueInput[];
      update?:
        | IndividualComputerLabItemUpdateWithWhereUniqueWithoutComputerLabItemInput
        | IndividualComputerLabItemUpdateWithWhereUniqueWithoutComputerLabItemInput[];
      updateMany?:
        | IndividualComputerLabItemUpdateManyWithWhereWithoutComputerLabItemInput
        | IndividualComputerLabItemUpdateManyWithWhereWithoutComputerLabItemInput[];
      deleteMany?:
        | IndividualComputerLabItemScalarWhereInput
        | IndividualComputerLabItemScalarWhereInput[];
    };

  export type IndividualComputerLabItemUncheckedUpdateManyWithoutComputerLabItemNestedInput =
    {
      create?:
        | XOR<
            IndividualComputerLabItemCreateWithoutComputerLabItemInput,
            IndividualComputerLabItemUncheckedCreateWithoutComputerLabItemInput
          >
        | IndividualComputerLabItemCreateWithoutComputerLabItemInput[]
        | IndividualComputerLabItemUncheckedCreateWithoutComputerLabItemInput[];
      connectOrCreate?:
        | IndividualComputerLabItemCreateOrConnectWithoutComputerLabItemInput
        | IndividualComputerLabItemCreateOrConnectWithoutComputerLabItemInput[];
      upsert?:
        | IndividualComputerLabItemUpsertWithWhereUniqueWithoutComputerLabItemInput
        | IndividualComputerLabItemUpsertWithWhereUniqueWithoutComputerLabItemInput[];
      createMany?: IndividualComputerLabItemCreateManyComputerLabItemInputEnvelope;
      set?:
        | IndividualComputerLabItemWhereUniqueInput
        | IndividualComputerLabItemWhereUniqueInput[];
      disconnect?:
        | IndividualComputerLabItemWhereUniqueInput
        | IndividualComputerLabItemWhereUniqueInput[];
      delete?:
        | IndividualComputerLabItemWhereUniqueInput
        | IndividualComputerLabItemWhereUniqueInput[];
      connect?:
        | IndividualComputerLabItemWhereUniqueInput
        | IndividualComputerLabItemWhereUniqueInput[];
      update?:
        | IndividualComputerLabItemUpdateWithWhereUniqueWithoutComputerLabItemInput
        | IndividualComputerLabItemUpdateWithWhereUniqueWithoutComputerLabItemInput[];
      updateMany?:
        | IndividualComputerLabItemUpdateManyWithWhereWithoutComputerLabItemInput
        | IndividualComputerLabItemUpdateManyWithWhereWithoutComputerLabItemInput[];
      deleteMany?:
        | IndividualComputerLabItemScalarWhereInput
        | IndividualComputerLabItemScalarWhereInput[];
    };

  export type AssetDamageCreateNestedManyWithoutIndividualComputerLabItemInput =
    {
      create?:
        | XOR<
            AssetDamageCreateWithoutIndividualComputerLabItemInput,
            AssetDamageUncheckedCreateWithoutIndividualComputerLabItemInput
          >
        | AssetDamageCreateWithoutIndividualComputerLabItemInput[]
        | AssetDamageUncheckedCreateWithoutIndividualComputerLabItemInput[];
      connectOrCreate?:
        | AssetDamageCreateOrConnectWithoutIndividualComputerLabItemInput
        | AssetDamageCreateOrConnectWithoutIndividualComputerLabItemInput[];
      createMany?: AssetDamageCreateManyIndividualComputerLabItemInputEnvelope;
      connect?: AssetDamageWhereUniqueInput | AssetDamageWhereUniqueInput[];
    };

  export type ComputerLabItemCreateNestedOneWithoutIndividualComputerLabItemsInput =
    {
      create?: XOR<
        ComputerLabItemCreateWithoutIndividualComputerLabItemsInput,
        ComputerLabItemUncheckedCreateWithoutIndividualComputerLabItemsInput
      >;
      connectOrCreate?: ComputerLabItemCreateOrConnectWithoutIndividualComputerLabItemsInput;
      connect?: ComputerLabItemWhereUniqueInput;
    };

  export type AssetDamageUncheckedCreateNestedManyWithoutIndividualComputerLabItemInput =
    {
      create?:
        | XOR<
            AssetDamageCreateWithoutIndividualComputerLabItemInput,
            AssetDamageUncheckedCreateWithoutIndividualComputerLabItemInput
          >
        | AssetDamageCreateWithoutIndividualComputerLabItemInput[]
        | AssetDamageUncheckedCreateWithoutIndividualComputerLabItemInput[];
      connectOrCreate?:
        | AssetDamageCreateOrConnectWithoutIndividualComputerLabItemInput
        | AssetDamageCreateOrConnectWithoutIndividualComputerLabItemInput[];
      createMany?: AssetDamageCreateManyIndividualComputerLabItemInputEnvelope;
      connect?: AssetDamageWhereUniqueInput | AssetDamageWhereUniqueInput[];
    };

  export type AssetDamageUpdateManyWithoutIndividualComputerLabItemNestedInput =
    {
      create?:
        | XOR<
            AssetDamageCreateWithoutIndividualComputerLabItemInput,
            AssetDamageUncheckedCreateWithoutIndividualComputerLabItemInput
          >
        | AssetDamageCreateWithoutIndividualComputerLabItemInput[]
        | AssetDamageUncheckedCreateWithoutIndividualComputerLabItemInput[];
      connectOrCreate?:
        | AssetDamageCreateOrConnectWithoutIndividualComputerLabItemInput
        | AssetDamageCreateOrConnectWithoutIndividualComputerLabItemInput[];
      upsert?:
        | AssetDamageUpsertWithWhereUniqueWithoutIndividualComputerLabItemInput
        | AssetDamageUpsertWithWhereUniqueWithoutIndividualComputerLabItemInput[];
      createMany?: AssetDamageCreateManyIndividualComputerLabItemInputEnvelope;
      set?: AssetDamageWhereUniqueInput | AssetDamageWhereUniqueInput[];
      disconnect?: AssetDamageWhereUniqueInput | AssetDamageWhereUniqueInput[];
      delete?: AssetDamageWhereUniqueInput | AssetDamageWhereUniqueInput[];
      connect?: AssetDamageWhereUniqueInput | AssetDamageWhereUniqueInput[];
      update?:
        | AssetDamageUpdateWithWhereUniqueWithoutIndividualComputerLabItemInput
        | AssetDamageUpdateWithWhereUniqueWithoutIndividualComputerLabItemInput[];
      updateMany?:
        | AssetDamageUpdateManyWithWhereWithoutIndividualComputerLabItemInput
        | AssetDamageUpdateManyWithWhereWithoutIndividualComputerLabItemInput[];
      deleteMany?: AssetDamageScalarWhereInput | AssetDamageScalarWhereInput[];
    };

  export type ComputerLabItemUpdateOneRequiredWithoutIndividualComputerLabItemsNestedInput =
    {
      create?: XOR<
        ComputerLabItemCreateWithoutIndividualComputerLabItemsInput,
        ComputerLabItemUncheckedCreateWithoutIndividualComputerLabItemsInput
      >;
      connectOrCreate?: ComputerLabItemCreateOrConnectWithoutIndividualComputerLabItemsInput;
      upsert?: ComputerLabItemUpsertWithoutIndividualComputerLabItemsInput;
      connect?: ComputerLabItemWhereUniqueInput;
      update?: XOR<
        XOR<
          ComputerLabItemUpdateToOneWithWhereWithoutIndividualComputerLabItemsInput,
          ComputerLabItemUpdateWithoutIndividualComputerLabItemsInput
        >,
        ComputerLabItemUncheckedUpdateWithoutIndividualComputerLabItemsInput
      >;
    };

  export type AssetDamageUncheckedUpdateManyWithoutIndividualComputerLabItemNestedInput =
    {
      create?:
        | XOR<
            AssetDamageCreateWithoutIndividualComputerLabItemInput,
            AssetDamageUncheckedCreateWithoutIndividualComputerLabItemInput
          >
        | AssetDamageCreateWithoutIndividualComputerLabItemInput[]
        | AssetDamageUncheckedCreateWithoutIndividualComputerLabItemInput[];
      connectOrCreate?:
        | AssetDamageCreateOrConnectWithoutIndividualComputerLabItemInput
        | AssetDamageCreateOrConnectWithoutIndividualComputerLabItemInput[];
      upsert?:
        | AssetDamageUpsertWithWhereUniqueWithoutIndividualComputerLabItemInput
        | AssetDamageUpsertWithWhereUniqueWithoutIndividualComputerLabItemInput[];
      createMany?: AssetDamageCreateManyIndividualComputerLabItemInputEnvelope;
      set?: AssetDamageWhereUniqueInput | AssetDamageWhereUniqueInput[];
      disconnect?: AssetDamageWhereUniqueInput | AssetDamageWhereUniqueInput[];
      delete?: AssetDamageWhereUniqueInput | AssetDamageWhereUniqueInput[];
      connect?: AssetDamageWhereUniqueInput | AssetDamageWhereUniqueInput[];
      update?:
        | AssetDamageUpdateWithWhereUniqueWithoutIndividualComputerLabItemInput
        | AssetDamageUpdateWithWhereUniqueWithoutIndividualComputerLabItemInput[];
      updateMany?:
        | AssetDamageUpdateManyWithWhereWithoutIndividualComputerLabItemInput
        | AssetDamageUpdateManyWithWhereWithoutIndividualComputerLabItemInput[];
      deleteMany?: AssetDamageScalarWhereInput | AssetDamageScalarWhereInput[];
    };

  export type AssetCreateNestedOneWithoutGeneralStoreItemsInput = {
    create?: XOR<
      AssetCreateWithoutGeneralStoreItemsInput,
      AssetUncheckedCreateWithoutGeneralStoreItemsInput
    >;
    connectOrCreate?: AssetCreateOrConnectWithoutGeneralStoreItemsInput;
    connect?: AssetWhereUniqueInput;
  };

  export type IndividualGeneralStoreItemCreateNestedManyWithoutGeneralStoreItemInput =
    {
      create?:
        | XOR<
            IndividualGeneralStoreItemCreateWithoutGeneralStoreItemInput,
            IndividualGeneralStoreItemUncheckedCreateWithoutGeneralStoreItemInput
          >
        | IndividualGeneralStoreItemCreateWithoutGeneralStoreItemInput[]
        | IndividualGeneralStoreItemUncheckedCreateWithoutGeneralStoreItemInput[];
      connectOrCreate?:
        | IndividualGeneralStoreItemCreateOrConnectWithoutGeneralStoreItemInput
        | IndividualGeneralStoreItemCreateOrConnectWithoutGeneralStoreItemInput[];
      createMany?: IndividualGeneralStoreItemCreateManyGeneralStoreItemInputEnvelope;
      connect?:
        | IndividualGeneralStoreItemWhereUniqueInput
        | IndividualGeneralStoreItemWhereUniqueInput[];
    };

  export type IndividualGeneralStoreItemUncheckedCreateNestedManyWithoutGeneralStoreItemInput =
    {
      create?:
        | XOR<
            IndividualGeneralStoreItemCreateWithoutGeneralStoreItemInput,
            IndividualGeneralStoreItemUncheckedCreateWithoutGeneralStoreItemInput
          >
        | IndividualGeneralStoreItemCreateWithoutGeneralStoreItemInput[]
        | IndividualGeneralStoreItemUncheckedCreateWithoutGeneralStoreItemInput[];
      connectOrCreate?:
        | IndividualGeneralStoreItemCreateOrConnectWithoutGeneralStoreItemInput
        | IndividualGeneralStoreItemCreateOrConnectWithoutGeneralStoreItemInput[];
      createMany?: IndividualGeneralStoreItemCreateManyGeneralStoreItemInputEnvelope;
      connect?:
        | IndividualGeneralStoreItemWhereUniqueInput
        | IndividualGeneralStoreItemWhereUniqueInput[];
    };

  export type AssetUpdateOneRequiredWithoutGeneralStoreItemsNestedInput = {
    create?: XOR<
      AssetCreateWithoutGeneralStoreItemsInput,
      AssetUncheckedCreateWithoutGeneralStoreItemsInput
    >;
    connectOrCreate?: AssetCreateOrConnectWithoutGeneralStoreItemsInput;
    upsert?: AssetUpsertWithoutGeneralStoreItemsInput;
    connect?: AssetWhereUniqueInput;
    update?: XOR<
      XOR<
        AssetUpdateToOneWithWhereWithoutGeneralStoreItemsInput,
        AssetUpdateWithoutGeneralStoreItemsInput
      >,
      AssetUncheckedUpdateWithoutGeneralStoreItemsInput
    >;
  };

  export type IndividualGeneralStoreItemUpdateManyWithoutGeneralStoreItemNestedInput =
    {
      create?:
        | XOR<
            IndividualGeneralStoreItemCreateWithoutGeneralStoreItemInput,
            IndividualGeneralStoreItemUncheckedCreateWithoutGeneralStoreItemInput
          >
        | IndividualGeneralStoreItemCreateWithoutGeneralStoreItemInput[]
        | IndividualGeneralStoreItemUncheckedCreateWithoutGeneralStoreItemInput[];
      connectOrCreate?:
        | IndividualGeneralStoreItemCreateOrConnectWithoutGeneralStoreItemInput
        | IndividualGeneralStoreItemCreateOrConnectWithoutGeneralStoreItemInput[];
      upsert?:
        | IndividualGeneralStoreItemUpsertWithWhereUniqueWithoutGeneralStoreItemInput
        | IndividualGeneralStoreItemUpsertWithWhereUniqueWithoutGeneralStoreItemInput[];
      createMany?: IndividualGeneralStoreItemCreateManyGeneralStoreItemInputEnvelope;
      set?:
        | IndividualGeneralStoreItemWhereUniqueInput
        | IndividualGeneralStoreItemWhereUniqueInput[];
      disconnect?:
        | IndividualGeneralStoreItemWhereUniqueInput
        | IndividualGeneralStoreItemWhereUniqueInput[];
      delete?:
        | IndividualGeneralStoreItemWhereUniqueInput
        | IndividualGeneralStoreItemWhereUniqueInput[];
      connect?:
        | IndividualGeneralStoreItemWhereUniqueInput
        | IndividualGeneralStoreItemWhereUniqueInput[];
      update?:
        | IndividualGeneralStoreItemUpdateWithWhereUniqueWithoutGeneralStoreItemInput
        | IndividualGeneralStoreItemUpdateWithWhereUniqueWithoutGeneralStoreItemInput[];
      updateMany?:
        | IndividualGeneralStoreItemUpdateManyWithWhereWithoutGeneralStoreItemInput
        | IndividualGeneralStoreItemUpdateManyWithWhereWithoutGeneralStoreItemInput[];
      deleteMany?:
        | IndividualGeneralStoreItemScalarWhereInput
        | IndividualGeneralStoreItemScalarWhereInput[];
    };

  export type IndividualGeneralStoreItemUncheckedUpdateManyWithoutGeneralStoreItemNestedInput =
    {
      create?:
        | XOR<
            IndividualGeneralStoreItemCreateWithoutGeneralStoreItemInput,
            IndividualGeneralStoreItemUncheckedCreateWithoutGeneralStoreItemInput
          >
        | IndividualGeneralStoreItemCreateWithoutGeneralStoreItemInput[]
        | IndividualGeneralStoreItemUncheckedCreateWithoutGeneralStoreItemInput[];
      connectOrCreate?:
        | IndividualGeneralStoreItemCreateOrConnectWithoutGeneralStoreItemInput
        | IndividualGeneralStoreItemCreateOrConnectWithoutGeneralStoreItemInput[];
      upsert?:
        | IndividualGeneralStoreItemUpsertWithWhereUniqueWithoutGeneralStoreItemInput
        | IndividualGeneralStoreItemUpsertWithWhereUniqueWithoutGeneralStoreItemInput[];
      createMany?: IndividualGeneralStoreItemCreateManyGeneralStoreItemInputEnvelope;
      set?:
        | IndividualGeneralStoreItemWhereUniqueInput
        | IndividualGeneralStoreItemWhereUniqueInput[];
      disconnect?:
        | IndividualGeneralStoreItemWhereUniqueInput
        | IndividualGeneralStoreItemWhereUniqueInput[];
      delete?:
        | IndividualGeneralStoreItemWhereUniqueInput
        | IndividualGeneralStoreItemWhereUniqueInput[];
      connect?:
        | IndividualGeneralStoreItemWhereUniqueInput
        | IndividualGeneralStoreItemWhereUniqueInput[];
      update?:
        | IndividualGeneralStoreItemUpdateWithWhereUniqueWithoutGeneralStoreItemInput
        | IndividualGeneralStoreItemUpdateWithWhereUniqueWithoutGeneralStoreItemInput[];
      updateMany?:
        | IndividualGeneralStoreItemUpdateManyWithWhereWithoutGeneralStoreItemInput
        | IndividualGeneralStoreItemUpdateManyWithWhereWithoutGeneralStoreItemInput[];
      deleteMany?:
        | IndividualGeneralStoreItemScalarWhereInput
        | IndividualGeneralStoreItemScalarWhereInput[];
    };

  export type AssetDamageCreateNestedManyWithoutIndividualGeneralStoreItemInput =
    {
      create?:
        | XOR<
            AssetDamageCreateWithoutIndividualGeneralStoreItemInput,
            AssetDamageUncheckedCreateWithoutIndividualGeneralStoreItemInput
          >
        | AssetDamageCreateWithoutIndividualGeneralStoreItemInput[]
        | AssetDamageUncheckedCreateWithoutIndividualGeneralStoreItemInput[];
      connectOrCreate?:
        | AssetDamageCreateOrConnectWithoutIndividualGeneralStoreItemInput
        | AssetDamageCreateOrConnectWithoutIndividualGeneralStoreItemInput[];
      createMany?: AssetDamageCreateManyIndividualGeneralStoreItemInputEnvelope;
      connect?: AssetDamageWhereUniqueInput | AssetDamageWhereUniqueInput[];
    };

  export type GeneralStoreItemCreateNestedOneWithoutIndividualGeneralStoreItemsInput =
    {
      create?: XOR<
        GeneralStoreItemCreateWithoutIndividualGeneralStoreItemsInput,
        GeneralStoreItemUncheckedCreateWithoutIndividualGeneralStoreItemsInput
      >;
      connectOrCreate?: GeneralStoreItemCreateOrConnectWithoutIndividualGeneralStoreItemsInput;
      connect?: GeneralStoreItemWhereUniqueInput;
    };

  export type AssetDamageUncheckedCreateNestedManyWithoutIndividualGeneralStoreItemInput =
    {
      create?:
        | XOR<
            AssetDamageCreateWithoutIndividualGeneralStoreItemInput,
            AssetDamageUncheckedCreateWithoutIndividualGeneralStoreItemInput
          >
        | AssetDamageCreateWithoutIndividualGeneralStoreItemInput[]
        | AssetDamageUncheckedCreateWithoutIndividualGeneralStoreItemInput[];
      connectOrCreate?:
        | AssetDamageCreateOrConnectWithoutIndividualGeneralStoreItemInput
        | AssetDamageCreateOrConnectWithoutIndividualGeneralStoreItemInput[];
      createMany?: AssetDamageCreateManyIndividualGeneralStoreItemInputEnvelope;
      connect?: AssetDamageWhereUniqueInput | AssetDamageWhereUniqueInput[];
    };

  export type AssetDamageUpdateManyWithoutIndividualGeneralStoreItemNestedInput =
    {
      create?:
        | XOR<
            AssetDamageCreateWithoutIndividualGeneralStoreItemInput,
            AssetDamageUncheckedCreateWithoutIndividualGeneralStoreItemInput
          >
        | AssetDamageCreateWithoutIndividualGeneralStoreItemInput[]
        | AssetDamageUncheckedCreateWithoutIndividualGeneralStoreItemInput[];
      connectOrCreate?:
        | AssetDamageCreateOrConnectWithoutIndividualGeneralStoreItemInput
        | AssetDamageCreateOrConnectWithoutIndividualGeneralStoreItemInput[];
      upsert?:
        | AssetDamageUpsertWithWhereUniqueWithoutIndividualGeneralStoreItemInput
        | AssetDamageUpsertWithWhereUniqueWithoutIndividualGeneralStoreItemInput[];
      createMany?: AssetDamageCreateManyIndividualGeneralStoreItemInputEnvelope;
      set?: AssetDamageWhereUniqueInput | AssetDamageWhereUniqueInput[];
      disconnect?: AssetDamageWhereUniqueInput | AssetDamageWhereUniqueInput[];
      delete?: AssetDamageWhereUniqueInput | AssetDamageWhereUniqueInput[];
      connect?: AssetDamageWhereUniqueInput | AssetDamageWhereUniqueInput[];
      update?:
        | AssetDamageUpdateWithWhereUniqueWithoutIndividualGeneralStoreItemInput
        | AssetDamageUpdateWithWhereUniqueWithoutIndividualGeneralStoreItemInput[];
      updateMany?:
        | AssetDamageUpdateManyWithWhereWithoutIndividualGeneralStoreItemInput
        | AssetDamageUpdateManyWithWhereWithoutIndividualGeneralStoreItemInput[];
      deleteMany?: AssetDamageScalarWhereInput | AssetDamageScalarWhereInput[];
    };

  export type GeneralStoreItemUpdateOneRequiredWithoutIndividualGeneralStoreItemsNestedInput =
    {
      create?: XOR<
        GeneralStoreItemCreateWithoutIndividualGeneralStoreItemsInput,
        GeneralStoreItemUncheckedCreateWithoutIndividualGeneralStoreItemsInput
      >;
      connectOrCreate?: GeneralStoreItemCreateOrConnectWithoutIndividualGeneralStoreItemsInput;
      upsert?: GeneralStoreItemUpsertWithoutIndividualGeneralStoreItemsInput;
      connect?: GeneralStoreItemWhereUniqueInput;
      update?: XOR<
        XOR<
          GeneralStoreItemUpdateToOneWithWhereWithoutIndividualGeneralStoreItemsInput,
          GeneralStoreItemUpdateWithoutIndividualGeneralStoreItemsInput
        >,
        GeneralStoreItemUncheckedUpdateWithoutIndividualGeneralStoreItemsInput
      >;
    };

  export type AssetDamageUncheckedUpdateManyWithoutIndividualGeneralStoreItemNestedInput =
    {
      create?:
        | XOR<
            AssetDamageCreateWithoutIndividualGeneralStoreItemInput,
            AssetDamageUncheckedCreateWithoutIndividualGeneralStoreItemInput
          >
        | AssetDamageCreateWithoutIndividualGeneralStoreItemInput[]
        | AssetDamageUncheckedCreateWithoutIndividualGeneralStoreItemInput[];
      connectOrCreate?:
        | AssetDamageCreateOrConnectWithoutIndividualGeneralStoreItemInput
        | AssetDamageCreateOrConnectWithoutIndividualGeneralStoreItemInput[];
      upsert?:
        | AssetDamageUpsertWithWhereUniqueWithoutIndividualGeneralStoreItemInput
        | AssetDamageUpsertWithWhereUniqueWithoutIndividualGeneralStoreItemInput[];
      createMany?: AssetDamageCreateManyIndividualGeneralStoreItemInputEnvelope;
      set?: AssetDamageWhereUniqueInput | AssetDamageWhereUniqueInput[];
      disconnect?: AssetDamageWhereUniqueInput | AssetDamageWhereUniqueInput[];
      delete?: AssetDamageWhereUniqueInput | AssetDamageWhereUniqueInput[];
      connect?: AssetDamageWhereUniqueInput | AssetDamageWhereUniqueInput[];
      update?:
        | AssetDamageUpdateWithWhereUniqueWithoutIndividualGeneralStoreItemInput
        | AssetDamageUpdateWithWhereUniqueWithoutIndividualGeneralStoreItemInput[];
      updateMany?:
        | AssetDamageUpdateManyWithWhereWithoutIndividualGeneralStoreItemInput
        | AssetDamageUpdateManyWithWhereWithoutIndividualGeneralStoreItemInput[];
      deleteMany?: AssetDamageScalarWhereInput | AssetDamageScalarWhereInput[];
    };

  export type IndividualBookCreateNestedOneWithoutBookDamagesInput = {
    create?: XOR<
      IndividualBookCreateWithoutBookDamagesInput,
      IndividualBookUncheckedCreateWithoutBookDamagesInput
    >;
    connectOrCreate?: IndividualBookCreateOrConnectWithoutBookDamagesInput;
    connect?: IndividualBookWhereUniqueInput;
  };

  export type IndividualComputerLabItemCreateNestedOneWithoutAssetDamagesInput =
    {
      create?: XOR<
        IndividualComputerLabItemCreateWithoutAssetDamagesInput,
        IndividualComputerLabItemUncheckedCreateWithoutAssetDamagesInput
      >;
      connectOrCreate?: IndividualComputerLabItemCreateOrConnectWithoutAssetDamagesInput;
      connect?: IndividualComputerLabItemWhereUniqueInput;
    };

  export type IndividualFoodStoreItemCreateNestedOneWithoutAssetDamagesInput = {
    create?: XOR<
      IndividualFoodStoreItemCreateWithoutAssetDamagesInput,
      IndividualFoodStoreItemUncheckedCreateWithoutAssetDamagesInput
    >;
    connectOrCreate?: IndividualFoodStoreItemCreateOrConnectWithoutAssetDamagesInput;
    connect?: IndividualFoodStoreItemWhereUniqueInput;
  };

  export type IndividualGeneralStoreItemCreateNestedOneWithoutAssetDamagesInput =
    {
      create?: XOR<
        IndividualGeneralStoreItemCreateWithoutAssetDamagesInput,
        IndividualGeneralStoreItemUncheckedCreateWithoutAssetDamagesInput
      >;
      connectOrCreate?: IndividualGeneralStoreItemCreateOrConnectWithoutAssetDamagesInput;
      connect?: IndividualGeneralStoreItemWhereUniqueInput;
    };

  export type IndividualLabItemCreateNestedOneWithoutAssetDamagesInput = {
    create?: XOR<
      IndividualLabItemCreateWithoutAssetDamagesInput,
      IndividualLabItemUncheckedCreateWithoutAssetDamagesInput
    >;
    connectOrCreate?: IndividualLabItemCreateOrConnectWithoutAssetDamagesInput;
    connect?: IndividualLabItemWhereUniqueInput;
  };

  export type UserCreateNestedOneWithoutAssetDamagesInput = {
    create?: XOR<
      UserCreateWithoutAssetDamagesInput,
      UserUncheckedCreateWithoutAssetDamagesInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutAssetDamagesInput;
    connect?: UserWhereUniqueInput;
  };

  export type AssetRepairPaymentCreateNestedManyWithoutAssetDamageInput = {
    create?:
      | XOR<
          AssetRepairPaymentCreateWithoutAssetDamageInput,
          AssetRepairPaymentUncheckedCreateWithoutAssetDamageInput
        >
      | AssetRepairPaymentCreateWithoutAssetDamageInput[]
      | AssetRepairPaymentUncheckedCreateWithoutAssetDamageInput[];
    connectOrCreate?:
      | AssetRepairPaymentCreateOrConnectWithoutAssetDamageInput
      | AssetRepairPaymentCreateOrConnectWithoutAssetDamageInput[];
    createMany?: AssetRepairPaymentCreateManyAssetDamageInputEnvelope;
    connect?:
      | AssetRepairPaymentWhereUniqueInput
      | AssetRepairPaymentWhereUniqueInput[];
  };

  export type AssetRepairPaymentUncheckedCreateNestedManyWithoutAssetDamageInput =
    {
      create?:
        | XOR<
            AssetRepairPaymentCreateWithoutAssetDamageInput,
            AssetRepairPaymentUncheckedCreateWithoutAssetDamageInput
          >
        | AssetRepairPaymentCreateWithoutAssetDamageInput[]
        | AssetRepairPaymentUncheckedCreateWithoutAssetDamageInput[];
      connectOrCreate?:
        | AssetRepairPaymentCreateOrConnectWithoutAssetDamageInput
        | AssetRepairPaymentCreateOrConnectWithoutAssetDamageInput[];
      createMany?: AssetRepairPaymentCreateManyAssetDamageInputEnvelope;
      connect?:
        | AssetRepairPaymentWhereUniqueInput
        | AssetRepairPaymentWhereUniqueInput[];
    };

  export type IndividualBookUpdateOneWithoutBookDamagesNestedInput = {
    create?: XOR<
      IndividualBookCreateWithoutBookDamagesInput,
      IndividualBookUncheckedCreateWithoutBookDamagesInput
    >;
    connectOrCreate?: IndividualBookCreateOrConnectWithoutBookDamagesInput;
    upsert?: IndividualBookUpsertWithoutBookDamagesInput;
    disconnect?: IndividualBookWhereInput | boolean;
    delete?: IndividualBookWhereInput | boolean;
    connect?: IndividualBookWhereUniqueInput;
    update?: XOR<
      XOR<
        IndividualBookUpdateToOneWithWhereWithoutBookDamagesInput,
        IndividualBookUpdateWithoutBookDamagesInput
      >,
      IndividualBookUncheckedUpdateWithoutBookDamagesInput
    >;
  };

  export type IndividualComputerLabItemUpdateOneWithoutAssetDamagesNestedInput =
    {
      create?: XOR<
        IndividualComputerLabItemCreateWithoutAssetDamagesInput,
        IndividualComputerLabItemUncheckedCreateWithoutAssetDamagesInput
      >;
      connectOrCreate?: IndividualComputerLabItemCreateOrConnectWithoutAssetDamagesInput;
      upsert?: IndividualComputerLabItemUpsertWithoutAssetDamagesInput;
      disconnect?: IndividualComputerLabItemWhereInput | boolean;
      delete?: IndividualComputerLabItemWhereInput | boolean;
      connect?: IndividualComputerLabItemWhereUniqueInput;
      update?: XOR<
        XOR<
          IndividualComputerLabItemUpdateToOneWithWhereWithoutAssetDamagesInput,
          IndividualComputerLabItemUpdateWithoutAssetDamagesInput
        >,
        IndividualComputerLabItemUncheckedUpdateWithoutAssetDamagesInput
      >;
    };

  export type IndividualFoodStoreItemUpdateOneWithoutAssetDamagesNestedInput = {
    create?: XOR<
      IndividualFoodStoreItemCreateWithoutAssetDamagesInput,
      IndividualFoodStoreItemUncheckedCreateWithoutAssetDamagesInput
    >;
    connectOrCreate?: IndividualFoodStoreItemCreateOrConnectWithoutAssetDamagesInput;
    upsert?: IndividualFoodStoreItemUpsertWithoutAssetDamagesInput;
    disconnect?: IndividualFoodStoreItemWhereInput | boolean;
    delete?: IndividualFoodStoreItemWhereInput | boolean;
    connect?: IndividualFoodStoreItemWhereUniqueInput;
    update?: XOR<
      XOR<
        IndividualFoodStoreItemUpdateToOneWithWhereWithoutAssetDamagesInput,
        IndividualFoodStoreItemUpdateWithoutAssetDamagesInput
      >,
      IndividualFoodStoreItemUncheckedUpdateWithoutAssetDamagesInput
    >;
  };

  export type IndividualGeneralStoreItemUpdateOneWithoutAssetDamagesNestedInput =
    {
      create?: XOR<
        IndividualGeneralStoreItemCreateWithoutAssetDamagesInput,
        IndividualGeneralStoreItemUncheckedCreateWithoutAssetDamagesInput
      >;
      connectOrCreate?: IndividualGeneralStoreItemCreateOrConnectWithoutAssetDamagesInput;
      upsert?: IndividualGeneralStoreItemUpsertWithoutAssetDamagesInput;
      disconnect?: IndividualGeneralStoreItemWhereInput | boolean;
      delete?: IndividualGeneralStoreItemWhereInput | boolean;
      connect?: IndividualGeneralStoreItemWhereUniqueInput;
      update?: XOR<
        XOR<
          IndividualGeneralStoreItemUpdateToOneWithWhereWithoutAssetDamagesInput,
          IndividualGeneralStoreItemUpdateWithoutAssetDamagesInput
        >,
        IndividualGeneralStoreItemUncheckedUpdateWithoutAssetDamagesInput
      >;
    };

  export type IndividualLabItemUpdateOneWithoutAssetDamagesNestedInput = {
    create?: XOR<
      IndividualLabItemCreateWithoutAssetDamagesInput,
      IndividualLabItemUncheckedCreateWithoutAssetDamagesInput
    >;
    connectOrCreate?: IndividualLabItemCreateOrConnectWithoutAssetDamagesInput;
    upsert?: IndividualLabItemUpsertWithoutAssetDamagesInput;
    disconnect?: IndividualLabItemWhereInput | boolean;
    delete?: IndividualLabItemWhereInput | boolean;
    connect?: IndividualLabItemWhereUniqueInput;
    update?: XOR<
      XOR<
        IndividualLabItemUpdateToOneWithWhereWithoutAssetDamagesInput,
        IndividualLabItemUpdateWithoutAssetDamagesInput
      >,
      IndividualLabItemUncheckedUpdateWithoutAssetDamagesInput
    >;
  };

  export type UserUpdateOneWithoutAssetDamagesNestedInput = {
    create?: XOR<
      UserCreateWithoutAssetDamagesInput,
      UserUncheckedCreateWithoutAssetDamagesInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutAssetDamagesInput;
    upsert?: UserUpsertWithoutAssetDamagesInput;
    disconnect?: UserWhereInput | boolean;
    delete?: UserWhereInput | boolean;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutAssetDamagesInput,
        UserUpdateWithoutAssetDamagesInput
      >,
      UserUncheckedUpdateWithoutAssetDamagesInput
    >;
  };

  export type AssetRepairPaymentUpdateManyWithoutAssetDamageNestedInput = {
    create?:
      | XOR<
          AssetRepairPaymentCreateWithoutAssetDamageInput,
          AssetRepairPaymentUncheckedCreateWithoutAssetDamageInput
        >
      | AssetRepairPaymentCreateWithoutAssetDamageInput[]
      | AssetRepairPaymentUncheckedCreateWithoutAssetDamageInput[];
    connectOrCreate?:
      | AssetRepairPaymentCreateOrConnectWithoutAssetDamageInput
      | AssetRepairPaymentCreateOrConnectWithoutAssetDamageInput[];
    upsert?:
      | AssetRepairPaymentUpsertWithWhereUniqueWithoutAssetDamageInput
      | AssetRepairPaymentUpsertWithWhereUniqueWithoutAssetDamageInput[];
    createMany?: AssetRepairPaymentCreateManyAssetDamageInputEnvelope;
    set?:
      | AssetRepairPaymentWhereUniqueInput
      | AssetRepairPaymentWhereUniqueInput[];
    disconnect?:
      | AssetRepairPaymentWhereUniqueInput
      | AssetRepairPaymentWhereUniqueInput[];
    delete?:
      | AssetRepairPaymentWhereUniqueInput
      | AssetRepairPaymentWhereUniqueInput[];
    connect?:
      | AssetRepairPaymentWhereUniqueInput
      | AssetRepairPaymentWhereUniqueInput[];
    update?:
      | AssetRepairPaymentUpdateWithWhereUniqueWithoutAssetDamageInput
      | AssetRepairPaymentUpdateWithWhereUniqueWithoutAssetDamageInput[];
    updateMany?:
      | AssetRepairPaymentUpdateManyWithWhereWithoutAssetDamageInput
      | AssetRepairPaymentUpdateManyWithWhereWithoutAssetDamageInput[];
    deleteMany?:
      | AssetRepairPaymentScalarWhereInput
      | AssetRepairPaymentScalarWhereInput[];
  };

  export type AssetRepairPaymentUncheckedUpdateManyWithoutAssetDamageNestedInput =
    {
      create?:
        | XOR<
            AssetRepairPaymentCreateWithoutAssetDamageInput,
            AssetRepairPaymentUncheckedCreateWithoutAssetDamageInput
          >
        | AssetRepairPaymentCreateWithoutAssetDamageInput[]
        | AssetRepairPaymentUncheckedCreateWithoutAssetDamageInput[];
      connectOrCreate?:
        | AssetRepairPaymentCreateOrConnectWithoutAssetDamageInput
        | AssetRepairPaymentCreateOrConnectWithoutAssetDamageInput[];
      upsert?:
        | AssetRepairPaymentUpsertWithWhereUniqueWithoutAssetDamageInput
        | AssetRepairPaymentUpsertWithWhereUniqueWithoutAssetDamageInput[];
      createMany?: AssetRepairPaymentCreateManyAssetDamageInputEnvelope;
      set?:
        | AssetRepairPaymentWhereUniqueInput
        | AssetRepairPaymentWhereUniqueInput[];
      disconnect?:
        | AssetRepairPaymentWhereUniqueInput
        | AssetRepairPaymentWhereUniqueInput[];
      delete?:
        | AssetRepairPaymentWhereUniqueInput
        | AssetRepairPaymentWhereUniqueInput[];
      connect?:
        | AssetRepairPaymentWhereUniqueInput
        | AssetRepairPaymentWhereUniqueInput[];
      update?:
        | AssetRepairPaymentUpdateWithWhereUniqueWithoutAssetDamageInput
        | AssetRepairPaymentUpdateWithWhereUniqueWithoutAssetDamageInput[];
      updateMany?:
        | AssetRepairPaymentUpdateManyWithWhereWithoutAssetDamageInput
        | AssetRepairPaymentUpdateManyWithWhereWithoutAssetDamageInput[];
      deleteMany?:
        | AssetRepairPaymentScalarWhereInput
        | AssetRepairPaymentScalarWhereInput[];
    };

  export type AssetDamageCreateNestedOneWithoutAssetRepairPaymentsInput = {
    create?: XOR<
      AssetDamageCreateWithoutAssetRepairPaymentsInput,
      AssetDamageUncheckedCreateWithoutAssetRepairPaymentsInput
    >;
    connectOrCreate?: AssetDamageCreateOrConnectWithoutAssetRepairPaymentsInput;
    connect?: AssetDamageWhereUniqueInput;
  };

  export type UserCreateNestedOneWithoutAssetRepairPaymentsInput = {
    create?: XOR<
      UserCreateWithoutAssetRepairPaymentsInput,
      UserUncheckedCreateWithoutAssetRepairPaymentsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutAssetRepairPaymentsInput;
    connect?: UserWhereUniqueInput;
  };

  export type AssetDamageUpdateOneWithoutAssetRepairPaymentsNestedInput = {
    create?: XOR<
      AssetDamageCreateWithoutAssetRepairPaymentsInput,
      AssetDamageUncheckedCreateWithoutAssetRepairPaymentsInput
    >;
    connectOrCreate?: AssetDamageCreateOrConnectWithoutAssetRepairPaymentsInput;
    upsert?: AssetDamageUpsertWithoutAssetRepairPaymentsInput;
    disconnect?: AssetDamageWhereInput | boolean;
    delete?: AssetDamageWhereInput | boolean;
    connect?: AssetDamageWhereUniqueInput;
    update?: XOR<
      XOR<
        AssetDamageUpdateToOneWithWhereWithoutAssetRepairPaymentsInput,
        AssetDamageUpdateWithoutAssetRepairPaymentsInput
      >,
      AssetDamageUncheckedUpdateWithoutAssetRepairPaymentsInput
    >;
  };

  export type UserUpdateOneWithoutAssetRepairPaymentsNestedInput = {
    create?: XOR<
      UserCreateWithoutAssetRepairPaymentsInput,
      UserUncheckedCreateWithoutAssetRepairPaymentsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutAssetRepairPaymentsInput;
    upsert?: UserUpsertWithoutAssetRepairPaymentsInput;
    disconnect?: UserWhereInput | boolean;
    delete?: UserWhereInput | boolean;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutAssetRepairPaymentsInput,
        UserUpdateWithoutAssetRepairPaymentsInput
      >,
      UserUncheckedUpdateWithoutAssetRepairPaymentsInput
    >;
  };

  export type ExamSubjectCreateNestedOneWithoutExamScoresInput = {
    create?: XOR<
      ExamSubjectCreateWithoutExamScoresInput,
      ExamSubjectUncheckedCreateWithoutExamScoresInput
    >;
    connectOrCreate?: ExamSubjectCreateOrConnectWithoutExamScoresInput;
    connect?: ExamSubjectWhereUniqueInput;
  };

  export type PupilCreateNestedOneWithoutExamScoresInput = {
    create?: XOR<
      PupilCreateWithoutExamScoresInput,
      PupilUncheckedCreateWithoutExamScoresInput
    >;
    connectOrCreate?: PupilCreateOrConnectWithoutExamScoresInput;
    connect?: PupilWhereUniqueInput;
  };

  export type ExamSubjectUpdateOneRequiredWithoutExamScoresNestedInput = {
    create?: XOR<
      ExamSubjectCreateWithoutExamScoresInput,
      ExamSubjectUncheckedCreateWithoutExamScoresInput
    >;
    connectOrCreate?: ExamSubjectCreateOrConnectWithoutExamScoresInput;
    upsert?: ExamSubjectUpsertWithoutExamScoresInput;
    connect?: ExamSubjectWhereUniqueInput;
    update?: XOR<
      XOR<
        ExamSubjectUpdateToOneWithWhereWithoutExamScoresInput,
        ExamSubjectUpdateWithoutExamScoresInput
      >,
      ExamSubjectUncheckedUpdateWithoutExamScoresInput
    >;
  };

  export type PupilUpdateOneRequiredWithoutExamScoresNestedInput = {
    create?: XOR<
      PupilCreateWithoutExamScoresInput,
      PupilUncheckedCreateWithoutExamScoresInput
    >;
    connectOrCreate?: PupilCreateOrConnectWithoutExamScoresInput;
    upsert?: PupilUpsertWithoutExamScoresInput;
    connect?: PupilWhereUniqueInput;
    update?: XOR<
      XOR<
        PupilUpdateToOneWithWhereWithoutExamScoresInput,
        PupilUpdateWithoutExamScoresInput
      >,
      PupilUncheckedUpdateWithoutExamScoresInput
    >;
  };

  export type ExamSubjectCreateNestedManyWithoutExamInput = {
    create?:
      | XOR<
          ExamSubjectCreateWithoutExamInput,
          ExamSubjectUncheckedCreateWithoutExamInput
        >
      | ExamSubjectCreateWithoutExamInput[]
      | ExamSubjectUncheckedCreateWithoutExamInput[];
    connectOrCreate?:
      | ExamSubjectCreateOrConnectWithoutExamInput
      | ExamSubjectCreateOrConnectWithoutExamInput[];
    createMany?: ExamSubjectCreateManyExamInputEnvelope;
    connect?: ExamSubjectWhereUniqueInput | ExamSubjectWhereUniqueInput[];
  };

  export type ClassTermCreateNestedOneWithoutExamsInput = {
    create?: XOR<
      ClassTermCreateWithoutExamsInput,
      ClassTermUncheckedCreateWithoutExamsInput
    >;
    connectOrCreate?: ClassTermCreateOrConnectWithoutExamsInput;
    connect?: ClassTermWhereUniqueInput;
  };

  export type ExamSubjectUncheckedCreateNestedManyWithoutExamInput = {
    create?:
      | XOR<
          ExamSubjectCreateWithoutExamInput,
          ExamSubjectUncheckedCreateWithoutExamInput
        >
      | ExamSubjectCreateWithoutExamInput[]
      | ExamSubjectUncheckedCreateWithoutExamInput[];
    connectOrCreate?:
      | ExamSubjectCreateOrConnectWithoutExamInput
      | ExamSubjectCreateOrConnectWithoutExamInput[];
    createMany?: ExamSubjectCreateManyExamInputEnvelope;
    connect?: ExamSubjectWhereUniqueInput | ExamSubjectWhereUniqueInput[];
  };

  export type EnumExamTypeFieldUpdateOperationsInput = {
    set?: $Enums.ExamType;
  };

  export type ExamSubjectUpdateManyWithoutExamNestedInput = {
    create?:
      | XOR<
          ExamSubjectCreateWithoutExamInput,
          ExamSubjectUncheckedCreateWithoutExamInput
        >
      | ExamSubjectCreateWithoutExamInput[]
      | ExamSubjectUncheckedCreateWithoutExamInput[];
    connectOrCreate?:
      | ExamSubjectCreateOrConnectWithoutExamInput
      | ExamSubjectCreateOrConnectWithoutExamInput[];
    upsert?:
      | ExamSubjectUpsertWithWhereUniqueWithoutExamInput
      | ExamSubjectUpsertWithWhereUniqueWithoutExamInput[];
    createMany?: ExamSubjectCreateManyExamInputEnvelope;
    set?: ExamSubjectWhereUniqueInput | ExamSubjectWhereUniqueInput[];
    disconnect?: ExamSubjectWhereUniqueInput | ExamSubjectWhereUniqueInput[];
    delete?: ExamSubjectWhereUniqueInput | ExamSubjectWhereUniqueInput[];
    connect?: ExamSubjectWhereUniqueInput | ExamSubjectWhereUniqueInput[];
    update?:
      | ExamSubjectUpdateWithWhereUniqueWithoutExamInput
      | ExamSubjectUpdateWithWhereUniqueWithoutExamInput[];
    updateMany?:
      | ExamSubjectUpdateManyWithWhereWithoutExamInput
      | ExamSubjectUpdateManyWithWhereWithoutExamInput[];
    deleteMany?: ExamSubjectScalarWhereInput | ExamSubjectScalarWhereInput[];
  };

  export type ClassTermUpdateOneRequiredWithoutExamsNestedInput = {
    create?: XOR<
      ClassTermCreateWithoutExamsInput,
      ClassTermUncheckedCreateWithoutExamsInput
    >;
    connectOrCreate?: ClassTermCreateOrConnectWithoutExamsInput;
    upsert?: ClassTermUpsertWithoutExamsInput;
    connect?: ClassTermWhereUniqueInput;
    update?: XOR<
      XOR<
        ClassTermUpdateToOneWithWhereWithoutExamsInput,
        ClassTermUpdateWithoutExamsInput
      >,
      ClassTermUncheckedUpdateWithoutExamsInput
    >;
  };

  export type ExamSubjectUncheckedUpdateManyWithoutExamNestedInput = {
    create?:
      | XOR<
          ExamSubjectCreateWithoutExamInput,
          ExamSubjectUncheckedCreateWithoutExamInput
        >
      | ExamSubjectCreateWithoutExamInput[]
      | ExamSubjectUncheckedCreateWithoutExamInput[];
    connectOrCreate?:
      | ExamSubjectCreateOrConnectWithoutExamInput
      | ExamSubjectCreateOrConnectWithoutExamInput[];
    upsert?:
      | ExamSubjectUpsertWithWhereUniqueWithoutExamInput
      | ExamSubjectUpsertWithWhereUniqueWithoutExamInput[];
    createMany?: ExamSubjectCreateManyExamInputEnvelope;
    set?: ExamSubjectWhereUniqueInput | ExamSubjectWhereUniqueInput[];
    disconnect?: ExamSubjectWhereUniqueInput | ExamSubjectWhereUniqueInput[];
    delete?: ExamSubjectWhereUniqueInput | ExamSubjectWhereUniqueInput[];
    connect?: ExamSubjectWhereUniqueInput | ExamSubjectWhereUniqueInput[];
    update?:
      | ExamSubjectUpdateWithWhereUniqueWithoutExamInput
      | ExamSubjectUpdateWithWhereUniqueWithoutExamInput[];
    updateMany?:
      | ExamSubjectUpdateManyWithWhereWithoutExamInput
      | ExamSubjectUpdateManyWithWhereWithoutExamInput[];
    deleteMany?: ExamSubjectScalarWhereInput | ExamSubjectScalarWhereInput[];
  };

  export type ExamCreateNestedOneWithoutExamSubjectsInput = {
    create?: XOR<
      ExamCreateWithoutExamSubjectsInput,
      ExamUncheckedCreateWithoutExamSubjectsInput
    >;
    connectOrCreate?: ExamCreateOrConnectWithoutExamSubjectsInput;
    connect?: ExamWhereUniqueInput;
  };

  export type AcademicYearSubjectCreateNestedOneWithoutExamSubjectsInput = {
    create?: XOR<
      AcademicYearSubjectCreateWithoutExamSubjectsInput,
      AcademicYearSubjectUncheckedCreateWithoutExamSubjectsInput
    >;
    connectOrCreate?: AcademicYearSubjectCreateOrConnectWithoutExamSubjectsInput;
    connect?: AcademicYearSubjectWhereUniqueInput;
  };

  export type ExamScoreCreateNestedManyWithoutExamSubjectInput = {
    create?:
      | XOR<
          ExamScoreCreateWithoutExamSubjectInput,
          ExamScoreUncheckedCreateWithoutExamSubjectInput
        >
      | ExamScoreCreateWithoutExamSubjectInput[]
      | ExamScoreUncheckedCreateWithoutExamSubjectInput[];
    connectOrCreate?:
      | ExamScoreCreateOrConnectWithoutExamSubjectInput
      | ExamScoreCreateOrConnectWithoutExamSubjectInput[];
    createMany?: ExamScoreCreateManyExamSubjectInputEnvelope;
    connect?: ExamScoreWhereUniqueInput | ExamScoreWhereUniqueInput[];
  };

  export type ExamScoreUncheckedCreateNestedManyWithoutExamSubjectInput = {
    create?:
      | XOR<
          ExamScoreCreateWithoutExamSubjectInput,
          ExamScoreUncheckedCreateWithoutExamSubjectInput
        >
      | ExamScoreCreateWithoutExamSubjectInput[]
      | ExamScoreUncheckedCreateWithoutExamSubjectInput[];
    connectOrCreate?:
      | ExamScoreCreateOrConnectWithoutExamSubjectInput
      | ExamScoreCreateOrConnectWithoutExamSubjectInput[];
    createMany?: ExamScoreCreateManyExamSubjectInputEnvelope;
    connect?: ExamScoreWhereUniqueInput | ExamScoreWhereUniqueInput[];
  };

  export type ExamUpdateOneRequiredWithoutExamSubjectsNestedInput = {
    create?: XOR<
      ExamCreateWithoutExamSubjectsInput,
      ExamUncheckedCreateWithoutExamSubjectsInput
    >;
    connectOrCreate?: ExamCreateOrConnectWithoutExamSubjectsInput;
    upsert?: ExamUpsertWithoutExamSubjectsInput;
    connect?: ExamWhereUniqueInput;
    update?: XOR<
      XOR<
        ExamUpdateToOneWithWhereWithoutExamSubjectsInput,
        ExamUpdateWithoutExamSubjectsInput
      >,
      ExamUncheckedUpdateWithoutExamSubjectsInput
    >;
  };

  export type AcademicYearSubjectUpdateOneRequiredWithoutExamSubjectsNestedInput =
    {
      create?: XOR<
        AcademicYearSubjectCreateWithoutExamSubjectsInput,
        AcademicYearSubjectUncheckedCreateWithoutExamSubjectsInput
      >;
      connectOrCreate?: AcademicYearSubjectCreateOrConnectWithoutExamSubjectsInput;
      upsert?: AcademicYearSubjectUpsertWithoutExamSubjectsInput;
      connect?: AcademicYearSubjectWhereUniqueInput;
      update?: XOR<
        XOR<
          AcademicYearSubjectUpdateToOneWithWhereWithoutExamSubjectsInput,
          AcademicYearSubjectUpdateWithoutExamSubjectsInput
        >,
        AcademicYearSubjectUncheckedUpdateWithoutExamSubjectsInput
      >;
    };

  export type ExamScoreUpdateManyWithoutExamSubjectNestedInput = {
    create?:
      | XOR<
          ExamScoreCreateWithoutExamSubjectInput,
          ExamScoreUncheckedCreateWithoutExamSubjectInput
        >
      | ExamScoreCreateWithoutExamSubjectInput[]
      | ExamScoreUncheckedCreateWithoutExamSubjectInput[];
    connectOrCreate?:
      | ExamScoreCreateOrConnectWithoutExamSubjectInput
      | ExamScoreCreateOrConnectWithoutExamSubjectInput[];
    upsert?:
      | ExamScoreUpsertWithWhereUniqueWithoutExamSubjectInput
      | ExamScoreUpsertWithWhereUniqueWithoutExamSubjectInput[];
    createMany?: ExamScoreCreateManyExamSubjectInputEnvelope;
    set?: ExamScoreWhereUniqueInput | ExamScoreWhereUniqueInput[];
    disconnect?: ExamScoreWhereUniqueInput | ExamScoreWhereUniqueInput[];
    delete?: ExamScoreWhereUniqueInput | ExamScoreWhereUniqueInput[];
    connect?: ExamScoreWhereUniqueInput | ExamScoreWhereUniqueInput[];
    update?:
      | ExamScoreUpdateWithWhereUniqueWithoutExamSubjectInput
      | ExamScoreUpdateWithWhereUniqueWithoutExamSubjectInput[];
    updateMany?:
      | ExamScoreUpdateManyWithWhereWithoutExamSubjectInput
      | ExamScoreUpdateManyWithWhereWithoutExamSubjectInput[];
    deleteMany?: ExamScoreScalarWhereInput | ExamScoreScalarWhereInput[];
  };

  export type ExamScoreUncheckedUpdateManyWithoutExamSubjectNestedInput = {
    create?:
      | XOR<
          ExamScoreCreateWithoutExamSubjectInput,
          ExamScoreUncheckedCreateWithoutExamSubjectInput
        >
      | ExamScoreCreateWithoutExamSubjectInput[]
      | ExamScoreUncheckedCreateWithoutExamSubjectInput[];
    connectOrCreate?:
      | ExamScoreCreateOrConnectWithoutExamSubjectInput
      | ExamScoreCreateOrConnectWithoutExamSubjectInput[];
    upsert?:
      | ExamScoreUpsertWithWhereUniqueWithoutExamSubjectInput
      | ExamScoreUpsertWithWhereUniqueWithoutExamSubjectInput[];
    createMany?: ExamScoreCreateManyExamSubjectInputEnvelope;
    set?: ExamScoreWhereUniqueInput | ExamScoreWhereUniqueInput[];
    disconnect?: ExamScoreWhereUniqueInput | ExamScoreWhereUniqueInput[];
    delete?: ExamScoreWhereUniqueInput | ExamScoreWhereUniqueInput[];
    connect?: ExamScoreWhereUniqueInput | ExamScoreWhereUniqueInput[];
    update?:
      | ExamScoreUpdateWithWhereUniqueWithoutExamSubjectInput
      | ExamScoreUpdateWithWhereUniqueWithoutExamSubjectInput[];
    updateMany?:
      | ExamScoreUpdateManyWithWhereWithoutExamSubjectInput
      | ExamScoreUpdateManyWithWhereWithoutExamSubjectInput[];
    deleteMany?: ExamScoreScalarWhereInput | ExamScoreScalarWhereInput[];
  };

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedStringFilter<$PrismaModel> | string;
  };

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedStringNullableFilter<$PrismaModel> | string | null;
  };

  export type NestedEnumRoleNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel> | null;
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null;
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null;
    not?: NestedEnumRoleNullableFilter<$PrismaModel> | $Enums.Role | null;
  };

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string;
  };

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolFilter<$PrismaModel> | boolean;
  };

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedStringFilter<$PrismaModel>;
    _max?: NestedStringFilter<$PrismaModel>;
  };

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntFilter<$PrismaModel> | number;
  };

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?:
      | NestedStringNullableWithAggregatesFilter<$PrismaModel>
      | string
      | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedStringNullableFilter<$PrismaModel>;
    _max?: NestedStringNullableFilter<$PrismaModel>;
  };

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableFilter<$PrismaModel> | number | null;
  };

  export type NestedEnumRoleNullableWithAggregatesFilter<$PrismaModel = never> =
    {
      equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel> | null;
      in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null;
      notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null;
      not?:
        | NestedEnumRoleNullableWithAggregatesFilter<$PrismaModel>
        | $Enums.Role
        | null;
      _count?: NestedIntNullableFilter<$PrismaModel>;
      _min?: NestedEnumRoleNullableFilter<$PrismaModel>;
      _max?: NestedEnumRoleNullableFilter<$PrismaModel>;
    };

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedDateTimeFilter<$PrismaModel>;
    _max?: NestedDateTimeFilter<$PrismaModel>;
  };

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedBoolFilter<$PrismaModel>;
    _max?: NestedBoolFilter<$PrismaModel>;
  };

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>;
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>;
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>;
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>;
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>;
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>;
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>;
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number;
  };

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>;
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>;
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>;
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>;
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>;
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>;
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>;
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedBigIntFilter<$PrismaModel>;
    _min?: NestedBigIntFilter<$PrismaModel>;
    _max?: NestedBigIntFilter<$PrismaModel>;
  };

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatFilter<$PrismaModel> | number;
  };

  export type NestedEnumStaffTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.StaffType | EnumStaffTypeFieldRefInput<$PrismaModel>;
    in?: $Enums.StaffType[] | ListEnumStaffTypeFieldRefInput<$PrismaModel>;
    notIn?: $Enums.StaffType[] | ListEnumStaffTypeFieldRefInput<$PrismaModel>;
    not?: NestedEnumStaffTypeFilter<$PrismaModel> | $Enums.StaffType;
  };

  export type NestedEnumStaffTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StaffType | EnumStaffTypeFieldRefInput<$PrismaModel>;
    in?: $Enums.StaffType[] | ListEnumStaffTypeFieldRefInput<$PrismaModel>;
    notIn?: $Enums.StaffType[] | ListEnumStaffTypeFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumStaffTypeWithAggregatesFilter<$PrismaModel>
      | $Enums.StaffType;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumStaffTypeFilter<$PrismaModel>;
    _max?: NestedEnumStaffTypeFilter<$PrismaModel>;
  };

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedFloatFilter<$PrismaModel>;
    _min?: NestedFloatFilter<$PrismaModel>;
    _max?: NestedFloatFilter<$PrismaModel>;
  };

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedFloatNullableFilter<$PrismaModel>;
    _sum?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedIntNullableFilter<$PrismaModel>;
    _max?: NestedIntNullableFilter<$PrismaModel>;
  };

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null;
  };

  export type NestedEnumFeesStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.FeesStatus | EnumFeesStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.FeesStatus[] | ListEnumFeesStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.FeesStatus[] | ListEnumFeesStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumFeesStatusFilter<$PrismaModel> | $Enums.FeesStatus;
  };

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedIntFilter<$PrismaModel>;
    _min?: NestedIntFilter<$PrismaModel>;
    _max?: NestedIntFilter<$PrismaModel>;
  };

  export type NestedEnumFeesStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FeesStatus | EnumFeesStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.FeesStatus[] | ListEnumFeesStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.FeesStatus[] | ListEnumFeesStatusFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumFeesStatusWithAggregatesFilter<$PrismaModel>
      | $Enums.FeesStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumFeesStatusFilter<$PrismaModel>;
    _max?: NestedEnumFeesStatusFilter<$PrismaModel>;
  };

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>;
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>;
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>;
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role;
  };

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>;
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>;
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>;
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumRoleFilter<$PrismaModel>;
    _max?: NestedEnumRoleFilter<$PrismaModel>;
  };

  export type NestedEnumAssetCategoryFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.AssetCategory
      | EnumAssetCategoryFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.AssetCategory[]
      | ListEnumAssetCategoryFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.AssetCategory[]
      | ListEnumAssetCategoryFieldRefInput<$PrismaModel>;
    not?: NestedEnumAssetCategoryFilter<$PrismaModel> | $Enums.AssetCategory;
  };

  export type NestedEnumAssetCategoryWithAggregatesFilter<
    $PrismaModel = never,
  > = {
    equals?:
      | $Enums.AssetCategory
      | EnumAssetCategoryFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.AssetCategory[]
      | ListEnumAssetCategoryFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.AssetCategory[]
      | ListEnumAssetCategoryFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumAssetCategoryWithAggregatesFilter<$PrismaModel>
      | $Enums.AssetCategory;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumAssetCategoryFilter<$PrismaModel>;
    _max?: NestedEnumAssetCategoryFilter<$PrismaModel>;
  };

  export type NestedEnumAssetUnitFilter<$PrismaModel = never> = {
    equals?: $Enums.AssetUnit | EnumAssetUnitFieldRefInput<$PrismaModel>;
    in?: $Enums.AssetUnit[] | ListEnumAssetUnitFieldRefInput<$PrismaModel>;
    notIn?: $Enums.AssetUnit[] | ListEnumAssetUnitFieldRefInput<$PrismaModel>;
    not?: NestedEnumAssetUnitFilter<$PrismaModel> | $Enums.AssetUnit;
  };

  export type NestedEnumAssetItemStatusFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.AssetItemStatus
      | EnumAssetItemStatusFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.AssetItemStatus[]
      | ListEnumAssetItemStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.AssetItemStatus[]
      | ListEnumAssetItemStatusFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumAssetItemStatusFilter<$PrismaModel>
      | $Enums.AssetItemStatus;
  };

  export type NestedEnumAssetUnitWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AssetUnit | EnumAssetUnitFieldRefInput<$PrismaModel>;
    in?: $Enums.AssetUnit[] | ListEnumAssetUnitFieldRefInput<$PrismaModel>;
    notIn?: $Enums.AssetUnit[] | ListEnumAssetUnitFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumAssetUnitWithAggregatesFilter<$PrismaModel>
      | $Enums.AssetUnit;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumAssetUnitFilter<$PrismaModel>;
    _max?: NestedEnumAssetUnitFilter<$PrismaModel>;
  };

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedFloatNullableFilter<$PrismaModel>;
    _sum?: NestedFloatNullableFilter<$PrismaModel>;
    _min?: NestedFloatNullableFilter<$PrismaModel>;
    _max?: NestedFloatNullableFilter<$PrismaModel>;
  };

  export type NestedEnumAssetItemStatusWithAggregatesFilter<
    $PrismaModel = never,
  > = {
    equals?:
      | $Enums.AssetItemStatus
      | EnumAssetItemStatusFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.AssetItemStatus[]
      | ListEnumAssetItemStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.AssetItemStatus[]
      | ListEnumAssetItemStatusFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumAssetItemStatusWithAggregatesFilter<$PrismaModel>
      | $Enums.AssetItemStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumAssetItemStatusFilter<$PrismaModel>;
    _max?: NestedEnumAssetItemStatusFilter<$PrismaModel>;
  };

  export type NestedEnumAssetStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AssetStatus | EnumAssetStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.AssetStatus[] | ListEnumAssetStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.AssetStatus[]
      | ListEnumAssetStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumAssetStatusFilter<$PrismaModel> | $Enums.AssetStatus;
  };

  export type NestedEnumAssetConditionFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.AssetCondition
      | EnumAssetConditionFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.AssetCondition[]
      | ListEnumAssetConditionFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.AssetCondition[]
      | ListEnumAssetConditionFieldRefInput<$PrismaModel>;
    not?: NestedEnumAssetConditionFilter<$PrismaModel> | $Enums.AssetCondition;
  };

  export type NestedEnumAssetStatusWithAggregatesFilter<$PrismaModel = never> =
    {
      equals?: $Enums.AssetStatus | EnumAssetStatusFieldRefInput<$PrismaModel>;
      in?:
        | $Enums.AssetStatus[]
        | ListEnumAssetStatusFieldRefInput<$PrismaModel>;
      notIn?:
        | $Enums.AssetStatus[]
        | ListEnumAssetStatusFieldRefInput<$PrismaModel>;
      not?:
        | NestedEnumAssetStatusWithAggregatesFilter<$PrismaModel>
        | $Enums.AssetStatus;
      _count?: NestedIntFilter<$PrismaModel>;
      _min?: NestedEnumAssetStatusFilter<$PrismaModel>;
      _max?: NestedEnumAssetStatusFilter<$PrismaModel>;
    };

  export type NestedEnumAssetConditionWithAggregatesFilter<
    $PrismaModel = never,
  > = {
    equals?:
      | $Enums.AssetCondition
      | EnumAssetConditionFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.AssetCondition[]
      | ListEnumAssetConditionFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.AssetCondition[]
      | ListEnumAssetConditionFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumAssetConditionWithAggregatesFilter<$PrismaModel>
      | $Enums.AssetCondition;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumAssetConditionFilter<$PrismaModel>;
    _max?: NestedEnumAssetConditionFilter<$PrismaModel>;
  };

  export type NestedEnumBookStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BookStatus | EnumBookStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.BookStatus[] | ListEnumBookStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.BookStatus[] | ListEnumBookStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumBookStatusFilter<$PrismaModel> | $Enums.BookStatus;
  };

  export type NestedEnumBookStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookStatus | EnumBookStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.BookStatus[] | ListEnumBookStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.BookStatus[] | ListEnumBookStatusFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumBookStatusWithAggregatesFilter<$PrismaModel>
      | $Enums.BookStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumBookStatusFilter<$PrismaModel>;
    _max?: NestedEnumBookStatusFilter<$PrismaModel>;
  };

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null;
  };

  export type NestedEnumBorrowStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BorrowStatus | EnumBorrowStatusFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.BorrowStatus[]
      | ListEnumBorrowStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.BorrowStatus[]
      | ListEnumBorrowStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumBorrowStatusFilter<$PrismaModel> | $Enums.BorrowStatus;
  };

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> =
    {
      equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
      in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
      notIn?:
        | Date[]
        | string[]
        | ListDateTimeFieldRefInput<$PrismaModel>
        | null;
      lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      not?:
        | NestedDateTimeNullableWithAggregatesFilter<$PrismaModel>
        | Date
        | string
        | null;
      _count?: NestedIntNullableFilter<$PrismaModel>;
      _min?: NestedDateTimeNullableFilter<$PrismaModel>;
      _max?: NestedDateTimeNullableFilter<$PrismaModel>;
    };

  export type NestedEnumBorrowStatusWithAggregatesFilter<$PrismaModel = never> =
    {
      equals?:
        | $Enums.BorrowStatus
        | EnumBorrowStatusFieldRefInput<$PrismaModel>;
      in?:
        | $Enums.BorrowStatus[]
        | ListEnumBorrowStatusFieldRefInput<$PrismaModel>;
      notIn?:
        | $Enums.BorrowStatus[]
        | ListEnumBorrowStatusFieldRefInput<$PrismaModel>;
      not?:
        | NestedEnumBorrowStatusWithAggregatesFilter<$PrismaModel>
        | $Enums.BorrowStatus;
      _count?: NestedIntFilter<$PrismaModel>;
      _min?: NestedEnumBorrowStatusFilter<$PrismaModel>;
      _max?: NestedEnumBorrowStatusFilter<$PrismaModel>;
    };

  export type NestedEnumExamTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ExamType | EnumExamTypeFieldRefInput<$PrismaModel>;
    in?: $Enums.ExamType[] | ListEnumExamTypeFieldRefInput<$PrismaModel>;
    notIn?: $Enums.ExamType[] | ListEnumExamTypeFieldRefInput<$PrismaModel>;
    not?: NestedEnumExamTypeFilter<$PrismaModel> | $Enums.ExamType;
  };

  export type NestedEnumExamTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ExamType | EnumExamTypeFieldRefInput<$PrismaModel>;
    in?: $Enums.ExamType[] | ListEnumExamTypeFieldRefInput<$PrismaModel>;
    notIn?: $Enums.ExamType[] | ListEnumExamTypeFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumExamTypeWithAggregatesFilter<$PrismaModel>
      | $Enums.ExamType;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumExamTypeFilter<$PrismaModel>;
    _max?: NestedEnumExamTypeFilter<$PrismaModel>;
  };

  export type AssetDamageCreateWithoutDamagedByInput = {
    id?: string;
    damageDetails: string;
    condition: $Enums.AssetCondition;
    quantity: number;
    isRepaired?: boolean;
    repairedAt?: Date | string | null;
    createdAt?: Date | string;
    isSchoolCost?: boolean;
    repairBalance?: number;
    repairPrice?: number | null;
    individualBook?: IndividualBookCreateNestedOneWithoutBookDamagesInput;
    individualComputerLabItem?: IndividualComputerLabItemCreateNestedOneWithoutAssetDamagesInput;
    individualFoodStoreItem?: IndividualFoodStoreItemCreateNestedOneWithoutAssetDamagesInput;
    individualGeneralStoreItem?: IndividualGeneralStoreItemCreateNestedOneWithoutAssetDamagesInput;
    individualLabItem?: IndividualLabItemCreateNestedOneWithoutAssetDamagesInput;
    assetRepairPayments?: AssetRepairPaymentCreateNestedManyWithoutAssetDamageInput;
  };

  export type AssetDamageUncheckedCreateWithoutDamagedByInput = {
    id?: string;
    damageDetails: string;
    condition: $Enums.AssetCondition;
    quantity: number;
    individualComputerLabItemId?: string | null;
    isRepaired?: boolean;
    repairedAt?: Date | string | null;
    createdAt?: Date | string;
    individualBookId?: string | null;
    individualLabItemId?: string | null;
    individualFoodStoreItemId?: string | null;
    individualGeneralStoreItemId?: string | null;
    isSchoolCost?: boolean;
    repairBalance?: number;
    repairPrice?: number | null;
    assetRepairPayments?: AssetRepairPaymentUncheckedCreateNestedManyWithoutAssetDamageInput;
  };

  export type AssetDamageCreateOrConnectWithoutDamagedByInput = {
    where: AssetDamageWhereUniqueInput;
    create: XOR<
      AssetDamageCreateWithoutDamagedByInput,
      AssetDamageUncheckedCreateWithoutDamagedByInput
    >;
  };

  export type AssetDamageCreateManyDamagedByInputEnvelope = {
    data:
      | AssetDamageCreateManyDamagedByInput
      | AssetDamageCreateManyDamagedByInput[];
    skipDuplicates?: boolean;
  };

  export type AssetRepairPaymentCreateWithoutReceivedByInput = {
    id?: string;
    paidAmount: number;
    paidAt?: Date | string;
    updatedAt?: Date | string;
    isSchoolCost?: boolean;
    assetDamage?: AssetDamageCreateNestedOneWithoutAssetRepairPaymentsInput;
  };

  export type AssetRepairPaymentUncheckedCreateWithoutReceivedByInput = {
    id?: string;
    paidAmount: number;
    paidAt?: Date | string;
    updatedAt?: Date | string;
    assetDamageId?: string | null;
    isSchoolCost?: boolean;
  };

  export type AssetRepairPaymentCreateOrConnectWithoutReceivedByInput = {
    where: AssetRepairPaymentWhereUniqueInput;
    create: XOR<
      AssetRepairPaymentCreateWithoutReceivedByInput,
      AssetRepairPaymentUncheckedCreateWithoutReceivedByInput
    >;
  };

  export type AssetRepairPaymentCreateManyReceivedByInputEnvelope = {
    data:
      | AssetRepairPaymentCreateManyReceivedByInput
      | AssetRepairPaymentCreateManyReceivedByInput[];
    skipDuplicates?: boolean;
  };

  export type BorrowerCreateWithoutUserInput = {
    id?: string;
    borrowedAt?: Date | string;
    returnAt?: Date | string | null;
    status?: $Enums.BorrowStatus;
    libraryBook?: IndividualBookCreateNestedOneWithoutBorrowersInput;
  };

  export type BorrowerUncheckedCreateWithoutUserInput = {
    id?: string;
    borrowedAt?: Date | string;
    returnAt?: Date | string | null;
    status?: $Enums.BorrowStatus;
    individualBookId?: string | null;
  };

  export type BorrowerCreateOrConnectWithoutUserInput = {
    where: BorrowerWhereUniqueInput;
    create: XOR<
      BorrowerCreateWithoutUserInput,
      BorrowerUncheckedCreateWithoutUserInput
    >;
  };

  export type BorrowerCreateManyUserInputEnvelope = {
    data: BorrowerCreateManyUserInput | BorrowerCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type EmailVerificationTokenCreateWithoutUserInput = {
    id?: string;
    expires: bigint | number;
  };

  export type EmailVerificationTokenUncheckedCreateWithoutUserInput = {
    id?: string;
    expires: bigint | number;
  };

  export type EmailVerificationTokenCreateOrConnectWithoutUserInput = {
    where: EmailVerificationTokenWhereUniqueInput;
    create: XOR<
      EmailVerificationTokenCreateWithoutUserInput,
      EmailVerificationTokenUncheckedCreateWithoutUserInput
    >;
  };

  export type EmailVerificationTokenCreateManyUserInputEnvelope = {
    data:
      | EmailVerificationTokenCreateManyUserInput
      | EmailVerificationTokenCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type FeesPaymentCreateWithoutPaidByInput = {
    id?: string;
    amountPaid: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    fees?: FeesCreateNestedOneWithoutFeesPaymentsInput;
  };

  export type FeesPaymentUncheckedCreateWithoutPaidByInput = {
    id?: string;
    amountPaid: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    feesId?: string | null;
  };

  export type FeesPaymentCreateOrConnectWithoutPaidByInput = {
    where: FeesPaymentWhereUniqueInput;
    create: XOR<
      FeesPaymentCreateWithoutPaidByInput,
      FeesPaymentUncheckedCreateWithoutPaidByInput
    >;
  };

  export type FeesPaymentCreateManyPaidByInputEnvelope = {
    data: FeesPaymentCreateManyPaidByInput | FeesPaymentCreateManyPaidByInput[];
    skipDuplicates?: boolean;
  };

  export type PupilCreateWithoutUserInput = {
    id?: string;
    genericPassword: string;
    classStreams?: classStreamCreateNestedManyWithoutPupilsInput;
    examScores?: ExamScoreCreateNestedManyWithoutPupilInput;
    fees?: FeesCreateNestedManyWithoutPupilInput;
  };

  export type PupilUncheckedCreateWithoutUserInput = {
    id?: string;
    genericPassword: string;
    classStreams?: classStreamUncheckedCreateNestedManyWithoutPupilsInput;
    examScores?: ExamScoreUncheckedCreateNestedManyWithoutPupilInput;
    fees?: FeesUncheckedCreateNestedManyWithoutPupilInput;
  };

  export type PupilCreateOrConnectWithoutUserInput = {
    where: PupilWhereUniqueInput;
    create: XOR<
      PupilCreateWithoutUserInput,
      PupilUncheckedCreateWithoutUserInput
    >;
  };

  export type PupilCreateManyUserInputEnvelope = {
    data: PupilCreateManyUserInput | PupilCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type SessionCreateWithoutUserInput = {
    id?: string;
    expiresAt: Date | string;
    role?: $Enums.Role;
  };

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string;
    expiresAt: Date | string;
    role?: $Enums.Role;
  };

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput;
    create: XOR<
      SessionCreateWithoutUserInput,
      SessionUncheckedCreateWithoutUserInput
    >;
  };

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type StaffCreateWithoutUserInput = {
    id?: string;
    staffType?: $Enums.StaffType;
    genericPassword: string;
    academicYearSubjects?: AcademicYearSubjectCreateNestedManyWithoutTeachersInput;
    classStreams?: classStreamCreateNestedManyWithoutClassTeacherInput;
  };

  export type StaffUncheckedCreateWithoutUserInput = {
    id?: string;
    staffType?: $Enums.StaffType;
    genericPassword: string;
    academicYearSubjects?: AcademicYearSubjectUncheckedCreateNestedManyWithoutTeachersInput;
    classStreams?: classStreamUncheckedCreateNestedManyWithoutClassTeacherInput;
  };

  export type StaffCreateOrConnectWithoutUserInput = {
    where: StaffWhereUniqueInput;
    create: XOR<
      StaffCreateWithoutUserInput,
      StaffUncheckedCreateWithoutUserInput
    >;
  };

  export type StaffCreateManyUserInputEnvelope = {
    data: StaffCreateManyUserInput | StaffCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type AssetDamageUpsertWithWhereUniqueWithoutDamagedByInput = {
    where: AssetDamageWhereUniqueInput;
    update: XOR<
      AssetDamageUpdateWithoutDamagedByInput,
      AssetDamageUncheckedUpdateWithoutDamagedByInput
    >;
    create: XOR<
      AssetDamageCreateWithoutDamagedByInput,
      AssetDamageUncheckedCreateWithoutDamagedByInput
    >;
  };

  export type AssetDamageUpdateWithWhereUniqueWithoutDamagedByInput = {
    where: AssetDamageWhereUniqueInput;
    data: XOR<
      AssetDamageUpdateWithoutDamagedByInput,
      AssetDamageUncheckedUpdateWithoutDamagedByInput
    >;
  };

  export type AssetDamageUpdateManyWithWhereWithoutDamagedByInput = {
    where: AssetDamageScalarWhereInput;
    data: XOR<
      AssetDamageUpdateManyMutationInput,
      AssetDamageUncheckedUpdateManyWithoutDamagedByInput
    >;
  };

  export type AssetDamageScalarWhereInput = {
    AND?: AssetDamageScalarWhereInput | AssetDamageScalarWhereInput[];
    OR?: AssetDamageScalarWhereInput[];
    NOT?: AssetDamageScalarWhereInput | AssetDamageScalarWhereInput[];
    id?: StringFilter<"AssetDamage"> | string;
    damageDetails?: StringFilter<"AssetDamage"> | string;
    condition?: EnumAssetConditionFilter<"AssetDamage"> | $Enums.AssetCondition;
    quantity?: IntFilter<"AssetDamage"> | number;
    userId?: StringNullableFilter<"AssetDamage"> | string | null;
    individualComputerLabItemId?:
      | StringNullableFilter<"AssetDamage">
      | string
      | null;
    isRepaired?: BoolFilter<"AssetDamage"> | boolean;
    repairedAt?: DateTimeNullableFilter<"AssetDamage"> | Date | string | null;
    createdAt?: DateTimeFilter<"AssetDamage"> | Date | string;
    individualBookId?: StringNullableFilter<"AssetDamage"> | string | null;
    individualLabItemId?: StringNullableFilter<"AssetDamage"> | string | null;
    individualFoodStoreItemId?:
      | StringNullableFilter<"AssetDamage">
      | string
      | null;
    individualGeneralStoreItemId?:
      | StringNullableFilter<"AssetDamage">
      | string
      | null;
    isSchoolCost?: BoolFilter<"AssetDamage"> | boolean;
    repairBalance?: FloatFilter<"AssetDamage"> | number;
    repairPrice?: FloatNullableFilter<"AssetDamage"> | number | null;
  };

  export type AssetRepairPaymentUpsertWithWhereUniqueWithoutReceivedByInput = {
    where: AssetRepairPaymentWhereUniqueInput;
    update: XOR<
      AssetRepairPaymentUpdateWithoutReceivedByInput,
      AssetRepairPaymentUncheckedUpdateWithoutReceivedByInput
    >;
    create: XOR<
      AssetRepairPaymentCreateWithoutReceivedByInput,
      AssetRepairPaymentUncheckedCreateWithoutReceivedByInput
    >;
  };

  export type AssetRepairPaymentUpdateWithWhereUniqueWithoutReceivedByInput = {
    where: AssetRepairPaymentWhereUniqueInput;
    data: XOR<
      AssetRepairPaymentUpdateWithoutReceivedByInput,
      AssetRepairPaymentUncheckedUpdateWithoutReceivedByInput
    >;
  };

  export type AssetRepairPaymentUpdateManyWithWhereWithoutReceivedByInput = {
    where: AssetRepairPaymentScalarWhereInput;
    data: XOR<
      AssetRepairPaymentUpdateManyMutationInput,
      AssetRepairPaymentUncheckedUpdateManyWithoutReceivedByInput
    >;
  };

  export type AssetRepairPaymentScalarWhereInput = {
    AND?:
      | AssetRepairPaymentScalarWhereInput
      | AssetRepairPaymentScalarWhereInput[];
    OR?: AssetRepairPaymentScalarWhereInput[];
    NOT?:
      | AssetRepairPaymentScalarWhereInput
      | AssetRepairPaymentScalarWhereInput[];
    id?: StringFilter<"AssetRepairPayment"> | string;
    paidAmount?: FloatFilter<"AssetRepairPayment"> | number;
    paidAt?: DateTimeFilter<"AssetRepairPayment"> | Date | string;
    updatedAt?: DateTimeFilter<"AssetRepairPayment"> | Date | string;
    assetDamageId?: StringNullableFilter<"AssetRepairPayment"> | string | null;
    userId?: StringNullableFilter<"AssetRepairPayment"> | string | null;
    isSchoolCost?: BoolFilter<"AssetRepairPayment"> | boolean;
  };

  export type BorrowerUpsertWithWhereUniqueWithoutUserInput = {
    where: BorrowerWhereUniqueInput;
    update: XOR<
      BorrowerUpdateWithoutUserInput,
      BorrowerUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      BorrowerCreateWithoutUserInput,
      BorrowerUncheckedCreateWithoutUserInput
    >;
  };

  export type BorrowerUpdateWithWhereUniqueWithoutUserInput = {
    where: BorrowerWhereUniqueInput;
    data: XOR<
      BorrowerUpdateWithoutUserInput,
      BorrowerUncheckedUpdateWithoutUserInput
    >;
  };

  export type BorrowerUpdateManyWithWhereWithoutUserInput = {
    where: BorrowerScalarWhereInput;
    data: XOR<
      BorrowerUpdateManyMutationInput,
      BorrowerUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type BorrowerScalarWhereInput = {
    AND?: BorrowerScalarWhereInput | BorrowerScalarWhereInput[];
    OR?: BorrowerScalarWhereInput[];
    NOT?: BorrowerScalarWhereInput | BorrowerScalarWhereInput[];
    id?: StringFilter<"Borrower"> | string;
    borrowedAt?: DateTimeFilter<"Borrower"> | Date | string;
    returnAt?: DateTimeNullableFilter<"Borrower"> | Date | string | null;
    status?: EnumBorrowStatusFilter<"Borrower"> | $Enums.BorrowStatus;
    userId?: StringFilter<"Borrower"> | string;
    individualBookId?: StringNullableFilter<"Borrower"> | string | null;
  };

  export type EmailVerificationTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: EmailVerificationTokenWhereUniqueInput;
    update: XOR<
      EmailVerificationTokenUpdateWithoutUserInput,
      EmailVerificationTokenUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      EmailVerificationTokenCreateWithoutUserInput,
      EmailVerificationTokenUncheckedCreateWithoutUserInput
    >;
  };

  export type EmailVerificationTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: EmailVerificationTokenWhereUniqueInput;
    data: XOR<
      EmailVerificationTokenUpdateWithoutUserInput,
      EmailVerificationTokenUncheckedUpdateWithoutUserInput
    >;
  };

  export type EmailVerificationTokenUpdateManyWithWhereWithoutUserInput = {
    where: EmailVerificationTokenScalarWhereInput;
    data: XOR<
      EmailVerificationTokenUpdateManyMutationInput,
      EmailVerificationTokenUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type EmailVerificationTokenScalarWhereInput = {
    AND?:
      | EmailVerificationTokenScalarWhereInput
      | EmailVerificationTokenScalarWhereInput[];
    OR?: EmailVerificationTokenScalarWhereInput[];
    NOT?:
      | EmailVerificationTokenScalarWhereInput
      | EmailVerificationTokenScalarWhereInput[];
    id?: StringFilter<"EmailVerificationToken"> | string;
    userId?: StringFilter<"EmailVerificationToken"> | string;
    expires?: BigIntFilter<"EmailVerificationToken"> | bigint | number;
  };

  export type FeesPaymentUpsertWithWhereUniqueWithoutPaidByInput = {
    where: FeesPaymentWhereUniqueInput;
    update: XOR<
      FeesPaymentUpdateWithoutPaidByInput,
      FeesPaymentUncheckedUpdateWithoutPaidByInput
    >;
    create: XOR<
      FeesPaymentCreateWithoutPaidByInput,
      FeesPaymentUncheckedCreateWithoutPaidByInput
    >;
  };

  export type FeesPaymentUpdateWithWhereUniqueWithoutPaidByInput = {
    where: FeesPaymentWhereUniqueInput;
    data: XOR<
      FeesPaymentUpdateWithoutPaidByInput,
      FeesPaymentUncheckedUpdateWithoutPaidByInput
    >;
  };

  export type FeesPaymentUpdateManyWithWhereWithoutPaidByInput = {
    where: FeesPaymentScalarWhereInput;
    data: XOR<
      FeesPaymentUpdateManyMutationInput,
      FeesPaymentUncheckedUpdateManyWithoutPaidByInput
    >;
  };

  export type FeesPaymentScalarWhereInput = {
    AND?: FeesPaymentScalarWhereInput | FeesPaymentScalarWhereInput[];
    OR?: FeesPaymentScalarWhereInput[];
    NOT?: FeesPaymentScalarWhereInput | FeesPaymentScalarWhereInput[];
    id?: StringFilter<"FeesPayment"> | string;
    amountPaid?: IntFilter<"FeesPayment"> | number;
    createdAt?: DateTimeFilter<"FeesPayment"> | Date | string;
    updatedAt?: DateTimeFilter<"FeesPayment"> | Date | string;
    feesId?: StringNullableFilter<"FeesPayment"> | string | null;
    userId?: StringFilter<"FeesPayment"> | string;
  };

  export type PupilUpsertWithWhereUniqueWithoutUserInput = {
    where: PupilWhereUniqueInput;
    update: XOR<
      PupilUpdateWithoutUserInput,
      PupilUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      PupilCreateWithoutUserInput,
      PupilUncheckedCreateWithoutUserInput
    >;
  };

  export type PupilUpdateWithWhereUniqueWithoutUserInput = {
    where: PupilWhereUniqueInput;
    data: XOR<
      PupilUpdateWithoutUserInput,
      PupilUncheckedUpdateWithoutUserInput
    >;
  };

  export type PupilUpdateManyWithWhereWithoutUserInput = {
    where: PupilScalarWhereInput;
    data: XOR<
      PupilUpdateManyMutationInput,
      PupilUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type PupilScalarWhereInput = {
    AND?: PupilScalarWhereInput | PupilScalarWhereInput[];
    OR?: PupilScalarWhereInput[];
    NOT?: PupilScalarWhereInput | PupilScalarWhereInput[];
    id?: StringFilter<"Pupil"> | string;
    userId?: StringNullableFilter<"Pupil"> | string | null;
    genericPassword?: StringFilter<"Pupil"> | string;
  };

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput;
    update: XOR<
      SessionUpdateWithoutUserInput,
      SessionUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      SessionCreateWithoutUserInput,
      SessionUncheckedCreateWithoutUserInput
    >;
  };

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput;
    data: XOR<
      SessionUpdateWithoutUserInput,
      SessionUncheckedUpdateWithoutUserInput
    >;
  };

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput;
    data: XOR<
      SessionUpdateManyMutationInput,
      SessionUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[];
    OR?: SessionScalarWhereInput[];
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[];
    id?: StringFilter<"Session"> | string;
    userId?: StringFilter<"Session"> | string;
    expiresAt?: DateTimeFilter<"Session"> | Date | string;
    role?: EnumRoleFilter<"Session"> | $Enums.Role;
  };

  export type StaffUpsertWithWhereUniqueWithoutUserInput = {
    where: StaffWhereUniqueInput;
    update: XOR<
      StaffUpdateWithoutUserInput,
      StaffUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      StaffCreateWithoutUserInput,
      StaffUncheckedCreateWithoutUserInput
    >;
  };

  export type StaffUpdateWithWhereUniqueWithoutUserInput = {
    where: StaffWhereUniqueInput;
    data: XOR<
      StaffUpdateWithoutUserInput,
      StaffUncheckedUpdateWithoutUserInput
    >;
  };

  export type StaffUpdateManyWithWhereWithoutUserInput = {
    where: StaffScalarWhereInput;
    data: XOR<
      StaffUpdateManyMutationInput,
      StaffUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type StaffScalarWhereInput = {
    AND?: StaffScalarWhereInput | StaffScalarWhereInput[];
    OR?: StaffScalarWhereInput[];
    NOT?: StaffScalarWhereInput | StaffScalarWhereInput[];
    id?: StringFilter<"Staff"> | string;
    staffType?: EnumStaffTypeFilter<"Staff"> | $Enums.StaffType;
    userId?: StringNullableFilter<"Staff"> | string | null;
    genericPassword?: StringFilter<"Staff"> | string;
  };

  export type UserCreateWithoutEmailVerificationTokensInput = {
    id?: string;
    name?: string | null;
    username?: string | null;
    email?: string | null;
    avatarUrl?: string | null;
    role?: $Enums.Role | null;
    createdAt?: Date | string;
    telephone?: string | null;
    passwordHash?: string | null;
    googleId?: string | null;
    bio?: string | null;
    isWelcomed?: boolean;
    isVerified?: boolean;
    emailVerified?: boolean;
    assetDamages?: AssetDamageCreateNestedManyWithoutDamagedByInput;
    assetRepairPayments?: AssetRepairPaymentCreateNestedManyWithoutReceivedByInput;
    borrowers?: BorrowerCreateNestedManyWithoutUserInput;
    feesPayments?: FeesPaymentCreateNestedManyWithoutPaidByInput;
    pupils?: PupilCreateNestedManyWithoutUserInput;
    sessions?: SessionCreateNestedManyWithoutUserInput;
    staffs?: StaffCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutEmailVerificationTokensInput = {
    id?: string;
    name?: string | null;
    username?: string | null;
    email?: string | null;
    avatarUrl?: string | null;
    role?: $Enums.Role | null;
    createdAt?: Date | string;
    telephone?: string | null;
    passwordHash?: string | null;
    googleId?: string | null;
    bio?: string | null;
    isWelcomed?: boolean;
    isVerified?: boolean;
    emailVerified?: boolean;
    assetDamages?: AssetDamageUncheckedCreateNestedManyWithoutDamagedByInput;
    assetRepairPayments?: AssetRepairPaymentUncheckedCreateNestedManyWithoutReceivedByInput;
    borrowers?: BorrowerUncheckedCreateNestedManyWithoutUserInput;
    feesPayments?: FeesPaymentUncheckedCreateNestedManyWithoutPaidByInput;
    pupils?: PupilUncheckedCreateNestedManyWithoutUserInput;
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput;
    staffs?: StaffUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutEmailVerificationTokensInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutEmailVerificationTokensInput,
      UserUncheckedCreateWithoutEmailVerificationTokensInput
    >;
  };

  export type UserUpsertWithoutEmailVerificationTokensInput = {
    update: XOR<
      UserUpdateWithoutEmailVerificationTokensInput,
      UserUncheckedUpdateWithoutEmailVerificationTokensInput
    >;
    create: XOR<
      UserCreateWithoutEmailVerificationTokensInput,
      UserUncheckedCreateWithoutEmailVerificationTokensInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutEmailVerificationTokensInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutEmailVerificationTokensInput,
      UserUncheckedUpdateWithoutEmailVerificationTokensInput
    >;
  };

  export type UserUpdateWithoutEmailVerificationTokensInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    telephone?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    googleId?: NullableStringFieldUpdateOperationsInput | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    isWelcomed?: BoolFieldUpdateOperationsInput | boolean;
    isVerified?: BoolFieldUpdateOperationsInput | boolean;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    assetDamages?: AssetDamageUpdateManyWithoutDamagedByNestedInput;
    assetRepairPayments?: AssetRepairPaymentUpdateManyWithoutReceivedByNestedInput;
    borrowers?: BorrowerUpdateManyWithoutUserNestedInput;
    feesPayments?: FeesPaymentUpdateManyWithoutPaidByNestedInput;
    pupils?: PupilUpdateManyWithoutUserNestedInput;
    sessions?: SessionUpdateManyWithoutUserNestedInput;
    staffs?: StaffUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutEmailVerificationTokensInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    telephone?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    googleId?: NullableStringFieldUpdateOperationsInput | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    isWelcomed?: BoolFieldUpdateOperationsInput | boolean;
    isVerified?: BoolFieldUpdateOperationsInput | boolean;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    assetDamages?: AssetDamageUncheckedUpdateManyWithoutDamagedByNestedInput;
    assetRepairPayments?: AssetRepairPaymentUncheckedUpdateManyWithoutReceivedByNestedInput;
    borrowers?: BorrowerUncheckedUpdateManyWithoutUserNestedInput;
    feesPayments?: FeesPaymentUncheckedUpdateManyWithoutPaidByNestedInput;
    pupils?: PupilUncheckedUpdateManyWithoutUserNestedInput;
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput;
    staffs?: StaffUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type classStreamCreateWithoutPupilsInput = {
    id?: string;
    class?: AcademicYearClassCreateNestedOneWithoutStreamsInput;
    classTeacher?: StaffCreateNestedOneWithoutClassStreamsInput;
    stream?: StreamCreateNestedOneWithoutClassStreamsInput;
    terms?: ClassTermCreateNestedManyWithoutClassStreamInput;
  };

  export type classStreamUncheckedCreateWithoutPupilsInput = {
    id?: string;
    staffId?: string | null;
    classId?: string | null;
    streamId?: string | null;
    terms?: ClassTermUncheckedCreateNestedManyWithoutClassStreamInput;
  };

  export type classStreamCreateOrConnectWithoutPupilsInput = {
    where: classStreamWhereUniqueInput;
    create: XOR<
      classStreamCreateWithoutPupilsInput,
      classStreamUncheckedCreateWithoutPupilsInput
    >;
  };

  export type ExamScoreCreateWithoutPupilInput = {
    id?: string;
    score: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    examSubject: ExamSubjectCreateNestedOneWithoutExamScoresInput;
  };

  export type ExamScoreUncheckedCreateWithoutPupilInput = {
    id?: string;
    score: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    examSubjectId: string;
  };

  export type ExamScoreCreateOrConnectWithoutPupilInput = {
    where: ExamScoreWhereUniqueInput;
    create: XOR<
      ExamScoreCreateWithoutPupilInput,
      ExamScoreUncheckedCreateWithoutPupilInput
    >;
  };

  export type ExamScoreCreateManyPupilInputEnvelope = {
    data: ExamScoreCreateManyPupilInput | ExamScoreCreateManyPupilInput[];
    skipDuplicates?: boolean;
  };

  export type FeesCreateWithoutPupilInput = {
    id?: string;
    balance?: number;
    status?: $Enums.FeesStatus;
    term: ClassTermCreateNestedOneWithoutFeesInput;
    feesPayments?: FeesPaymentCreateNestedManyWithoutFeesInput;
  };

  export type FeesUncheckedCreateWithoutPupilInput = {
    id?: string;
    balance?: number;
    termId: string;
    status?: $Enums.FeesStatus;
    feesPayments?: FeesPaymentUncheckedCreateNestedManyWithoutFeesInput;
  };

  export type FeesCreateOrConnectWithoutPupilInput = {
    where: FeesWhereUniqueInput;
    create: XOR<
      FeesCreateWithoutPupilInput,
      FeesUncheckedCreateWithoutPupilInput
    >;
  };

  export type FeesCreateManyPupilInputEnvelope = {
    data: FeesCreateManyPupilInput | FeesCreateManyPupilInput[];
    skipDuplicates?: boolean;
  };

  export type UserCreateWithoutPupilsInput = {
    id?: string;
    name?: string | null;
    username?: string | null;
    email?: string | null;
    avatarUrl?: string | null;
    role?: $Enums.Role | null;
    createdAt?: Date | string;
    telephone?: string | null;
    passwordHash?: string | null;
    googleId?: string | null;
    bio?: string | null;
    isWelcomed?: boolean;
    isVerified?: boolean;
    emailVerified?: boolean;
    assetDamages?: AssetDamageCreateNestedManyWithoutDamagedByInput;
    assetRepairPayments?: AssetRepairPaymentCreateNestedManyWithoutReceivedByInput;
    borrowers?: BorrowerCreateNestedManyWithoutUserInput;
    emailVerificationTokens?: EmailVerificationTokenCreateNestedManyWithoutUserInput;
    feesPayments?: FeesPaymentCreateNestedManyWithoutPaidByInput;
    sessions?: SessionCreateNestedManyWithoutUserInput;
    staffs?: StaffCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutPupilsInput = {
    id?: string;
    name?: string | null;
    username?: string | null;
    email?: string | null;
    avatarUrl?: string | null;
    role?: $Enums.Role | null;
    createdAt?: Date | string;
    telephone?: string | null;
    passwordHash?: string | null;
    googleId?: string | null;
    bio?: string | null;
    isWelcomed?: boolean;
    isVerified?: boolean;
    emailVerified?: boolean;
    assetDamages?: AssetDamageUncheckedCreateNestedManyWithoutDamagedByInput;
    assetRepairPayments?: AssetRepairPaymentUncheckedCreateNestedManyWithoutReceivedByInput;
    borrowers?: BorrowerUncheckedCreateNestedManyWithoutUserInput;
    emailVerificationTokens?: EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput;
    feesPayments?: FeesPaymentUncheckedCreateNestedManyWithoutPaidByInput;
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput;
    staffs?: StaffUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutPupilsInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutPupilsInput,
      UserUncheckedCreateWithoutPupilsInput
    >;
  };

  export type classStreamUpsertWithWhereUniqueWithoutPupilsInput = {
    where: classStreamWhereUniqueInput;
    update: XOR<
      classStreamUpdateWithoutPupilsInput,
      classStreamUncheckedUpdateWithoutPupilsInput
    >;
    create: XOR<
      classStreamCreateWithoutPupilsInput,
      classStreamUncheckedCreateWithoutPupilsInput
    >;
  };

  export type classStreamUpdateWithWhereUniqueWithoutPupilsInput = {
    where: classStreamWhereUniqueInput;
    data: XOR<
      classStreamUpdateWithoutPupilsInput,
      classStreamUncheckedUpdateWithoutPupilsInput
    >;
  };

  export type classStreamUpdateManyWithWhereWithoutPupilsInput = {
    where: classStreamScalarWhereInput;
    data: XOR<
      classStreamUpdateManyMutationInput,
      classStreamUncheckedUpdateManyWithoutPupilsInput
    >;
  };

  export type classStreamScalarWhereInput = {
    AND?: classStreamScalarWhereInput | classStreamScalarWhereInput[];
    OR?: classStreamScalarWhereInput[];
    NOT?: classStreamScalarWhereInput | classStreamScalarWhereInput[];
    id?: StringFilter<"classStream"> | string;
    staffId?: StringNullableFilter<"classStream"> | string | null;
    classId?: StringNullableFilter<"classStream"> | string | null;
    streamId?: StringNullableFilter<"classStream"> | string | null;
  };

  export type ExamScoreUpsertWithWhereUniqueWithoutPupilInput = {
    where: ExamScoreWhereUniqueInput;
    update: XOR<
      ExamScoreUpdateWithoutPupilInput,
      ExamScoreUncheckedUpdateWithoutPupilInput
    >;
    create: XOR<
      ExamScoreCreateWithoutPupilInput,
      ExamScoreUncheckedCreateWithoutPupilInput
    >;
  };

  export type ExamScoreUpdateWithWhereUniqueWithoutPupilInput = {
    where: ExamScoreWhereUniqueInput;
    data: XOR<
      ExamScoreUpdateWithoutPupilInput,
      ExamScoreUncheckedUpdateWithoutPupilInput
    >;
  };

  export type ExamScoreUpdateManyWithWhereWithoutPupilInput = {
    where: ExamScoreScalarWhereInput;
    data: XOR<
      ExamScoreUpdateManyMutationInput,
      ExamScoreUncheckedUpdateManyWithoutPupilInput
    >;
  };

  export type ExamScoreScalarWhereInput = {
    AND?: ExamScoreScalarWhereInput | ExamScoreScalarWhereInput[];
    OR?: ExamScoreScalarWhereInput[];
    NOT?: ExamScoreScalarWhereInput | ExamScoreScalarWhereInput[];
    id?: StringFilter<"ExamScore"> | string;
    score?: FloatFilter<"ExamScore"> | number;
    createdAt?: DateTimeFilter<"ExamScore"> | Date | string;
    updatedAt?: DateTimeFilter<"ExamScore"> | Date | string;
    examSubjectId?: StringFilter<"ExamScore"> | string;
    pupilId?: StringFilter<"ExamScore"> | string;
  };

  export type FeesUpsertWithWhereUniqueWithoutPupilInput = {
    where: FeesWhereUniqueInput;
    update: XOR<
      FeesUpdateWithoutPupilInput,
      FeesUncheckedUpdateWithoutPupilInput
    >;
    create: XOR<
      FeesCreateWithoutPupilInput,
      FeesUncheckedCreateWithoutPupilInput
    >;
  };

  export type FeesUpdateWithWhereUniqueWithoutPupilInput = {
    where: FeesWhereUniqueInput;
    data: XOR<
      FeesUpdateWithoutPupilInput,
      FeesUncheckedUpdateWithoutPupilInput
    >;
  };

  export type FeesUpdateManyWithWhereWithoutPupilInput = {
    where: FeesScalarWhereInput;
    data: XOR<
      FeesUpdateManyMutationInput,
      FeesUncheckedUpdateManyWithoutPupilInput
    >;
  };

  export type FeesScalarWhereInput = {
    AND?: FeesScalarWhereInput | FeesScalarWhereInput[];
    OR?: FeesScalarWhereInput[];
    NOT?: FeesScalarWhereInput | FeesScalarWhereInput[];
    id?: StringFilter<"Fees"> | string;
    pupilId?: StringFilter<"Fees"> | string;
    balance?: IntFilter<"Fees"> | number;
    termId?: StringFilter<"Fees"> | string;
    status?: EnumFeesStatusFilter<"Fees"> | $Enums.FeesStatus;
  };

  export type UserUpsertWithoutPupilsInput = {
    update: XOR<
      UserUpdateWithoutPupilsInput,
      UserUncheckedUpdateWithoutPupilsInput
    >;
    create: XOR<
      UserCreateWithoutPupilsInput,
      UserUncheckedCreateWithoutPupilsInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutPupilsInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutPupilsInput,
      UserUncheckedUpdateWithoutPupilsInput
    >;
  };

  export type UserUpdateWithoutPupilsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    telephone?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    googleId?: NullableStringFieldUpdateOperationsInput | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    isWelcomed?: BoolFieldUpdateOperationsInput | boolean;
    isVerified?: BoolFieldUpdateOperationsInput | boolean;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    assetDamages?: AssetDamageUpdateManyWithoutDamagedByNestedInput;
    assetRepairPayments?: AssetRepairPaymentUpdateManyWithoutReceivedByNestedInput;
    borrowers?: BorrowerUpdateManyWithoutUserNestedInput;
    emailVerificationTokens?: EmailVerificationTokenUpdateManyWithoutUserNestedInput;
    feesPayments?: FeesPaymentUpdateManyWithoutPaidByNestedInput;
    sessions?: SessionUpdateManyWithoutUserNestedInput;
    staffs?: StaffUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutPupilsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    telephone?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    googleId?: NullableStringFieldUpdateOperationsInput | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    isWelcomed?: BoolFieldUpdateOperationsInput | boolean;
    isVerified?: BoolFieldUpdateOperationsInput | boolean;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    assetDamages?: AssetDamageUncheckedUpdateManyWithoutDamagedByNestedInput;
    assetRepairPayments?: AssetRepairPaymentUncheckedUpdateManyWithoutReceivedByNestedInput;
    borrowers?: BorrowerUncheckedUpdateManyWithoutUserNestedInput;
    emailVerificationTokens?: EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput;
    feesPayments?: FeesPaymentUncheckedUpdateManyWithoutPaidByNestedInput;
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput;
    staffs?: StaffUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type AcademicYearSubjectCreateWithoutTeachersInput = {
    id?: string;
    customGrading?: GradingCreateNestedManyWithoutAcademicYearSubjectsInput;
    academicYearClass: AcademicYearClassCreateNestedOneWithoutAcademicYearSubjectsInput;
    subject: SubjectCreateNestedOneWithoutAcademicYearSubjectsInput;
    examSubjects?: ExamSubjectCreateNestedManyWithoutAcademicYearSubjectInput;
  };

  export type AcademicYearSubjectUncheckedCreateWithoutTeachersInput = {
    id?: string;
    academicYearClassId: string;
    subjectId: string;
    customGrading?: GradingUncheckedCreateNestedManyWithoutAcademicYearSubjectsInput;
    examSubjects?: ExamSubjectUncheckedCreateNestedManyWithoutAcademicYearSubjectInput;
  };

  export type AcademicYearSubjectCreateOrConnectWithoutTeachersInput = {
    where: AcademicYearSubjectWhereUniqueInput;
    create: XOR<
      AcademicYearSubjectCreateWithoutTeachersInput,
      AcademicYearSubjectUncheckedCreateWithoutTeachersInput
    >;
  };

  export type classStreamCreateWithoutClassTeacherInput = {
    id?: string;
    pupils?: PupilCreateNestedManyWithoutClassStreamsInput;
    class?: AcademicYearClassCreateNestedOneWithoutStreamsInput;
    stream?: StreamCreateNestedOneWithoutClassStreamsInput;
    terms?: ClassTermCreateNestedManyWithoutClassStreamInput;
  };

  export type classStreamUncheckedCreateWithoutClassTeacherInput = {
    id?: string;
    classId?: string | null;
    streamId?: string | null;
    pupils?: PupilUncheckedCreateNestedManyWithoutClassStreamsInput;
    terms?: ClassTermUncheckedCreateNestedManyWithoutClassStreamInput;
  };

  export type classStreamCreateOrConnectWithoutClassTeacherInput = {
    where: classStreamWhereUniqueInput;
    create: XOR<
      classStreamCreateWithoutClassTeacherInput,
      classStreamUncheckedCreateWithoutClassTeacherInput
    >;
  };

  export type classStreamCreateManyClassTeacherInputEnvelope = {
    data:
      | classStreamCreateManyClassTeacherInput
      | classStreamCreateManyClassTeacherInput[];
    skipDuplicates?: boolean;
  };

  export type UserCreateWithoutStaffsInput = {
    id?: string;
    name?: string | null;
    username?: string | null;
    email?: string | null;
    avatarUrl?: string | null;
    role?: $Enums.Role | null;
    createdAt?: Date | string;
    telephone?: string | null;
    passwordHash?: string | null;
    googleId?: string | null;
    bio?: string | null;
    isWelcomed?: boolean;
    isVerified?: boolean;
    emailVerified?: boolean;
    assetDamages?: AssetDamageCreateNestedManyWithoutDamagedByInput;
    assetRepairPayments?: AssetRepairPaymentCreateNestedManyWithoutReceivedByInput;
    borrowers?: BorrowerCreateNestedManyWithoutUserInput;
    emailVerificationTokens?: EmailVerificationTokenCreateNestedManyWithoutUserInput;
    feesPayments?: FeesPaymentCreateNestedManyWithoutPaidByInput;
    pupils?: PupilCreateNestedManyWithoutUserInput;
    sessions?: SessionCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutStaffsInput = {
    id?: string;
    name?: string | null;
    username?: string | null;
    email?: string | null;
    avatarUrl?: string | null;
    role?: $Enums.Role | null;
    createdAt?: Date | string;
    telephone?: string | null;
    passwordHash?: string | null;
    googleId?: string | null;
    bio?: string | null;
    isWelcomed?: boolean;
    isVerified?: boolean;
    emailVerified?: boolean;
    assetDamages?: AssetDamageUncheckedCreateNestedManyWithoutDamagedByInput;
    assetRepairPayments?: AssetRepairPaymentUncheckedCreateNestedManyWithoutReceivedByInput;
    borrowers?: BorrowerUncheckedCreateNestedManyWithoutUserInput;
    emailVerificationTokens?: EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput;
    feesPayments?: FeesPaymentUncheckedCreateNestedManyWithoutPaidByInput;
    pupils?: PupilUncheckedCreateNestedManyWithoutUserInput;
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutStaffsInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutStaffsInput,
      UserUncheckedCreateWithoutStaffsInput
    >;
  };

  export type AcademicYearSubjectUpsertWithWhereUniqueWithoutTeachersInput = {
    where: AcademicYearSubjectWhereUniqueInput;
    update: XOR<
      AcademicYearSubjectUpdateWithoutTeachersInput,
      AcademicYearSubjectUncheckedUpdateWithoutTeachersInput
    >;
    create: XOR<
      AcademicYearSubjectCreateWithoutTeachersInput,
      AcademicYearSubjectUncheckedCreateWithoutTeachersInput
    >;
  };

  export type AcademicYearSubjectUpdateWithWhereUniqueWithoutTeachersInput = {
    where: AcademicYearSubjectWhereUniqueInput;
    data: XOR<
      AcademicYearSubjectUpdateWithoutTeachersInput,
      AcademicYearSubjectUncheckedUpdateWithoutTeachersInput
    >;
  };

  export type AcademicYearSubjectUpdateManyWithWhereWithoutTeachersInput = {
    where: AcademicYearSubjectScalarWhereInput;
    data: XOR<
      AcademicYearSubjectUpdateManyMutationInput,
      AcademicYearSubjectUncheckedUpdateManyWithoutTeachersInput
    >;
  };

  export type AcademicYearSubjectScalarWhereInput = {
    AND?:
      | AcademicYearSubjectScalarWhereInput
      | AcademicYearSubjectScalarWhereInput[];
    OR?: AcademicYearSubjectScalarWhereInput[];
    NOT?:
      | AcademicYearSubjectScalarWhereInput
      | AcademicYearSubjectScalarWhereInput[];
    id?: StringFilter<"AcademicYearSubject"> | string;
    academicYearClassId?: StringFilter<"AcademicYearSubject"> | string;
    subjectId?: StringFilter<"AcademicYearSubject"> | string;
  };

  export type classStreamUpsertWithWhereUniqueWithoutClassTeacherInput = {
    where: classStreamWhereUniqueInput;
    update: XOR<
      classStreamUpdateWithoutClassTeacherInput,
      classStreamUncheckedUpdateWithoutClassTeacherInput
    >;
    create: XOR<
      classStreamCreateWithoutClassTeacherInput,
      classStreamUncheckedCreateWithoutClassTeacherInput
    >;
  };

  export type classStreamUpdateWithWhereUniqueWithoutClassTeacherInput = {
    where: classStreamWhereUniqueInput;
    data: XOR<
      classStreamUpdateWithoutClassTeacherInput,
      classStreamUncheckedUpdateWithoutClassTeacherInput
    >;
  };

  export type classStreamUpdateManyWithWhereWithoutClassTeacherInput = {
    where: classStreamScalarWhereInput;
    data: XOR<
      classStreamUpdateManyMutationInput,
      classStreamUncheckedUpdateManyWithoutClassTeacherInput
    >;
  };

  export type UserUpsertWithoutStaffsInput = {
    update: XOR<
      UserUpdateWithoutStaffsInput,
      UserUncheckedUpdateWithoutStaffsInput
    >;
    create: XOR<
      UserCreateWithoutStaffsInput,
      UserUncheckedCreateWithoutStaffsInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutStaffsInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutStaffsInput,
      UserUncheckedUpdateWithoutStaffsInput
    >;
  };

  export type UserUpdateWithoutStaffsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    telephone?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    googleId?: NullableStringFieldUpdateOperationsInput | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    isWelcomed?: BoolFieldUpdateOperationsInput | boolean;
    isVerified?: BoolFieldUpdateOperationsInput | boolean;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    assetDamages?: AssetDamageUpdateManyWithoutDamagedByNestedInput;
    assetRepairPayments?: AssetRepairPaymentUpdateManyWithoutReceivedByNestedInput;
    borrowers?: BorrowerUpdateManyWithoutUserNestedInput;
    emailVerificationTokens?: EmailVerificationTokenUpdateManyWithoutUserNestedInput;
    feesPayments?: FeesPaymentUpdateManyWithoutPaidByNestedInput;
    pupils?: PupilUpdateManyWithoutUserNestedInput;
    sessions?: SessionUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutStaffsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    telephone?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    googleId?: NullableStringFieldUpdateOperationsInput | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    isWelcomed?: BoolFieldUpdateOperationsInput | boolean;
    isVerified?: BoolFieldUpdateOperationsInput | boolean;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    assetDamages?: AssetDamageUncheckedUpdateManyWithoutDamagedByNestedInput;
    assetRepairPayments?: AssetRepairPaymentUncheckedUpdateManyWithoutReceivedByNestedInput;
    borrowers?: BorrowerUncheckedUpdateManyWithoutUserNestedInput;
    emailVerificationTokens?: EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput;
    feesPayments?: FeesPaymentUncheckedUpdateManyWithoutPaidByNestedInput;
    pupils?: PupilUncheckedUpdateManyWithoutUserNestedInput;
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type ClassCreateWithoutLevelInput = {
    id?: string;
    name: string;
    createdAt?: Date | string;
    slug: string;
    academicYearClasses?: AcademicYearClassCreateNestedManyWithoutClassInput;
  };

  export type ClassUncheckedCreateWithoutLevelInput = {
    id?: string;
    name: string;
    createdAt?: Date | string;
    slug: string;
    academicYearClasses?: AcademicYearClassUncheckedCreateNestedManyWithoutClassInput;
  };

  export type ClassCreateOrConnectWithoutLevelInput = {
    where: ClassWhereUniqueInput;
    create: XOR<
      ClassCreateWithoutLevelInput,
      ClassUncheckedCreateWithoutLevelInput
    >;
  };

  export type ClassCreateManyLevelInputEnvelope = {
    data: ClassCreateManyLevelInput | ClassCreateManyLevelInput[];
    skipDuplicates?: boolean;
  };

  export type SubjectCreateWithoutLevelInput = {
    id?: string;
    subjectName: string;
    slug: string;
    code: string;
    grading?: GradingCreateNestedManyWithoutSubjectsInput;
    academicYearSubjects?: AcademicYearSubjectCreateNestedManyWithoutSubjectInput;
  };

  export type SubjectUncheckedCreateWithoutLevelInput = {
    id?: string;
    subjectName: string;
    slug: string;
    code: string;
    grading?: GradingUncheckedCreateNestedManyWithoutSubjectsInput;
    academicYearSubjects?: AcademicYearSubjectUncheckedCreateNestedManyWithoutSubjectInput;
  };

  export type SubjectCreateOrConnectWithoutLevelInput = {
    where: SubjectWhereUniqueInput;
    create: XOR<
      SubjectCreateWithoutLevelInput,
      SubjectUncheckedCreateWithoutLevelInput
    >;
  };

  export type SubjectCreateManyLevelInputEnvelope = {
    data: SubjectCreateManyLevelInput | SubjectCreateManyLevelInput[];
    skipDuplicates?: boolean;
  };

  export type ClassUpsertWithWhereUniqueWithoutLevelInput = {
    where: ClassWhereUniqueInput;
    update: XOR<
      ClassUpdateWithoutLevelInput,
      ClassUncheckedUpdateWithoutLevelInput
    >;
    create: XOR<
      ClassCreateWithoutLevelInput,
      ClassUncheckedCreateWithoutLevelInput
    >;
  };

  export type ClassUpdateWithWhereUniqueWithoutLevelInput = {
    where: ClassWhereUniqueInput;
    data: XOR<
      ClassUpdateWithoutLevelInput,
      ClassUncheckedUpdateWithoutLevelInput
    >;
  };

  export type ClassUpdateManyWithWhereWithoutLevelInput = {
    where: ClassScalarWhereInput;
    data: XOR<
      ClassUpdateManyMutationInput,
      ClassUncheckedUpdateManyWithoutLevelInput
    >;
  };

  export type ClassScalarWhereInput = {
    AND?: ClassScalarWhereInput | ClassScalarWhereInput[];
    OR?: ClassScalarWhereInput[];
    NOT?: ClassScalarWhereInput | ClassScalarWhereInput[];
    id?: StringFilter<"Class"> | string;
    name?: StringFilter<"Class"> | string;
    levelId?: StringNullableFilter<"Class"> | string | null;
    createdAt?: DateTimeFilter<"Class"> | Date | string;
    slug?: StringFilter<"Class"> | string;
  };

  export type SubjectUpsertWithWhereUniqueWithoutLevelInput = {
    where: SubjectWhereUniqueInput;
    update: XOR<
      SubjectUpdateWithoutLevelInput,
      SubjectUncheckedUpdateWithoutLevelInput
    >;
    create: XOR<
      SubjectCreateWithoutLevelInput,
      SubjectUncheckedCreateWithoutLevelInput
    >;
  };

  export type SubjectUpdateWithWhereUniqueWithoutLevelInput = {
    where: SubjectWhereUniqueInput;
    data: XOR<
      SubjectUpdateWithoutLevelInput,
      SubjectUncheckedUpdateWithoutLevelInput
    >;
  };

  export type SubjectUpdateManyWithWhereWithoutLevelInput = {
    where: SubjectScalarWhereInput;
    data: XOR<
      SubjectUpdateManyMutationInput,
      SubjectUncheckedUpdateManyWithoutLevelInput
    >;
  };

  export type SubjectScalarWhereInput = {
    AND?: SubjectScalarWhereInput | SubjectScalarWhereInput[];
    OR?: SubjectScalarWhereInput[];
    NOT?: SubjectScalarWhereInput | SubjectScalarWhereInput[];
    id?: StringFilter<"Subject"> | string;
    subjectName?: StringFilter<"Subject"> | string;
    slug?: StringFilter<"Subject"> | string;
    code?: StringFilter<"Subject"> | string;
    levelId?: StringFilter<"Subject"> | string;
  };

  export type classStreamCreateWithoutStreamInput = {
    id?: string;
    pupils?: PupilCreateNestedManyWithoutClassStreamsInput;
    class?: AcademicYearClassCreateNestedOneWithoutStreamsInput;
    classTeacher?: StaffCreateNestedOneWithoutClassStreamsInput;
    terms?: ClassTermCreateNestedManyWithoutClassStreamInput;
  };

  export type classStreamUncheckedCreateWithoutStreamInput = {
    id?: string;
    staffId?: string | null;
    classId?: string | null;
    pupils?: PupilUncheckedCreateNestedManyWithoutClassStreamsInput;
    terms?: ClassTermUncheckedCreateNestedManyWithoutClassStreamInput;
  };

  export type classStreamCreateOrConnectWithoutStreamInput = {
    where: classStreamWhereUniqueInput;
    create: XOR<
      classStreamCreateWithoutStreamInput,
      classStreamUncheckedCreateWithoutStreamInput
    >;
  };

  export type classStreamCreateManyStreamInputEnvelope = {
    data: classStreamCreateManyStreamInput | classStreamCreateManyStreamInput[];
    skipDuplicates?: boolean;
  };

  export type classStreamUpsertWithWhereUniqueWithoutStreamInput = {
    where: classStreamWhereUniqueInput;
    update: XOR<
      classStreamUpdateWithoutStreamInput,
      classStreamUncheckedUpdateWithoutStreamInput
    >;
    create: XOR<
      classStreamCreateWithoutStreamInput,
      classStreamUncheckedCreateWithoutStreamInput
    >;
  };

  export type classStreamUpdateWithWhereUniqueWithoutStreamInput = {
    where: classStreamWhereUniqueInput;
    data: XOR<
      classStreamUpdateWithoutStreamInput,
      classStreamUncheckedUpdateWithoutStreamInput
    >;
  };

  export type classStreamUpdateManyWithWhereWithoutStreamInput = {
    where: classStreamScalarWhereInput;
    data: XOR<
      classStreamUpdateManyMutationInput,
      classStreamUncheckedUpdateManyWithoutStreamInput
    >;
  };

  export type AcademicYearClassCreateWithoutClassInput = {
    id?: string;
    academicYear?: AcademicYearCreateNestedOneWithoutAcademicYearClassesInput;
    academicYearSubjects?: AcademicYearSubjectCreateNestedManyWithoutAcademicYearClassInput;
    streams?: classStreamCreateNestedManyWithoutClassInput;
  };

  export type AcademicYearClassUncheckedCreateWithoutClassInput = {
    id?: string;
    academicYearId?: string | null;
    academicYearSubjects?: AcademicYearSubjectUncheckedCreateNestedManyWithoutAcademicYearClassInput;
    streams?: classStreamUncheckedCreateNestedManyWithoutClassInput;
  };

  export type AcademicYearClassCreateOrConnectWithoutClassInput = {
    where: AcademicYearClassWhereUniqueInput;
    create: XOR<
      AcademicYearClassCreateWithoutClassInput,
      AcademicYearClassUncheckedCreateWithoutClassInput
    >;
  };

  export type AcademicYearClassCreateManyClassInputEnvelope = {
    data:
      | AcademicYearClassCreateManyClassInput
      | AcademicYearClassCreateManyClassInput[];
    skipDuplicates?: boolean;
  };

  export type LevelCreateWithoutClassesInput = {
    id?: string;
    name: string;
    slug: string;
    subjects?: SubjectCreateNestedManyWithoutLevelInput;
  };

  export type LevelUncheckedCreateWithoutClassesInput = {
    id?: string;
    name: string;
    slug: string;
    subjects?: SubjectUncheckedCreateNestedManyWithoutLevelInput;
  };

  export type LevelCreateOrConnectWithoutClassesInput = {
    where: LevelWhereUniqueInput;
    create: XOR<
      LevelCreateWithoutClassesInput,
      LevelUncheckedCreateWithoutClassesInput
    >;
  };

  export type AcademicYearClassUpsertWithWhereUniqueWithoutClassInput = {
    where: AcademicYearClassWhereUniqueInput;
    update: XOR<
      AcademicYearClassUpdateWithoutClassInput,
      AcademicYearClassUncheckedUpdateWithoutClassInput
    >;
    create: XOR<
      AcademicYearClassCreateWithoutClassInput,
      AcademicYearClassUncheckedCreateWithoutClassInput
    >;
  };

  export type AcademicYearClassUpdateWithWhereUniqueWithoutClassInput = {
    where: AcademicYearClassWhereUniqueInput;
    data: XOR<
      AcademicYearClassUpdateWithoutClassInput,
      AcademicYearClassUncheckedUpdateWithoutClassInput
    >;
  };

  export type AcademicYearClassUpdateManyWithWhereWithoutClassInput = {
    where: AcademicYearClassScalarWhereInput;
    data: XOR<
      AcademicYearClassUpdateManyMutationInput,
      AcademicYearClassUncheckedUpdateManyWithoutClassInput
    >;
  };

  export type AcademicYearClassScalarWhereInput = {
    AND?:
      | AcademicYearClassScalarWhereInput
      | AcademicYearClassScalarWhereInput[];
    OR?: AcademicYearClassScalarWhereInput[];
    NOT?:
      | AcademicYearClassScalarWhereInput
      | AcademicYearClassScalarWhereInput[];
    id?: StringFilter<"AcademicYearClass"> | string;
    academicYearId?: StringNullableFilter<"AcademicYearClass"> | string | null;
    classId?: StringNullableFilter<"AcademicYearClass"> | string | null;
  };

  export type LevelUpsertWithoutClassesInput = {
    update: XOR<
      LevelUpdateWithoutClassesInput,
      LevelUncheckedUpdateWithoutClassesInput
    >;
    create: XOR<
      LevelCreateWithoutClassesInput,
      LevelUncheckedCreateWithoutClassesInput
    >;
    where?: LevelWhereInput;
  };

  export type LevelUpdateToOneWithWhereWithoutClassesInput = {
    where?: LevelWhereInput;
    data: XOR<
      LevelUpdateWithoutClassesInput,
      LevelUncheckedUpdateWithoutClassesInput
    >;
  };

  export type LevelUpdateWithoutClassesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    subjects?: SubjectUpdateManyWithoutLevelNestedInput;
  };

  export type LevelUncheckedUpdateWithoutClassesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    subjects?: SubjectUncheckedUpdateManyWithoutLevelNestedInput;
  };

  export type AcademicYearClassCreateWithoutAcademicYearInput = {
    id?: string;
    class?: ClassCreateNestedOneWithoutAcademicYearClassesInput;
    academicYearSubjects?: AcademicYearSubjectCreateNestedManyWithoutAcademicYearClassInput;
    streams?: classStreamCreateNestedManyWithoutClassInput;
  };

  export type AcademicYearClassUncheckedCreateWithoutAcademicYearInput = {
    id?: string;
    classId?: string | null;
    academicYearSubjects?: AcademicYearSubjectUncheckedCreateNestedManyWithoutAcademicYearClassInput;
    streams?: classStreamUncheckedCreateNestedManyWithoutClassInput;
  };

  export type AcademicYearClassCreateOrConnectWithoutAcademicYearInput = {
    where: AcademicYearClassWhereUniqueInput;
    create: XOR<
      AcademicYearClassCreateWithoutAcademicYearInput,
      AcademicYearClassUncheckedCreateWithoutAcademicYearInput
    >;
  };

  export type AcademicYearClassCreateManyAcademicYearInputEnvelope = {
    data:
      | AcademicYearClassCreateManyAcademicYearInput
      | AcademicYearClassCreateManyAcademicYearInput[];
    skipDuplicates?: boolean;
  };

  export type AcademicYearClassUpsertWithWhereUniqueWithoutAcademicYearInput = {
    where: AcademicYearClassWhereUniqueInput;
    update: XOR<
      AcademicYearClassUpdateWithoutAcademicYearInput,
      AcademicYearClassUncheckedUpdateWithoutAcademicYearInput
    >;
    create: XOR<
      AcademicYearClassCreateWithoutAcademicYearInput,
      AcademicYearClassUncheckedCreateWithoutAcademicYearInput
    >;
  };

  export type AcademicYearClassUpdateWithWhereUniqueWithoutAcademicYearInput = {
    where: AcademicYearClassWhereUniqueInput;
    data: XOR<
      AcademicYearClassUpdateWithoutAcademicYearInput,
      AcademicYearClassUncheckedUpdateWithoutAcademicYearInput
    >;
  };

  export type AcademicYearClassUpdateManyWithWhereWithoutAcademicYearInput = {
    where: AcademicYearClassScalarWhereInput;
    data: XOR<
      AcademicYearClassUpdateManyMutationInput,
      AcademicYearClassUncheckedUpdateManyWithoutAcademicYearInput
    >;
  };

  export type AcademicYearCreateWithoutAcademicYearClassesInput = {
    id?: string;
    year: string;
    startAt?: Date | string;
    endAt: Date | string;
  };

  export type AcademicYearUncheckedCreateWithoutAcademicYearClassesInput = {
    id?: string;
    year: string;
    startAt?: Date | string;
    endAt: Date | string;
  };

  export type AcademicYearCreateOrConnectWithoutAcademicYearClassesInput = {
    where: AcademicYearWhereUniqueInput;
    create: XOR<
      AcademicYearCreateWithoutAcademicYearClassesInput,
      AcademicYearUncheckedCreateWithoutAcademicYearClassesInput
    >;
  };

  export type ClassCreateWithoutAcademicYearClassesInput = {
    id?: string;
    name: string;
    createdAt?: Date | string;
    slug: string;
    level?: LevelCreateNestedOneWithoutClassesInput;
  };

  export type ClassUncheckedCreateWithoutAcademicYearClassesInput = {
    id?: string;
    name: string;
    levelId?: string | null;
    createdAt?: Date | string;
    slug: string;
  };

  export type ClassCreateOrConnectWithoutAcademicYearClassesInput = {
    where: ClassWhereUniqueInput;
    create: XOR<
      ClassCreateWithoutAcademicYearClassesInput,
      ClassUncheckedCreateWithoutAcademicYearClassesInput
    >;
  };

  export type AcademicYearSubjectCreateWithoutAcademicYearClassInput = {
    id?: string;
    customGrading?: GradingCreateNestedManyWithoutAcademicYearSubjectsInput;
    teachers?: StaffCreateNestedManyWithoutAcademicYearSubjectsInput;
    subject: SubjectCreateNestedOneWithoutAcademicYearSubjectsInput;
    examSubjects?: ExamSubjectCreateNestedManyWithoutAcademicYearSubjectInput;
  };

  export type AcademicYearSubjectUncheckedCreateWithoutAcademicYearClassInput =
    {
      id?: string;
      subjectId: string;
      customGrading?: GradingUncheckedCreateNestedManyWithoutAcademicYearSubjectsInput;
      teachers?: StaffUncheckedCreateNestedManyWithoutAcademicYearSubjectsInput;
      examSubjects?: ExamSubjectUncheckedCreateNestedManyWithoutAcademicYearSubjectInput;
    };

  export type AcademicYearSubjectCreateOrConnectWithoutAcademicYearClassInput =
    {
      where: AcademicYearSubjectWhereUniqueInput;
      create: XOR<
        AcademicYearSubjectCreateWithoutAcademicYearClassInput,
        AcademicYearSubjectUncheckedCreateWithoutAcademicYearClassInput
      >;
    };

  export type AcademicYearSubjectCreateManyAcademicYearClassInputEnvelope = {
    data:
      | AcademicYearSubjectCreateManyAcademicYearClassInput
      | AcademicYearSubjectCreateManyAcademicYearClassInput[];
    skipDuplicates?: boolean;
  };

  export type classStreamCreateWithoutClassInput = {
    id?: string;
    pupils?: PupilCreateNestedManyWithoutClassStreamsInput;
    classTeacher?: StaffCreateNestedOneWithoutClassStreamsInput;
    stream?: StreamCreateNestedOneWithoutClassStreamsInput;
    terms?: ClassTermCreateNestedManyWithoutClassStreamInput;
  };

  export type classStreamUncheckedCreateWithoutClassInput = {
    id?: string;
    staffId?: string | null;
    streamId?: string | null;
    pupils?: PupilUncheckedCreateNestedManyWithoutClassStreamsInput;
    terms?: ClassTermUncheckedCreateNestedManyWithoutClassStreamInput;
  };

  export type classStreamCreateOrConnectWithoutClassInput = {
    where: classStreamWhereUniqueInput;
    create: XOR<
      classStreamCreateWithoutClassInput,
      classStreamUncheckedCreateWithoutClassInput
    >;
  };

  export type classStreamCreateManyClassInputEnvelope = {
    data: classStreamCreateManyClassInput | classStreamCreateManyClassInput[];
    skipDuplicates?: boolean;
  };

  export type AcademicYearUpsertWithoutAcademicYearClassesInput = {
    update: XOR<
      AcademicYearUpdateWithoutAcademicYearClassesInput,
      AcademicYearUncheckedUpdateWithoutAcademicYearClassesInput
    >;
    create: XOR<
      AcademicYearCreateWithoutAcademicYearClassesInput,
      AcademicYearUncheckedCreateWithoutAcademicYearClassesInput
    >;
    where?: AcademicYearWhereInput;
  };

  export type AcademicYearUpdateToOneWithWhereWithoutAcademicYearClassesInput =
    {
      where?: AcademicYearWhereInput;
      data: XOR<
        AcademicYearUpdateWithoutAcademicYearClassesInput,
        AcademicYearUncheckedUpdateWithoutAcademicYearClassesInput
      >;
    };

  export type AcademicYearUpdateWithoutAcademicYearClassesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    year?: StringFieldUpdateOperationsInput | string;
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AcademicYearUncheckedUpdateWithoutAcademicYearClassesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    year?: StringFieldUpdateOperationsInput | string;
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ClassUpsertWithoutAcademicYearClassesInput = {
    update: XOR<
      ClassUpdateWithoutAcademicYearClassesInput,
      ClassUncheckedUpdateWithoutAcademicYearClassesInput
    >;
    create: XOR<
      ClassCreateWithoutAcademicYearClassesInput,
      ClassUncheckedCreateWithoutAcademicYearClassesInput
    >;
    where?: ClassWhereInput;
  };

  export type ClassUpdateToOneWithWhereWithoutAcademicYearClassesInput = {
    where?: ClassWhereInput;
    data: XOR<
      ClassUpdateWithoutAcademicYearClassesInput,
      ClassUncheckedUpdateWithoutAcademicYearClassesInput
    >;
  };

  export type ClassUpdateWithoutAcademicYearClassesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    slug?: StringFieldUpdateOperationsInput | string;
    level?: LevelUpdateOneWithoutClassesNestedInput;
  };

  export type ClassUncheckedUpdateWithoutAcademicYearClassesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    levelId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    slug?: StringFieldUpdateOperationsInput | string;
  };

  export type AcademicYearSubjectUpsertWithWhereUniqueWithoutAcademicYearClassInput =
    {
      where: AcademicYearSubjectWhereUniqueInput;
      update: XOR<
        AcademicYearSubjectUpdateWithoutAcademicYearClassInput,
        AcademicYearSubjectUncheckedUpdateWithoutAcademicYearClassInput
      >;
      create: XOR<
        AcademicYearSubjectCreateWithoutAcademicYearClassInput,
        AcademicYearSubjectUncheckedCreateWithoutAcademicYearClassInput
      >;
    };

  export type AcademicYearSubjectUpdateWithWhereUniqueWithoutAcademicYearClassInput =
    {
      where: AcademicYearSubjectWhereUniqueInput;
      data: XOR<
        AcademicYearSubjectUpdateWithoutAcademicYearClassInput,
        AcademicYearSubjectUncheckedUpdateWithoutAcademicYearClassInput
      >;
    };

  export type AcademicYearSubjectUpdateManyWithWhereWithoutAcademicYearClassInput =
    {
      where: AcademicYearSubjectScalarWhereInput;
      data: XOR<
        AcademicYearSubjectUpdateManyMutationInput,
        AcademicYearSubjectUncheckedUpdateManyWithoutAcademicYearClassInput
      >;
    };

  export type classStreamUpsertWithWhereUniqueWithoutClassInput = {
    where: classStreamWhereUniqueInput;
    update: XOR<
      classStreamUpdateWithoutClassInput,
      classStreamUncheckedUpdateWithoutClassInput
    >;
    create: XOR<
      classStreamCreateWithoutClassInput,
      classStreamUncheckedCreateWithoutClassInput
    >;
  };

  export type classStreamUpdateWithWhereUniqueWithoutClassInput = {
    where: classStreamWhereUniqueInput;
    data: XOR<
      classStreamUpdateWithoutClassInput,
      classStreamUncheckedUpdateWithoutClassInput
    >;
  };

  export type classStreamUpdateManyWithWhereWithoutClassInput = {
    where: classStreamScalarWhereInput;
    data: XOR<
      classStreamUpdateManyMutationInput,
      classStreamUncheckedUpdateManyWithoutClassInput
    >;
  };

  export type GradingCreateWithoutSubjectsInput = {
    id?: string;
    from: number;
    to: number;
    grade: string;
    remarks?: string | null;
    academicYearSubjects?: AcademicYearSubjectCreateNestedManyWithoutCustomGradingInput;
  };

  export type GradingUncheckedCreateWithoutSubjectsInput = {
    id?: string;
    from: number;
    to: number;
    grade: string;
    remarks?: string | null;
    academicYearSubjects?: AcademicYearSubjectUncheckedCreateNestedManyWithoutCustomGradingInput;
  };

  export type GradingCreateOrConnectWithoutSubjectsInput = {
    where: GradingWhereUniqueInput;
    create: XOR<
      GradingCreateWithoutSubjectsInput,
      GradingUncheckedCreateWithoutSubjectsInput
    >;
  };

  export type AcademicYearSubjectCreateWithoutSubjectInput = {
    id?: string;
    customGrading?: GradingCreateNestedManyWithoutAcademicYearSubjectsInput;
    academicYearClass: AcademicYearClassCreateNestedOneWithoutAcademicYearSubjectsInput;
    teachers?: StaffCreateNestedManyWithoutAcademicYearSubjectsInput;
    examSubjects?: ExamSubjectCreateNestedManyWithoutAcademicYearSubjectInput;
  };

  export type AcademicYearSubjectUncheckedCreateWithoutSubjectInput = {
    id?: string;
    academicYearClassId: string;
    customGrading?: GradingUncheckedCreateNestedManyWithoutAcademicYearSubjectsInput;
    teachers?: StaffUncheckedCreateNestedManyWithoutAcademicYearSubjectsInput;
    examSubjects?: ExamSubjectUncheckedCreateNestedManyWithoutAcademicYearSubjectInput;
  };

  export type AcademicYearSubjectCreateOrConnectWithoutSubjectInput = {
    where: AcademicYearSubjectWhereUniqueInput;
    create: XOR<
      AcademicYearSubjectCreateWithoutSubjectInput,
      AcademicYearSubjectUncheckedCreateWithoutSubjectInput
    >;
  };

  export type AcademicYearSubjectCreateManySubjectInputEnvelope = {
    data:
      | AcademicYearSubjectCreateManySubjectInput
      | AcademicYearSubjectCreateManySubjectInput[];
    skipDuplicates?: boolean;
  };

  export type LevelCreateWithoutSubjectsInput = {
    id?: string;
    name: string;
    slug: string;
    classes?: ClassCreateNestedManyWithoutLevelInput;
  };

  export type LevelUncheckedCreateWithoutSubjectsInput = {
    id?: string;
    name: string;
    slug: string;
    classes?: ClassUncheckedCreateNestedManyWithoutLevelInput;
  };

  export type LevelCreateOrConnectWithoutSubjectsInput = {
    where: LevelWhereUniqueInput;
    create: XOR<
      LevelCreateWithoutSubjectsInput,
      LevelUncheckedCreateWithoutSubjectsInput
    >;
  };

  export type GradingUpsertWithWhereUniqueWithoutSubjectsInput = {
    where: GradingWhereUniqueInput;
    update: XOR<
      GradingUpdateWithoutSubjectsInput,
      GradingUncheckedUpdateWithoutSubjectsInput
    >;
    create: XOR<
      GradingCreateWithoutSubjectsInput,
      GradingUncheckedCreateWithoutSubjectsInput
    >;
  };

  export type GradingUpdateWithWhereUniqueWithoutSubjectsInput = {
    where: GradingWhereUniqueInput;
    data: XOR<
      GradingUpdateWithoutSubjectsInput,
      GradingUncheckedUpdateWithoutSubjectsInput
    >;
  };

  export type GradingUpdateManyWithWhereWithoutSubjectsInput = {
    where: GradingScalarWhereInput;
    data: XOR<
      GradingUpdateManyMutationInput,
      GradingUncheckedUpdateManyWithoutSubjectsInput
    >;
  };

  export type GradingScalarWhereInput = {
    AND?: GradingScalarWhereInput | GradingScalarWhereInput[];
    OR?: GradingScalarWhereInput[];
    NOT?: GradingScalarWhereInput | GradingScalarWhereInput[];
    id?: StringFilter<"Grading"> | string;
    from?: FloatFilter<"Grading"> | number;
    to?: FloatFilter<"Grading"> | number;
    grade?: StringFilter<"Grading"> | string;
    remarks?: StringNullableFilter<"Grading"> | string | null;
  };

  export type AcademicYearSubjectUpsertWithWhereUniqueWithoutSubjectInput = {
    where: AcademicYearSubjectWhereUniqueInput;
    update: XOR<
      AcademicYearSubjectUpdateWithoutSubjectInput,
      AcademicYearSubjectUncheckedUpdateWithoutSubjectInput
    >;
    create: XOR<
      AcademicYearSubjectCreateWithoutSubjectInput,
      AcademicYearSubjectUncheckedCreateWithoutSubjectInput
    >;
  };

  export type AcademicYearSubjectUpdateWithWhereUniqueWithoutSubjectInput = {
    where: AcademicYearSubjectWhereUniqueInput;
    data: XOR<
      AcademicYearSubjectUpdateWithoutSubjectInput,
      AcademicYearSubjectUncheckedUpdateWithoutSubjectInput
    >;
  };

  export type AcademicYearSubjectUpdateManyWithWhereWithoutSubjectInput = {
    where: AcademicYearSubjectScalarWhereInput;
    data: XOR<
      AcademicYearSubjectUpdateManyMutationInput,
      AcademicYearSubjectUncheckedUpdateManyWithoutSubjectInput
    >;
  };

  export type LevelUpsertWithoutSubjectsInput = {
    update: XOR<
      LevelUpdateWithoutSubjectsInput,
      LevelUncheckedUpdateWithoutSubjectsInput
    >;
    create: XOR<
      LevelCreateWithoutSubjectsInput,
      LevelUncheckedCreateWithoutSubjectsInput
    >;
    where?: LevelWhereInput;
  };

  export type LevelUpdateToOneWithWhereWithoutSubjectsInput = {
    where?: LevelWhereInput;
    data: XOR<
      LevelUpdateWithoutSubjectsInput,
      LevelUncheckedUpdateWithoutSubjectsInput
    >;
  };

  export type LevelUpdateWithoutSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    classes?: ClassUpdateManyWithoutLevelNestedInput;
  };

  export type LevelUncheckedUpdateWithoutSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    classes?: ClassUncheckedUpdateManyWithoutLevelNestedInput;
  };

  export type SubjectCreateWithoutGradingInput = {
    id?: string;
    subjectName: string;
    slug: string;
    code: string;
    academicYearSubjects?: AcademicYearSubjectCreateNestedManyWithoutSubjectInput;
    level: LevelCreateNestedOneWithoutSubjectsInput;
  };

  export type SubjectUncheckedCreateWithoutGradingInput = {
    id?: string;
    subjectName: string;
    slug: string;
    code: string;
    levelId: string;
    academicYearSubjects?: AcademicYearSubjectUncheckedCreateNestedManyWithoutSubjectInput;
  };

  export type SubjectCreateOrConnectWithoutGradingInput = {
    where: SubjectWhereUniqueInput;
    create: XOR<
      SubjectCreateWithoutGradingInput,
      SubjectUncheckedCreateWithoutGradingInput
    >;
  };

  export type AcademicYearSubjectCreateWithoutCustomGradingInput = {
    id?: string;
    academicYearClass: AcademicYearClassCreateNestedOneWithoutAcademicYearSubjectsInput;
    teachers?: StaffCreateNestedManyWithoutAcademicYearSubjectsInput;
    subject: SubjectCreateNestedOneWithoutAcademicYearSubjectsInput;
    examSubjects?: ExamSubjectCreateNestedManyWithoutAcademicYearSubjectInput;
  };

  export type AcademicYearSubjectUncheckedCreateWithoutCustomGradingInput = {
    id?: string;
    academicYearClassId: string;
    subjectId: string;
    teachers?: StaffUncheckedCreateNestedManyWithoutAcademicYearSubjectsInput;
    examSubjects?: ExamSubjectUncheckedCreateNestedManyWithoutAcademicYearSubjectInput;
  };

  export type AcademicYearSubjectCreateOrConnectWithoutCustomGradingInput = {
    where: AcademicYearSubjectWhereUniqueInput;
    create: XOR<
      AcademicYearSubjectCreateWithoutCustomGradingInput,
      AcademicYearSubjectUncheckedCreateWithoutCustomGradingInput
    >;
  };

  export type SubjectUpsertWithWhereUniqueWithoutGradingInput = {
    where: SubjectWhereUniqueInput;
    update: XOR<
      SubjectUpdateWithoutGradingInput,
      SubjectUncheckedUpdateWithoutGradingInput
    >;
    create: XOR<
      SubjectCreateWithoutGradingInput,
      SubjectUncheckedCreateWithoutGradingInput
    >;
  };

  export type SubjectUpdateWithWhereUniqueWithoutGradingInput = {
    where: SubjectWhereUniqueInput;
    data: XOR<
      SubjectUpdateWithoutGradingInput,
      SubjectUncheckedUpdateWithoutGradingInput
    >;
  };

  export type SubjectUpdateManyWithWhereWithoutGradingInput = {
    where: SubjectScalarWhereInput;
    data: XOR<
      SubjectUpdateManyMutationInput,
      SubjectUncheckedUpdateManyWithoutGradingInput
    >;
  };

  export type AcademicYearSubjectUpsertWithWhereUniqueWithoutCustomGradingInput =
    {
      where: AcademicYearSubjectWhereUniqueInput;
      update: XOR<
        AcademicYearSubjectUpdateWithoutCustomGradingInput,
        AcademicYearSubjectUncheckedUpdateWithoutCustomGradingInput
      >;
      create: XOR<
        AcademicYearSubjectCreateWithoutCustomGradingInput,
        AcademicYearSubjectUncheckedCreateWithoutCustomGradingInput
      >;
    };

  export type AcademicYearSubjectUpdateWithWhereUniqueWithoutCustomGradingInput =
    {
      where: AcademicYearSubjectWhereUniqueInput;
      data: XOR<
        AcademicYearSubjectUpdateWithoutCustomGradingInput,
        AcademicYearSubjectUncheckedUpdateWithoutCustomGradingInput
      >;
    };

  export type AcademicYearSubjectUpdateManyWithWhereWithoutCustomGradingInput =
    {
      where: AcademicYearSubjectScalarWhereInput;
      data: XOR<
        AcademicYearSubjectUpdateManyMutationInput,
        AcademicYearSubjectUncheckedUpdateManyWithoutCustomGradingInput
      >;
    };

  export type GradingCreateWithoutAcademicYearSubjectsInput = {
    id?: string;
    from: number;
    to: number;
    grade: string;
    remarks?: string | null;
    subjects?: SubjectCreateNestedManyWithoutGradingInput;
  };

  export type GradingUncheckedCreateWithoutAcademicYearSubjectsInput = {
    id?: string;
    from: number;
    to: number;
    grade: string;
    remarks?: string | null;
    subjects?: SubjectUncheckedCreateNestedManyWithoutGradingInput;
  };

  export type GradingCreateOrConnectWithoutAcademicYearSubjectsInput = {
    where: GradingWhereUniqueInput;
    create: XOR<
      GradingCreateWithoutAcademicYearSubjectsInput,
      GradingUncheckedCreateWithoutAcademicYearSubjectsInput
    >;
  };

  export type AcademicYearClassCreateWithoutAcademicYearSubjectsInput = {
    id?: string;
    academicYear?: AcademicYearCreateNestedOneWithoutAcademicYearClassesInput;
    class?: ClassCreateNestedOneWithoutAcademicYearClassesInput;
    streams?: classStreamCreateNestedManyWithoutClassInput;
  };

  export type AcademicYearClassUncheckedCreateWithoutAcademicYearSubjectsInput =
    {
      id?: string;
      academicYearId?: string | null;
      classId?: string | null;
      streams?: classStreamUncheckedCreateNestedManyWithoutClassInput;
    };

  export type AcademicYearClassCreateOrConnectWithoutAcademicYearSubjectsInput =
    {
      where: AcademicYearClassWhereUniqueInput;
      create: XOR<
        AcademicYearClassCreateWithoutAcademicYearSubjectsInput,
        AcademicYearClassUncheckedCreateWithoutAcademicYearSubjectsInput
      >;
    };

  export type StaffCreateWithoutAcademicYearSubjectsInput = {
    id?: string;
    staffType?: $Enums.StaffType;
    genericPassword: string;
    classStreams?: classStreamCreateNestedManyWithoutClassTeacherInput;
    user?: UserCreateNestedOneWithoutStaffsInput;
  };

  export type StaffUncheckedCreateWithoutAcademicYearSubjectsInput = {
    id?: string;
    staffType?: $Enums.StaffType;
    userId?: string | null;
    genericPassword: string;
    classStreams?: classStreamUncheckedCreateNestedManyWithoutClassTeacherInput;
  };

  export type StaffCreateOrConnectWithoutAcademicYearSubjectsInput = {
    where: StaffWhereUniqueInput;
    create: XOR<
      StaffCreateWithoutAcademicYearSubjectsInput,
      StaffUncheckedCreateWithoutAcademicYearSubjectsInput
    >;
  };

  export type SubjectCreateWithoutAcademicYearSubjectsInput = {
    id?: string;
    subjectName: string;
    slug: string;
    code: string;
    grading?: GradingCreateNestedManyWithoutSubjectsInput;
    level: LevelCreateNestedOneWithoutSubjectsInput;
  };

  export type SubjectUncheckedCreateWithoutAcademicYearSubjectsInput = {
    id?: string;
    subjectName: string;
    slug: string;
    code: string;
    levelId: string;
    grading?: GradingUncheckedCreateNestedManyWithoutSubjectsInput;
  };

  export type SubjectCreateOrConnectWithoutAcademicYearSubjectsInput = {
    where: SubjectWhereUniqueInput;
    create: XOR<
      SubjectCreateWithoutAcademicYearSubjectsInput,
      SubjectUncheckedCreateWithoutAcademicYearSubjectsInput
    >;
  };

  export type ExamSubjectCreateWithoutAcademicYearSubjectInput = {
    id?: string;
    examDate: Date | string;
    exam: ExamCreateNestedOneWithoutExamSubjectsInput;
    examScores?: ExamScoreCreateNestedManyWithoutExamSubjectInput;
  };

  export type ExamSubjectUncheckedCreateWithoutAcademicYearSubjectInput = {
    id?: string;
    examId: string;
    examDate: Date | string;
    examScores?: ExamScoreUncheckedCreateNestedManyWithoutExamSubjectInput;
  };

  export type ExamSubjectCreateOrConnectWithoutAcademicYearSubjectInput = {
    where: ExamSubjectWhereUniqueInput;
    create: XOR<
      ExamSubjectCreateWithoutAcademicYearSubjectInput,
      ExamSubjectUncheckedCreateWithoutAcademicYearSubjectInput
    >;
  };

  export type ExamSubjectCreateManyAcademicYearSubjectInputEnvelope = {
    data:
      | ExamSubjectCreateManyAcademicYearSubjectInput
      | ExamSubjectCreateManyAcademicYearSubjectInput[];
    skipDuplicates?: boolean;
  };

  export type GradingUpsertWithWhereUniqueWithoutAcademicYearSubjectsInput = {
    where: GradingWhereUniqueInput;
    update: XOR<
      GradingUpdateWithoutAcademicYearSubjectsInput,
      GradingUncheckedUpdateWithoutAcademicYearSubjectsInput
    >;
    create: XOR<
      GradingCreateWithoutAcademicYearSubjectsInput,
      GradingUncheckedCreateWithoutAcademicYearSubjectsInput
    >;
  };

  export type GradingUpdateWithWhereUniqueWithoutAcademicYearSubjectsInput = {
    where: GradingWhereUniqueInput;
    data: XOR<
      GradingUpdateWithoutAcademicYearSubjectsInput,
      GradingUncheckedUpdateWithoutAcademicYearSubjectsInput
    >;
  };

  export type GradingUpdateManyWithWhereWithoutAcademicYearSubjectsInput = {
    where: GradingScalarWhereInput;
    data: XOR<
      GradingUpdateManyMutationInput,
      GradingUncheckedUpdateManyWithoutAcademicYearSubjectsInput
    >;
  };

  export type AcademicYearClassUpsertWithoutAcademicYearSubjectsInput = {
    update: XOR<
      AcademicYearClassUpdateWithoutAcademicYearSubjectsInput,
      AcademicYearClassUncheckedUpdateWithoutAcademicYearSubjectsInput
    >;
    create: XOR<
      AcademicYearClassCreateWithoutAcademicYearSubjectsInput,
      AcademicYearClassUncheckedCreateWithoutAcademicYearSubjectsInput
    >;
    where?: AcademicYearClassWhereInput;
  };

  export type AcademicYearClassUpdateToOneWithWhereWithoutAcademicYearSubjectsInput =
    {
      where?: AcademicYearClassWhereInput;
      data: XOR<
        AcademicYearClassUpdateWithoutAcademicYearSubjectsInput,
        AcademicYearClassUncheckedUpdateWithoutAcademicYearSubjectsInput
      >;
    };

  export type AcademicYearClassUpdateWithoutAcademicYearSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    academicYear?: AcademicYearUpdateOneWithoutAcademicYearClassesNestedInput;
    class?: ClassUpdateOneWithoutAcademicYearClassesNestedInput;
    streams?: classStreamUpdateManyWithoutClassNestedInput;
  };

  export type AcademicYearClassUncheckedUpdateWithoutAcademicYearSubjectsInput =
    {
      id?: StringFieldUpdateOperationsInput | string;
      academicYearId?: NullableStringFieldUpdateOperationsInput | string | null;
      classId?: NullableStringFieldUpdateOperationsInput | string | null;
      streams?: classStreamUncheckedUpdateManyWithoutClassNestedInput;
    };

  export type StaffUpsertWithWhereUniqueWithoutAcademicYearSubjectsInput = {
    where: StaffWhereUniqueInput;
    update: XOR<
      StaffUpdateWithoutAcademicYearSubjectsInput,
      StaffUncheckedUpdateWithoutAcademicYearSubjectsInput
    >;
    create: XOR<
      StaffCreateWithoutAcademicYearSubjectsInput,
      StaffUncheckedCreateWithoutAcademicYearSubjectsInput
    >;
  };

  export type StaffUpdateWithWhereUniqueWithoutAcademicYearSubjectsInput = {
    where: StaffWhereUniqueInput;
    data: XOR<
      StaffUpdateWithoutAcademicYearSubjectsInput,
      StaffUncheckedUpdateWithoutAcademicYearSubjectsInput
    >;
  };

  export type StaffUpdateManyWithWhereWithoutAcademicYearSubjectsInput = {
    where: StaffScalarWhereInput;
    data: XOR<
      StaffUpdateManyMutationInput,
      StaffUncheckedUpdateManyWithoutAcademicYearSubjectsInput
    >;
  };

  export type SubjectUpsertWithoutAcademicYearSubjectsInput = {
    update: XOR<
      SubjectUpdateWithoutAcademicYearSubjectsInput,
      SubjectUncheckedUpdateWithoutAcademicYearSubjectsInput
    >;
    create: XOR<
      SubjectCreateWithoutAcademicYearSubjectsInput,
      SubjectUncheckedCreateWithoutAcademicYearSubjectsInput
    >;
    where?: SubjectWhereInput;
  };

  export type SubjectUpdateToOneWithWhereWithoutAcademicYearSubjectsInput = {
    where?: SubjectWhereInput;
    data: XOR<
      SubjectUpdateWithoutAcademicYearSubjectsInput,
      SubjectUncheckedUpdateWithoutAcademicYearSubjectsInput
    >;
  };

  export type SubjectUpdateWithoutAcademicYearSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    subjectName?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    code?: StringFieldUpdateOperationsInput | string;
    grading?: GradingUpdateManyWithoutSubjectsNestedInput;
    level?: LevelUpdateOneRequiredWithoutSubjectsNestedInput;
  };

  export type SubjectUncheckedUpdateWithoutAcademicYearSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    subjectName?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    code?: StringFieldUpdateOperationsInput | string;
    levelId?: StringFieldUpdateOperationsInput | string;
    grading?: GradingUncheckedUpdateManyWithoutSubjectsNestedInput;
  };

  export type ExamSubjectUpsertWithWhereUniqueWithoutAcademicYearSubjectInput =
    {
      where: ExamSubjectWhereUniqueInput;
      update: XOR<
        ExamSubjectUpdateWithoutAcademicYearSubjectInput,
        ExamSubjectUncheckedUpdateWithoutAcademicYearSubjectInput
      >;
      create: XOR<
        ExamSubjectCreateWithoutAcademicYearSubjectInput,
        ExamSubjectUncheckedCreateWithoutAcademicYearSubjectInput
      >;
    };

  export type ExamSubjectUpdateWithWhereUniqueWithoutAcademicYearSubjectInput =
    {
      where: ExamSubjectWhereUniqueInput;
      data: XOR<
        ExamSubjectUpdateWithoutAcademicYearSubjectInput,
        ExamSubjectUncheckedUpdateWithoutAcademicYearSubjectInput
      >;
    };

  export type ExamSubjectUpdateManyWithWhereWithoutAcademicYearSubjectInput = {
    where: ExamSubjectScalarWhereInput;
    data: XOR<
      ExamSubjectUpdateManyMutationInput,
      ExamSubjectUncheckedUpdateManyWithoutAcademicYearSubjectInput
    >;
  };

  export type ExamSubjectScalarWhereInput = {
    AND?: ExamSubjectScalarWhereInput | ExamSubjectScalarWhereInput[];
    OR?: ExamSubjectScalarWhereInput[];
    NOT?: ExamSubjectScalarWhereInput | ExamSubjectScalarWhereInput[];
    id?: StringFilter<"ExamSubject"> | string;
    examId?: StringFilter<"ExamSubject"> | string;
    examDate?: DateTimeFilter<"ExamSubject"> | Date | string;
    academicYearSubjectId?: StringFilter<"ExamSubject"> | string;
  };

  export type PupilCreateWithoutClassStreamsInput = {
    id?: string;
    genericPassword: string;
    examScores?: ExamScoreCreateNestedManyWithoutPupilInput;
    fees?: FeesCreateNestedManyWithoutPupilInput;
    user?: UserCreateNestedOneWithoutPupilsInput;
  };

  export type PupilUncheckedCreateWithoutClassStreamsInput = {
    id?: string;
    userId?: string | null;
    genericPassword: string;
    examScores?: ExamScoreUncheckedCreateNestedManyWithoutPupilInput;
    fees?: FeesUncheckedCreateNestedManyWithoutPupilInput;
  };

  export type PupilCreateOrConnectWithoutClassStreamsInput = {
    where: PupilWhereUniqueInput;
    create: XOR<
      PupilCreateWithoutClassStreamsInput,
      PupilUncheckedCreateWithoutClassStreamsInput
    >;
  };

  export type AcademicYearClassCreateWithoutStreamsInput = {
    id?: string;
    academicYear?: AcademicYearCreateNestedOneWithoutAcademicYearClassesInput;
    class?: ClassCreateNestedOneWithoutAcademicYearClassesInput;
    academicYearSubjects?: AcademicYearSubjectCreateNestedManyWithoutAcademicYearClassInput;
  };

  export type AcademicYearClassUncheckedCreateWithoutStreamsInput = {
    id?: string;
    academicYearId?: string | null;
    classId?: string | null;
    academicYearSubjects?: AcademicYearSubjectUncheckedCreateNestedManyWithoutAcademicYearClassInput;
  };

  export type AcademicYearClassCreateOrConnectWithoutStreamsInput = {
    where: AcademicYearClassWhereUniqueInput;
    create: XOR<
      AcademicYearClassCreateWithoutStreamsInput,
      AcademicYearClassUncheckedCreateWithoutStreamsInput
    >;
  };

  export type StaffCreateWithoutClassStreamsInput = {
    id?: string;
    staffType?: $Enums.StaffType;
    genericPassword: string;
    academicYearSubjects?: AcademicYearSubjectCreateNestedManyWithoutTeachersInput;
    user?: UserCreateNestedOneWithoutStaffsInput;
  };

  export type StaffUncheckedCreateWithoutClassStreamsInput = {
    id?: string;
    staffType?: $Enums.StaffType;
    userId?: string | null;
    genericPassword: string;
    academicYearSubjects?: AcademicYearSubjectUncheckedCreateNestedManyWithoutTeachersInput;
  };

  export type StaffCreateOrConnectWithoutClassStreamsInput = {
    where: StaffWhereUniqueInput;
    create: XOR<
      StaffCreateWithoutClassStreamsInput,
      StaffUncheckedCreateWithoutClassStreamsInput
    >;
  };

  export type StreamCreateWithoutClassStreamsInput = {
    id?: string;
    name: string;
  };

  export type StreamUncheckedCreateWithoutClassStreamsInput = {
    id?: string;
    name: string;
  };

  export type StreamCreateOrConnectWithoutClassStreamsInput = {
    where: StreamWhereUniqueInput;
    create: XOR<
      StreamCreateWithoutClassStreamsInput,
      StreamUncheckedCreateWithoutClassStreamsInput
    >;
  };

  export type ClassTermCreateWithoutClassStreamInput = {
    id?: string;
    startAt?: Date | string;
    endAt: Date | string;
    feesAmount?: number | null;
    term?: TermCreateNestedOneWithoutClassTermsInput;
    exams?: ExamCreateNestedManyWithoutClassTermInput;
    fees?: FeesCreateNestedManyWithoutTermInput;
  };

  export type ClassTermUncheckedCreateWithoutClassStreamInput = {
    id?: string;
    startAt?: Date | string;
    endAt: Date | string;
    termId?: string | null;
    feesAmount?: number | null;
    exams?: ExamUncheckedCreateNestedManyWithoutClassTermInput;
    fees?: FeesUncheckedCreateNestedManyWithoutTermInput;
  };

  export type ClassTermCreateOrConnectWithoutClassStreamInput = {
    where: ClassTermWhereUniqueInput;
    create: XOR<
      ClassTermCreateWithoutClassStreamInput,
      ClassTermUncheckedCreateWithoutClassStreamInput
    >;
  };

  export type ClassTermCreateManyClassStreamInputEnvelope = {
    data:
      | ClassTermCreateManyClassStreamInput
      | ClassTermCreateManyClassStreamInput[];
    skipDuplicates?: boolean;
  };

  export type PupilUpsertWithWhereUniqueWithoutClassStreamsInput = {
    where: PupilWhereUniqueInput;
    update: XOR<
      PupilUpdateWithoutClassStreamsInput,
      PupilUncheckedUpdateWithoutClassStreamsInput
    >;
    create: XOR<
      PupilCreateWithoutClassStreamsInput,
      PupilUncheckedCreateWithoutClassStreamsInput
    >;
  };

  export type PupilUpdateWithWhereUniqueWithoutClassStreamsInput = {
    where: PupilWhereUniqueInput;
    data: XOR<
      PupilUpdateWithoutClassStreamsInput,
      PupilUncheckedUpdateWithoutClassStreamsInput
    >;
  };

  export type PupilUpdateManyWithWhereWithoutClassStreamsInput = {
    where: PupilScalarWhereInput;
    data: XOR<
      PupilUpdateManyMutationInput,
      PupilUncheckedUpdateManyWithoutClassStreamsInput
    >;
  };

  export type AcademicYearClassUpsertWithoutStreamsInput = {
    update: XOR<
      AcademicYearClassUpdateWithoutStreamsInput,
      AcademicYearClassUncheckedUpdateWithoutStreamsInput
    >;
    create: XOR<
      AcademicYearClassCreateWithoutStreamsInput,
      AcademicYearClassUncheckedCreateWithoutStreamsInput
    >;
    where?: AcademicYearClassWhereInput;
  };

  export type AcademicYearClassUpdateToOneWithWhereWithoutStreamsInput = {
    where?: AcademicYearClassWhereInput;
    data: XOR<
      AcademicYearClassUpdateWithoutStreamsInput,
      AcademicYearClassUncheckedUpdateWithoutStreamsInput
    >;
  };

  export type AcademicYearClassUpdateWithoutStreamsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    academicYear?: AcademicYearUpdateOneWithoutAcademicYearClassesNestedInput;
    class?: ClassUpdateOneWithoutAcademicYearClassesNestedInput;
    academicYearSubjects?: AcademicYearSubjectUpdateManyWithoutAcademicYearClassNestedInput;
  };

  export type AcademicYearClassUncheckedUpdateWithoutStreamsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    academicYearId?: NullableStringFieldUpdateOperationsInput | string | null;
    classId?: NullableStringFieldUpdateOperationsInput | string | null;
    academicYearSubjects?: AcademicYearSubjectUncheckedUpdateManyWithoutAcademicYearClassNestedInput;
  };

  export type StaffUpsertWithoutClassStreamsInput = {
    update: XOR<
      StaffUpdateWithoutClassStreamsInput,
      StaffUncheckedUpdateWithoutClassStreamsInput
    >;
    create: XOR<
      StaffCreateWithoutClassStreamsInput,
      StaffUncheckedCreateWithoutClassStreamsInput
    >;
    where?: StaffWhereInput;
  };

  export type StaffUpdateToOneWithWhereWithoutClassStreamsInput = {
    where?: StaffWhereInput;
    data: XOR<
      StaffUpdateWithoutClassStreamsInput,
      StaffUncheckedUpdateWithoutClassStreamsInput
    >;
  };

  export type StaffUpdateWithoutClassStreamsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    staffType?: EnumStaffTypeFieldUpdateOperationsInput | $Enums.StaffType;
    genericPassword?: StringFieldUpdateOperationsInput | string;
    academicYearSubjects?: AcademicYearSubjectUpdateManyWithoutTeachersNestedInput;
    user?: UserUpdateOneWithoutStaffsNestedInput;
  };

  export type StaffUncheckedUpdateWithoutClassStreamsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    staffType?: EnumStaffTypeFieldUpdateOperationsInput | $Enums.StaffType;
    userId?: NullableStringFieldUpdateOperationsInput | string | null;
    genericPassword?: StringFieldUpdateOperationsInput | string;
    academicYearSubjects?: AcademicYearSubjectUncheckedUpdateManyWithoutTeachersNestedInput;
  };

  export type StreamUpsertWithoutClassStreamsInput = {
    update: XOR<
      StreamUpdateWithoutClassStreamsInput,
      StreamUncheckedUpdateWithoutClassStreamsInput
    >;
    create: XOR<
      StreamCreateWithoutClassStreamsInput,
      StreamUncheckedCreateWithoutClassStreamsInput
    >;
    where?: StreamWhereInput;
  };

  export type StreamUpdateToOneWithWhereWithoutClassStreamsInput = {
    where?: StreamWhereInput;
    data: XOR<
      StreamUpdateWithoutClassStreamsInput,
      StreamUncheckedUpdateWithoutClassStreamsInput
    >;
  };

  export type StreamUpdateWithoutClassStreamsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
  };

  export type StreamUncheckedUpdateWithoutClassStreamsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
  };

  export type ClassTermUpsertWithWhereUniqueWithoutClassStreamInput = {
    where: ClassTermWhereUniqueInput;
    update: XOR<
      ClassTermUpdateWithoutClassStreamInput,
      ClassTermUncheckedUpdateWithoutClassStreamInput
    >;
    create: XOR<
      ClassTermCreateWithoutClassStreamInput,
      ClassTermUncheckedCreateWithoutClassStreamInput
    >;
  };

  export type ClassTermUpdateWithWhereUniqueWithoutClassStreamInput = {
    where: ClassTermWhereUniqueInput;
    data: XOR<
      ClassTermUpdateWithoutClassStreamInput,
      ClassTermUncheckedUpdateWithoutClassStreamInput
    >;
  };

  export type ClassTermUpdateManyWithWhereWithoutClassStreamInput = {
    where: ClassTermScalarWhereInput;
    data: XOR<
      ClassTermUpdateManyMutationInput,
      ClassTermUncheckedUpdateManyWithoutClassStreamInput
    >;
  };

  export type ClassTermScalarWhereInput = {
    AND?: ClassTermScalarWhereInput | ClassTermScalarWhereInput[];
    OR?: ClassTermScalarWhereInput[];
    NOT?: ClassTermScalarWhereInput | ClassTermScalarWhereInput[];
    id?: StringFilter<"ClassTerm"> | string;
    startAt?: DateTimeFilter<"ClassTerm"> | Date | string;
    endAt?: DateTimeFilter<"ClassTerm"> | Date | string;
    termId?: StringNullableFilter<"ClassTerm"> | string | null;
    classStreamId?: StringNullableFilter<"ClassTerm"> | string | null;
    feesAmount?: IntNullableFilter<"ClassTerm"> | number | null;
  };

  export type ClassTermCreateWithoutTermInput = {
    id?: string;
    startAt?: Date | string;
    endAt: Date | string;
    feesAmount?: number | null;
    classStream?: classStreamCreateNestedOneWithoutTermsInput;
    exams?: ExamCreateNestedManyWithoutClassTermInput;
    fees?: FeesCreateNestedManyWithoutTermInput;
  };

  export type ClassTermUncheckedCreateWithoutTermInput = {
    id?: string;
    startAt?: Date | string;
    endAt: Date | string;
    classStreamId?: string | null;
    feesAmount?: number | null;
    exams?: ExamUncheckedCreateNestedManyWithoutClassTermInput;
    fees?: FeesUncheckedCreateNestedManyWithoutTermInput;
  };

  export type ClassTermCreateOrConnectWithoutTermInput = {
    where: ClassTermWhereUniqueInput;
    create: XOR<
      ClassTermCreateWithoutTermInput,
      ClassTermUncheckedCreateWithoutTermInput
    >;
  };

  export type ClassTermCreateManyTermInputEnvelope = {
    data: ClassTermCreateManyTermInput | ClassTermCreateManyTermInput[];
    skipDuplicates?: boolean;
  };

  export type ClassTermUpsertWithWhereUniqueWithoutTermInput = {
    where: ClassTermWhereUniqueInput;
    update: XOR<
      ClassTermUpdateWithoutTermInput,
      ClassTermUncheckedUpdateWithoutTermInput
    >;
    create: XOR<
      ClassTermCreateWithoutTermInput,
      ClassTermUncheckedCreateWithoutTermInput
    >;
  };

  export type ClassTermUpdateWithWhereUniqueWithoutTermInput = {
    where: ClassTermWhereUniqueInput;
    data: XOR<
      ClassTermUpdateWithoutTermInput,
      ClassTermUncheckedUpdateWithoutTermInput
    >;
  };

  export type ClassTermUpdateManyWithWhereWithoutTermInput = {
    where: ClassTermScalarWhereInput;
    data: XOR<
      ClassTermUpdateManyMutationInput,
      ClassTermUncheckedUpdateManyWithoutTermInput
    >;
  };

  export type classStreamCreateWithoutTermsInput = {
    id?: string;
    pupils?: PupilCreateNestedManyWithoutClassStreamsInput;
    class?: AcademicYearClassCreateNestedOneWithoutStreamsInput;
    classTeacher?: StaffCreateNestedOneWithoutClassStreamsInput;
    stream?: StreamCreateNestedOneWithoutClassStreamsInput;
  };

  export type classStreamUncheckedCreateWithoutTermsInput = {
    id?: string;
    staffId?: string | null;
    classId?: string | null;
    streamId?: string | null;
    pupils?: PupilUncheckedCreateNestedManyWithoutClassStreamsInput;
  };

  export type classStreamCreateOrConnectWithoutTermsInput = {
    where: classStreamWhereUniqueInput;
    create: XOR<
      classStreamCreateWithoutTermsInput,
      classStreamUncheckedCreateWithoutTermsInput
    >;
  };

  export type TermCreateWithoutClassTermsInput = {
    id?: string;
    term: string;
    slug: string;
  };

  export type TermUncheckedCreateWithoutClassTermsInput = {
    id?: string;
    term: string;
    slug: string;
  };

  export type TermCreateOrConnectWithoutClassTermsInput = {
    where: TermWhereUniqueInput;
    create: XOR<
      TermCreateWithoutClassTermsInput,
      TermUncheckedCreateWithoutClassTermsInput
    >;
  };

  export type ExamCreateWithoutClassTermInput = {
    id: string;
    examName: string;
    examType?: $Enums.ExamType;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    examSubjects?: ExamSubjectCreateNestedManyWithoutExamInput;
  };

  export type ExamUncheckedCreateWithoutClassTermInput = {
    id: string;
    examName: string;
    examType?: $Enums.ExamType;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    examSubjects?: ExamSubjectUncheckedCreateNestedManyWithoutExamInput;
  };

  export type ExamCreateOrConnectWithoutClassTermInput = {
    where: ExamWhereUniqueInput;
    create: XOR<
      ExamCreateWithoutClassTermInput,
      ExamUncheckedCreateWithoutClassTermInput
    >;
  };

  export type ExamCreateManyClassTermInputEnvelope = {
    data: ExamCreateManyClassTermInput | ExamCreateManyClassTermInput[];
    skipDuplicates?: boolean;
  };

  export type FeesCreateWithoutTermInput = {
    id?: string;
    balance?: number;
    status?: $Enums.FeesStatus;
    pupil: PupilCreateNestedOneWithoutFeesInput;
    feesPayments?: FeesPaymentCreateNestedManyWithoutFeesInput;
  };

  export type FeesUncheckedCreateWithoutTermInput = {
    id?: string;
    pupilId: string;
    balance?: number;
    status?: $Enums.FeesStatus;
    feesPayments?: FeesPaymentUncheckedCreateNestedManyWithoutFeesInput;
  };

  export type FeesCreateOrConnectWithoutTermInput = {
    where: FeesWhereUniqueInput;
    create: XOR<
      FeesCreateWithoutTermInput,
      FeesUncheckedCreateWithoutTermInput
    >;
  };

  export type FeesCreateManyTermInputEnvelope = {
    data: FeesCreateManyTermInput | FeesCreateManyTermInput[];
    skipDuplicates?: boolean;
  };

  export type classStreamUpsertWithoutTermsInput = {
    update: XOR<
      classStreamUpdateWithoutTermsInput,
      classStreamUncheckedUpdateWithoutTermsInput
    >;
    create: XOR<
      classStreamCreateWithoutTermsInput,
      classStreamUncheckedCreateWithoutTermsInput
    >;
    where?: classStreamWhereInput;
  };

  export type classStreamUpdateToOneWithWhereWithoutTermsInput = {
    where?: classStreamWhereInput;
    data: XOR<
      classStreamUpdateWithoutTermsInput,
      classStreamUncheckedUpdateWithoutTermsInput
    >;
  };

  export type classStreamUpdateWithoutTermsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    pupils?: PupilUpdateManyWithoutClassStreamsNestedInput;
    class?: AcademicYearClassUpdateOneWithoutStreamsNestedInput;
    classTeacher?: StaffUpdateOneWithoutClassStreamsNestedInput;
    stream?: StreamUpdateOneWithoutClassStreamsNestedInput;
  };

  export type classStreamUncheckedUpdateWithoutTermsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    staffId?: NullableStringFieldUpdateOperationsInput | string | null;
    classId?: NullableStringFieldUpdateOperationsInput | string | null;
    streamId?: NullableStringFieldUpdateOperationsInput | string | null;
    pupils?: PupilUncheckedUpdateManyWithoutClassStreamsNestedInput;
  };

  export type TermUpsertWithoutClassTermsInput = {
    update: XOR<
      TermUpdateWithoutClassTermsInput,
      TermUncheckedUpdateWithoutClassTermsInput
    >;
    create: XOR<
      TermCreateWithoutClassTermsInput,
      TermUncheckedCreateWithoutClassTermsInput
    >;
    where?: TermWhereInput;
  };

  export type TermUpdateToOneWithWhereWithoutClassTermsInput = {
    where?: TermWhereInput;
    data: XOR<
      TermUpdateWithoutClassTermsInput,
      TermUncheckedUpdateWithoutClassTermsInput
    >;
  };

  export type TermUpdateWithoutClassTermsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    term?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
  };

  export type TermUncheckedUpdateWithoutClassTermsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    term?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
  };

  export type ExamUpsertWithWhereUniqueWithoutClassTermInput = {
    where: ExamWhereUniqueInput;
    update: XOR<
      ExamUpdateWithoutClassTermInput,
      ExamUncheckedUpdateWithoutClassTermInput
    >;
    create: XOR<
      ExamCreateWithoutClassTermInput,
      ExamUncheckedCreateWithoutClassTermInput
    >;
  };

  export type ExamUpdateWithWhereUniqueWithoutClassTermInput = {
    where: ExamWhereUniqueInput;
    data: XOR<
      ExamUpdateWithoutClassTermInput,
      ExamUncheckedUpdateWithoutClassTermInput
    >;
  };

  export type ExamUpdateManyWithWhereWithoutClassTermInput = {
    where: ExamScalarWhereInput;
    data: XOR<
      ExamUpdateManyMutationInput,
      ExamUncheckedUpdateManyWithoutClassTermInput
    >;
  };

  export type ExamScalarWhereInput = {
    AND?: ExamScalarWhereInput | ExamScalarWhereInput[];
    OR?: ExamScalarWhereInput[];
    NOT?: ExamScalarWhereInput | ExamScalarWhereInput[];
    id?: StringFilter<"Exam"> | string;
    examName?: StringFilter<"Exam"> | string;
    examType?: EnumExamTypeFilter<"Exam"> | $Enums.ExamType;
    classTermId?: StringFilter<"Exam"> | string;
    createdAt?: DateTimeFilter<"Exam"> | Date | string;
    updatedAt?: DateTimeFilter<"Exam"> | Date | string;
  };

  export type FeesUpsertWithWhereUniqueWithoutTermInput = {
    where: FeesWhereUniqueInput;
    update: XOR<
      FeesUpdateWithoutTermInput,
      FeesUncheckedUpdateWithoutTermInput
    >;
    create: XOR<
      FeesCreateWithoutTermInput,
      FeesUncheckedCreateWithoutTermInput
    >;
  };

  export type FeesUpdateWithWhereUniqueWithoutTermInput = {
    where: FeesWhereUniqueInput;
    data: XOR<FeesUpdateWithoutTermInput, FeesUncheckedUpdateWithoutTermInput>;
  };

  export type FeesUpdateManyWithWhereWithoutTermInput = {
    where: FeesScalarWhereInput;
    data: XOR<
      FeesUpdateManyMutationInput,
      FeesUncheckedUpdateManyWithoutTermInput
    >;
  };

  export type PupilCreateWithoutFeesInput = {
    id?: string;
    genericPassword: string;
    classStreams?: classStreamCreateNestedManyWithoutPupilsInput;
    examScores?: ExamScoreCreateNestedManyWithoutPupilInput;
    user?: UserCreateNestedOneWithoutPupilsInput;
  };

  export type PupilUncheckedCreateWithoutFeesInput = {
    id?: string;
    userId?: string | null;
    genericPassword: string;
    classStreams?: classStreamUncheckedCreateNestedManyWithoutPupilsInput;
    examScores?: ExamScoreUncheckedCreateNestedManyWithoutPupilInput;
  };

  export type PupilCreateOrConnectWithoutFeesInput = {
    where: PupilWhereUniqueInput;
    create: XOR<
      PupilCreateWithoutFeesInput,
      PupilUncheckedCreateWithoutFeesInput
    >;
  };

  export type ClassTermCreateWithoutFeesInput = {
    id?: string;
    startAt?: Date | string;
    endAt: Date | string;
    feesAmount?: number | null;
    classStream?: classStreamCreateNestedOneWithoutTermsInput;
    term?: TermCreateNestedOneWithoutClassTermsInput;
    exams?: ExamCreateNestedManyWithoutClassTermInput;
  };

  export type ClassTermUncheckedCreateWithoutFeesInput = {
    id?: string;
    startAt?: Date | string;
    endAt: Date | string;
    termId?: string | null;
    classStreamId?: string | null;
    feesAmount?: number | null;
    exams?: ExamUncheckedCreateNestedManyWithoutClassTermInput;
  };

  export type ClassTermCreateOrConnectWithoutFeesInput = {
    where: ClassTermWhereUniqueInput;
    create: XOR<
      ClassTermCreateWithoutFeesInput,
      ClassTermUncheckedCreateWithoutFeesInput
    >;
  };

  export type FeesPaymentCreateWithoutFeesInput = {
    id?: string;
    amountPaid: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    paidBy: UserCreateNestedOneWithoutFeesPaymentsInput;
  };

  export type FeesPaymentUncheckedCreateWithoutFeesInput = {
    id?: string;
    amountPaid: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    userId: string;
  };

  export type FeesPaymentCreateOrConnectWithoutFeesInput = {
    where: FeesPaymentWhereUniqueInput;
    create: XOR<
      FeesPaymentCreateWithoutFeesInput,
      FeesPaymentUncheckedCreateWithoutFeesInput
    >;
  };

  export type FeesPaymentCreateManyFeesInputEnvelope = {
    data: FeesPaymentCreateManyFeesInput | FeesPaymentCreateManyFeesInput[];
    skipDuplicates?: boolean;
  };

  export type PupilUpsertWithoutFeesInput = {
    update: XOR<
      PupilUpdateWithoutFeesInput,
      PupilUncheckedUpdateWithoutFeesInput
    >;
    create: XOR<
      PupilCreateWithoutFeesInput,
      PupilUncheckedCreateWithoutFeesInput
    >;
    where?: PupilWhereInput;
  };

  export type PupilUpdateToOneWithWhereWithoutFeesInput = {
    where?: PupilWhereInput;
    data: XOR<
      PupilUpdateWithoutFeesInput,
      PupilUncheckedUpdateWithoutFeesInput
    >;
  };

  export type PupilUpdateWithoutFeesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    genericPassword?: StringFieldUpdateOperationsInput | string;
    classStreams?: classStreamUpdateManyWithoutPupilsNestedInput;
    examScores?: ExamScoreUpdateManyWithoutPupilNestedInput;
    user?: UserUpdateOneWithoutPupilsNestedInput;
  };

  export type PupilUncheckedUpdateWithoutFeesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: NullableStringFieldUpdateOperationsInput | string | null;
    genericPassword?: StringFieldUpdateOperationsInput | string;
    classStreams?: classStreamUncheckedUpdateManyWithoutPupilsNestedInput;
    examScores?: ExamScoreUncheckedUpdateManyWithoutPupilNestedInput;
  };

  export type ClassTermUpsertWithoutFeesInput = {
    update: XOR<
      ClassTermUpdateWithoutFeesInput,
      ClassTermUncheckedUpdateWithoutFeesInput
    >;
    create: XOR<
      ClassTermCreateWithoutFeesInput,
      ClassTermUncheckedCreateWithoutFeesInput
    >;
    where?: ClassTermWhereInput;
  };

  export type ClassTermUpdateToOneWithWhereWithoutFeesInput = {
    where?: ClassTermWhereInput;
    data: XOR<
      ClassTermUpdateWithoutFeesInput,
      ClassTermUncheckedUpdateWithoutFeesInput
    >;
  };

  export type ClassTermUpdateWithoutFeesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    feesAmount?: NullableIntFieldUpdateOperationsInput | number | null;
    classStream?: classStreamUpdateOneWithoutTermsNestedInput;
    term?: TermUpdateOneWithoutClassTermsNestedInput;
    exams?: ExamUpdateManyWithoutClassTermNestedInput;
  };

  export type ClassTermUncheckedUpdateWithoutFeesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    termId?: NullableStringFieldUpdateOperationsInput | string | null;
    classStreamId?: NullableStringFieldUpdateOperationsInput | string | null;
    feesAmount?: NullableIntFieldUpdateOperationsInput | number | null;
    exams?: ExamUncheckedUpdateManyWithoutClassTermNestedInput;
  };

  export type FeesPaymentUpsertWithWhereUniqueWithoutFeesInput = {
    where: FeesPaymentWhereUniqueInput;
    update: XOR<
      FeesPaymentUpdateWithoutFeesInput,
      FeesPaymentUncheckedUpdateWithoutFeesInput
    >;
    create: XOR<
      FeesPaymentCreateWithoutFeesInput,
      FeesPaymentUncheckedCreateWithoutFeesInput
    >;
  };

  export type FeesPaymentUpdateWithWhereUniqueWithoutFeesInput = {
    where: FeesPaymentWhereUniqueInput;
    data: XOR<
      FeesPaymentUpdateWithoutFeesInput,
      FeesPaymentUncheckedUpdateWithoutFeesInput
    >;
  };

  export type FeesPaymentUpdateManyWithWhereWithoutFeesInput = {
    where: FeesPaymentScalarWhereInput;
    data: XOR<
      FeesPaymentUpdateManyMutationInput,
      FeesPaymentUncheckedUpdateManyWithoutFeesInput
    >;
  };

  export type FeesCreateWithoutFeesPaymentsInput = {
    id?: string;
    balance?: number;
    status?: $Enums.FeesStatus;
    pupil: PupilCreateNestedOneWithoutFeesInput;
    term: ClassTermCreateNestedOneWithoutFeesInput;
  };

  export type FeesUncheckedCreateWithoutFeesPaymentsInput = {
    id?: string;
    pupilId: string;
    balance?: number;
    termId: string;
    status?: $Enums.FeesStatus;
  };

  export type FeesCreateOrConnectWithoutFeesPaymentsInput = {
    where: FeesWhereUniqueInput;
    create: XOR<
      FeesCreateWithoutFeesPaymentsInput,
      FeesUncheckedCreateWithoutFeesPaymentsInput
    >;
  };

  export type UserCreateWithoutFeesPaymentsInput = {
    id?: string;
    name?: string | null;
    username?: string | null;
    email?: string | null;
    avatarUrl?: string | null;
    role?: $Enums.Role | null;
    createdAt?: Date | string;
    telephone?: string | null;
    passwordHash?: string | null;
    googleId?: string | null;
    bio?: string | null;
    isWelcomed?: boolean;
    isVerified?: boolean;
    emailVerified?: boolean;
    assetDamages?: AssetDamageCreateNestedManyWithoutDamagedByInput;
    assetRepairPayments?: AssetRepairPaymentCreateNestedManyWithoutReceivedByInput;
    borrowers?: BorrowerCreateNestedManyWithoutUserInput;
    emailVerificationTokens?: EmailVerificationTokenCreateNestedManyWithoutUserInput;
    pupils?: PupilCreateNestedManyWithoutUserInput;
    sessions?: SessionCreateNestedManyWithoutUserInput;
    staffs?: StaffCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutFeesPaymentsInput = {
    id?: string;
    name?: string | null;
    username?: string | null;
    email?: string | null;
    avatarUrl?: string | null;
    role?: $Enums.Role | null;
    createdAt?: Date | string;
    telephone?: string | null;
    passwordHash?: string | null;
    googleId?: string | null;
    bio?: string | null;
    isWelcomed?: boolean;
    isVerified?: boolean;
    emailVerified?: boolean;
    assetDamages?: AssetDamageUncheckedCreateNestedManyWithoutDamagedByInput;
    assetRepairPayments?: AssetRepairPaymentUncheckedCreateNestedManyWithoutReceivedByInput;
    borrowers?: BorrowerUncheckedCreateNestedManyWithoutUserInput;
    emailVerificationTokens?: EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput;
    pupils?: PupilUncheckedCreateNestedManyWithoutUserInput;
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput;
    staffs?: StaffUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutFeesPaymentsInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutFeesPaymentsInput,
      UserUncheckedCreateWithoutFeesPaymentsInput
    >;
  };

  export type FeesUpsertWithoutFeesPaymentsInput = {
    update: XOR<
      FeesUpdateWithoutFeesPaymentsInput,
      FeesUncheckedUpdateWithoutFeesPaymentsInput
    >;
    create: XOR<
      FeesCreateWithoutFeesPaymentsInput,
      FeesUncheckedCreateWithoutFeesPaymentsInput
    >;
    where?: FeesWhereInput;
  };

  export type FeesUpdateToOneWithWhereWithoutFeesPaymentsInput = {
    where?: FeesWhereInput;
    data: XOR<
      FeesUpdateWithoutFeesPaymentsInput,
      FeesUncheckedUpdateWithoutFeesPaymentsInput
    >;
  };

  export type FeesUpdateWithoutFeesPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    balance?: IntFieldUpdateOperationsInput | number;
    status?: EnumFeesStatusFieldUpdateOperationsInput | $Enums.FeesStatus;
    pupil?: PupilUpdateOneRequiredWithoutFeesNestedInput;
    term?: ClassTermUpdateOneRequiredWithoutFeesNestedInput;
  };

  export type FeesUncheckedUpdateWithoutFeesPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    pupilId?: StringFieldUpdateOperationsInput | string;
    balance?: IntFieldUpdateOperationsInput | number;
    termId?: StringFieldUpdateOperationsInput | string;
    status?: EnumFeesStatusFieldUpdateOperationsInput | $Enums.FeesStatus;
  };

  export type UserUpsertWithoutFeesPaymentsInput = {
    update: XOR<
      UserUpdateWithoutFeesPaymentsInput,
      UserUncheckedUpdateWithoutFeesPaymentsInput
    >;
    create: XOR<
      UserCreateWithoutFeesPaymentsInput,
      UserUncheckedCreateWithoutFeesPaymentsInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutFeesPaymentsInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutFeesPaymentsInput,
      UserUncheckedUpdateWithoutFeesPaymentsInput
    >;
  };

  export type UserUpdateWithoutFeesPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    telephone?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    googleId?: NullableStringFieldUpdateOperationsInput | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    isWelcomed?: BoolFieldUpdateOperationsInput | boolean;
    isVerified?: BoolFieldUpdateOperationsInput | boolean;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    assetDamages?: AssetDamageUpdateManyWithoutDamagedByNestedInput;
    assetRepairPayments?: AssetRepairPaymentUpdateManyWithoutReceivedByNestedInput;
    borrowers?: BorrowerUpdateManyWithoutUserNestedInput;
    emailVerificationTokens?: EmailVerificationTokenUpdateManyWithoutUserNestedInput;
    pupils?: PupilUpdateManyWithoutUserNestedInput;
    sessions?: SessionUpdateManyWithoutUserNestedInput;
    staffs?: StaffUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutFeesPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    telephone?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    googleId?: NullableStringFieldUpdateOperationsInput | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    isWelcomed?: BoolFieldUpdateOperationsInput | boolean;
    isVerified?: BoolFieldUpdateOperationsInput | boolean;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    assetDamages?: AssetDamageUncheckedUpdateManyWithoutDamagedByNestedInput;
    assetRepairPayments?: AssetRepairPaymentUncheckedUpdateManyWithoutReceivedByNestedInput;
    borrowers?: BorrowerUncheckedUpdateManyWithoutUserNestedInput;
    emailVerificationTokens?: EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput;
    pupils?: PupilUncheckedUpdateManyWithoutUserNestedInput;
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput;
    staffs?: StaffUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type UserCreateWithoutSessionsInput = {
    id?: string;
    name?: string | null;
    username?: string | null;
    email?: string | null;
    avatarUrl?: string | null;
    role?: $Enums.Role | null;
    createdAt?: Date | string;
    telephone?: string | null;
    passwordHash?: string | null;
    googleId?: string | null;
    bio?: string | null;
    isWelcomed?: boolean;
    isVerified?: boolean;
    emailVerified?: boolean;
    assetDamages?: AssetDamageCreateNestedManyWithoutDamagedByInput;
    assetRepairPayments?: AssetRepairPaymentCreateNestedManyWithoutReceivedByInput;
    borrowers?: BorrowerCreateNestedManyWithoutUserInput;
    emailVerificationTokens?: EmailVerificationTokenCreateNestedManyWithoutUserInput;
    feesPayments?: FeesPaymentCreateNestedManyWithoutPaidByInput;
    pupils?: PupilCreateNestedManyWithoutUserInput;
    staffs?: StaffCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string;
    name?: string | null;
    username?: string | null;
    email?: string | null;
    avatarUrl?: string | null;
    role?: $Enums.Role | null;
    createdAt?: Date | string;
    telephone?: string | null;
    passwordHash?: string | null;
    googleId?: string | null;
    bio?: string | null;
    isWelcomed?: boolean;
    isVerified?: boolean;
    emailVerified?: boolean;
    assetDamages?: AssetDamageUncheckedCreateNestedManyWithoutDamagedByInput;
    assetRepairPayments?: AssetRepairPaymentUncheckedCreateNestedManyWithoutReceivedByInput;
    borrowers?: BorrowerUncheckedCreateNestedManyWithoutUserInput;
    emailVerificationTokens?: EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput;
    feesPayments?: FeesPaymentUncheckedCreateNestedManyWithoutPaidByInput;
    pupils?: PupilUncheckedCreateNestedManyWithoutUserInput;
    staffs?: StaffUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutSessionsInput,
      UserUncheckedCreateWithoutSessionsInput
    >;
  };

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<
      UserUpdateWithoutSessionsInput,
      UserUncheckedUpdateWithoutSessionsInput
    >;
    create: XOR<
      UserCreateWithoutSessionsInput,
      UserUncheckedCreateWithoutSessionsInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutSessionsInput,
      UserUncheckedUpdateWithoutSessionsInput
    >;
  };

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    telephone?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    googleId?: NullableStringFieldUpdateOperationsInput | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    isWelcomed?: BoolFieldUpdateOperationsInput | boolean;
    isVerified?: BoolFieldUpdateOperationsInput | boolean;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    assetDamages?: AssetDamageUpdateManyWithoutDamagedByNestedInput;
    assetRepairPayments?: AssetRepairPaymentUpdateManyWithoutReceivedByNestedInput;
    borrowers?: BorrowerUpdateManyWithoutUserNestedInput;
    emailVerificationTokens?: EmailVerificationTokenUpdateManyWithoutUserNestedInput;
    feesPayments?: FeesPaymentUpdateManyWithoutPaidByNestedInput;
    pupils?: PupilUpdateManyWithoutUserNestedInput;
    staffs?: StaffUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    telephone?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    googleId?: NullableStringFieldUpdateOperationsInput | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    isWelcomed?: BoolFieldUpdateOperationsInput | boolean;
    isVerified?: BoolFieldUpdateOperationsInput | boolean;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    assetDamages?: AssetDamageUncheckedUpdateManyWithoutDamagedByNestedInput;
    assetRepairPayments?: AssetRepairPaymentUncheckedUpdateManyWithoutReceivedByNestedInput;
    borrowers?: BorrowerUncheckedUpdateManyWithoutUserNestedInput;
    emailVerificationTokens?: EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput;
    feesPayments?: FeesPaymentUncheckedUpdateManyWithoutPaidByNestedInput;
    pupils?: PupilUncheckedUpdateManyWithoutUserNestedInput;
    staffs?: StaffUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type ComputerLabItemCreateWithoutAssetInput = {
    id?: string;
    name: string;
    model?: string | null;
    specification?: string | null;
    quantity?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    trackQuantity?: boolean;
    unit: $Enums.AssetUnit;
    individualComputerLabItems?: IndividualComputerLabItemCreateNestedManyWithoutComputerLabItemInput;
  };

  export type ComputerLabItemUncheckedCreateWithoutAssetInput = {
    id?: string;
    name: string;
    model?: string | null;
    specification?: string | null;
    quantity?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    trackQuantity?: boolean;
    unit: $Enums.AssetUnit;
    individualComputerLabItems?: IndividualComputerLabItemUncheckedCreateNestedManyWithoutComputerLabItemInput;
  };

  export type ComputerLabItemCreateOrConnectWithoutAssetInput = {
    where: ComputerLabItemWhereUniqueInput;
    create: XOR<
      ComputerLabItemCreateWithoutAssetInput,
      ComputerLabItemUncheckedCreateWithoutAssetInput
    >;
  };

  export type ComputerLabItemCreateManyAssetInputEnvelope = {
    data:
      | ComputerLabItemCreateManyAssetInput
      | ComputerLabItemCreateManyAssetInput[];
    skipDuplicates?: boolean;
  };

  export type FoodStoreItemCreateWithoutAssetInput = {
    id?: string;
    foodName: string;
    unit: $Enums.AssetUnit;
    quantity?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    trackQuantity?: boolean;
    status?: $Enums.AssetItemStatus;
    isConsumable?: boolean;
    consumptions?: FoodConsumptionCreateNestedManyWithoutFoodItemInput;
    supplier?: SupplierCreateNestedOneWithoutFoodStoreItemsInput;
    individualFoodStoreItems?: IndividualFoodStoreItemCreateNestedManyWithoutFoodStoreItemInput;
  };

  export type FoodStoreItemUncheckedCreateWithoutAssetInput = {
    id?: string;
    foodName: string;
    unit: $Enums.AssetUnit;
    quantity?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    supplierId?: string | null;
    trackQuantity?: boolean;
    status?: $Enums.AssetItemStatus;
    isConsumable?: boolean;
    consumptions?: FoodConsumptionUncheckedCreateNestedManyWithoutFoodItemInput;
    individualFoodStoreItems?: IndividualFoodStoreItemUncheckedCreateNestedManyWithoutFoodStoreItemInput;
  };

  export type FoodStoreItemCreateOrConnectWithoutAssetInput = {
    where: FoodStoreItemWhereUniqueInput;
    create: XOR<
      FoodStoreItemCreateWithoutAssetInput,
      FoodStoreItemUncheckedCreateWithoutAssetInput
    >;
  };

  export type FoodStoreItemCreateManyAssetInputEnvelope = {
    data:
      | FoodStoreItemCreateManyAssetInput
      | FoodStoreItemCreateManyAssetInput[];
    skipDuplicates?: boolean;
  };

  export type GeneralStoreItemCreateWithoutAssetInput = {
    id?: string;
    name: string;
    quantity?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    status?: $Enums.AssetItemStatus;
    trackQuantity?: boolean;
    unit: $Enums.AssetUnit;
    individualGeneralStoreItems?: IndividualGeneralStoreItemCreateNestedManyWithoutGeneralStoreItemInput;
  };

  export type GeneralStoreItemUncheckedCreateWithoutAssetInput = {
    id?: string;
    name: string;
    quantity?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    status?: $Enums.AssetItemStatus;
    trackQuantity?: boolean;
    unit: $Enums.AssetUnit;
    individualGeneralStoreItems?: IndividualGeneralStoreItemUncheckedCreateNestedManyWithoutGeneralStoreItemInput;
  };

  export type GeneralStoreItemCreateOrConnectWithoutAssetInput = {
    where: GeneralStoreItemWhereUniqueInput;
    create: XOR<
      GeneralStoreItemCreateWithoutAssetInput,
      GeneralStoreItemUncheckedCreateWithoutAssetInput
    >;
  };

  export type GeneralStoreItemCreateManyAssetInputEnvelope = {
    data:
      | GeneralStoreItemCreateManyAssetInput
      | GeneralStoreItemCreateManyAssetInput[];
    skipDuplicates?: boolean;
  };

  export type LabItemCreateWithoutAssetInput = {
    id?: string;
    name: string;
    quantity?: number | null;
    unit: $Enums.AssetUnit;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    trackQuantity?: boolean;
    status?: $Enums.AssetStatus;
    individualLabItems?: IndividualLabItemCreateNestedManyWithoutLabItemInput;
  };

  export type LabItemUncheckedCreateWithoutAssetInput = {
    id?: string;
    name: string;
    quantity?: number | null;
    unit: $Enums.AssetUnit;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    trackQuantity?: boolean;
    status?: $Enums.AssetStatus;
    individualLabItems?: IndividualLabItemUncheckedCreateNestedManyWithoutLabItemInput;
  };

  export type LabItemCreateOrConnectWithoutAssetInput = {
    where: LabItemWhereUniqueInput;
    create: XOR<
      LabItemCreateWithoutAssetInput,
      LabItemUncheckedCreateWithoutAssetInput
    >;
  };

  export type LabItemCreateManyAssetInputEnvelope = {
    data: LabItemCreateManyAssetInput | LabItemCreateManyAssetInput[];
    skipDuplicates?: boolean;
  };

  export type LibraryBookCreateWithoutAssetInput = {
    id?: string;
    title: string;
    author: string;
    quantity?: number | null;
    trackQuantity?: boolean;
    unit: $Enums.AssetUnit;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    individualBooks?: IndividualBookCreateNestedManyWithoutLibraryBookInput;
    category: LibraryBookCategoryCreateNestedOneWithoutLibraryBooksInput;
  };

  export type LibraryBookUncheckedCreateWithoutAssetInput = {
    id?: string;
    title: string;
    author: string;
    libraryBookCategoryId: string;
    quantity?: number | null;
    trackQuantity?: boolean;
    unit: $Enums.AssetUnit;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    individualBooks?: IndividualBookUncheckedCreateNestedManyWithoutLibraryBookInput;
  };

  export type LibraryBookCreateOrConnectWithoutAssetInput = {
    where: LibraryBookWhereUniqueInput;
    create: XOR<
      LibraryBookCreateWithoutAssetInput,
      LibraryBookUncheckedCreateWithoutAssetInput
    >;
  };

  export type LibraryBookCreateManyAssetInputEnvelope = {
    data: LibraryBookCreateManyAssetInput | LibraryBookCreateManyAssetInput[];
    skipDuplicates?: boolean;
  };

  export type ComputerLabItemUpsertWithWhereUniqueWithoutAssetInput = {
    where: ComputerLabItemWhereUniqueInput;
    update: XOR<
      ComputerLabItemUpdateWithoutAssetInput,
      ComputerLabItemUncheckedUpdateWithoutAssetInput
    >;
    create: XOR<
      ComputerLabItemCreateWithoutAssetInput,
      ComputerLabItemUncheckedCreateWithoutAssetInput
    >;
  };

  export type ComputerLabItemUpdateWithWhereUniqueWithoutAssetInput = {
    where: ComputerLabItemWhereUniqueInput;
    data: XOR<
      ComputerLabItemUpdateWithoutAssetInput,
      ComputerLabItemUncheckedUpdateWithoutAssetInput
    >;
  };

  export type ComputerLabItemUpdateManyWithWhereWithoutAssetInput = {
    where: ComputerLabItemScalarWhereInput;
    data: XOR<
      ComputerLabItemUpdateManyMutationInput,
      ComputerLabItemUncheckedUpdateManyWithoutAssetInput
    >;
  };

  export type ComputerLabItemScalarWhereInput = {
    AND?: ComputerLabItemScalarWhereInput | ComputerLabItemScalarWhereInput[];
    OR?: ComputerLabItemScalarWhereInput[];
    NOT?: ComputerLabItemScalarWhereInput | ComputerLabItemScalarWhereInput[];
    id?: StringFilter<"ComputerLabItem"> | string;
    name?: StringFilter<"ComputerLabItem"> | string;
    model?: StringNullableFilter<"ComputerLabItem"> | string | null;
    specification?: StringNullableFilter<"ComputerLabItem"> | string | null;
    quantity?: FloatNullableFilter<"ComputerLabItem"> | number | null;
    createdAt?: DateTimeFilter<"ComputerLabItem"> | Date | string;
    updatedAt?: DateTimeFilter<"ComputerLabItem"> | Date | string;
    assetId?: StringFilter<"ComputerLabItem"> | string;
    trackQuantity?: BoolFilter<"ComputerLabItem"> | boolean;
    unit?: EnumAssetUnitFilter<"ComputerLabItem"> | $Enums.AssetUnit;
  };

  export type FoodStoreItemUpsertWithWhereUniqueWithoutAssetInput = {
    where: FoodStoreItemWhereUniqueInput;
    update: XOR<
      FoodStoreItemUpdateWithoutAssetInput,
      FoodStoreItemUncheckedUpdateWithoutAssetInput
    >;
    create: XOR<
      FoodStoreItemCreateWithoutAssetInput,
      FoodStoreItemUncheckedCreateWithoutAssetInput
    >;
  };

  export type FoodStoreItemUpdateWithWhereUniqueWithoutAssetInput = {
    where: FoodStoreItemWhereUniqueInput;
    data: XOR<
      FoodStoreItemUpdateWithoutAssetInput,
      FoodStoreItemUncheckedUpdateWithoutAssetInput
    >;
  };

  export type FoodStoreItemUpdateManyWithWhereWithoutAssetInput = {
    where: FoodStoreItemScalarWhereInput;
    data: XOR<
      FoodStoreItemUpdateManyMutationInput,
      FoodStoreItemUncheckedUpdateManyWithoutAssetInput
    >;
  };

  export type FoodStoreItemScalarWhereInput = {
    AND?: FoodStoreItemScalarWhereInput | FoodStoreItemScalarWhereInput[];
    OR?: FoodStoreItemScalarWhereInput[];
    NOT?: FoodStoreItemScalarWhereInput | FoodStoreItemScalarWhereInput[];
    id?: StringFilter<"FoodStoreItem"> | string;
    assetId?: StringFilter<"FoodStoreItem"> | string;
    foodName?: StringFilter<"FoodStoreItem"> | string;
    unit?: EnumAssetUnitFilter<"FoodStoreItem"> | $Enums.AssetUnit;
    quantity?: FloatNullableFilter<"FoodStoreItem"> | number | null;
    createdAt?: DateTimeFilter<"FoodStoreItem"> | Date | string;
    updatedAt?: DateTimeFilter<"FoodStoreItem"> | Date | string;
    supplierId?: StringNullableFilter<"FoodStoreItem"> | string | null;
    trackQuantity?: BoolFilter<"FoodStoreItem"> | boolean;
    status?:
      | EnumAssetItemStatusFilter<"FoodStoreItem">
      | $Enums.AssetItemStatus;
    isConsumable?: BoolFilter<"FoodStoreItem"> | boolean;
  };

  export type GeneralStoreItemUpsertWithWhereUniqueWithoutAssetInput = {
    where: GeneralStoreItemWhereUniqueInput;
    update: XOR<
      GeneralStoreItemUpdateWithoutAssetInput,
      GeneralStoreItemUncheckedUpdateWithoutAssetInput
    >;
    create: XOR<
      GeneralStoreItemCreateWithoutAssetInput,
      GeneralStoreItemUncheckedCreateWithoutAssetInput
    >;
  };

  export type GeneralStoreItemUpdateWithWhereUniqueWithoutAssetInput = {
    where: GeneralStoreItemWhereUniqueInput;
    data: XOR<
      GeneralStoreItemUpdateWithoutAssetInput,
      GeneralStoreItemUncheckedUpdateWithoutAssetInput
    >;
  };

  export type GeneralStoreItemUpdateManyWithWhereWithoutAssetInput = {
    where: GeneralStoreItemScalarWhereInput;
    data: XOR<
      GeneralStoreItemUpdateManyMutationInput,
      GeneralStoreItemUncheckedUpdateManyWithoutAssetInput
    >;
  };

  export type GeneralStoreItemScalarWhereInput = {
    AND?: GeneralStoreItemScalarWhereInput | GeneralStoreItemScalarWhereInput[];
    OR?: GeneralStoreItemScalarWhereInput[];
    NOT?: GeneralStoreItemScalarWhereInput | GeneralStoreItemScalarWhereInput[];
    id?: StringFilter<"GeneralStoreItem"> | string;
    name?: StringFilter<"GeneralStoreItem"> | string;
    quantity?: FloatNullableFilter<"GeneralStoreItem"> | number | null;
    createdAt?: DateTimeFilter<"GeneralStoreItem"> | Date | string;
    updatedAt?: DateTimeFilter<"GeneralStoreItem"> | Date | string;
    assetId?: StringFilter<"GeneralStoreItem"> | string;
    status?:
      | EnumAssetItemStatusFilter<"GeneralStoreItem">
      | $Enums.AssetItemStatus;
    trackQuantity?: BoolFilter<"GeneralStoreItem"> | boolean;
    unit?: EnumAssetUnitFilter<"GeneralStoreItem"> | $Enums.AssetUnit;
  };

  export type LabItemUpsertWithWhereUniqueWithoutAssetInput = {
    where: LabItemWhereUniqueInput;
    update: XOR<
      LabItemUpdateWithoutAssetInput,
      LabItemUncheckedUpdateWithoutAssetInput
    >;
    create: XOR<
      LabItemCreateWithoutAssetInput,
      LabItemUncheckedCreateWithoutAssetInput
    >;
  };

  export type LabItemUpdateWithWhereUniqueWithoutAssetInput = {
    where: LabItemWhereUniqueInput;
    data: XOR<
      LabItemUpdateWithoutAssetInput,
      LabItemUncheckedUpdateWithoutAssetInput
    >;
  };

  export type LabItemUpdateManyWithWhereWithoutAssetInput = {
    where: LabItemScalarWhereInput;
    data: XOR<
      LabItemUpdateManyMutationInput,
      LabItemUncheckedUpdateManyWithoutAssetInput
    >;
  };

  export type LabItemScalarWhereInput = {
    AND?: LabItemScalarWhereInput | LabItemScalarWhereInput[];
    OR?: LabItemScalarWhereInput[];
    NOT?: LabItemScalarWhereInput | LabItemScalarWhereInput[];
    id?: StringFilter<"LabItem"> | string;
    name?: StringFilter<"LabItem"> | string;
    quantity?: FloatNullableFilter<"LabItem"> | number | null;
    unit?: EnumAssetUnitFilter<"LabItem"> | $Enums.AssetUnit;
    createdAt?: DateTimeFilter<"LabItem"> | Date | string;
    updatedAt?: DateTimeFilter<"LabItem"> | Date | string;
    assetId?: StringFilter<"LabItem"> | string;
    trackQuantity?: BoolFilter<"LabItem"> | boolean;
    status?: EnumAssetStatusFilter<"LabItem"> | $Enums.AssetStatus;
  };

  export type LibraryBookUpsertWithWhereUniqueWithoutAssetInput = {
    where: LibraryBookWhereUniqueInput;
    update: XOR<
      LibraryBookUpdateWithoutAssetInput,
      LibraryBookUncheckedUpdateWithoutAssetInput
    >;
    create: XOR<
      LibraryBookCreateWithoutAssetInput,
      LibraryBookUncheckedCreateWithoutAssetInput
    >;
  };

  export type LibraryBookUpdateWithWhereUniqueWithoutAssetInput = {
    where: LibraryBookWhereUniqueInput;
    data: XOR<
      LibraryBookUpdateWithoutAssetInput,
      LibraryBookUncheckedUpdateWithoutAssetInput
    >;
  };

  export type LibraryBookUpdateManyWithWhereWithoutAssetInput = {
    where: LibraryBookScalarWhereInput;
    data: XOR<
      LibraryBookUpdateManyMutationInput,
      LibraryBookUncheckedUpdateManyWithoutAssetInput
    >;
  };

  export type LibraryBookScalarWhereInput = {
    AND?: LibraryBookScalarWhereInput | LibraryBookScalarWhereInput[];
    OR?: LibraryBookScalarWhereInput[];
    NOT?: LibraryBookScalarWhereInput | LibraryBookScalarWhereInput[];
    id?: StringFilter<"LibraryBook"> | string;
    title?: StringFilter<"LibraryBook"> | string;
    author?: StringFilter<"LibraryBook"> | string;
    assetId?: StringFilter<"LibraryBook"> | string;
    libraryBookCategoryId?: StringFilter<"LibraryBook"> | string;
    quantity?: FloatNullableFilter<"LibraryBook"> | number | null;
    trackQuantity?: BoolFilter<"LibraryBook"> | boolean;
    unit?: EnumAssetUnitFilter<"LibraryBook"> | $Enums.AssetUnit;
    createdAt?: DateTimeFilter<"LibraryBook"> | Date | string;
    updatedAt?: DateTimeFilter<"LibraryBook"> | Date | string;
  };

  export type FoodConsumptionCreateWithoutFoodItemInput = {
    id?: string;
    quantityUsed?: number | null;
    dateUsedAt?: Date | string;
    usageDetails?: string | null;
  };

  export type FoodConsumptionUncheckedCreateWithoutFoodItemInput = {
    id?: string;
    quantityUsed?: number | null;
    dateUsedAt?: Date | string;
    usageDetails?: string | null;
  };

  export type FoodConsumptionCreateOrConnectWithoutFoodItemInput = {
    where: FoodConsumptionWhereUniqueInput;
    create: XOR<
      FoodConsumptionCreateWithoutFoodItemInput,
      FoodConsumptionUncheckedCreateWithoutFoodItemInput
    >;
  };

  export type FoodConsumptionCreateManyFoodItemInputEnvelope = {
    data:
      | FoodConsumptionCreateManyFoodItemInput
      | FoodConsumptionCreateManyFoodItemInput[];
    skipDuplicates?: boolean;
  };

  export type AssetCreateWithoutFoodStoreItemsInput = {
    id?: string;
    name: string;
    description?: string | null;
    category: $Enums.AssetCategory;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    computerLabItems?: ComputerLabItemCreateNestedManyWithoutAssetInput;
    generalStoreItems?: GeneralStoreItemCreateNestedManyWithoutAssetInput;
    labItems?: LabItemCreateNestedManyWithoutAssetInput;
    libraryBooks?: LibraryBookCreateNestedManyWithoutAssetInput;
  };

  export type AssetUncheckedCreateWithoutFoodStoreItemsInput = {
    id?: string;
    name: string;
    description?: string | null;
    category: $Enums.AssetCategory;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    computerLabItems?: ComputerLabItemUncheckedCreateNestedManyWithoutAssetInput;
    generalStoreItems?: GeneralStoreItemUncheckedCreateNestedManyWithoutAssetInput;
    labItems?: LabItemUncheckedCreateNestedManyWithoutAssetInput;
    libraryBooks?: LibraryBookUncheckedCreateNestedManyWithoutAssetInput;
  };

  export type AssetCreateOrConnectWithoutFoodStoreItemsInput = {
    where: AssetWhereUniqueInput;
    create: XOR<
      AssetCreateWithoutFoodStoreItemsInput,
      AssetUncheckedCreateWithoutFoodStoreItemsInput
    >;
  };

  export type SupplierCreateWithoutFoodStoreItemsInput = {
    id?: string;
    name: string;
    contactInfo?: string | null;
    address?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type SupplierUncheckedCreateWithoutFoodStoreItemsInput = {
    id?: string;
    name: string;
    contactInfo?: string | null;
    address?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type SupplierCreateOrConnectWithoutFoodStoreItemsInput = {
    where: SupplierWhereUniqueInput;
    create: XOR<
      SupplierCreateWithoutFoodStoreItemsInput,
      SupplierUncheckedCreateWithoutFoodStoreItemsInput
    >;
  };

  export type IndividualFoodStoreItemCreateWithoutFoodStoreItemInput = {
    id?: string;
    uniqueIdentifier?: string | null;
    status?: $Enums.AssetStatus;
    condition?: $Enums.AssetCondition;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    assetDamages?: AssetDamageCreateNestedManyWithoutIndividualFoodStoreItemInput;
  };

  export type IndividualFoodStoreItemUncheckedCreateWithoutFoodStoreItemInput =
    {
      id?: string;
      uniqueIdentifier?: string | null;
      status?: $Enums.AssetStatus;
      condition?: $Enums.AssetCondition;
      createdAt?: Date | string;
      updatedAt?: Date | string;
      assetDamages?: AssetDamageUncheckedCreateNestedManyWithoutIndividualFoodStoreItemInput;
    };

  export type IndividualFoodStoreItemCreateOrConnectWithoutFoodStoreItemInput =
    {
      where: IndividualFoodStoreItemWhereUniqueInput;
      create: XOR<
        IndividualFoodStoreItemCreateWithoutFoodStoreItemInput,
        IndividualFoodStoreItemUncheckedCreateWithoutFoodStoreItemInput
      >;
    };

  export type IndividualFoodStoreItemCreateManyFoodStoreItemInputEnvelope = {
    data:
      | IndividualFoodStoreItemCreateManyFoodStoreItemInput
      | IndividualFoodStoreItemCreateManyFoodStoreItemInput[];
    skipDuplicates?: boolean;
  };

  export type FoodConsumptionUpsertWithWhereUniqueWithoutFoodItemInput = {
    where: FoodConsumptionWhereUniqueInput;
    update: XOR<
      FoodConsumptionUpdateWithoutFoodItemInput,
      FoodConsumptionUncheckedUpdateWithoutFoodItemInput
    >;
    create: XOR<
      FoodConsumptionCreateWithoutFoodItemInput,
      FoodConsumptionUncheckedCreateWithoutFoodItemInput
    >;
  };

  export type FoodConsumptionUpdateWithWhereUniqueWithoutFoodItemInput = {
    where: FoodConsumptionWhereUniqueInput;
    data: XOR<
      FoodConsumptionUpdateWithoutFoodItemInput,
      FoodConsumptionUncheckedUpdateWithoutFoodItemInput
    >;
  };

  export type FoodConsumptionUpdateManyWithWhereWithoutFoodItemInput = {
    where: FoodConsumptionScalarWhereInput;
    data: XOR<
      FoodConsumptionUpdateManyMutationInput,
      FoodConsumptionUncheckedUpdateManyWithoutFoodItemInput
    >;
  };

  export type FoodConsumptionScalarWhereInput = {
    AND?: FoodConsumptionScalarWhereInput | FoodConsumptionScalarWhereInput[];
    OR?: FoodConsumptionScalarWhereInput[];
    NOT?: FoodConsumptionScalarWhereInput | FoodConsumptionScalarWhereInput[];
    id?: StringFilter<"FoodConsumption"> | string;
    quantityUsed?: FloatNullableFilter<"FoodConsumption"> | number | null;
    dateUsedAt?: DateTimeFilter<"FoodConsumption"> | Date | string;
    usageDetails?: StringNullableFilter<"FoodConsumption"> | string | null;
    foodStoreItemId?: StringFilter<"FoodConsumption"> | string;
  };

  export type AssetUpsertWithoutFoodStoreItemsInput = {
    update: XOR<
      AssetUpdateWithoutFoodStoreItemsInput,
      AssetUncheckedUpdateWithoutFoodStoreItemsInput
    >;
    create: XOR<
      AssetCreateWithoutFoodStoreItemsInput,
      AssetUncheckedCreateWithoutFoodStoreItemsInput
    >;
    where?: AssetWhereInput;
  };

  export type AssetUpdateToOneWithWhereWithoutFoodStoreItemsInput = {
    where?: AssetWhereInput;
    data: XOR<
      AssetUpdateWithoutFoodStoreItemsInput,
      AssetUncheckedUpdateWithoutFoodStoreItemsInput
    >;
  };

  export type AssetUpdateWithoutFoodStoreItemsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    category?:
      | EnumAssetCategoryFieldUpdateOperationsInput
      | $Enums.AssetCategory;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    computerLabItems?: ComputerLabItemUpdateManyWithoutAssetNestedInput;
    generalStoreItems?: GeneralStoreItemUpdateManyWithoutAssetNestedInput;
    labItems?: LabItemUpdateManyWithoutAssetNestedInput;
    libraryBooks?: LibraryBookUpdateManyWithoutAssetNestedInput;
  };

  export type AssetUncheckedUpdateWithoutFoodStoreItemsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    category?:
      | EnumAssetCategoryFieldUpdateOperationsInput
      | $Enums.AssetCategory;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    computerLabItems?: ComputerLabItemUncheckedUpdateManyWithoutAssetNestedInput;
    generalStoreItems?: GeneralStoreItemUncheckedUpdateManyWithoutAssetNestedInput;
    labItems?: LabItemUncheckedUpdateManyWithoutAssetNestedInput;
    libraryBooks?: LibraryBookUncheckedUpdateManyWithoutAssetNestedInput;
  };

  export type SupplierUpsertWithoutFoodStoreItemsInput = {
    update: XOR<
      SupplierUpdateWithoutFoodStoreItemsInput,
      SupplierUncheckedUpdateWithoutFoodStoreItemsInput
    >;
    create: XOR<
      SupplierCreateWithoutFoodStoreItemsInput,
      SupplierUncheckedCreateWithoutFoodStoreItemsInput
    >;
    where?: SupplierWhereInput;
  };

  export type SupplierUpdateToOneWithWhereWithoutFoodStoreItemsInput = {
    where?: SupplierWhereInput;
    data: XOR<
      SupplierUpdateWithoutFoodStoreItemsInput,
      SupplierUncheckedUpdateWithoutFoodStoreItemsInput
    >;
  };

  export type SupplierUpdateWithoutFoodStoreItemsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type SupplierUncheckedUpdateWithoutFoodStoreItemsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type IndividualFoodStoreItemUpsertWithWhereUniqueWithoutFoodStoreItemInput =
    {
      where: IndividualFoodStoreItemWhereUniqueInput;
      update: XOR<
        IndividualFoodStoreItemUpdateWithoutFoodStoreItemInput,
        IndividualFoodStoreItemUncheckedUpdateWithoutFoodStoreItemInput
      >;
      create: XOR<
        IndividualFoodStoreItemCreateWithoutFoodStoreItemInput,
        IndividualFoodStoreItemUncheckedCreateWithoutFoodStoreItemInput
      >;
    };

  export type IndividualFoodStoreItemUpdateWithWhereUniqueWithoutFoodStoreItemInput =
    {
      where: IndividualFoodStoreItemWhereUniqueInput;
      data: XOR<
        IndividualFoodStoreItemUpdateWithoutFoodStoreItemInput,
        IndividualFoodStoreItemUncheckedUpdateWithoutFoodStoreItemInput
      >;
    };

  export type IndividualFoodStoreItemUpdateManyWithWhereWithoutFoodStoreItemInput =
    {
      where: IndividualFoodStoreItemScalarWhereInput;
      data: XOR<
        IndividualFoodStoreItemUpdateManyMutationInput,
        IndividualFoodStoreItemUncheckedUpdateManyWithoutFoodStoreItemInput
      >;
    };

  export type IndividualFoodStoreItemScalarWhereInput = {
    AND?:
      | IndividualFoodStoreItemScalarWhereInput
      | IndividualFoodStoreItemScalarWhereInput[];
    OR?: IndividualFoodStoreItemScalarWhereInput[];
    NOT?:
      | IndividualFoodStoreItemScalarWhereInput
      | IndividualFoodStoreItemScalarWhereInput[];
    id?: StringFilter<"IndividualFoodStoreItem"> | string;
    foodStoreItemId?: StringFilter<"IndividualFoodStoreItem"> | string;
    uniqueIdentifier?:
      | StringNullableFilter<"IndividualFoodStoreItem">
      | string
      | null;
    status?:
      | EnumAssetStatusFilter<"IndividualFoodStoreItem">
      | $Enums.AssetStatus;
    condition?:
      | EnumAssetConditionFilter<"IndividualFoodStoreItem">
      | $Enums.AssetCondition;
    createdAt?: DateTimeFilter<"IndividualFoodStoreItem"> | Date | string;
    updatedAt?: DateTimeFilter<"IndividualFoodStoreItem"> | Date | string;
  };

  export type AssetDamageCreateWithoutIndividualFoodStoreItemInput = {
    id?: string;
    damageDetails: string;
    condition: $Enums.AssetCondition;
    quantity: number;
    isRepaired?: boolean;
    repairedAt?: Date | string | null;
    createdAt?: Date | string;
    isSchoolCost?: boolean;
    repairBalance?: number;
    repairPrice?: number | null;
    individualBook?: IndividualBookCreateNestedOneWithoutBookDamagesInput;
    individualComputerLabItem?: IndividualComputerLabItemCreateNestedOneWithoutAssetDamagesInput;
    individualGeneralStoreItem?: IndividualGeneralStoreItemCreateNestedOneWithoutAssetDamagesInput;
    individualLabItem?: IndividualLabItemCreateNestedOneWithoutAssetDamagesInput;
    damagedBy?: UserCreateNestedOneWithoutAssetDamagesInput;
    assetRepairPayments?: AssetRepairPaymentCreateNestedManyWithoutAssetDamageInput;
  };

  export type AssetDamageUncheckedCreateWithoutIndividualFoodStoreItemInput = {
    id?: string;
    damageDetails: string;
    condition: $Enums.AssetCondition;
    quantity: number;
    userId?: string | null;
    individualComputerLabItemId?: string | null;
    isRepaired?: boolean;
    repairedAt?: Date | string | null;
    createdAt?: Date | string;
    individualBookId?: string | null;
    individualLabItemId?: string | null;
    individualGeneralStoreItemId?: string | null;
    isSchoolCost?: boolean;
    repairBalance?: number;
    repairPrice?: number | null;
    assetRepairPayments?: AssetRepairPaymentUncheckedCreateNestedManyWithoutAssetDamageInput;
  };

  export type AssetDamageCreateOrConnectWithoutIndividualFoodStoreItemInput = {
    where: AssetDamageWhereUniqueInput;
    create: XOR<
      AssetDamageCreateWithoutIndividualFoodStoreItemInput,
      AssetDamageUncheckedCreateWithoutIndividualFoodStoreItemInput
    >;
  };

  export type AssetDamageCreateManyIndividualFoodStoreItemInputEnvelope = {
    data:
      | AssetDamageCreateManyIndividualFoodStoreItemInput
      | AssetDamageCreateManyIndividualFoodStoreItemInput[];
    skipDuplicates?: boolean;
  };

  export type FoodStoreItemCreateWithoutIndividualFoodStoreItemsInput = {
    id?: string;
    foodName: string;
    unit: $Enums.AssetUnit;
    quantity?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    trackQuantity?: boolean;
    status?: $Enums.AssetItemStatus;
    isConsumable?: boolean;
    consumptions?: FoodConsumptionCreateNestedManyWithoutFoodItemInput;
    asset: AssetCreateNestedOneWithoutFoodStoreItemsInput;
    supplier?: SupplierCreateNestedOneWithoutFoodStoreItemsInput;
  };

  export type FoodStoreItemUncheckedCreateWithoutIndividualFoodStoreItemsInput =
    {
      id?: string;
      assetId: string;
      foodName: string;
      unit: $Enums.AssetUnit;
      quantity?: number | null;
      createdAt?: Date | string;
      updatedAt?: Date | string;
      supplierId?: string | null;
      trackQuantity?: boolean;
      status?: $Enums.AssetItemStatus;
      isConsumable?: boolean;
      consumptions?: FoodConsumptionUncheckedCreateNestedManyWithoutFoodItemInput;
    };

  export type FoodStoreItemCreateOrConnectWithoutIndividualFoodStoreItemsInput =
    {
      where: FoodStoreItemWhereUniqueInput;
      create: XOR<
        FoodStoreItemCreateWithoutIndividualFoodStoreItemsInput,
        FoodStoreItemUncheckedCreateWithoutIndividualFoodStoreItemsInput
      >;
    };

  export type AssetDamageUpsertWithWhereUniqueWithoutIndividualFoodStoreItemInput =
    {
      where: AssetDamageWhereUniqueInput;
      update: XOR<
        AssetDamageUpdateWithoutIndividualFoodStoreItemInput,
        AssetDamageUncheckedUpdateWithoutIndividualFoodStoreItemInput
      >;
      create: XOR<
        AssetDamageCreateWithoutIndividualFoodStoreItemInput,
        AssetDamageUncheckedCreateWithoutIndividualFoodStoreItemInput
      >;
    };

  export type AssetDamageUpdateWithWhereUniqueWithoutIndividualFoodStoreItemInput =
    {
      where: AssetDamageWhereUniqueInput;
      data: XOR<
        AssetDamageUpdateWithoutIndividualFoodStoreItemInput,
        AssetDamageUncheckedUpdateWithoutIndividualFoodStoreItemInput
      >;
    };

  export type AssetDamageUpdateManyWithWhereWithoutIndividualFoodStoreItemInput =
    {
      where: AssetDamageScalarWhereInput;
      data: XOR<
        AssetDamageUpdateManyMutationInput,
        AssetDamageUncheckedUpdateManyWithoutIndividualFoodStoreItemInput
      >;
    };

  export type FoodStoreItemUpsertWithoutIndividualFoodStoreItemsInput = {
    update: XOR<
      FoodStoreItemUpdateWithoutIndividualFoodStoreItemsInput,
      FoodStoreItemUncheckedUpdateWithoutIndividualFoodStoreItemsInput
    >;
    create: XOR<
      FoodStoreItemCreateWithoutIndividualFoodStoreItemsInput,
      FoodStoreItemUncheckedCreateWithoutIndividualFoodStoreItemsInput
    >;
    where?: FoodStoreItemWhereInput;
  };

  export type FoodStoreItemUpdateToOneWithWhereWithoutIndividualFoodStoreItemsInput =
    {
      where?: FoodStoreItemWhereInput;
      data: XOR<
        FoodStoreItemUpdateWithoutIndividualFoodStoreItemsInput,
        FoodStoreItemUncheckedUpdateWithoutIndividualFoodStoreItemsInput
      >;
    };

  export type FoodStoreItemUpdateWithoutIndividualFoodStoreItemsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    foodName?: StringFieldUpdateOperationsInput | string;
    unit?: EnumAssetUnitFieldUpdateOperationsInput | $Enums.AssetUnit;
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    trackQuantity?: BoolFieldUpdateOperationsInput | boolean;
    status?:
      | EnumAssetItemStatusFieldUpdateOperationsInput
      | $Enums.AssetItemStatus;
    isConsumable?: BoolFieldUpdateOperationsInput | boolean;
    consumptions?: FoodConsumptionUpdateManyWithoutFoodItemNestedInput;
    asset?: AssetUpdateOneRequiredWithoutFoodStoreItemsNestedInput;
    supplier?: SupplierUpdateOneWithoutFoodStoreItemsNestedInput;
  };

  export type FoodStoreItemUncheckedUpdateWithoutIndividualFoodStoreItemsInput =
    {
      id?: StringFieldUpdateOperationsInput | string;
      assetId?: StringFieldUpdateOperationsInput | string;
      foodName?: StringFieldUpdateOperationsInput | string;
      unit?: EnumAssetUnitFieldUpdateOperationsInput | $Enums.AssetUnit;
      quantity?: NullableFloatFieldUpdateOperationsInput | number | null;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      supplierId?: NullableStringFieldUpdateOperationsInput | string | null;
      trackQuantity?: BoolFieldUpdateOperationsInput | boolean;
      status?:
        | EnumAssetItemStatusFieldUpdateOperationsInput
        | $Enums.AssetItemStatus;
      isConsumable?: BoolFieldUpdateOperationsInput | boolean;
      consumptions?: FoodConsumptionUncheckedUpdateManyWithoutFoodItemNestedInput;
    };

  export type FoodStoreItemCreateWithoutConsumptionsInput = {
    id?: string;
    foodName: string;
    unit: $Enums.AssetUnit;
    quantity?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    trackQuantity?: boolean;
    status?: $Enums.AssetItemStatus;
    isConsumable?: boolean;
    asset: AssetCreateNestedOneWithoutFoodStoreItemsInput;
    supplier?: SupplierCreateNestedOneWithoutFoodStoreItemsInput;
    individualFoodStoreItems?: IndividualFoodStoreItemCreateNestedManyWithoutFoodStoreItemInput;
  };

  export type FoodStoreItemUncheckedCreateWithoutConsumptionsInput = {
    id?: string;
    assetId: string;
    foodName: string;
    unit: $Enums.AssetUnit;
    quantity?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    supplierId?: string | null;
    trackQuantity?: boolean;
    status?: $Enums.AssetItemStatus;
    isConsumable?: boolean;
    individualFoodStoreItems?: IndividualFoodStoreItemUncheckedCreateNestedManyWithoutFoodStoreItemInput;
  };

  export type FoodStoreItemCreateOrConnectWithoutConsumptionsInput = {
    where: FoodStoreItemWhereUniqueInput;
    create: XOR<
      FoodStoreItemCreateWithoutConsumptionsInput,
      FoodStoreItemUncheckedCreateWithoutConsumptionsInput
    >;
  };

  export type FoodStoreItemUpsertWithoutConsumptionsInput = {
    update: XOR<
      FoodStoreItemUpdateWithoutConsumptionsInput,
      FoodStoreItemUncheckedUpdateWithoutConsumptionsInput
    >;
    create: XOR<
      FoodStoreItemCreateWithoutConsumptionsInput,
      FoodStoreItemUncheckedCreateWithoutConsumptionsInput
    >;
    where?: FoodStoreItemWhereInput;
  };

  export type FoodStoreItemUpdateToOneWithWhereWithoutConsumptionsInput = {
    where?: FoodStoreItemWhereInput;
    data: XOR<
      FoodStoreItemUpdateWithoutConsumptionsInput,
      FoodStoreItemUncheckedUpdateWithoutConsumptionsInput
    >;
  };

  export type FoodStoreItemUpdateWithoutConsumptionsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    foodName?: StringFieldUpdateOperationsInput | string;
    unit?: EnumAssetUnitFieldUpdateOperationsInput | $Enums.AssetUnit;
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    trackQuantity?: BoolFieldUpdateOperationsInput | boolean;
    status?:
      | EnumAssetItemStatusFieldUpdateOperationsInput
      | $Enums.AssetItemStatus;
    isConsumable?: BoolFieldUpdateOperationsInput | boolean;
    asset?: AssetUpdateOneRequiredWithoutFoodStoreItemsNestedInput;
    supplier?: SupplierUpdateOneWithoutFoodStoreItemsNestedInput;
    individualFoodStoreItems?: IndividualFoodStoreItemUpdateManyWithoutFoodStoreItemNestedInput;
  };

  export type FoodStoreItemUncheckedUpdateWithoutConsumptionsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    assetId?: StringFieldUpdateOperationsInput | string;
    foodName?: StringFieldUpdateOperationsInput | string;
    unit?: EnumAssetUnitFieldUpdateOperationsInput | $Enums.AssetUnit;
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null;
    trackQuantity?: BoolFieldUpdateOperationsInput | boolean;
    status?:
      | EnumAssetItemStatusFieldUpdateOperationsInput
      | $Enums.AssetItemStatus;
    isConsumable?: BoolFieldUpdateOperationsInput | boolean;
    individualFoodStoreItems?: IndividualFoodStoreItemUncheckedUpdateManyWithoutFoodStoreItemNestedInput;
  };

  export type FoodStoreItemCreateWithoutSupplierInput = {
    id?: string;
    foodName: string;
    unit: $Enums.AssetUnit;
    quantity?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    trackQuantity?: boolean;
    status?: $Enums.AssetItemStatus;
    isConsumable?: boolean;
    consumptions?: FoodConsumptionCreateNestedManyWithoutFoodItemInput;
    asset: AssetCreateNestedOneWithoutFoodStoreItemsInput;
    individualFoodStoreItems?: IndividualFoodStoreItemCreateNestedManyWithoutFoodStoreItemInput;
  };

  export type FoodStoreItemUncheckedCreateWithoutSupplierInput = {
    id?: string;
    assetId: string;
    foodName: string;
    unit: $Enums.AssetUnit;
    quantity?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    trackQuantity?: boolean;
    status?: $Enums.AssetItemStatus;
    isConsumable?: boolean;
    consumptions?: FoodConsumptionUncheckedCreateNestedManyWithoutFoodItemInput;
    individualFoodStoreItems?: IndividualFoodStoreItemUncheckedCreateNestedManyWithoutFoodStoreItemInput;
  };

  export type FoodStoreItemCreateOrConnectWithoutSupplierInput = {
    where: FoodStoreItemWhereUniqueInput;
    create: XOR<
      FoodStoreItemCreateWithoutSupplierInput,
      FoodStoreItemUncheckedCreateWithoutSupplierInput
    >;
  };

  export type FoodStoreItemCreateManySupplierInputEnvelope = {
    data:
      | FoodStoreItemCreateManySupplierInput
      | FoodStoreItemCreateManySupplierInput[];
    skipDuplicates?: boolean;
  };

  export type FoodStoreItemUpsertWithWhereUniqueWithoutSupplierInput = {
    where: FoodStoreItemWhereUniqueInput;
    update: XOR<
      FoodStoreItemUpdateWithoutSupplierInput,
      FoodStoreItemUncheckedUpdateWithoutSupplierInput
    >;
    create: XOR<
      FoodStoreItemCreateWithoutSupplierInput,
      FoodStoreItemUncheckedCreateWithoutSupplierInput
    >;
  };

  export type FoodStoreItemUpdateWithWhereUniqueWithoutSupplierInput = {
    where: FoodStoreItemWhereUniqueInput;
    data: XOR<
      FoodStoreItemUpdateWithoutSupplierInput,
      FoodStoreItemUncheckedUpdateWithoutSupplierInput
    >;
  };

  export type FoodStoreItemUpdateManyWithWhereWithoutSupplierInput = {
    where: FoodStoreItemScalarWhereInput;
    data: XOR<
      FoodStoreItemUpdateManyMutationInput,
      FoodStoreItemUncheckedUpdateManyWithoutSupplierInput
    >;
  };

  export type IndividualBookCreateWithoutLibraryBookInput = {
    id?: string;
    isbn?: string | null;
    status?: $Enums.BookStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    condition?: $Enums.AssetCondition;
    borrowCount?: number;
    bookDamages?: AssetDamageCreateNestedManyWithoutIndividualBookInput;
    borrowers?: BorrowerCreateNestedManyWithoutLibraryBookInput;
  };

  export type IndividualBookUncheckedCreateWithoutLibraryBookInput = {
    id?: string;
    isbn?: string | null;
    status?: $Enums.BookStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    condition?: $Enums.AssetCondition;
    borrowCount?: number;
    bookDamages?: AssetDamageUncheckedCreateNestedManyWithoutIndividualBookInput;
    borrowers?: BorrowerUncheckedCreateNestedManyWithoutLibraryBookInput;
  };

  export type IndividualBookCreateOrConnectWithoutLibraryBookInput = {
    where: IndividualBookWhereUniqueInput;
    create: XOR<
      IndividualBookCreateWithoutLibraryBookInput,
      IndividualBookUncheckedCreateWithoutLibraryBookInput
    >;
  };

  export type IndividualBookCreateManyLibraryBookInputEnvelope = {
    data:
      | IndividualBookCreateManyLibraryBookInput
      | IndividualBookCreateManyLibraryBookInput[];
    skipDuplicates?: boolean;
  };

  export type AssetCreateWithoutLibraryBooksInput = {
    id?: string;
    name: string;
    description?: string | null;
    category: $Enums.AssetCategory;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    computerLabItems?: ComputerLabItemCreateNestedManyWithoutAssetInput;
    foodStoreItems?: FoodStoreItemCreateNestedManyWithoutAssetInput;
    generalStoreItems?: GeneralStoreItemCreateNestedManyWithoutAssetInput;
    labItems?: LabItemCreateNestedManyWithoutAssetInput;
  };

  export type AssetUncheckedCreateWithoutLibraryBooksInput = {
    id?: string;
    name: string;
    description?: string | null;
    category: $Enums.AssetCategory;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    computerLabItems?: ComputerLabItemUncheckedCreateNestedManyWithoutAssetInput;
    foodStoreItems?: FoodStoreItemUncheckedCreateNestedManyWithoutAssetInput;
    generalStoreItems?: GeneralStoreItemUncheckedCreateNestedManyWithoutAssetInput;
    labItems?: LabItemUncheckedCreateNestedManyWithoutAssetInput;
  };

  export type AssetCreateOrConnectWithoutLibraryBooksInput = {
    where: AssetWhereUniqueInput;
    create: XOR<
      AssetCreateWithoutLibraryBooksInput,
      AssetUncheckedCreateWithoutLibraryBooksInput
    >;
  };

  export type LibraryBookCategoryCreateWithoutLibraryBooksInput = {
    id?: string;
    category: string;
    description?: string | null;
  };

  export type LibraryBookCategoryUncheckedCreateWithoutLibraryBooksInput = {
    id?: string;
    category: string;
    description?: string | null;
  };

  export type LibraryBookCategoryCreateOrConnectWithoutLibraryBooksInput = {
    where: LibraryBookCategoryWhereUniqueInput;
    create: XOR<
      LibraryBookCategoryCreateWithoutLibraryBooksInput,
      LibraryBookCategoryUncheckedCreateWithoutLibraryBooksInput
    >;
  };

  export type IndividualBookUpsertWithWhereUniqueWithoutLibraryBookInput = {
    where: IndividualBookWhereUniqueInput;
    update: XOR<
      IndividualBookUpdateWithoutLibraryBookInput,
      IndividualBookUncheckedUpdateWithoutLibraryBookInput
    >;
    create: XOR<
      IndividualBookCreateWithoutLibraryBookInput,
      IndividualBookUncheckedCreateWithoutLibraryBookInput
    >;
  };

  export type IndividualBookUpdateWithWhereUniqueWithoutLibraryBookInput = {
    where: IndividualBookWhereUniqueInput;
    data: XOR<
      IndividualBookUpdateWithoutLibraryBookInput,
      IndividualBookUncheckedUpdateWithoutLibraryBookInput
    >;
  };

  export type IndividualBookUpdateManyWithWhereWithoutLibraryBookInput = {
    where: IndividualBookScalarWhereInput;
    data: XOR<
      IndividualBookUpdateManyMutationInput,
      IndividualBookUncheckedUpdateManyWithoutLibraryBookInput
    >;
  };

  export type IndividualBookScalarWhereInput = {
    AND?: IndividualBookScalarWhereInput | IndividualBookScalarWhereInput[];
    OR?: IndividualBookScalarWhereInput[];
    NOT?: IndividualBookScalarWhereInput | IndividualBookScalarWhereInput[];
    id?: StringFilter<"IndividualBook"> | string;
    isbn?: StringNullableFilter<"IndividualBook"> | string | null;
    status?: EnumBookStatusFilter<"IndividualBook"> | $Enums.BookStatus;
    createdAt?: DateTimeFilter<"IndividualBook"> | Date | string;
    updatedAt?: DateTimeFilter<"IndividualBook"> | Date | string;
    libraryBookId?: StringFilter<"IndividualBook"> | string;
    condition?:
      | EnumAssetConditionFilter<"IndividualBook">
      | $Enums.AssetCondition;
    borrowCount?: IntFilter<"IndividualBook"> | number;
  };

  export type AssetUpsertWithoutLibraryBooksInput = {
    update: XOR<
      AssetUpdateWithoutLibraryBooksInput,
      AssetUncheckedUpdateWithoutLibraryBooksInput
    >;
    create: XOR<
      AssetCreateWithoutLibraryBooksInput,
      AssetUncheckedCreateWithoutLibraryBooksInput
    >;
    where?: AssetWhereInput;
  };

  export type AssetUpdateToOneWithWhereWithoutLibraryBooksInput = {
    where?: AssetWhereInput;
    data: XOR<
      AssetUpdateWithoutLibraryBooksInput,
      AssetUncheckedUpdateWithoutLibraryBooksInput
    >;
  };

  export type AssetUpdateWithoutLibraryBooksInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    category?:
      | EnumAssetCategoryFieldUpdateOperationsInput
      | $Enums.AssetCategory;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    computerLabItems?: ComputerLabItemUpdateManyWithoutAssetNestedInput;
    foodStoreItems?: FoodStoreItemUpdateManyWithoutAssetNestedInput;
    generalStoreItems?: GeneralStoreItemUpdateManyWithoutAssetNestedInput;
    labItems?: LabItemUpdateManyWithoutAssetNestedInput;
  };

  export type AssetUncheckedUpdateWithoutLibraryBooksInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    category?:
      | EnumAssetCategoryFieldUpdateOperationsInput
      | $Enums.AssetCategory;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    computerLabItems?: ComputerLabItemUncheckedUpdateManyWithoutAssetNestedInput;
    foodStoreItems?: FoodStoreItemUncheckedUpdateManyWithoutAssetNestedInput;
    generalStoreItems?: GeneralStoreItemUncheckedUpdateManyWithoutAssetNestedInput;
    labItems?: LabItemUncheckedUpdateManyWithoutAssetNestedInput;
  };

  export type LibraryBookCategoryUpsertWithoutLibraryBooksInput = {
    update: XOR<
      LibraryBookCategoryUpdateWithoutLibraryBooksInput,
      LibraryBookCategoryUncheckedUpdateWithoutLibraryBooksInput
    >;
    create: XOR<
      LibraryBookCategoryCreateWithoutLibraryBooksInput,
      LibraryBookCategoryUncheckedCreateWithoutLibraryBooksInput
    >;
    where?: LibraryBookCategoryWhereInput;
  };

  export type LibraryBookCategoryUpdateToOneWithWhereWithoutLibraryBooksInput =
    {
      where?: LibraryBookCategoryWhereInput;
      data: XOR<
        LibraryBookCategoryUpdateWithoutLibraryBooksInput,
        LibraryBookCategoryUncheckedUpdateWithoutLibraryBooksInput
      >;
    };

  export type LibraryBookCategoryUpdateWithoutLibraryBooksInput = {
    id?: StringFieldUpdateOperationsInput | string;
    category?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type LibraryBookCategoryUncheckedUpdateWithoutLibraryBooksInput = {
    id?: StringFieldUpdateOperationsInput | string;
    category?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type AssetDamageCreateWithoutIndividualBookInput = {
    id?: string;
    damageDetails: string;
    condition: $Enums.AssetCondition;
    quantity: number;
    isRepaired?: boolean;
    repairedAt?: Date | string | null;
    createdAt?: Date | string;
    isSchoolCost?: boolean;
    repairBalance?: number;
    repairPrice?: number | null;
    individualComputerLabItem?: IndividualComputerLabItemCreateNestedOneWithoutAssetDamagesInput;
    individualFoodStoreItem?: IndividualFoodStoreItemCreateNestedOneWithoutAssetDamagesInput;
    individualGeneralStoreItem?: IndividualGeneralStoreItemCreateNestedOneWithoutAssetDamagesInput;
    individualLabItem?: IndividualLabItemCreateNestedOneWithoutAssetDamagesInput;
    damagedBy?: UserCreateNestedOneWithoutAssetDamagesInput;
    assetRepairPayments?: AssetRepairPaymentCreateNestedManyWithoutAssetDamageInput;
  };

  export type AssetDamageUncheckedCreateWithoutIndividualBookInput = {
    id?: string;
    damageDetails: string;
    condition: $Enums.AssetCondition;
    quantity: number;
    userId?: string | null;
    individualComputerLabItemId?: string | null;
    isRepaired?: boolean;
    repairedAt?: Date | string | null;
    createdAt?: Date | string;
    individualLabItemId?: string | null;
    individualFoodStoreItemId?: string | null;
    individualGeneralStoreItemId?: string | null;
    isSchoolCost?: boolean;
    repairBalance?: number;
    repairPrice?: number | null;
    assetRepairPayments?: AssetRepairPaymentUncheckedCreateNestedManyWithoutAssetDamageInput;
  };

  export type AssetDamageCreateOrConnectWithoutIndividualBookInput = {
    where: AssetDamageWhereUniqueInput;
    create: XOR<
      AssetDamageCreateWithoutIndividualBookInput,
      AssetDamageUncheckedCreateWithoutIndividualBookInput
    >;
  };

  export type AssetDamageCreateManyIndividualBookInputEnvelope = {
    data:
      | AssetDamageCreateManyIndividualBookInput
      | AssetDamageCreateManyIndividualBookInput[];
    skipDuplicates?: boolean;
  };

  export type BorrowerCreateWithoutLibraryBookInput = {
    id?: string;
    borrowedAt?: Date | string;
    returnAt?: Date | string | null;
    status?: $Enums.BorrowStatus;
    user: UserCreateNestedOneWithoutBorrowersInput;
  };

  export type BorrowerUncheckedCreateWithoutLibraryBookInput = {
    id?: string;
    borrowedAt?: Date | string;
    returnAt?: Date | string | null;
    status?: $Enums.BorrowStatus;
    userId: string;
  };

  export type BorrowerCreateOrConnectWithoutLibraryBookInput = {
    where: BorrowerWhereUniqueInput;
    create: XOR<
      BorrowerCreateWithoutLibraryBookInput,
      BorrowerUncheckedCreateWithoutLibraryBookInput
    >;
  };

  export type BorrowerCreateManyLibraryBookInputEnvelope = {
    data:
      | BorrowerCreateManyLibraryBookInput
      | BorrowerCreateManyLibraryBookInput[];
    skipDuplicates?: boolean;
  };

  export type LibraryBookCreateWithoutIndividualBooksInput = {
    id?: string;
    title: string;
    author: string;
    quantity?: number | null;
    trackQuantity?: boolean;
    unit: $Enums.AssetUnit;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    asset: AssetCreateNestedOneWithoutLibraryBooksInput;
    category: LibraryBookCategoryCreateNestedOneWithoutLibraryBooksInput;
  };

  export type LibraryBookUncheckedCreateWithoutIndividualBooksInput = {
    id?: string;
    title: string;
    author: string;
    assetId: string;
    libraryBookCategoryId: string;
    quantity?: number | null;
    trackQuantity?: boolean;
    unit: $Enums.AssetUnit;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type LibraryBookCreateOrConnectWithoutIndividualBooksInput = {
    where: LibraryBookWhereUniqueInput;
    create: XOR<
      LibraryBookCreateWithoutIndividualBooksInput,
      LibraryBookUncheckedCreateWithoutIndividualBooksInput
    >;
  };

  export type AssetDamageUpsertWithWhereUniqueWithoutIndividualBookInput = {
    where: AssetDamageWhereUniqueInput;
    update: XOR<
      AssetDamageUpdateWithoutIndividualBookInput,
      AssetDamageUncheckedUpdateWithoutIndividualBookInput
    >;
    create: XOR<
      AssetDamageCreateWithoutIndividualBookInput,
      AssetDamageUncheckedCreateWithoutIndividualBookInput
    >;
  };

  export type AssetDamageUpdateWithWhereUniqueWithoutIndividualBookInput = {
    where: AssetDamageWhereUniqueInput;
    data: XOR<
      AssetDamageUpdateWithoutIndividualBookInput,
      AssetDamageUncheckedUpdateWithoutIndividualBookInput
    >;
  };

  export type AssetDamageUpdateManyWithWhereWithoutIndividualBookInput = {
    where: AssetDamageScalarWhereInput;
    data: XOR<
      AssetDamageUpdateManyMutationInput,
      AssetDamageUncheckedUpdateManyWithoutIndividualBookInput
    >;
  };

  export type BorrowerUpsertWithWhereUniqueWithoutLibraryBookInput = {
    where: BorrowerWhereUniqueInput;
    update: XOR<
      BorrowerUpdateWithoutLibraryBookInput,
      BorrowerUncheckedUpdateWithoutLibraryBookInput
    >;
    create: XOR<
      BorrowerCreateWithoutLibraryBookInput,
      BorrowerUncheckedCreateWithoutLibraryBookInput
    >;
  };

  export type BorrowerUpdateWithWhereUniqueWithoutLibraryBookInput = {
    where: BorrowerWhereUniqueInput;
    data: XOR<
      BorrowerUpdateWithoutLibraryBookInput,
      BorrowerUncheckedUpdateWithoutLibraryBookInput
    >;
  };

  export type BorrowerUpdateManyWithWhereWithoutLibraryBookInput = {
    where: BorrowerScalarWhereInput;
    data: XOR<
      BorrowerUpdateManyMutationInput,
      BorrowerUncheckedUpdateManyWithoutLibraryBookInput
    >;
  };

  export type LibraryBookUpsertWithoutIndividualBooksInput = {
    update: XOR<
      LibraryBookUpdateWithoutIndividualBooksInput,
      LibraryBookUncheckedUpdateWithoutIndividualBooksInput
    >;
    create: XOR<
      LibraryBookCreateWithoutIndividualBooksInput,
      LibraryBookUncheckedCreateWithoutIndividualBooksInput
    >;
    where?: LibraryBookWhereInput;
  };

  export type LibraryBookUpdateToOneWithWhereWithoutIndividualBooksInput = {
    where?: LibraryBookWhereInput;
    data: XOR<
      LibraryBookUpdateWithoutIndividualBooksInput,
      LibraryBookUncheckedUpdateWithoutIndividualBooksInput
    >;
  };

  export type LibraryBookUpdateWithoutIndividualBooksInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    author?: StringFieldUpdateOperationsInput | string;
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null;
    trackQuantity?: BoolFieldUpdateOperationsInput | boolean;
    unit?: EnumAssetUnitFieldUpdateOperationsInput | $Enums.AssetUnit;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    asset?: AssetUpdateOneRequiredWithoutLibraryBooksNestedInput;
    category?: LibraryBookCategoryUpdateOneRequiredWithoutLibraryBooksNestedInput;
  };

  export type LibraryBookUncheckedUpdateWithoutIndividualBooksInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    author?: StringFieldUpdateOperationsInput | string;
    assetId?: StringFieldUpdateOperationsInput | string;
    libraryBookCategoryId?: StringFieldUpdateOperationsInput | string;
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null;
    trackQuantity?: BoolFieldUpdateOperationsInput | boolean;
    unit?: EnumAssetUnitFieldUpdateOperationsInput | $Enums.AssetUnit;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type LibraryBookCreateWithoutCategoryInput = {
    id?: string;
    title: string;
    author: string;
    quantity?: number | null;
    trackQuantity?: boolean;
    unit: $Enums.AssetUnit;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    individualBooks?: IndividualBookCreateNestedManyWithoutLibraryBookInput;
    asset: AssetCreateNestedOneWithoutLibraryBooksInput;
  };

  export type LibraryBookUncheckedCreateWithoutCategoryInput = {
    id?: string;
    title: string;
    author: string;
    assetId: string;
    quantity?: number | null;
    trackQuantity?: boolean;
    unit: $Enums.AssetUnit;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    individualBooks?: IndividualBookUncheckedCreateNestedManyWithoutLibraryBookInput;
  };

  export type LibraryBookCreateOrConnectWithoutCategoryInput = {
    where: LibraryBookWhereUniqueInput;
    create: XOR<
      LibraryBookCreateWithoutCategoryInput,
      LibraryBookUncheckedCreateWithoutCategoryInput
    >;
  };

  export type LibraryBookCreateManyCategoryInputEnvelope = {
    data:
      | LibraryBookCreateManyCategoryInput
      | LibraryBookCreateManyCategoryInput[];
    skipDuplicates?: boolean;
  };

  export type LibraryBookUpsertWithWhereUniqueWithoutCategoryInput = {
    where: LibraryBookWhereUniqueInput;
    update: XOR<
      LibraryBookUpdateWithoutCategoryInput,
      LibraryBookUncheckedUpdateWithoutCategoryInput
    >;
    create: XOR<
      LibraryBookCreateWithoutCategoryInput,
      LibraryBookUncheckedCreateWithoutCategoryInput
    >;
  };

  export type LibraryBookUpdateWithWhereUniqueWithoutCategoryInput = {
    where: LibraryBookWhereUniqueInput;
    data: XOR<
      LibraryBookUpdateWithoutCategoryInput,
      LibraryBookUncheckedUpdateWithoutCategoryInput
    >;
  };

  export type LibraryBookUpdateManyWithWhereWithoutCategoryInput = {
    where: LibraryBookScalarWhereInput;
    data: XOR<
      LibraryBookUpdateManyMutationInput,
      LibraryBookUncheckedUpdateManyWithoutCategoryInput
    >;
  };

  export type IndividualBookCreateWithoutBorrowersInput = {
    id?: string;
    isbn?: string | null;
    status?: $Enums.BookStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    condition?: $Enums.AssetCondition;
    borrowCount?: number;
    bookDamages?: AssetDamageCreateNestedManyWithoutIndividualBookInput;
    libraryBook: LibraryBookCreateNestedOneWithoutIndividualBooksInput;
  };

  export type IndividualBookUncheckedCreateWithoutBorrowersInput = {
    id?: string;
    isbn?: string | null;
    status?: $Enums.BookStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    libraryBookId: string;
    condition?: $Enums.AssetCondition;
    borrowCount?: number;
    bookDamages?: AssetDamageUncheckedCreateNestedManyWithoutIndividualBookInput;
  };

  export type IndividualBookCreateOrConnectWithoutBorrowersInput = {
    where: IndividualBookWhereUniqueInput;
    create: XOR<
      IndividualBookCreateWithoutBorrowersInput,
      IndividualBookUncheckedCreateWithoutBorrowersInput
    >;
  };

  export type UserCreateWithoutBorrowersInput = {
    id?: string;
    name?: string | null;
    username?: string | null;
    email?: string | null;
    avatarUrl?: string | null;
    role?: $Enums.Role | null;
    createdAt?: Date | string;
    telephone?: string | null;
    passwordHash?: string | null;
    googleId?: string | null;
    bio?: string | null;
    isWelcomed?: boolean;
    isVerified?: boolean;
    emailVerified?: boolean;
    assetDamages?: AssetDamageCreateNestedManyWithoutDamagedByInput;
    assetRepairPayments?: AssetRepairPaymentCreateNestedManyWithoutReceivedByInput;
    emailVerificationTokens?: EmailVerificationTokenCreateNestedManyWithoutUserInput;
    feesPayments?: FeesPaymentCreateNestedManyWithoutPaidByInput;
    pupils?: PupilCreateNestedManyWithoutUserInput;
    sessions?: SessionCreateNestedManyWithoutUserInput;
    staffs?: StaffCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutBorrowersInput = {
    id?: string;
    name?: string | null;
    username?: string | null;
    email?: string | null;
    avatarUrl?: string | null;
    role?: $Enums.Role | null;
    createdAt?: Date | string;
    telephone?: string | null;
    passwordHash?: string | null;
    googleId?: string | null;
    bio?: string | null;
    isWelcomed?: boolean;
    isVerified?: boolean;
    emailVerified?: boolean;
    assetDamages?: AssetDamageUncheckedCreateNestedManyWithoutDamagedByInput;
    assetRepairPayments?: AssetRepairPaymentUncheckedCreateNestedManyWithoutReceivedByInput;
    emailVerificationTokens?: EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput;
    feesPayments?: FeesPaymentUncheckedCreateNestedManyWithoutPaidByInput;
    pupils?: PupilUncheckedCreateNestedManyWithoutUserInput;
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput;
    staffs?: StaffUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutBorrowersInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutBorrowersInput,
      UserUncheckedCreateWithoutBorrowersInput
    >;
  };

  export type IndividualBookUpsertWithoutBorrowersInput = {
    update: XOR<
      IndividualBookUpdateWithoutBorrowersInput,
      IndividualBookUncheckedUpdateWithoutBorrowersInput
    >;
    create: XOR<
      IndividualBookCreateWithoutBorrowersInput,
      IndividualBookUncheckedCreateWithoutBorrowersInput
    >;
    where?: IndividualBookWhereInput;
  };

  export type IndividualBookUpdateToOneWithWhereWithoutBorrowersInput = {
    where?: IndividualBookWhereInput;
    data: XOR<
      IndividualBookUpdateWithoutBorrowersInput,
      IndividualBookUncheckedUpdateWithoutBorrowersInput
    >;
  };

  export type IndividualBookUpdateWithoutBorrowersInput = {
    id?: StringFieldUpdateOperationsInput | string;
    isbn?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumBookStatusFieldUpdateOperationsInput | $Enums.BookStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    condition?:
      | EnumAssetConditionFieldUpdateOperationsInput
      | $Enums.AssetCondition;
    borrowCount?: IntFieldUpdateOperationsInput | number;
    bookDamages?: AssetDamageUpdateManyWithoutIndividualBookNestedInput;
    libraryBook?: LibraryBookUpdateOneRequiredWithoutIndividualBooksNestedInput;
  };

  export type IndividualBookUncheckedUpdateWithoutBorrowersInput = {
    id?: StringFieldUpdateOperationsInput | string;
    isbn?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumBookStatusFieldUpdateOperationsInput | $Enums.BookStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    libraryBookId?: StringFieldUpdateOperationsInput | string;
    condition?:
      | EnumAssetConditionFieldUpdateOperationsInput
      | $Enums.AssetCondition;
    borrowCount?: IntFieldUpdateOperationsInput | number;
    bookDamages?: AssetDamageUncheckedUpdateManyWithoutIndividualBookNestedInput;
  };

  export type UserUpsertWithoutBorrowersInput = {
    update: XOR<
      UserUpdateWithoutBorrowersInput,
      UserUncheckedUpdateWithoutBorrowersInput
    >;
    create: XOR<
      UserCreateWithoutBorrowersInput,
      UserUncheckedCreateWithoutBorrowersInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutBorrowersInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutBorrowersInput,
      UserUncheckedUpdateWithoutBorrowersInput
    >;
  };

  export type UserUpdateWithoutBorrowersInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    telephone?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    googleId?: NullableStringFieldUpdateOperationsInput | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    isWelcomed?: BoolFieldUpdateOperationsInput | boolean;
    isVerified?: BoolFieldUpdateOperationsInput | boolean;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    assetDamages?: AssetDamageUpdateManyWithoutDamagedByNestedInput;
    assetRepairPayments?: AssetRepairPaymentUpdateManyWithoutReceivedByNestedInput;
    emailVerificationTokens?: EmailVerificationTokenUpdateManyWithoutUserNestedInput;
    feesPayments?: FeesPaymentUpdateManyWithoutPaidByNestedInput;
    pupils?: PupilUpdateManyWithoutUserNestedInput;
    sessions?: SessionUpdateManyWithoutUserNestedInput;
    staffs?: StaffUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutBorrowersInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    telephone?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    googleId?: NullableStringFieldUpdateOperationsInput | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    isWelcomed?: BoolFieldUpdateOperationsInput | boolean;
    isVerified?: BoolFieldUpdateOperationsInput | boolean;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    assetDamages?: AssetDamageUncheckedUpdateManyWithoutDamagedByNestedInput;
    assetRepairPayments?: AssetRepairPaymentUncheckedUpdateManyWithoutReceivedByNestedInput;
    emailVerificationTokens?: EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput;
    feesPayments?: FeesPaymentUncheckedUpdateManyWithoutPaidByNestedInput;
    pupils?: PupilUncheckedUpdateManyWithoutUserNestedInput;
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput;
    staffs?: StaffUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type IndividualLabItemCreateWithoutLabItemInput = {
    id?: string;
    uniqueIdentifier?: string | null;
    status?: $Enums.AssetStatus;
    condition?: $Enums.AssetCondition;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    assetDamages?: AssetDamageCreateNestedManyWithoutIndividualLabItemInput;
  };

  export type IndividualLabItemUncheckedCreateWithoutLabItemInput = {
    id?: string;
    uniqueIdentifier?: string | null;
    status?: $Enums.AssetStatus;
    condition?: $Enums.AssetCondition;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    assetDamages?: AssetDamageUncheckedCreateNestedManyWithoutIndividualLabItemInput;
  };

  export type IndividualLabItemCreateOrConnectWithoutLabItemInput = {
    where: IndividualLabItemWhereUniqueInput;
    create: XOR<
      IndividualLabItemCreateWithoutLabItemInput,
      IndividualLabItemUncheckedCreateWithoutLabItemInput
    >;
  };

  export type IndividualLabItemCreateManyLabItemInputEnvelope = {
    data:
      | IndividualLabItemCreateManyLabItemInput
      | IndividualLabItemCreateManyLabItemInput[];
    skipDuplicates?: boolean;
  };

  export type AssetCreateWithoutLabItemsInput = {
    id?: string;
    name: string;
    description?: string | null;
    category: $Enums.AssetCategory;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    computerLabItems?: ComputerLabItemCreateNestedManyWithoutAssetInput;
    foodStoreItems?: FoodStoreItemCreateNestedManyWithoutAssetInput;
    generalStoreItems?: GeneralStoreItemCreateNestedManyWithoutAssetInput;
    libraryBooks?: LibraryBookCreateNestedManyWithoutAssetInput;
  };

  export type AssetUncheckedCreateWithoutLabItemsInput = {
    id?: string;
    name: string;
    description?: string | null;
    category: $Enums.AssetCategory;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    computerLabItems?: ComputerLabItemUncheckedCreateNestedManyWithoutAssetInput;
    foodStoreItems?: FoodStoreItemUncheckedCreateNestedManyWithoutAssetInput;
    generalStoreItems?: GeneralStoreItemUncheckedCreateNestedManyWithoutAssetInput;
    libraryBooks?: LibraryBookUncheckedCreateNestedManyWithoutAssetInput;
  };

  export type AssetCreateOrConnectWithoutLabItemsInput = {
    where: AssetWhereUniqueInput;
    create: XOR<
      AssetCreateWithoutLabItemsInput,
      AssetUncheckedCreateWithoutLabItemsInput
    >;
  };

  export type IndividualLabItemUpsertWithWhereUniqueWithoutLabItemInput = {
    where: IndividualLabItemWhereUniqueInput;
    update: XOR<
      IndividualLabItemUpdateWithoutLabItemInput,
      IndividualLabItemUncheckedUpdateWithoutLabItemInput
    >;
    create: XOR<
      IndividualLabItemCreateWithoutLabItemInput,
      IndividualLabItemUncheckedCreateWithoutLabItemInput
    >;
  };

  export type IndividualLabItemUpdateWithWhereUniqueWithoutLabItemInput = {
    where: IndividualLabItemWhereUniqueInput;
    data: XOR<
      IndividualLabItemUpdateWithoutLabItemInput,
      IndividualLabItemUncheckedUpdateWithoutLabItemInput
    >;
  };

  export type IndividualLabItemUpdateManyWithWhereWithoutLabItemInput = {
    where: IndividualLabItemScalarWhereInput;
    data: XOR<
      IndividualLabItemUpdateManyMutationInput,
      IndividualLabItemUncheckedUpdateManyWithoutLabItemInput
    >;
  };

  export type IndividualLabItemScalarWhereInput = {
    AND?:
      | IndividualLabItemScalarWhereInput
      | IndividualLabItemScalarWhereInput[];
    OR?: IndividualLabItemScalarWhereInput[];
    NOT?:
      | IndividualLabItemScalarWhereInput
      | IndividualLabItemScalarWhereInput[];
    id?: StringFilter<"IndividualLabItem"> | string;
    labItemId?: StringFilter<"IndividualLabItem"> | string;
    uniqueIdentifier?:
      | StringNullableFilter<"IndividualLabItem">
      | string
      | null;
    status?: EnumAssetStatusFilter<"IndividualLabItem"> | $Enums.AssetStatus;
    condition?:
      | EnumAssetConditionFilter<"IndividualLabItem">
      | $Enums.AssetCondition;
    createdAt?: DateTimeFilter<"IndividualLabItem"> | Date | string;
    updatedAt?: DateTimeFilter<"IndividualLabItem"> | Date | string;
  };

  export type AssetUpsertWithoutLabItemsInput = {
    update: XOR<
      AssetUpdateWithoutLabItemsInput,
      AssetUncheckedUpdateWithoutLabItemsInput
    >;
    create: XOR<
      AssetCreateWithoutLabItemsInput,
      AssetUncheckedCreateWithoutLabItemsInput
    >;
    where?: AssetWhereInput;
  };

  export type AssetUpdateToOneWithWhereWithoutLabItemsInput = {
    where?: AssetWhereInput;
    data: XOR<
      AssetUpdateWithoutLabItemsInput,
      AssetUncheckedUpdateWithoutLabItemsInput
    >;
  };

  export type AssetUpdateWithoutLabItemsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    category?:
      | EnumAssetCategoryFieldUpdateOperationsInput
      | $Enums.AssetCategory;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    computerLabItems?: ComputerLabItemUpdateManyWithoutAssetNestedInput;
    foodStoreItems?: FoodStoreItemUpdateManyWithoutAssetNestedInput;
    generalStoreItems?: GeneralStoreItemUpdateManyWithoutAssetNestedInput;
    libraryBooks?: LibraryBookUpdateManyWithoutAssetNestedInput;
  };

  export type AssetUncheckedUpdateWithoutLabItemsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    category?:
      | EnumAssetCategoryFieldUpdateOperationsInput
      | $Enums.AssetCategory;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    computerLabItems?: ComputerLabItemUncheckedUpdateManyWithoutAssetNestedInput;
    foodStoreItems?: FoodStoreItemUncheckedUpdateManyWithoutAssetNestedInput;
    generalStoreItems?: GeneralStoreItemUncheckedUpdateManyWithoutAssetNestedInput;
    libraryBooks?: LibraryBookUncheckedUpdateManyWithoutAssetNestedInput;
  };

  export type AssetDamageCreateWithoutIndividualLabItemInput = {
    id?: string;
    damageDetails: string;
    condition: $Enums.AssetCondition;
    quantity: number;
    isRepaired?: boolean;
    repairedAt?: Date | string | null;
    createdAt?: Date | string;
    isSchoolCost?: boolean;
    repairBalance?: number;
    repairPrice?: number | null;
    individualBook?: IndividualBookCreateNestedOneWithoutBookDamagesInput;
    individualComputerLabItem?: IndividualComputerLabItemCreateNestedOneWithoutAssetDamagesInput;
    individualFoodStoreItem?: IndividualFoodStoreItemCreateNestedOneWithoutAssetDamagesInput;
    individualGeneralStoreItem?: IndividualGeneralStoreItemCreateNestedOneWithoutAssetDamagesInput;
    damagedBy?: UserCreateNestedOneWithoutAssetDamagesInput;
    assetRepairPayments?: AssetRepairPaymentCreateNestedManyWithoutAssetDamageInput;
  };

  export type AssetDamageUncheckedCreateWithoutIndividualLabItemInput = {
    id?: string;
    damageDetails: string;
    condition: $Enums.AssetCondition;
    quantity: number;
    userId?: string | null;
    individualComputerLabItemId?: string | null;
    isRepaired?: boolean;
    repairedAt?: Date | string | null;
    createdAt?: Date | string;
    individualBookId?: string | null;
    individualFoodStoreItemId?: string | null;
    individualGeneralStoreItemId?: string | null;
    isSchoolCost?: boolean;
    repairBalance?: number;
    repairPrice?: number | null;
    assetRepairPayments?: AssetRepairPaymentUncheckedCreateNestedManyWithoutAssetDamageInput;
  };

  export type AssetDamageCreateOrConnectWithoutIndividualLabItemInput = {
    where: AssetDamageWhereUniqueInput;
    create: XOR<
      AssetDamageCreateWithoutIndividualLabItemInput,
      AssetDamageUncheckedCreateWithoutIndividualLabItemInput
    >;
  };

  export type AssetDamageCreateManyIndividualLabItemInputEnvelope = {
    data:
      | AssetDamageCreateManyIndividualLabItemInput
      | AssetDamageCreateManyIndividualLabItemInput[];
    skipDuplicates?: boolean;
  };

  export type LabItemCreateWithoutIndividualLabItemsInput = {
    id?: string;
    name: string;
    quantity?: number | null;
    unit: $Enums.AssetUnit;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    trackQuantity?: boolean;
    status?: $Enums.AssetStatus;
    asset: AssetCreateNestedOneWithoutLabItemsInput;
  };

  export type LabItemUncheckedCreateWithoutIndividualLabItemsInput = {
    id?: string;
    name: string;
    quantity?: number | null;
    unit: $Enums.AssetUnit;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    assetId: string;
    trackQuantity?: boolean;
    status?: $Enums.AssetStatus;
  };

  export type LabItemCreateOrConnectWithoutIndividualLabItemsInput = {
    where: LabItemWhereUniqueInput;
    create: XOR<
      LabItemCreateWithoutIndividualLabItemsInput,
      LabItemUncheckedCreateWithoutIndividualLabItemsInput
    >;
  };

  export type AssetDamageUpsertWithWhereUniqueWithoutIndividualLabItemInput = {
    where: AssetDamageWhereUniqueInput;
    update: XOR<
      AssetDamageUpdateWithoutIndividualLabItemInput,
      AssetDamageUncheckedUpdateWithoutIndividualLabItemInput
    >;
    create: XOR<
      AssetDamageCreateWithoutIndividualLabItemInput,
      AssetDamageUncheckedCreateWithoutIndividualLabItemInput
    >;
  };

  export type AssetDamageUpdateWithWhereUniqueWithoutIndividualLabItemInput = {
    where: AssetDamageWhereUniqueInput;
    data: XOR<
      AssetDamageUpdateWithoutIndividualLabItemInput,
      AssetDamageUncheckedUpdateWithoutIndividualLabItemInput
    >;
  };

  export type AssetDamageUpdateManyWithWhereWithoutIndividualLabItemInput = {
    where: AssetDamageScalarWhereInput;
    data: XOR<
      AssetDamageUpdateManyMutationInput,
      AssetDamageUncheckedUpdateManyWithoutIndividualLabItemInput
    >;
  };

  export type LabItemUpsertWithoutIndividualLabItemsInput = {
    update: XOR<
      LabItemUpdateWithoutIndividualLabItemsInput,
      LabItemUncheckedUpdateWithoutIndividualLabItemsInput
    >;
    create: XOR<
      LabItemCreateWithoutIndividualLabItemsInput,
      LabItemUncheckedCreateWithoutIndividualLabItemsInput
    >;
    where?: LabItemWhereInput;
  };

  export type LabItemUpdateToOneWithWhereWithoutIndividualLabItemsInput = {
    where?: LabItemWhereInput;
    data: XOR<
      LabItemUpdateWithoutIndividualLabItemsInput,
      LabItemUncheckedUpdateWithoutIndividualLabItemsInput
    >;
  };

  export type LabItemUpdateWithoutIndividualLabItemsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null;
    unit?: EnumAssetUnitFieldUpdateOperationsInput | $Enums.AssetUnit;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    trackQuantity?: BoolFieldUpdateOperationsInput | boolean;
    status?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus;
    asset?: AssetUpdateOneRequiredWithoutLabItemsNestedInput;
  };

  export type LabItemUncheckedUpdateWithoutIndividualLabItemsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null;
    unit?: EnumAssetUnitFieldUpdateOperationsInput | $Enums.AssetUnit;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    assetId?: StringFieldUpdateOperationsInput | string;
    trackQuantity?: BoolFieldUpdateOperationsInput | boolean;
    status?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus;
  };

  export type AssetCreateWithoutComputerLabItemsInput = {
    id?: string;
    name: string;
    description?: string | null;
    category: $Enums.AssetCategory;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    foodStoreItems?: FoodStoreItemCreateNestedManyWithoutAssetInput;
    generalStoreItems?: GeneralStoreItemCreateNestedManyWithoutAssetInput;
    labItems?: LabItemCreateNestedManyWithoutAssetInput;
    libraryBooks?: LibraryBookCreateNestedManyWithoutAssetInput;
  };

  export type AssetUncheckedCreateWithoutComputerLabItemsInput = {
    id?: string;
    name: string;
    description?: string | null;
    category: $Enums.AssetCategory;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    foodStoreItems?: FoodStoreItemUncheckedCreateNestedManyWithoutAssetInput;
    generalStoreItems?: GeneralStoreItemUncheckedCreateNestedManyWithoutAssetInput;
    labItems?: LabItemUncheckedCreateNestedManyWithoutAssetInput;
    libraryBooks?: LibraryBookUncheckedCreateNestedManyWithoutAssetInput;
  };

  export type AssetCreateOrConnectWithoutComputerLabItemsInput = {
    where: AssetWhereUniqueInput;
    create: XOR<
      AssetCreateWithoutComputerLabItemsInput,
      AssetUncheckedCreateWithoutComputerLabItemsInput
    >;
  };

  export type IndividualComputerLabItemCreateWithoutComputerLabItemInput = {
    id?: string;
    uniqueIdentifier?: string | null;
    status?: $Enums.AssetStatus;
    condition?: $Enums.AssetCondition;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    assetDamages?: AssetDamageCreateNestedManyWithoutIndividualComputerLabItemInput;
  };

  export type IndividualComputerLabItemUncheckedCreateWithoutComputerLabItemInput =
    {
      id?: string;
      uniqueIdentifier?: string | null;
      status?: $Enums.AssetStatus;
      condition?: $Enums.AssetCondition;
      createdAt?: Date | string;
      updatedAt?: Date | string;
      assetDamages?: AssetDamageUncheckedCreateNestedManyWithoutIndividualComputerLabItemInput;
    };

  export type IndividualComputerLabItemCreateOrConnectWithoutComputerLabItemInput =
    {
      where: IndividualComputerLabItemWhereUniqueInput;
      create: XOR<
        IndividualComputerLabItemCreateWithoutComputerLabItemInput,
        IndividualComputerLabItemUncheckedCreateWithoutComputerLabItemInput
      >;
    };

  export type IndividualComputerLabItemCreateManyComputerLabItemInputEnvelope =
    {
      data:
        | IndividualComputerLabItemCreateManyComputerLabItemInput
        | IndividualComputerLabItemCreateManyComputerLabItemInput[];
      skipDuplicates?: boolean;
    };

  export type AssetUpsertWithoutComputerLabItemsInput = {
    update: XOR<
      AssetUpdateWithoutComputerLabItemsInput,
      AssetUncheckedUpdateWithoutComputerLabItemsInput
    >;
    create: XOR<
      AssetCreateWithoutComputerLabItemsInput,
      AssetUncheckedCreateWithoutComputerLabItemsInput
    >;
    where?: AssetWhereInput;
  };

  export type AssetUpdateToOneWithWhereWithoutComputerLabItemsInput = {
    where?: AssetWhereInput;
    data: XOR<
      AssetUpdateWithoutComputerLabItemsInput,
      AssetUncheckedUpdateWithoutComputerLabItemsInput
    >;
  };

  export type AssetUpdateWithoutComputerLabItemsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    category?:
      | EnumAssetCategoryFieldUpdateOperationsInput
      | $Enums.AssetCategory;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    foodStoreItems?: FoodStoreItemUpdateManyWithoutAssetNestedInput;
    generalStoreItems?: GeneralStoreItemUpdateManyWithoutAssetNestedInput;
    labItems?: LabItemUpdateManyWithoutAssetNestedInput;
    libraryBooks?: LibraryBookUpdateManyWithoutAssetNestedInput;
  };

  export type AssetUncheckedUpdateWithoutComputerLabItemsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    category?:
      | EnumAssetCategoryFieldUpdateOperationsInput
      | $Enums.AssetCategory;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    foodStoreItems?: FoodStoreItemUncheckedUpdateManyWithoutAssetNestedInput;
    generalStoreItems?: GeneralStoreItemUncheckedUpdateManyWithoutAssetNestedInput;
    labItems?: LabItemUncheckedUpdateManyWithoutAssetNestedInput;
    libraryBooks?: LibraryBookUncheckedUpdateManyWithoutAssetNestedInput;
  };

  export type IndividualComputerLabItemUpsertWithWhereUniqueWithoutComputerLabItemInput =
    {
      where: IndividualComputerLabItemWhereUniqueInput;
      update: XOR<
        IndividualComputerLabItemUpdateWithoutComputerLabItemInput,
        IndividualComputerLabItemUncheckedUpdateWithoutComputerLabItemInput
      >;
      create: XOR<
        IndividualComputerLabItemCreateWithoutComputerLabItemInput,
        IndividualComputerLabItemUncheckedCreateWithoutComputerLabItemInput
      >;
    };

  export type IndividualComputerLabItemUpdateWithWhereUniqueWithoutComputerLabItemInput =
    {
      where: IndividualComputerLabItemWhereUniqueInput;
      data: XOR<
        IndividualComputerLabItemUpdateWithoutComputerLabItemInput,
        IndividualComputerLabItemUncheckedUpdateWithoutComputerLabItemInput
      >;
    };

  export type IndividualComputerLabItemUpdateManyWithWhereWithoutComputerLabItemInput =
    {
      where: IndividualComputerLabItemScalarWhereInput;
      data: XOR<
        IndividualComputerLabItemUpdateManyMutationInput,
        IndividualComputerLabItemUncheckedUpdateManyWithoutComputerLabItemInput
      >;
    };

  export type IndividualComputerLabItemScalarWhereInput = {
    AND?:
      | IndividualComputerLabItemScalarWhereInput
      | IndividualComputerLabItemScalarWhereInput[];
    OR?: IndividualComputerLabItemScalarWhereInput[];
    NOT?:
      | IndividualComputerLabItemScalarWhereInput
      | IndividualComputerLabItemScalarWhereInput[];
    id?: StringFilter<"IndividualComputerLabItem"> | string;
    computerLabItemId?: StringFilter<"IndividualComputerLabItem"> | string;
    uniqueIdentifier?:
      | StringNullableFilter<"IndividualComputerLabItem">
      | string
      | null;
    status?:
      | EnumAssetStatusFilter<"IndividualComputerLabItem">
      | $Enums.AssetStatus;
    condition?:
      | EnumAssetConditionFilter<"IndividualComputerLabItem">
      | $Enums.AssetCondition;
    createdAt?: DateTimeFilter<"IndividualComputerLabItem"> | Date | string;
    updatedAt?: DateTimeFilter<"IndividualComputerLabItem"> | Date | string;
  };

  export type AssetDamageCreateWithoutIndividualComputerLabItemInput = {
    id?: string;
    damageDetails: string;
    condition: $Enums.AssetCondition;
    quantity: number;
    isRepaired?: boolean;
    repairedAt?: Date | string | null;
    createdAt?: Date | string;
    isSchoolCost?: boolean;
    repairBalance?: number;
    repairPrice?: number | null;
    individualBook?: IndividualBookCreateNestedOneWithoutBookDamagesInput;
    individualFoodStoreItem?: IndividualFoodStoreItemCreateNestedOneWithoutAssetDamagesInput;
    individualGeneralStoreItem?: IndividualGeneralStoreItemCreateNestedOneWithoutAssetDamagesInput;
    individualLabItem?: IndividualLabItemCreateNestedOneWithoutAssetDamagesInput;
    damagedBy?: UserCreateNestedOneWithoutAssetDamagesInput;
    assetRepairPayments?: AssetRepairPaymentCreateNestedManyWithoutAssetDamageInput;
  };

  export type AssetDamageUncheckedCreateWithoutIndividualComputerLabItemInput =
    {
      id?: string;
      damageDetails: string;
      condition: $Enums.AssetCondition;
      quantity: number;
      userId?: string | null;
      isRepaired?: boolean;
      repairedAt?: Date | string | null;
      createdAt?: Date | string;
      individualBookId?: string | null;
      individualLabItemId?: string | null;
      individualFoodStoreItemId?: string | null;
      individualGeneralStoreItemId?: string | null;
      isSchoolCost?: boolean;
      repairBalance?: number;
      repairPrice?: number | null;
      assetRepairPayments?: AssetRepairPaymentUncheckedCreateNestedManyWithoutAssetDamageInput;
    };

  export type AssetDamageCreateOrConnectWithoutIndividualComputerLabItemInput =
    {
      where: AssetDamageWhereUniqueInput;
      create: XOR<
        AssetDamageCreateWithoutIndividualComputerLabItemInput,
        AssetDamageUncheckedCreateWithoutIndividualComputerLabItemInput
      >;
    };

  export type AssetDamageCreateManyIndividualComputerLabItemInputEnvelope = {
    data:
      | AssetDamageCreateManyIndividualComputerLabItemInput
      | AssetDamageCreateManyIndividualComputerLabItemInput[];
    skipDuplicates?: boolean;
  };

  export type ComputerLabItemCreateWithoutIndividualComputerLabItemsInput = {
    id?: string;
    name: string;
    model?: string | null;
    specification?: string | null;
    quantity?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    trackQuantity?: boolean;
    unit: $Enums.AssetUnit;
    asset: AssetCreateNestedOneWithoutComputerLabItemsInput;
  };

  export type ComputerLabItemUncheckedCreateWithoutIndividualComputerLabItemsInput =
    {
      id?: string;
      name: string;
      model?: string | null;
      specification?: string | null;
      quantity?: number | null;
      createdAt?: Date | string;
      updatedAt?: Date | string;
      assetId: string;
      trackQuantity?: boolean;
      unit: $Enums.AssetUnit;
    };

  export type ComputerLabItemCreateOrConnectWithoutIndividualComputerLabItemsInput =
    {
      where: ComputerLabItemWhereUniqueInput;
      create: XOR<
        ComputerLabItemCreateWithoutIndividualComputerLabItemsInput,
        ComputerLabItemUncheckedCreateWithoutIndividualComputerLabItemsInput
      >;
    };

  export type AssetDamageUpsertWithWhereUniqueWithoutIndividualComputerLabItemInput =
    {
      where: AssetDamageWhereUniqueInput;
      update: XOR<
        AssetDamageUpdateWithoutIndividualComputerLabItemInput,
        AssetDamageUncheckedUpdateWithoutIndividualComputerLabItemInput
      >;
      create: XOR<
        AssetDamageCreateWithoutIndividualComputerLabItemInput,
        AssetDamageUncheckedCreateWithoutIndividualComputerLabItemInput
      >;
    };

  export type AssetDamageUpdateWithWhereUniqueWithoutIndividualComputerLabItemInput =
    {
      where: AssetDamageWhereUniqueInput;
      data: XOR<
        AssetDamageUpdateWithoutIndividualComputerLabItemInput,
        AssetDamageUncheckedUpdateWithoutIndividualComputerLabItemInput
      >;
    };

  export type AssetDamageUpdateManyWithWhereWithoutIndividualComputerLabItemInput =
    {
      where: AssetDamageScalarWhereInput;
      data: XOR<
        AssetDamageUpdateManyMutationInput,
        AssetDamageUncheckedUpdateManyWithoutIndividualComputerLabItemInput
      >;
    };

  export type ComputerLabItemUpsertWithoutIndividualComputerLabItemsInput = {
    update: XOR<
      ComputerLabItemUpdateWithoutIndividualComputerLabItemsInput,
      ComputerLabItemUncheckedUpdateWithoutIndividualComputerLabItemsInput
    >;
    create: XOR<
      ComputerLabItemCreateWithoutIndividualComputerLabItemsInput,
      ComputerLabItemUncheckedCreateWithoutIndividualComputerLabItemsInput
    >;
    where?: ComputerLabItemWhereInput;
  };

  export type ComputerLabItemUpdateToOneWithWhereWithoutIndividualComputerLabItemsInput =
    {
      where?: ComputerLabItemWhereInput;
      data: XOR<
        ComputerLabItemUpdateWithoutIndividualComputerLabItemsInput,
        ComputerLabItemUncheckedUpdateWithoutIndividualComputerLabItemsInput
      >;
    };

  export type ComputerLabItemUpdateWithoutIndividualComputerLabItemsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    model?: NullableStringFieldUpdateOperationsInput | string | null;
    specification?: NullableStringFieldUpdateOperationsInput | string | null;
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    trackQuantity?: BoolFieldUpdateOperationsInput | boolean;
    unit?: EnumAssetUnitFieldUpdateOperationsInput | $Enums.AssetUnit;
    asset?: AssetUpdateOneRequiredWithoutComputerLabItemsNestedInput;
  };

  export type ComputerLabItemUncheckedUpdateWithoutIndividualComputerLabItemsInput =
    {
      id?: StringFieldUpdateOperationsInput | string;
      name?: StringFieldUpdateOperationsInput | string;
      model?: NullableStringFieldUpdateOperationsInput | string | null;
      specification?: NullableStringFieldUpdateOperationsInput | string | null;
      quantity?: NullableFloatFieldUpdateOperationsInput | number | null;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      assetId?: StringFieldUpdateOperationsInput | string;
      trackQuantity?: BoolFieldUpdateOperationsInput | boolean;
      unit?: EnumAssetUnitFieldUpdateOperationsInput | $Enums.AssetUnit;
    };

  export type AssetCreateWithoutGeneralStoreItemsInput = {
    id?: string;
    name: string;
    description?: string | null;
    category: $Enums.AssetCategory;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    computerLabItems?: ComputerLabItemCreateNestedManyWithoutAssetInput;
    foodStoreItems?: FoodStoreItemCreateNestedManyWithoutAssetInput;
    labItems?: LabItemCreateNestedManyWithoutAssetInput;
    libraryBooks?: LibraryBookCreateNestedManyWithoutAssetInput;
  };

  export type AssetUncheckedCreateWithoutGeneralStoreItemsInput = {
    id?: string;
    name: string;
    description?: string | null;
    category: $Enums.AssetCategory;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    computerLabItems?: ComputerLabItemUncheckedCreateNestedManyWithoutAssetInput;
    foodStoreItems?: FoodStoreItemUncheckedCreateNestedManyWithoutAssetInput;
    labItems?: LabItemUncheckedCreateNestedManyWithoutAssetInput;
    libraryBooks?: LibraryBookUncheckedCreateNestedManyWithoutAssetInput;
  };

  export type AssetCreateOrConnectWithoutGeneralStoreItemsInput = {
    where: AssetWhereUniqueInput;
    create: XOR<
      AssetCreateWithoutGeneralStoreItemsInput,
      AssetUncheckedCreateWithoutGeneralStoreItemsInput
    >;
  };

  export type IndividualGeneralStoreItemCreateWithoutGeneralStoreItemInput = {
    id?: string;
    uniqueIdentifier?: string | null;
    status?: $Enums.AssetStatus;
    condition?: $Enums.AssetCondition;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    assetDamages?: AssetDamageCreateNestedManyWithoutIndividualGeneralStoreItemInput;
  };

  export type IndividualGeneralStoreItemUncheckedCreateWithoutGeneralStoreItemInput =
    {
      id?: string;
      uniqueIdentifier?: string | null;
      status?: $Enums.AssetStatus;
      condition?: $Enums.AssetCondition;
      createdAt?: Date | string;
      updatedAt?: Date | string;
      assetDamages?: AssetDamageUncheckedCreateNestedManyWithoutIndividualGeneralStoreItemInput;
    };

  export type IndividualGeneralStoreItemCreateOrConnectWithoutGeneralStoreItemInput =
    {
      where: IndividualGeneralStoreItemWhereUniqueInput;
      create: XOR<
        IndividualGeneralStoreItemCreateWithoutGeneralStoreItemInput,
        IndividualGeneralStoreItemUncheckedCreateWithoutGeneralStoreItemInput
      >;
    };

  export type IndividualGeneralStoreItemCreateManyGeneralStoreItemInputEnvelope =
    {
      data:
        | IndividualGeneralStoreItemCreateManyGeneralStoreItemInput
        | IndividualGeneralStoreItemCreateManyGeneralStoreItemInput[];
      skipDuplicates?: boolean;
    };

  export type AssetUpsertWithoutGeneralStoreItemsInput = {
    update: XOR<
      AssetUpdateWithoutGeneralStoreItemsInput,
      AssetUncheckedUpdateWithoutGeneralStoreItemsInput
    >;
    create: XOR<
      AssetCreateWithoutGeneralStoreItemsInput,
      AssetUncheckedCreateWithoutGeneralStoreItemsInput
    >;
    where?: AssetWhereInput;
  };

  export type AssetUpdateToOneWithWhereWithoutGeneralStoreItemsInput = {
    where?: AssetWhereInput;
    data: XOR<
      AssetUpdateWithoutGeneralStoreItemsInput,
      AssetUncheckedUpdateWithoutGeneralStoreItemsInput
    >;
  };

  export type AssetUpdateWithoutGeneralStoreItemsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    category?:
      | EnumAssetCategoryFieldUpdateOperationsInput
      | $Enums.AssetCategory;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    computerLabItems?: ComputerLabItemUpdateManyWithoutAssetNestedInput;
    foodStoreItems?: FoodStoreItemUpdateManyWithoutAssetNestedInput;
    labItems?: LabItemUpdateManyWithoutAssetNestedInput;
    libraryBooks?: LibraryBookUpdateManyWithoutAssetNestedInput;
  };

  export type AssetUncheckedUpdateWithoutGeneralStoreItemsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    category?:
      | EnumAssetCategoryFieldUpdateOperationsInput
      | $Enums.AssetCategory;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    computerLabItems?: ComputerLabItemUncheckedUpdateManyWithoutAssetNestedInput;
    foodStoreItems?: FoodStoreItemUncheckedUpdateManyWithoutAssetNestedInput;
    labItems?: LabItemUncheckedUpdateManyWithoutAssetNestedInput;
    libraryBooks?: LibraryBookUncheckedUpdateManyWithoutAssetNestedInput;
  };

  export type IndividualGeneralStoreItemUpsertWithWhereUniqueWithoutGeneralStoreItemInput =
    {
      where: IndividualGeneralStoreItemWhereUniqueInput;
      update: XOR<
        IndividualGeneralStoreItemUpdateWithoutGeneralStoreItemInput,
        IndividualGeneralStoreItemUncheckedUpdateWithoutGeneralStoreItemInput
      >;
      create: XOR<
        IndividualGeneralStoreItemCreateWithoutGeneralStoreItemInput,
        IndividualGeneralStoreItemUncheckedCreateWithoutGeneralStoreItemInput
      >;
    };

  export type IndividualGeneralStoreItemUpdateWithWhereUniqueWithoutGeneralStoreItemInput =
    {
      where: IndividualGeneralStoreItemWhereUniqueInput;
      data: XOR<
        IndividualGeneralStoreItemUpdateWithoutGeneralStoreItemInput,
        IndividualGeneralStoreItemUncheckedUpdateWithoutGeneralStoreItemInput
      >;
    };

  export type IndividualGeneralStoreItemUpdateManyWithWhereWithoutGeneralStoreItemInput =
    {
      where: IndividualGeneralStoreItemScalarWhereInput;
      data: XOR<
        IndividualGeneralStoreItemUpdateManyMutationInput,
        IndividualGeneralStoreItemUncheckedUpdateManyWithoutGeneralStoreItemInput
      >;
    };

  export type IndividualGeneralStoreItemScalarWhereInput = {
    AND?:
      | IndividualGeneralStoreItemScalarWhereInput
      | IndividualGeneralStoreItemScalarWhereInput[];
    OR?: IndividualGeneralStoreItemScalarWhereInput[];
    NOT?:
      | IndividualGeneralStoreItemScalarWhereInput
      | IndividualGeneralStoreItemScalarWhereInput[];
    id?: StringFilter<"IndividualGeneralStoreItem"> | string;
    generalStoreItemId?: StringFilter<"IndividualGeneralStoreItem"> | string;
    uniqueIdentifier?:
      | StringNullableFilter<"IndividualGeneralStoreItem">
      | string
      | null;
    status?:
      | EnumAssetStatusFilter<"IndividualGeneralStoreItem">
      | $Enums.AssetStatus;
    condition?:
      | EnumAssetConditionFilter<"IndividualGeneralStoreItem">
      | $Enums.AssetCondition;
    createdAt?: DateTimeFilter<"IndividualGeneralStoreItem"> | Date | string;
    updatedAt?: DateTimeFilter<"IndividualGeneralStoreItem"> | Date | string;
  };

  export type AssetDamageCreateWithoutIndividualGeneralStoreItemInput = {
    id?: string;
    damageDetails: string;
    condition: $Enums.AssetCondition;
    quantity: number;
    isRepaired?: boolean;
    repairedAt?: Date | string | null;
    createdAt?: Date | string;
    isSchoolCost?: boolean;
    repairBalance?: number;
    repairPrice?: number | null;
    individualBook?: IndividualBookCreateNestedOneWithoutBookDamagesInput;
    individualComputerLabItem?: IndividualComputerLabItemCreateNestedOneWithoutAssetDamagesInput;
    individualFoodStoreItem?: IndividualFoodStoreItemCreateNestedOneWithoutAssetDamagesInput;
    individualLabItem?: IndividualLabItemCreateNestedOneWithoutAssetDamagesInput;
    damagedBy?: UserCreateNestedOneWithoutAssetDamagesInput;
    assetRepairPayments?: AssetRepairPaymentCreateNestedManyWithoutAssetDamageInput;
  };

  export type AssetDamageUncheckedCreateWithoutIndividualGeneralStoreItemInput =
    {
      id?: string;
      damageDetails: string;
      condition: $Enums.AssetCondition;
      quantity: number;
      userId?: string | null;
      individualComputerLabItemId?: string | null;
      isRepaired?: boolean;
      repairedAt?: Date | string | null;
      createdAt?: Date | string;
      individualBookId?: string | null;
      individualLabItemId?: string | null;
      individualFoodStoreItemId?: string | null;
      isSchoolCost?: boolean;
      repairBalance?: number;
      repairPrice?: number | null;
      assetRepairPayments?: AssetRepairPaymentUncheckedCreateNestedManyWithoutAssetDamageInput;
    };

  export type AssetDamageCreateOrConnectWithoutIndividualGeneralStoreItemInput =
    {
      where: AssetDamageWhereUniqueInput;
      create: XOR<
        AssetDamageCreateWithoutIndividualGeneralStoreItemInput,
        AssetDamageUncheckedCreateWithoutIndividualGeneralStoreItemInput
      >;
    };

  export type AssetDamageCreateManyIndividualGeneralStoreItemInputEnvelope = {
    data:
      | AssetDamageCreateManyIndividualGeneralStoreItemInput
      | AssetDamageCreateManyIndividualGeneralStoreItemInput[];
    skipDuplicates?: boolean;
  };

  export type GeneralStoreItemCreateWithoutIndividualGeneralStoreItemsInput = {
    id?: string;
    name: string;
    quantity?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    status?: $Enums.AssetItemStatus;
    trackQuantity?: boolean;
    unit: $Enums.AssetUnit;
    asset: AssetCreateNestedOneWithoutGeneralStoreItemsInput;
  };

  export type GeneralStoreItemUncheckedCreateWithoutIndividualGeneralStoreItemsInput =
    {
      id?: string;
      name: string;
      quantity?: number | null;
      createdAt?: Date | string;
      updatedAt?: Date | string;
      assetId: string;
      status?: $Enums.AssetItemStatus;
      trackQuantity?: boolean;
      unit: $Enums.AssetUnit;
    };

  export type GeneralStoreItemCreateOrConnectWithoutIndividualGeneralStoreItemsInput =
    {
      where: GeneralStoreItemWhereUniqueInput;
      create: XOR<
        GeneralStoreItemCreateWithoutIndividualGeneralStoreItemsInput,
        GeneralStoreItemUncheckedCreateWithoutIndividualGeneralStoreItemsInput
      >;
    };

  export type AssetDamageUpsertWithWhereUniqueWithoutIndividualGeneralStoreItemInput =
    {
      where: AssetDamageWhereUniqueInput;
      update: XOR<
        AssetDamageUpdateWithoutIndividualGeneralStoreItemInput,
        AssetDamageUncheckedUpdateWithoutIndividualGeneralStoreItemInput
      >;
      create: XOR<
        AssetDamageCreateWithoutIndividualGeneralStoreItemInput,
        AssetDamageUncheckedCreateWithoutIndividualGeneralStoreItemInput
      >;
    };

  export type AssetDamageUpdateWithWhereUniqueWithoutIndividualGeneralStoreItemInput =
    {
      where: AssetDamageWhereUniqueInput;
      data: XOR<
        AssetDamageUpdateWithoutIndividualGeneralStoreItemInput,
        AssetDamageUncheckedUpdateWithoutIndividualGeneralStoreItemInput
      >;
    };

  export type AssetDamageUpdateManyWithWhereWithoutIndividualGeneralStoreItemInput =
    {
      where: AssetDamageScalarWhereInput;
      data: XOR<
        AssetDamageUpdateManyMutationInput,
        AssetDamageUncheckedUpdateManyWithoutIndividualGeneralStoreItemInput
      >;
    };

  export type GeneralStoreItemUpsertWithoutIndividualGeneralStoreItemsInput = {
    update: XOR<
      GeneralStoreItemUpdateWithoutIndividualGeneralStoreItemsInput,
      GeneralStoreItemUncheckedUpdateWithoutIndividualGeneralStoreItemsInput
    >;
    create: XOR<
      GeneralStoreItemCreateWithoutIndividualGeneralStoreItemsInput,
      GeneralStoreItemUncheckedCreateWithoutIndividualGeneralStoreItemsInput
    >;
    where?: GeneralStoreItemWhereInput;
  };

  export type GeneralStoreItemUpdateToOneWithWhereWithoutIndividualGeneralStoreItemsInput =
    {
      where?: GeneralStoreItemWhereInput;
      data: XOR<
        GeneralStoreItemUpdateWithoutIndividualGeneralStoreItemsInput,
        GeneralStoreItemUncheckedUpdateWithoutIndividualGeneralStoreItemsInput
      >;
    };

  export type GeneralStoreItemUpdateWithoutIndividualGeneralStoreItemsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    status?:
      | EnumAssetItemStatusFieldUpdateOperationsInput
      | $Enums.AssetItemStatus;
    trackQuantity?: BoolFieldUpdateOperationsInput | boolean;
    unit?: EnumAssetUnitFieldUpdateOperationsInput | $Enums.AssetUnit;
    asset?: AssetUpdateOneRequiredWithoutGeneralStoreItemsNestedInput;
  };

  export type GeneralStoreItemUncheckedUpdateWithoutIndividualGeneralStoreItemsInput =
    {
      id?: StringFieldUpdateOperationsInput | string;
      name?: StringFieldUpdateOperationsInput | string;
      quantity?: NullableFloatFieldUpdateOperationsInput | number | null;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      assetId?: StringFieldUpdateOperationsInput | string;
      status?:
        | EnumAssetItemStatusFieldUpdateOperationsInput
        | $Enums.AssetItemStatus;
      trackQuantity?: BoolFieldUpdateOperationsInput | boolean;
      unit?: EnumAssetUnitFieldUpdateOperationsInput | $Enums.AssetUnit;
    };

  export type IndividualBookCreateWithoutBookDamagesInput = {
    id?: string;
    isbn?: string | null;
    status?: $Enums.BookStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    condition?: $Enums.AssetCondition;
    borrowCount?: number;
    borrowers?: BorrowerCreateNestedManyWithoutLibraryBookInput;
    libraryBook: LibraryBookCreateNestedOneWithoutIndividualBooksInput;
  };

  export type IndividualBookUncheckedCreateWithoutBookDamagesInput = {
    id?: string;
    isbn?: string | null;
    status?: $Enums.BookStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    libraryBookId: string;
    condition?: $Enums.AssetCondition;
    borrowCount?: number;
    borrowers?: BorrowerUncheckedCreateNestedManyWithoutLibraryBookInput;
  };

  export type IndividualBookCreateOrConnectWithoutBookDamagesInput = {
    where: IndividualBookWhereUniqueInput;
    create: XOR<
      IndividualBookCreateWithoutBookDamagesInput,
      IndividualBookUncheckedCreateWithoutBookDamagesInput
    >;
  };

  export type IndividualComputerLabItemCreateWithoutAssetDamagesInput = {
    id?: string;
    uniqueIdentifier?: string | null;
    status?: $Enums.AssetStatus;
    condition?: $Enums.AssetCondition;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    computerLabItem: ComputerLabItemCreateNestedOneWithoutIndividualComputerLabItemsInput;
  };

  export type IndividualComputerLabItemUncheckedCreateWithoutAssetDamagesInput =
    {
      id?: string;
      computerLabItemId: string;
      uniqueIdentifier?: string | null;
      status?: $Enums.AssetStatus;
      condition?: $Enums.AssetCondition;
      createdAt?: Date | string;
      updatedAt?: Date | string;
    };

  export type IndividualComputerLabItemCreateOrConnectWithoutAssetDamagesInput =
    {
      where: IndividualComputerLabItemWhereUniqueInput;
      create: XOR<
        IndividualComputerLabItemCreateWithoutAssetDamagesInput,
        IndividualComputerLabItemUncheckedCreateWithoutAssetDamagesInput
      >;
    };

  export type IndividualFoodStoreItemCreateWithoutAssetDamagesInput = {
    id?: string;
    uniqueIdentifier?: string | null;
    status?: $Enums.AssetStatus;
    condition?: $Enums.AssetCondition;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    foodStoreItem: FoodStoreItemCreateNestedOneWithoutIndividualFoodStoreItemsInput;
  };

  export type IndividualFoodStoreItemUncheckedCreateWithoutAssetDamagesInput = {
    id?: string;
    foodStoreItemId: string;
    uniqueIdentifier?: string | null;
    status?: $Enums.AssetStatus;
    condition?: $Enums.AssetCondition;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type IndividualFoodStoreItemCreateOrConnectWithoutAssetDamagesInput = {
    where: IndividualFoodStoreItemWhereUniqueInput;
    create: XOR<
      IndividualFoodStoreItemCreateWithoutAssetDamagesInput,
      IndividualFoodStoreItemUncheckedCreateWithoutAssetDamagesInput
    >;
  };

  export type IndividualGeneralStoreItemCreateWithoutAssetDamagesInput = {
    id?: string;
    uniqueIdentifier?: string | null;
    status?: $Enums.AssetStatus;
    condition?: $Enums.AssetCondition;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    generalStoreItem: GeneralStoreItemCreateNestedOneWithoutIndividualGeneralStoreItemsInput;
  };

  export type IndividualGeneralStoreItemUncheckedCreateWithoutAssetDamagesInput =
    {
      id?: string;
      generalStoreItemId: string;
      uniqueIdentifier?: string | null;
      status?: $Enums.AssetStatus;
      condition?: $Enums.AssetCondition;
      createdAt?: Date | string;
      updatedAt?: Date | string;
    };

  export type IndividualGeneralStoreItemCreateOrConnectWithoutAssetDamagesInput =
    {
      where: IndividualGeneralStoreItemWhereUniqueInput;
      create: XOR<
        IndividualGeneralStoreItemCreateWithoutAssetDamagesInput,
        IndividualGeneralStoreItemUncheckedCreateWithoutAssetDamagesInput
      >;
    };

  export type IndividualLabItemCreateWithoutAssetDamagesInput = {
    id?: string;
    uniqueIdentifier?: string | null;
    status?: $Enums.AssetStatus;
    condition?: $Enums.AssetCondition;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    labItem: LabItemCreateNestedOneWithoutIndividualLabItemsInput;
  };

  export type IndividualLabItemUncheckedCreateWithoutAssetDamagesInput = {
    id?: string;
    labItemId: string;
    uniqueIdentifier?: string | null;
    status?: $Enums.AssetStatus;
    condition?: $Enums.AssetCondition;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type IndividualLabItemCreateOrConnectWithoutAssetDamagesInput = {
    where: IndividualLabItemWhereUniqueInput;
    create: XOR<
      IndividualLabItemCreateWithoutAssetDamagesInput,
      IndividualLabItemUncheckedCreateWithoutAssetDamagesInput
    >;
  };

  export type UserCreateWithoutAssetDamagesInput = {
    id?: string;
    name?: string | null;
    username?: string | null;
    email?: string | null;
    avatarUrl?: string | null;
    role?: $Enums.Role | null;
    createdAt?: Date | string;
    telephone?: string | null;
    passwordHash?: string | null;
    googleId?: string | null;
    bio?: string | null;
    isWelcomed?: boolean;
    isVerified?: boolean;
    emailVerified?: boolean;
    assetRepairPayments?: AssetRepairPaymentCreateNestedManyWithoutReceivedByInput;
    borrowers?: BorrowerCreateNestedManyWithoutUserInput;
    emailVerificationTokens?: EmailVerificationTokenCreateNestedManyWithoutUserInput;
    feesPayments?: FeesPaymentCreateNestedManyWithoutPaidByInput;
    pupils?: PupilCreateNestedManyWithoutUserInput;
    sessions?: SessionCreateNestedManyWithoutUserInput;
    staffs?: StaffCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutAssetDamagesInput = {
    id?: string;
    name?: string | null;
    username?: string | null;
    email?: string | null;
    avatarUrl?: string | null;
    role?: $Enums.Role | null;
    createdAt?: Date | string;
    telephone?: string | null;
    passwordHash?: string | null;
    googleId?: string | null;
    bio?: string | null;
    isWelcomed?: boolean;
    isVerified?: boolean;
    emailVerified?: boolean;
    assetRepairPayments?: AssetRepairPaymentUncheckedCreateNestedManyWithoutReceivedByInput;
    borrowers?: BorrowerUncheckedCreateNestedManyWithoutUserInput;
    emailVerificationTokens?: EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput;
    feesPayments?: FeesPaymentUncheckedCreateNestedManyWithoutPaidByInput;
    pupils?: PupilUncheckedCreateNestedManyWithoutUserInput;
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput;
    staffs?: StaffUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutAssetDamagesInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutAssetDamagesInput,
      UserUncheckedCreateWithoutAssetDamagesInput
    >;
  };

  export type AssetRepairPaymentCreateWithoutAssetDamageInput = {
    id?: string;
    paidAmount: number;
    paidAt?: Date | string;
    updatedAt?: Date | string;
    isSchoolCost?: boolean;
    receivedBy?: UserCreateNestedOneWithoutAssetRepairPaymentsInput;
  };

  export type AssetRepairPaymentUncheckedCreateWithoutAssetDamageInput = {
    id?: string;
    paidAmount: number;
    paidAt?: Date | string;
    updatedAt?: Date | string;
    userId?: string | null;
    isSchoolCost?: boolean;
  };

  export type AssetRepairPaymentCreateOrConnectWithoutAssetDamageInput = {
    where: AssetRepairPaymentWhereUniqueInput;
    create: XOR<
      AssetRepairPaymentCreateWithoutAssetDamageInput,
      AssetRepairPaymentUncheckedCreateWithoutAssetDamageInput
    >;
  };

  export type AssetRepairPaymentCreateManyAssetDamageInputEnvelope = {
    data:
      | AssetRepairPaymentCreateManyAssetDamageInput
      | AssetRepairPaymentCreateManyAssetDamageInput[];
    skipDuplicates?: boolean;
  };

  export type IndividualBookUpsertWithoutBookDamagesInput = {
    update: XOR<
      IndividualBookUpdateWithoutBookDamagesInput,
      IndividualBookUncheckedUpdateWithoutBookDamagesInput
    >;
    create: XOR<
      IndividualBookCreateWithoutBookDamagesInput,
      IndividualBookUncheckedCreateWithoutBookDamagesInput
    >;
    where?: IndividualBookWhereInput;
  };

  export type IndividualBookUpdateToOneWithWhereWithoutBookDamagesInput = {
    where?: IndividualBookWhereInput;
    data: XOR<
      IndividualBookUpdateWithoutBookDamagesInput,
      IndividualBookUncheckedUpdateWithoutBookDamagesInput
    >;
  };

  export type IndividualBookUpdateWithoutBookDamagesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    isbn?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumBookStatusFieldUpdateOperationsInput | $Enums.BookStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    condition?:
      | EnumAssetConditionFieldUpdateOperationsInput
      | $Enums.AssetCondition;
    borrowCount?: IntFieldUpdateOperationsInput | number;
    borrowers?: BorrowerUpdateManyWithoutLibraryBookNestedInput;
    libraryBook?: LibraryBookUpdateOneRequiredWithoutIndividualBooksNestedInput;
  };

  export type IndividualBookUncheckedUpdateWithoutBookDamagesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    isbn?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumBookStatusFieldUpdateOperationsInput | $Enums.BookStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    libraryBookId?: StringFieldUpdateOperationsInput | string;
    condition?:
      | EnumAssetConditionFieldUpdateOperationsInput
      | $Enums.AssetCondition;
    borrowCount?: IntFieldUpdateOperationsInput | number;
    borrowers?: BorrowerUncheckedUpdateManyWithoutLibraryBookNestedInput;
  };

  export type IndividualComputerLabItemUpsertWithoutAssetDamagesInput = {
    update: XOR<
      IndividualComputerLabItemUpdateWithoutAssetDamagesInput,
      IndividualComputerLabItemUncheckedUpdateWithoutAssetDamagesInput
    >;
    create: XOR<
      IndividualComputerLabItemCreateWithoutAssetDamagesInput,
      IndividualComputerLabItemUncheckedCreateWithoutAssetDamagesInput
    >;
    where?: IndividualComputerLabItemWhereInput;
  };

  export type IndividualComputerLabItemUpdateToOneWithWhereWithoutAssetDamagesInput =
    {
      where?: IndividualComputerLabItemWhereInput;
      data: XOR<
        IndividualComputerLabItemUpdateWithoutAssetDamagesInput,
        IndividualComputerLabItemUncheckedUpdateWithoutAssetDamagesInput
      >;
    };

  export type IndividualComputerLabItemUpdateWithoutAssetDamagesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    uniqueIdentifier?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus;
    condition?:
      | EnumAssetConditionFieldUpdateOperationsInput
      | $Enums.AssetCondition;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    computerLabItem?: ComputerLabItemUpdateOneRequiredWithoutIndividualComputerLabItemsNestedInput;
  };

  export type IndividualComputerLabItemUncheckedUpdateWithoutAssetDamagesInput =
    {
      id?: StringFieldUpdateOperationsInput | string;
      computerLabItemId?: StringFieldUpdateOperationsInput | string;
      uniqueIdentifier?:
        | NullableStringFieldUpdateOperationsInput
        | string
        | null;
      status?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus;
      condition?:
        | EnumAssetConditionFieldUpdateOperationsInput
        | $Enums.AssetCondition;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    };

  export type IndividualFoodStoreItemUpsertWithoutAssetDamagesInput = {
    update: XOR<
      IndividualFoodStoreItemUpdateWithoutAssetDamagesInput,
      IndividualFoodStoreItemUncheckedUpdateWithoutAssetDamagesInput
    >;
    create: XOR<
      IndividualFoodStoreItemCreateWithoutAssetDamagesInput,
      IndividualFoodStoreItemUncheckedCreateWithoutAssetDamagesInput
    >;
    where?: IndividualFoodStoreItemWhereInput;
  };

  export type IndividualFoodStoreItemUpdateToOneWithWhereWithoutAssetDamagesInput =
    {
      where?: IndividualFoodStoreItemWhereInput;
      data: XOR<
        IndividualFoodStoreItemUpdateWithoutAssetDamagesInput,
        IndividualFoodStoreItemUncheckedUpdateWithoutAssetDamagesInput
      >;
    };

  export type IndividualFoodStoreItemUpdateWithoutAssetDamagesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    uniqueIdentifier?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus;
    condition?:
      | EnumAssetConditionFieldUpdateOperationsInput
      | $Enums.AssetCondition;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    foodStoreItem?: FoodStoreItemUpdateOneRequiredWithoutIndividualFoodStoreItemsNestedInput;
  };

  export type IndividualFoodStoreItemUncheckedUpdateWithoutAssetDamagesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    foodStoreItemId?: StringFieldUpdateOperationsInput | string;
    uniqueIdentifier?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus;
    condition?:
      | EnumAssetConditionFieldUpdateOperationsInput
      | $Enums.AssetCondition;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type IndividualGeneralStoreItemUpsertWithoutAssetDamagesInput = {
    update: XOR<
      IndividualGeneralStoreItemUpdateWithoutAssetDamagesInput,
      IndividualGeneralStoreItemUncheckedUpdateWithoutAssetDamagesInput
    >;
    create: XOR<
      IndividualGeneralStoreItemCreateWithoutAssetDamagesInput,
      IndividualGeneralStoreItemUncheckedCreateWithoutAssetDamagesInput
    >;
    where?: IndividualGeneralStoreItemWhereInput;
  };

  export type IndividualGeneralStoreItemUpdateToOneWithWhereWithoutAssetDamagesInput =
    {
      where?: IndividualGeneralStoreItemWhereInput;
      data: XOR<
        IndividualGeneralStoreItemUpdateWithoutAssetDamagesInput,
        IndividualGeneralStoreItemUncheckedUpdateWithoutAssetDamagesInput
      >;
    };

  export type IndividualGeneralStoreItemUpdateWithoutAssetDamagesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    uniqueIdentifier?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus;
    condition?:
      | EnumAssetConditionFieldUpdateOperationsInput
      | $Enums.AssetCondition;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    generalStoreItem?: GeneralStoreItemUpdateOneRequiredWithoutIndividualGeneralStoreItemsNestedInput;
  };

  export type IndividualGeneralStoreItemUncheckedUpdateWithoutAssetDamagesInput =
    {
      id?: StringFieldUpdateOperationsInput | string;
      generalStoreItemId?: StringFieldUpdateOperationsInput | string;
      uniqueIdentifier?:
        | NullableStringFieldUpdateOperationsInput
        | string
        | null;
      status?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus;
      condition?:
        | EnumAssetConditionFieldUpdateOperationsInput
        | $Enums.AssetCondition;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    };

  export type IndividualLabItemUpsertWithoutAssetDamagesInput = {
    update: XOR<
      IndividualLabItemUpdateWithoutAssetDamagesInput,
      IndividualLabItemUncheckedUpdateWithoutAssetDamagesInput
    >;
    create: XOR<
      IndividualLabItemCreateWithoutAssetDamagesInput,
      IndividualLabItemUncheckedCreateWithoutAssetDamagesInput
    >;
    where?: IndividualLabItemWhereInput;
  };

  export type IndividualLabItemUpdateToOneWithWhereWithoutAssetDamagesInput = {
    where?: IndividualLabItemWhereInput;
    data: XOR<
      IndividualLabItemUpdateWithoutAssetDamagesInput,
      IndividualLabItemUncheckedUpdateWithoutAssetDamagesInput
    >;
  };

  export type IndividualLabItemUpdateWithoutAssetDamagesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    uniqueIdentifier?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus;
    condition?:
      | EnumAssetConditionFieldUpdateOperationsInput
      | $Enums.AssetCondition;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    labItem?: LabItemUpdateOneRequiredWithoutIndividualLabItemsNestedInput;
  };

  export type IndividualLabItemUncheckedUpdateWithoutAssetDamagesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    labItemId?: StringFieldUpdateOperationsInput | string;
    uniqueIdentifier?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus;
    condition?:
      | EnumAssetConditionFieldUpdateOperationsInput
      | $Enums.AssetCondition;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type UserUpsertWithoutAssetDamagesInput = {
    update: XOR<
      UserUpdateWithoutAssetDamagesInput,
      UserUncheckedUpdateWithoutAssetDamagesInput
    >;
    create: XOR<
      UserCreateWithoutAssetDamagesInput,
      UserUncheckedCreateWithoutAssetDamagesInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutAssetDamagesInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutAssetDamagesInput,
      UserUncheckedUpdateWithoutAssetDamagesInput
    >;
  };

  export type UserUpdateWithoutAssetDamagesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    telephone?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    googleId?: NullableStringFieldUpdateOperationsInput | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    isWelcomed?: BoolFieldUpdateOperationsInput | boolean;
    isVerified?: BoolFieldUpdateOperationsInput | boolean;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    assetRepairPayments?: AssetRepairPaymentUpdateManyWithoutReceivedByNestedInput;
    borrowers?: BorrowerUpdateManyWithoutUserNestedInput;
    emailVerificationTokens?: EmailVerificationTokenUpdateManyWithoutUserNestedInput;
    feesPayments?: FeesPaymentUpdateManyWithoutPaidByNestedInput;
    pupils?: PupilUpdateManyWithoutUserNestedInput;
    sessions?: SessionUpdateManyWithoutUserNestedInput;
    staffs?: StaffUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutAssetDamagesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    telephone?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    googleId?: NullableStringFieldUpdateOperationsInput | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    isWelcomed?: BoolFieldUpdateOperationsInput | boolean;
    isVerified?: BoolFieldUpdateOperationsInput | boolean;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    assetRepairPayments?: AssetRepairPaymentUncheckedUpdateManyWithoutReceivedByNestedInput;
    borrowers?: BorrowerUncheckedUpdateManyWithoutUserNestedInput;
    emailVerificationTokens?: EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput;
    feesPayments?: FeesPaymentUncheckedUpdateManyWithoutPaidByNestedInput;
    pupils?: PupilUncheckedUpdateManyWithoutUserNestedInput;
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput;
    staffs?: StaffUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type AssetRepairPaymentUpsertWithWhereUniqueWithoutAssetDamageInput = {
    where: AssetRepairPaymentWhereUniqueInput;
    update: XOR<
      AssetRepairPaymentUpdateWithoutAssetDamageInput,
      AssetRepairPaymentUncheckedUpdateWithoutAssetDamageInput
    >;
    create: XOR<
      AssetRepairPaymentCreateWithoutAssetDamageInput,
      AssetRepairPaymentUncheckedCreateWithoutAssetDamageInput
    >;
  };

  export type AssetRepairPaymentUpdateWithWhereUniqueWithoutAssetDamageInput = {
    where: AssetRepairPaymentWhereUniqueInput;
    data: XOR<
      AssetRepairPaymentUpdateWithoutAssetDamageInput,
      AssetRepairPaymentUncheckedUpdateWithoutAssetDamageInput
    >;
  };

  export type AssetRepairPaymentUpdateManyWithWhereWithoutAssetDamageInput = {
    where: AssetRepairPaymentScalarWhereInput;
    data: XOR<
      AssetRepairPaymentUpdateManyMutationInput,
      AssetRepairPaymentUncheckedUpdateManyWithoutAssetDamageInput
    >;
  };

  export type AssetDamageCreateWithoutAssetRepairPaymentsInput = {
    id?: string;
    damageDetails: string;
    condition: $Enums.AssetCondition;
    quantity: number;
    isRepaired?: boolean;
    repairedAt?: Date | string | null;
    createdAt?: Date | string;
    isSchoolCost?: boolean;
    repairBalance?: number;
    repairPrice?: number | null;
    individualBook?: IndividualBookCreateNestedOneWithoutBookDamagesInput;
    individualComputerLabItem?: IndividualComputerLabItemCreateNestedOneWithoutAssetDamagesInput;
    individualFoodStoreItem?: IndividualFoodStoreItemCreateNestedOneWithoutAssetDamagesInput;
    individualGeneralStoreItem?: IndividualGeneralStoreItemCreateNestedOneWithoutAssetDamagesInput;
    individualLabItem?: IndividualLabItemCreateNestedOneWithoutAssetDamagesInput;
    damagedBy?: UserCreateNestedOneWithoutAssetDamagesInput;
  };

  export type AssetDamageUncheckedCreateWithoutAssetRepairPaymentsInput = {
    id?: string;
    damageDetails: string;
    condition: $Enums.AssetCondition;
    quantity: number;
    userId?: string | null;
    individualComputerLabItemId?: string | null;
    isRepaired?: boolean;
    repairedAt?: Date | string | null;
    createdAt?: Date | string;
    individualBookId?: string | null;
    individualLabItemId?: string | null;
    individualFoodStoreItemId?: string | null;
    individualGeneralStoreItemId?: string | null;
    isSchoolCost?: boolean;
    repairBalance?: number;
    repairPrice?: number | null;
  };

  export type AssetDamageCreateOrConnectWithoutAssetRepairPaymentsInput = {
    where: AssetDamageWhereUniqueInput;
    create: XOR<
      AssetDamageCreateWithoutAssetRepairPaymentsInput,
      AssetDamageUncheckedCreateWithoutAssetRepairPaymentsInput
    >;
  };

  export type UserCreateWithoutAssetRepairPaymentsInput = {
    id?: string;
    name?: string | null;
    username?: string | null;
    email?: string | null;
    avatarUrl?: string | null;
    role?: $Enums.Role | null;
    createdAt?: Date | string;
    telephone?: string | null;
    passwordHash?: string | null;
    googleId?: string | null;
    bio?: string | null;
    isWelcomed?: boolean;
    isVerified?: boolean;
    emailVerified?: boolean;
    assetDamages?: AssetDamageCreateNestedManyWithoutDamagedByInput;
    borrowers?: BorrowerCreateNestedManyWithoutUserInput;
    emailVerificationTokens?: EmailVerificationTokenCreateNestedManyWithoutUserInput;
    feesPayments?: FeesPaymentCreateNestedManyWithoutPaidByInput;
    pupils?: PupilCreateNestedManyWithoutUserInput;
    sessions?: SessionCreateNestedManyWithoutUserInput;
    staffs?: StaffCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutAssetRepairPaymentsInput = {
    id?: string;
    name?: string | null;
    username?: string | null;
    email?: string | null;
    avatarUrl?: string | null;
    role?: $Enums.Role | null;
    createdAt?: Date | string;
    telephone?: string | null;
    passwordHash?: string | null;
    googleId?: string | null;
    bio?: string | null;
    isWelcomed?: boolean;
    isVerified?: boolean;
    emailVerified?: boolean;
    assetDamages?: AssetDamageUncheckedCreateNestedManyWithoutDamagedByInput;
    borrowers?: BorrowerUncheckedCreateNestedManyWithoutUserInput;
    emailVerificationTokens?: EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput;
    feesPayments?: FeesPaymentUncheckedCreateNestedManyWithoutPaidByInput;
    pupils?: PupilUncheckedCreateNestedManyWithoutUserInput;
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput;
    staffs?: StaffUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutAssetRepairPaymentsInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutAssetRepairPaymentsInput,
      UserUncheckedCreateWithoutAssetRepairPaymentsInput
    >;
  };

  export type AssetDamageUpsertWithoutAssetRepairPaymentsInput = {
    update: XOR<
      AssetDamageUpdateWithoutAssetRepairPaymentsInput,
      AssetDamageUncheckedUpdateWithoutAssetRepairPaymentsInput
    >;
    create: XOR<
      AssetDamageCreateWithoutAssetRepairPaymentsInput,
      AssetDamageUncheckedCreateWithoutAssetRepairPaymentsInput
    >;
    where?: AssetDamageWhereInput;
  };

  export type AssetDamageUpdateToOneWithWhereWithoutAssetRepairPaymentsInput = {
    where?: AssetDamageWhereInput;
    data: XOR<
      AssetDamageUpdateWithoutAssetRepairPaymentsInput,
      AssetDamageUncheckedUpdateWithoutAssetRepairPaymentsInput
    >;
  };

  export type AssetDamageUpdateWithoutAssetRepairPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    damageDetails?: StringFieldUpdateOperationsInput | string;
    condition?:
      | EnumAssetConditionFieldUpdateOperationsInput
      | $Enums.AssetCondition;
    quantity?: IntFieldUpdateOperationsInput | number;
    isRepaired?: BoolFieldUpdateOperationsInput | boolean;
    repairedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    isSchoolCost?: BoolFieldUpdateOperationsInput | boolean;
    repairBalance?: FloatFieldUpdateOperationsInput | number;
    repairPrice?: NullableFloatFieldUpdateOperationsInput | number | null;
    individualBook?: IndividualBookUpdateOneWithoutBookDamagesNestedInput;
    individualComputerLabItem?: IndividualComputerLabItemUpdateOneWithoutAssetDamagesNestedInput;
    individualFoodStoreItem?: IndividualFoodStoreItemUpdateOneWithoutAssetDamagesNestedInput;
    individualGeneralStoreItem?: IndividualGeneralStoreItemUpdateOneWithoutAssetDamagesNestedInput;
    individualLabItem?: IndividualLabItemUpdateOneWithoutAssetDamagesNestedInput;
    damagedBy?: UserUpdateOneWithoutAssetDamagesNestedInput;
  };

  export type AssetDamageUncheckedUpdateWithoutAssetRepairPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    damageDetails?: StringFieldUpdateOperationsInput | string;
    condition?:
      | EnumAssetConditionFieldUpdateOperationsInput
      | $Enums.AssetCondition;
    quantity?: IntFieldUpdateOperationsInput | number;
    userId?: NullableStringFieldUpdateOperationsInput | string | null;
    individualComputerLabItemId?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    isRepaired?: BoolFieldUpdateOperationsInput | boolean;
    repairedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    individualBookId?: NullableStringFieldUpdateOperationsInput | string | null;
    individualLabItemId?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    individualFoodStoreItemId?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    individualGeneralStoreItemId?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    isSchoolCost?: BoolFieldUpdateOperationsInput | boolean;
    repairBalance?: FloatFieldUpdateOperationsInput | number;
    repairPrice?: NullableFloatFieldUpdateOperationsInput | number | null;
  };

  export type UserUpsertWithoutAssetRepairPaymentsInput = {
    update: XOR<
      UserUpdateWithoutAssetRepairPaymentsInput,
      UserUncheckedUpdateWithoutAssetRepairPaymentsInput
    >;
    create: XOR<
      UserCreateWithoutAssetRepairPaymentsInput,
      UserUncheckedCreateWithoutAssetRepairPaymentsInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutAssetRepairPaymentsInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutAssetRepairPaymentsInput,
      UserUncheckedUpdateWithoutAssetRepairPaymentsInput
    >;
  };

  export type UserUpdateWithoutAssetRepairPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    telephone?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    googleId?: NullableStringFieldUpdateOperationsInput | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    isWelcomed?: BoolFieldUpdateOperationsInput | boolean;
    isVerified?: BoolFieldUpdateOperationsInput | boolean;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    assetDamages?: AssetDamageUpdateManyWithoutDamagedByNestedInput;
    borrowers?: BorrowerUpdateManyWithoutUserNestedInput;
    emailVerificationTokens?: EmailVerificationTokenUpdateManyWithoutUserNestedInput;
    feesPayments?: FeesPaymentUpdateManyWithoutPaidByNestedInput;
    pupils?: PupilUpdateManyWithoutUserNestedInput;
    sessions?: SessionUpdateManyWithoutUserNestedInput;
    staffs?: StaffUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutAssetRepairPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    telephone?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    googleId?: NullableStringFieldUpdateOperationsInput | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    isWelcomed?: BoolFieldUpdateOperationsInput | boolean;
    isVerified?: BoolFieldUpdateOperationsInput | boolean;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    assetDamages?: AssetDamageUncheckedUpdateManyWithoutDamagedByNestedInput;
    borrowers?: BorrowerUncheckedUpdateManyWithoutUserNestedInput;
    emailVerificationTokens?: EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput;
    feesPayments?: FeesPaymentUncheckedUpdateManyWithoutPaidByNestedInput;
    pupils?: PupilUncheckedUpdateManyWithoutUserNestedInput;
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput;
    staffs?: StaffUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type ExamSubjectCreateWithoutExamScoresInput = {
    id?: string;
    examDate: Date | string;
    exam: ExamCreateNestedOneWithoutExamSubjectsInput;
    academicYearSubject: AcademicYearSubjectCreateNestedOneWithoutExamSubjectsInput;
  };

  export type ExamSubjectUncheckedCreateWithoutExamScoresInput = {
    id?: string;
    examId: string;
    examDate: Date | string;
    academicYearSubjectId: string;
  };

  export type ExamSubjectCreateOrConnectWithoutExamScoresInput = {
    where: ExamSubjectWhereUniqueInput;
    create: XOR<
      ExamSubjectCreateWithoutExamScoresInput,
      ExamSubjectUncheckedCreateWithoutExamScoresInput
    >;
  };

  export type PupilCreateWithoutExamScoresInput = {
    id?: string;
    genericPassword: string;
    classStreams?: classStreamCreateNestedManyWithoutPupilsInput;
    fees?: FeesCreateNestedManyWithoutPupilInput;
    user?: UserCreateNestedOneWithoutPupilsInput;
  };

  export type PupilUncheckedCreateWithoutExamScoresInput = {
    id?: string;
    userId?: string | null;
    genericPassword: string;
    classStreams?: classStreamUncheckedCreateNestedManyWithoutPupilsInput;
    fees?: FeesUncheckedCreateNestedManyWithoutPupilInput;
  };

  export type PupilCreateOrConnectWithoutExamScoresInput = {
    where: PupilWhereUniqueInput;
    create: XOR<
      PupilCreateWithoutExamScoresInput,
      PupilUncheckedCreateWithoutExamScoresInput
    >;
  };

  export type ExamSubjectUpsertWithoutExamScoresInput = {
    update: XOR<
      ExamSubjectUpdateWithoutExamScoresInput,
      ExamSubjectUncheckedUpdateWithoutExamScoresInput
    >;
    create: XOR<
      ExamSubjectCreateWithoutExamScoresInput,
      ExamSubjectUncheckedCreateWithoutExamScoresInput
    >;
    where?: ExamSubjectWhereInput;
  };

  export type ExamSubjectUpdateToOneWithWhereWithoutExamScoresInput = {
    where?: ExamSubjectWhereInput;
    data: XOR<
      ExamSubjectUpdateWithoutExamScoresInput,
      ExamSubjectUncheckedUpdateWithoutExamScoresInput
    >;
  };

  export type ExamSubjectUpdateWithoutExamScoresInput = {
    id?: StringFieldUpdateOperationsInput | string;
    examDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    exam?: ExamUpdateOneRequiredWithoutExamSubjectsNestedInput;
    academicYearSubject?: AcademicYearSubjectUpdateOneRequiredWithoutExamSubjectsNestedInput;
  };

  export type ExamSubjectUncheckedUpdateWithoutExamScoresInput = {
    id?: StringFieldUpdateOperationsInput | string;
    examId?: StringFieldUpdateOperationsInput | string;
    examDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    academicYearSubjectId?: StringFieldUpdateOperationsInput | string;
  };

  export type PupilUpsertWithoutExamScoresInput = {
    update: XOR<
      PupilUpdateWithoutExamScoresInput,
      PupilUncheckedUpdateWithoutExamScoresInput
    >;
    create: XOR<
      PupilCreateWithoutExamScoresInput,
      PupilUncheckedCreateWithoutExamScoresInput
    >;
    where?: PupilWhereInput;
  };

  export type PupilUpdateToOneWithWhereWithoutExamScoresInput = {
    where?: PupilWhereInput;
    data: XOR<
      PupilUpdateWithoutExamScoresInput,
      PupilUncheckedUpdateWithoutExamScoresInput
    >;
  };

  export type PupilUpdateWithoutExamScoresInput = {
    id?: StringFieldUpdateOperationsInput | string;
    genericPassword?: StringFieldUpdateOperationsInput | string;
    classStreams?: classStreamUpdateManyWithoutPupilsNestedInput;
    fees?: FeesUpdateManyWithoutPupilNestedInput;
    user?: UserUpdateOneWithoutPupilsNestedInput;
  };

  export type PupilUncheckedUpdateWithoutExamScoresInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: NullableStringFieldUpdateOperationsInput | string | null;
    genericPassword?: StringFieldUpdateOperationsInput | string;
    classStreams?: classStreamUncheckedUpdateManyWithoutPupilsNestedInput;
    fees?: FeesUncheckedUpdateManyWithoutPupilNestedInput;
  };

  export type ExamSubjectCreateWithoutExamInput = {
    id?: string;
    examDate: Date | string;
    academicYearSubject: AcademicYearSubjectCreateNestedOneWithoutExamSubjectsInput;
    examScores?: ExamScoreCreateNestedManyWithoutExamSubjectInput;
  };

  export type ExamSubjectUncheckedCreateWithoutExamInput = {
    id?: string;
    examDate: Date | string;
    academicYearSubjectId: string;
    examScores?: ExamScoreUncheckedCreateNestedManyWithoutExamSubjectInput;
  };

  export type ExamSubjectCreateOrConnectWithoutExamInput = {
    where: ExamSubjectWhereUniqueInput;
    create: XOR<
      ExamSubjectCreateWithoutExamInput,
      ExamSubjectUncheckedCreateWithoutExamInput
    >;
  };

  export type ExamSubjectCreateManyExamInputEnvelope = {
    data: ExamSubjectCreateManyExamInput | ExamSubjectCreateManyExamInput[];
    skipDuplicates?: boolean;
  };

  export type ClassTermCreateWithoutExamsInput = {
    id?: string;
    startAt?: Date | string;
    endAt: Date | string;
    feesAmount?: number | null;
    classStream?: classStreamCreateNestedOneWithoutTermsInput;
    term?: TermCreateNestedOneWithoutClassTermsInput;
    fees?: FeesCreateNestedManyWithoutTermInput;
  };

  export type ClassTermUncheckedCreateWithoutExamsInput = {
    id?: string;
    startAt?: Date | string;
    endAt: Date | string;
    termId?: string | null;
    classStreamId?: string | null;
    feesAmount?: number | null;
    fees?: FeesUncheckedCreateNestedManyWithoutTermInput;
  };

  export type ClassTermCreateOrConnectWithoutExamsInput = {
    where: ClassTermWhereUniqueInput;
    create: XOR<
      ClassTermCreateWithoutExamsInput,
      ClassTermUncheckedCreateWithoutExamsInput
    >;
  };

  export type ExamSubjectUpsertWithWhereUniqueWithoutExamInput = {
    where: ExamSubjectWhereUniqueInput;
    update: XOR<
      ExamSubjectUpdateWithoutExamInput,
      ExamSubjectUncheckedUpdateWithoutExamInput
    >;
    create: XOR<
      ExamSubjectCreateWithoutExamInput,
      ExamSubjectUncheckedCreateWithoutExamInput
    >;
  };

  export type ExamSubjectUpdateWithWhereUniqueWithoutExamInput = {
    where: ExamSubjectWhereUniqueInput;
    data: XOR<
      ExamSubjectUpdateWithoutExamInput,
      ExamSubjectUncheckedUpdateWithoutExamInput
    >;
  };

  export type ExamSubjectUpdateManyWithWhereWithoutExamInput = {
    where: ExamSubjectScalarWhereInput;
    data: XOR<
      ExamSubjectUpdateManyMutationInput,
      ExamSubjectUncheckedUpdateManyWithoutExamInput
    >;
  };

  export type ClassTermUpsertWithoutExamsInput = {
    update: XOR<
      ClassTermUpdateWithoutExamsInput,
      ClassTermUncheckedUpdateWithoutExamsInput
    >;
    create: XOR<
      ClassTermCreateWithoutExamsInput,
      ClassTermUncheckedCreateWithoutExamsInput
    >;
    where?: ClassTermWhereInput;
  };

  export type ClassTermUpdateToOneWithWhereWithoutExamsInput = {
    where?: ClassTermWhereInput;
    data: XOR<
      ClassTermUpdateWithoutExamsInput,
      ClassTermUncheckedUpdateWithoutExamsInput
    >;
  };

  export type ClassTermUpdateWithoutExamsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    feesAmount?: NullableIntFieldUpdateOperationsInput | number | null;
    classStream?: classStreamUpdateOneWithoutTermsNestedInput;
    term?: TermUpdateOneWithoutClassTermsNestedInput;
    fees?: FeesUpdateManyWithoutTermNestedInput;
  };

  export type ClassTermUncheckedUpdateWithoutExamsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    termId?: NullableStringFieldUpdateOperationsInput | string | null;
    classStreamId?: NullableStringFieldUpdateOperationsInput | string | null;
    feesAmount?: NullableIntFieldUpdateOperationsInput | number | null;
    fees?: FeesUncheckedUpdateManyWithoutTermNestedInput;
  };

  export type ExamCreateWithoutExamSubjectsInput = {
    id: string;
    examName: string;
    examType?: $Enums.ExamType;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    classTerm: ClassTermCreateNestedOneWithoutExamsInput;
  };

  export type ExamUncheckedCreateWithoutExamSubjectsInput = {
    id: string;
    examName: string;
    examType?: $Enums.ExamType;
    classTermId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ExamCreateOrConnectWithoutExamSubjectsInput = {
    where: ExamWhereUniqueInput;
    create: XOR<
      ExamCreateWithoutExamSubjectsInput,
      ExamUncheckedCreateWithoutExamSubjectsInput
    >;
  };

  export type AcademicYearSubjectCreateWithoutExamSubjectsInput = {
    id?: string;
    customGrading?: GradingCreateNestedManyWithoutAcademicYearSubjectsInput;
    academicYearClass: AcademicYearClassCreateNestedOneWithoutAcademicYearSubjectsInput;
    teachers?: StaffCreateNestedManyWithoutAcademicYearSubjectsInput;
    subject: SubjectCreateNestedOneWithoutAcademicYearSubjectsInput;
  };

  export type AcademicYearSubjectUncheckedCreateWithoutExamSubjectsInput = {
    id?: string;
    academicYearClassId: string;
    subjectId: string;
    customGrading?: GradingUncheckedCreateNestedManyWithoutAcademicYearSubjectsInput;
    teachers?: StaffUncheckedCreateNestedManyWithoutAcademicYearSubjectsInput;
  };

  export type AcademicYearSubjectCreateOrConnectWithoutExamSubjectsInput = {
    where: AcademicYearSubjectWhereUniqueInput;
    create: XOR<
      AcademicYearSubjectCreateWithoutExamSubjectsInput,
      AcademicYearSubjectUncheckedCreateWithoutExamSubjectsInput
    >;
  };

  export type ExamScoreCreateWithoutExamSubjectInput = {
    id?: string;
    score: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    pupil: PupilCreateNestedOneWithoutExamScoresInput;
  };

  export type ExamScoreUncheckedCreateWithoutExamSubjectInput = {
    id?: string;
    score: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    pupilId: string;
  };

  export type ExamScoreCreateOrConnectWithoutExamSubjectInput = {
    where: ExamScoreWhereUniqueInput;
    create: XOR<
      ExamScoreCreateWithoutExamSubjectInput,
      ExamScoreUncheckedCreateWithoutExamSubjectInput
    >;
  };

  export type ExamScoreCreateManyExamSubjectInputEnvelope = {
    data:
      | ExamScoreCreateManyExamSubjectInput
      | ExamScoreCreateManyExamSubjectInput[];
    skipDuplicates?: boolean;
  };

  export type ExamUpsertWithoutExamSubjectsInput = {
    update: XOR<
      ExamUpdateWithoutExamSubjectsInput,
      ExamUncheckedUpdateWithoutExamSubjectsInput
    >;
    create: XOR<
      ExamCreateWithoutExamSubjectsInput,
      ExamUncheckedCreateWithoutExamSubjectsInput
    >;
    where?: ExamWhereInput;
  };

  export type ExamUpdateToOneWithWhereWithoutExamSubjectsInput = {
    where?: ExamWhereInput;
    data: XOR<
      ExamUpdateWithoutExamSubjectsInput,
      ExamUncheckedUpdateWithoutExamSubjectsInput
    >;
  };

  export type ExamUpdateWithoutExamSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    examName?: StringFieldUpdateOperationsInput | string;
    examType?: EnumExamTypeFieldUpdateOperationsInput | $Enums.ExamType;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    classTerm?: ClassTermUpdateOneRequiredWithoutExamsNestedInput;
  };

  export type ExamUncheckedUpdateWithoutExamSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    examName?: StringFieldUpdateOperationsInput | string;
    examType?: EnumExamTypeFieldUpdateOperationsInput | $Enums.ExamType;
    classTermId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AcademicYearSubjectUpsertWithoutExamSubjectsInput = {
    update: XOR<
      AcademicYearSubjectUpdateWithoutExamSubjectsInput,
      AcademicYearSubjectUncheckedUpdateWithoutExamSubjectsInput
    >;
    create: XOR<
      AcademicYearSubjectCreateWithoutExamSubjectsInput,
      AcademicYearSubjectUncheckedCreateWithoutExamSubjectsInput
    >;
    where?: AcademicYearSubjectWhereInput;
  };

  export type AcademicYearSubjectUpdateToOneWithWhereWithoutExamSubjectsInput =
    {
      where?: AcademicYearSubjectWhereInput;
      data: XOR<
        AcademicYearSubjectUpdateWithoutExamSubjectsInput,
        AcademicYearSubjectUncheckedUpdateWithoutExamSubjectsInput
      >;
    };

  export type AcademicYearSubjectUpdateWithoutExamSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    customGrading?: GradingUpdateManyWithoutAcademicYearSubjectsNestedInput;
    academicYearClass?: AcademicYearClassUpdateOneRequiredWithoutAcademicYearSubjectsNestedInput;
    teachers?: StaffUpdateManyWithoutAcademicYearSubjectsNestedInput;
    subject?: SubjectUpdateOneRequiredWithoutAcademicYearSubjectsNestedInput;
  };

  export type AcademicYearSubjectUncheckedUpdateWithoutExamSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    academicYearClassId?: StringFieldUpdateOperationsInput | string;
    subjectId?: StringFieldUpdateOperationsInput | string;
    customGrading?: GradingUncheckedUpdateManyWithoutAcademicYearSubjectsNestedInput;
    teachers?: StaffUncheckedUpdateManyWithoutAcademicYearSubjectsNestedInput;
  };

  export type ExamScoreUpsertWithWhereUniqueWithoutExamSubjectInput = {
    where: ExamScoreWhereUniqueInput;
    update: XOR<
      ExamScoreUpdateWithoutExamSubjectInput,
      ExamScoreUncheckedUpdateWithoutExamSubjectInput
    >;
    create: XOR<
      ExamScoreCreateWithoutExamSubjectInput,
      ExamScoreUncheckedCreateWithoutExamSubjectInput
    >;
  };

  export type ExamScoreUpdateWithWhereUniqueWithoutExamSubjectInput = {
    where: ExamScoreWhereUniqueInput;
    data: XOR<
      ExamScoreUpdateWithoutExamSubjectInput,
      ExamScoreUncheckedUpdateWithoutExamSubjectInput
    >;
  };

  export type ExamScoreUpdateManyWithWhereWithoutExamSubjectInput = {
    where: ExamScoreScalarWhereInput;
    data: XOR<
      ExamScoreUpdateManyMutationInput,
      ExamScoreUncheckedUpdateManyWithoutExamSubjectInput
    >;
  };

  export type AssetDamageCreateManyDamagedByInput = {
    id?: string;
    damageDetails: string;
    condition: $Enums.AssetCondition;
    quantity: number;
    individualComputerLabItemId?: string | null;
    isRepaired?: boolean;
    repairedAt?: Date | string | null;
    createdAt?: Date | string;
    individualBookId?: string | null;
    individualLabItemId?: string | null;
    individualFoodStoreItemId?: string | null;
    individualGeneralStoreItemId?: string | null;
    isSchoolCost?: boolean;
    repairBalance?: number;
    repairPrice?: number | null;
  };

  export type AssetRepairPaymentCreateManyReceivedByInput = {
    id?: string;
    paidAmount: number;
    paidAt?: Date | string;
    updatedAt?: Date | string;
    assetDamageId?: string | null;
    isSchoolCost?: boolean;
  };

  export type BorrowerCreateManyUserInput = {
    id?: string;
    borrowedAt?: Date | string;
    returnAt?: Date | string | null;
    status?: $Enums.BorrowStatus;
    individualBookId?: string | null;
  };

  export type EmailVerificationTokenCreateManyUserInput = {
    id?: string;
    expires: bigint | number;
  };

  export type FeesPaymentCreateManyPaidByInput = {
    id?: string;
    amountPaid: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    feesId?: string | null;
  };

  export type PupilCreateManyUserInput = {
    id?: string;
    genericPassword: string;
  };

  export type SessionCreateManyUserInput = {
    id?: string;
    expiresAt: Date | string;
    role?: $Enums.Role;
  };

  export type StaffCreateManyUserInput = {
    id?: string;
    staffType?: $Enums.StaffType;
    genericPassword: string;
  };

  export type AssetDamageUpdateWithoutDamagedByInput = {
    id?: StringFieldUpdateOperationsInput | string;
    damageDetails?: StringFieldUpdateOperationsInput | string;
    condition?:
      | EnumAssetConditionFieldUpdateOperationsInput
      | $Enums.AssetCondition;
    quantity?: IntFieldUpdateOperationsInput | number;
    isRepaired?: BoolFieldUpdateOperationsInput | boolean;
    repairedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    isSchoolCost?: BoolFieldUpdateOperationsInput | boolean;
    repairBalance?: FloatFieldUpdateOperationsInput | number;
    repairPrice?: NullableFloatFieldUpdateOperationsInput | number | null;
    individualBook?: IndividualBookUpdateOneWithoutBookDamagesNestedInput;
    individualComputerLabItem?: IndividualComputerLabItemUpdateOneWithoutAssetDamagesNestedInput;
    individualFoodStoreItem?: IndividualFoodStoreItemUpdateOneWithoutAssetDamagesNestedInput;
    individualGeneralStoreItem?: IndividualGeneralStoreItemUpdateOneWithoutAssetDamagesNestedInput;
    individualLabItem?: IndividualLabItemUpdateOneWithoutAssetDamagesNestedInput;
    assetRepairPayments?: AssetRepairPaymentUpdateManyWithoutAssetDamageNestedInput;
  };

  export type AssetDamageUncheckedUpdateWithoutDamagedByInput = {
    id?: StringFieldUpdateOperationsInput | string;
    damageDetails?: StringFieldUpdateOperationsInput | string;
    condition?:
      | EnumAssetConditionFieldUpdateOperationsInput
      | $Enums.AssetCondition;
    quantity?: IntFieldUpdateOperationsInput | number;
    individualComputerLabItemId?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    isRepaired?: BoolFieldUpdateOperationsInput | boolean;
    repairedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    individualBookId?: NullableStringFieldUpdateOperationsInput | string | null;
    individualLabItemId?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    individualFoodStoreItemId?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    individualGeneralStoreItemId?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    isSchoolCost?: BoolFieldUpdateOperationsInput | boolean;
    repairBalance?: FloatFieldUpdateOperationsInput | number;
    repairPrice?: NullableFloatFieldUpdateOperationsInput | number | null;
    assetRepairPayments?: AssetRepairPaymentUncheckedUpdateManyWithoutAssetDamageNestedInput;
  };

  export type AssetDamageUncheckedUpdateManyWithoutDamagedByInput = {
    id?: StringFieldUpdateOperationsInput | string;
    damageDetails?: StringFieldUpdateOperationsInput | string;
    condition?:
      | EnumAssetConditionFieldUpdateOperationsInput
      | $Enums.AssetCondition;
    quantity?: IntFieldUpdateOperationsInput | number;
    individualComputerLabItemId?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    isRepaired?: BoolFieldUpdateOperationsInput | boolean;
    repairedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    individualBookId?: NullableStringFieldUpdateOperationsInput | string | null;
    individualLabItemId?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    individualFoodStoreItemId?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    individualGeneralStoreItemId?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    isSchoolCost?: BoolFieldUpdateOperationsInput | boolean;
    repairBalance?: FloatFieldUpdateOperationsInput | number;
    repairPrice?: NullableFloatFieldUpdateOperationsInput | number | null;
  };

  export type AssetRepairPaymentUpdateWithoutReceivedByInput = {
    id?: StringFieldUpdateOperationsInput | string;
    paidAmount?: FloatFieldUpdateOperationsInput | number;
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    isSchoolCost?: BoolFieldUpdateOperationsInput | boolean;
    assetDamage?: AssetDamageUpdateOneWithoutAssetRepairPaymentsNestedInput;
  };

  export type AssetRepairPaymentUncheckedUpdateWithoutReceivedByInput = {
    id?: StringFieldUpdateOperationsInput | string;
    paidAmount?: FloatFieldUpdateOperationsInput | number;
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    assetDamageId?: NullableStringFieldUpdateOperationsInput | string | null;
    isSchoolCost?: BoolFieldUpdateOperationsInput | boolean;
  };

  export type AssetRepairPaymentUncheckedUpdateManyWithoutReceivedByInput = {
    id?: StringFieldUpdateOperationsInput | string;
    paidAmount?: FloatFieldUpdateOperationsInput | number;
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    assetDamageId?: NullableStringFieldUpdateOperationsInput | string | null;
    isSchoolCost?: BoolFieldUpdateOperationsInput | boolean;
  };

  export type BorrowerUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    borrowedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    returnAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    status?: EnumBorrowStatusFieldUpdateOperationsInput | $Enums.BorrowStatus;
    libraryBook?: IndividualBookUpdateOneWithoutBorrowersNestedInput;
  };

  export type BorrowerUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    borrowedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    returnAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    status?: EnumBorrowStatusFieldUpdateOperationsInput | $Enums.BorrowStatus;
    individualBookId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type BorrowerUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    borrowedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    returnAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    status?: EnumBorrowStatusFieldUpdateOperationsInput | $Enums.BorrowStatus;
    individualBookId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type EmailVerificationTokenUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    expires?: BigIntFieldUpdateOperationsInput | bigint | number;
  };

  export type EmailVerificationTokenUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    expires?: BigIntFieldUpdateOperationsInput | bigint | number;
  };

  export type EmailVerificationTokenUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    expires?: BigIntFieldUpdateOperationsInput | bigint | number;
  };

  export type FeesPaymentUpdateWithoutPaidByInput = {
    id?: StringFieldUpdateOperationsInput | string;
    amountPaid?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    fees?: FeesUpdateOneWithoutFeesPaymentsNestedInput;
  };

  export type FeesPaymentUncheckedUpdateWithoutPaidByInput = {
    id?: StringFieldUpdateOperationsInput | string;
    amountPaid?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    feesId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type FeesPaymentUncheckedUpdateManyWithoutPaidByInput = {
    id?: StringFieldUpdateOperationsInput | string;
    amountPaid?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    feesId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type PupilUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    genericPassword?: StringFieldUpdateOperationsInput | string;
    classStreams?: classStreamUpdateManyWithoutPupilsNestedInput;
    examScores?: ExamScoreUpdateManyWithoutPupilNestedInput;
    fees?: FeesUpdateManyWithoutPupilNestedInput;
  };

  export type PupilUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    genericPassword?: StringFieldUpdateOperationsInput | string;
    classStreams?: classStreamUncheckedUpdateManyWithoutPupilsNestedInput;
    examScores?: ExamScoreUncheckedUpdateManyWithoutPupilNestedInput;
    fees?: FeesUncheckedUpdateManyWithoutPupilNestedInput;
  };

  export type PupilUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    genericPassword?: StringFieldUpdateOperationsInput | string;
  };

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role;
  };

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role;
  };

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role;
  };

  export type StaffUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    staffType?: EnumStaffTypeFieldUpdateOperationsInput | $Enums.StaffType;
    genericPassword?: StringFieldUpdateOperationsInput | string;
    academicYearSubjects?: AcademicYearSubjectUpdateManyWithoutTeachersNestedInput;
    classStreams?: classStreamUpdateManyWithoutClassTeacherNestedInput;
  };

  export type StaffUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    staffType?: EnumStaffTypeFieldUpdateOperationsInput | $Enums.StaffType;
    genericPassword?: StringFieldUpdateOperationsInput | string;
    academicYearSubjects?: AcademicYearSubjectUncheckedUpdateManyWithoutTeachersNestedInput;
    classStreams?: classStreamUncheckedUpdateManyWithoutClassTeacherNestedInput;
  };

  export type StaffUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    staffType?: EnumStaffTypeFieldUpdateOperationsInput | $Enums.StaffType;
    genericPassword?: StringFieldUpdateOperationsInput | string;
  };

  export type ExamScoreCreateManyPupilInput = {
    id?: string;
    score: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    examSubjectId: string;
  };

  export type FeesCreateManyPupilInput = {
    id?: string;
    balance?: number;
    termId: string;
    status?: $Enums.FeesStatus;
  };

  export type classStreamUpdateWithoutPupilsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    class?: AcademicYearClassUpdateOneWithoutStreamsNestedInput;
    classTeacher?: StaffUpdateOneWithoutClassStreamsNestedInput;
    stream?: StreamUpdateOneWithoutClassStreamsNestedInput;
    terms?: ClassTermUpdateManyWithoutClassStreamNestedInput;
  };

  export type classStreamUncheckedUpdateWithoutPupilsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    staffId?: NullableStringFieldUpdateOperationsInput | string | null;
    classId?: NullableStringFieldUpdateOperationsInput | string | null;
    streamId?: NullableStringFieldUpdateOperationsInput | string | null;
    terms?: ClassTermUncheckedUpdateManyWithoutClassStreamNestedInput;
  };

  export type classStreamUncheckedUpdateManyWithoutPupilsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    staffId?: NullableStringFieldUpdateOperationsInput | string | null;
    classId?: NullableStringFieldUpdateOperationsInput | string | null;
    streamId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type ExamScoreUpdateWithoutPupilInput = {
    id?: StringFieldUpdateOperationsInput | string;
    score?: FloatFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    examSubject?: ExamSubjectUpdateOneRequiredWithoutExamScoresNestedInput;
  };

  export type ExamScoreUncheckedUpdateWithoutPupilInput = {
    id?: StringFieldUpdateOperationsInput | string;
    score?: FloatFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    examSubjectId?: StringFieldUpdateOperationsInput | string;
  };

  export type ExamScoreUncheckedUpdateManyWithoutPupilInput = {
    id?: StringFieldUpdateOperationsInput | string;
    score?: FloatFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    examSubjectId?: StringFieldUpdateOperationsInput | string;
  };

  export type FeesUpdateWithoutPupilInput = {
    id?: StringFieldUpdateOperationsInput | string;
    balance?: IntFieldUpdateOperationsInput | number;
    status?: EnumFeesStatusFieldUpdateOperationsInput | $Enums.FeesStatus;
    term?: ClassTermUpdateOneRequiredWithoutFeesNestedInput;
    feesPayments?: FeesPaymentUpdateManyWithoutFeesNestedInput;
  };

  export type FeesUncheckedUpdateWithoutPupilInput = {
    id?: StringFieldUpdateOperationsInput | string;
    balance?: IntFieldUpdateOperationsInput | number;
    termId?: StringFieldUpdateOperationsInput | string;
    status?: EnumFeesStatusFieldUpdateOperationsInput | $Enums.FeesStatus;
    feesPayments?: FeesPaymentUncheckedUpdateManyWithoutFeesNestedInput;
  };

  export type FeesUncheckedUpdateManyWithoutPupilInput = {
    id?: StringFieldUpdateOperationsInput | string;
    balance?: IntFieldUpdateOperationsInput | number;
    termId?: StringFieldUpdateOperationsInput | string;
    status?: EnumFeesStatusFieldUpdateOperationsInput | $Enums.FeesStatus;
  };

  export type classStreamCreateManyClassTeacherInput = {
    id?: string;
    classId?: string | null;
    streamId?: string | null;
  };

  export type AcademicYearSubjectUpdateWithoutTeachersInput = {
    id?: StringFieldUpdateOperationsInput | string;
    customGrading?: GradingUpdateManyWithoutAcademicYearSubjectsNestedInput;
    academicYearClass?: AcademicYearClassUpdateOneRequiredWithoutAcademicYearSubjectsNestedInput;
    subject?: SubjectUpdateOneRequiredWithoutAcademicYearSubjectsNestedInput;
    examSubjects?: ExamSubjectUpdateManyWithoutAcademicYearSubjectNestedInput;
  };

  export type AcademicYearSubjectUncheckedUpdateWithoutTeachersInput = {
    id?: StringFieldUpdateOperationsInput | string;
    academicYearClassId?: StringFieldUpdateOperationsInput | string;
    subjectId?: StringFieldUpdateOperationsInput | string;
    customGrading?: GradingUncheckedUpdateManyWithoutAcademicYearSubjectsNestedInput;
    examSubjects?: ExamSubjectUncheckedUpdateManyWithoutAcademicYearSubjectNestedInput;
  };

  export type AcademicYearSubjectUncheckedUpdateManyWithoutTeachersInput = {
    id?: StringFieldUpdateOperationsInput | string;
    academicYearClassId?: StringFieldUpdateOperationsInput | string;
    subjectId?: StringFieldUpdateOperationsInput | string;
  };

  export type classStreamUpdateWithoutClassTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string;
    pupils?: PupilUpdateManyWithoutClassStreamsNestedInput;
    class?: AcademicYearClassUpdateOneWithoutStreamsNestedInput;
    stream?: StreamUpdateOneWithoutClassStreamsNestedInput;
    terms?: ClassTermUpdateManyWithoutClassStreamNestedInput;
  };

  export type classStreamUncheckedUpdateWithoutClassTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string;
    classId?: NullableStringFieldUpdateOperationsInput | string | null;
    streamId?: NullableStringFieldUpdateOperationsInput | string | null;
    pupils?: PupilUncheckedUpdateManyWithoutClassStreamsNestedInput;
    terms?: ClassTermUncheckedUpdateManyWithoutClassStreamNestedInput;
  };

  export type classStreamUncheckedUpdateManyWithoutClassTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string;
    classId?: NullableStringFieldUpdateOperationsInput | string | null;
    streamId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type ClassCreateManyLevelInput = {
    id?: string;
    name: string;
    createdAt?: Date | string;
    slug: string;
  };

  export type SubjectCreateManyLevelInput = {
    id?: string;
    subjectName: string;
    slug: string;
    code: string;
  };

  export type ClassUpdateWithoutLevelInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    slug?: StringFieldUpdateOperationsInput | string;
    academicYearClasses?: AcademicYearClassUpdateManyWithoutClassNestedInput;
  };

  export type ClassUncheckedUpdateWithoutLevelInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    slug?: StringFieldUpdateOperationsInput | string;
    academicYearClasses?: AcademicYearClassUncheckedUpdateManyWithoutClassNestedInput;
  };

  export type ClassUncheckedUpdateManyWithoutLevelInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    slug?: StringFieldUpdateOperationsInput | string;
  };

  export type SubjectUpdateWithoutLevelInput = {
    id?: StringFieldUpdateOperationsInput | string;
    subjectName?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    code?: StringFieldUpdateOperationsInput | string;
    grading?: GradingUpdateManyWithoutSubjectsNestedInput;
    academicYearSubjects?: AcademicYearSubjectUpdateManyWithoutSubjectNestedInput;
  };

  export type SubjectUncheckedUpdateWithoutLevelInput = {
    id?: StringFieldUpdateOperationsInput | string;
    subjectName?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    code?: StringFieldUpdateOperationsInput | string;
    grading?: GradingUncheckedUpdateManyWithoutSubjectsNestedInput;
    academicYearSubjects?: AcademicYearSubjectUncheckedUpdateManyWithoutSubjectNestedInput;
  };

  export type SubjectUncheckedUpdateManyWithoutLevelInput = {
    id?: StringFieldUpdateOperationsInput | string;
    subjectName?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    code?: StringFieldUpdateOperationsInput | string;
  };

  export type classStreamCreateManyStreamInput = {
    id?: string;
    staffId?: string | null;
    classId?: string | null;
  };

  export type classStreamUpdateWithoutStreamInput = {
    id?: StringFieldUpdateOperationsInput | string;
    pupils?: PupilUpdateManyWithoutClassStreamsNestedInput;
    class?: AcademicYearClassUpdateOneWithoutStreamsNestedInput;
    classTeacher?: StaffUpdateOneWithoutClassStreamsNestedInput;
    terms?: ClassTermUpdateManyWithoutClassStreamNestedInput;
  };

  export type classStreamUncheckedUpdateWithoutStreamInput = {
    id?: StringFieldUpdateOperationsInput | string;
    staffId?: NullableStringFieldUpdateOperationsInput | string | null;
    classId?: NullableStringFieldUpdateOperationsInput | string | null;
    pupils?: PupilUncheckedUpdateManyWithoutClassStreamsNestedInput;
    terms?: ClassTermUncheckedUpdateManyWithoutClassStreamNestedInput;
  };

  export type classStreamUncheckedUpdateManyWithoutStreamInput = {
    id?: StringFieldUpdateOperationsInput | string;
    staffId?: NullableStringFieldUpdateOperationsInput | string | null;
    classId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type AcademicYearClassCreateManyClassInput = {
    id?: string;
    academicYearId?: string | null;
  };

  export type AcademicYearClassUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string;
    academicYear?: AcademicYearUpdateOneWithoutAcademicYearClassesNestedInput;
    academicYearSubjects?: AcademicYearSubjectUpdateManyWithoutAcademicYearClassNestedInput;
    streams?: classStreamUpdateManyWithoutClassNestedInput;
  };

  export type AcademicYearClassUncheckedUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string;
    academicYearId?: NullableStringFieldUpdateOperationsInput | string | null;
    academicYearSubjects?: AcademicYearSubjectUncheckedUpdateManyWithoutAcademicYearClassNestedInput;
    streams?: classStreamUncheckedUpdateManyWithoutClassNestedInput;
  };

  export type AcademicYearClassUncheckedUpdateManyWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string;
    academicYearId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type AcademicYearClassCreateManyAcademicYearInput = {
    id?: string;
    classId?: string | null;
  };

  export type AcademicYearClassUpdateWithoutAcademicYearInput = {
    id?: StringFieldUpdateOperationsInput | string;
    class?: ClassUpdateOneWithoutAcademicYearClassesNestedInput;
    academicYearSubjects?: AcademicYearSubjectUpdateManyWithoutAcademicYearClassNestedInput;
    streams?: classStreamUpdateManyWithoutClassNestedInput;
  };

  export type AcademicYearClassUncheckedUpdateWithoutAcademicYearInput = {
    id?: StringFieldUpdateOperationsInput | string;
    classId?: NullableStringFieldUpdateOperationsInput | string | null;
    academicYearSubjects?: AcademicYearSubjectUncheckedUpdateManyWithoutAcademicYearClassNestedInput;
    streams?: classStreamUncheckedUpdateManyWithoutClassNestedInput;
  };

  export type AcademicYearClassUncheckedUpdateManyWithoutAcademicYearInput = {
    id?: StringFieldUpdateOperationsInput | string;
    classId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type AcademicYearSubjectCreateManyAcademicYearClassInput = {
    id?: string;
    subjectId: string;
  };

  export type classStreamCreateManyClassInput = {
    id?: string;
    staffId?: string | null;
    streamId?: string | null;
  };

  export type AcademicYearSubjectUpdateWithoutAcademicYearClassInput = {
    id?: StringFieldUpdateOperationsInput | string;
    customGrading?: GradingUpdateManyWithoutAcademicYearSubjectsNestedInput;
    teachers?: StaffUpdateManyWithoutAcademicYearSubjectsNestedInput;
    subject?: SubjectUpdateOneRequiredWithoutAcademicYearSubjectsNestedInput;
    examSubjects?: ExamSubjectUpdateManyWithoutAcademicYearSubjectNestedInput;
  };

  export type AcademicYearSubjectUncheckedUpdateWithoutAcademicYearClassInput =
    {
      id?: StringFieldUpdateOperationsInput | string;
      subjectId?: StringFieldUpdateOperationsInput | string;
      customGrading?: GradingUncheckedUpdateManyWithoutAcademicYearSubjectsNestedInput;
      teachers?: StaffUncheckedUpdateManyWithoutAcademicYearSubjectsNestedInput;
      examSubjects?: ExamSubjectUncheckedUpdateManyWithoutAcademicYearSubjectNestedInput;
    };

  export type AcademicYearSubjectUncheckedUpdateManyWithoutAcademicYearClassInput =
    {
      id?: StringFieldUpdateOperationsInput | string;
      subjectId?: StringFieldUpdateOperationsInput | string;
    };

  export type classStreamUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string;
    pupils?: PupilUpdateManyWithoutClassStreamsNestedInput;
    classTeacher?: StaffUpdateOneWithoutClassStreamsNestedInput;
    stream?: StreamUpdateOneWithoutClassStreamsNestedInput;
    terms?: ClassTermUpdateManyWithoutClassStreamNestedInput;
  };

  export type classStreamUncheckedUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string;
    staffId?: NullableStringFieldUpdateOperationsInput | string | null;
    streamId?: NullableStringFieldUpdateOperationsInput | string | null;
    pupils?: PupilUncheckedUpdateManyWithoutClassStreamsNestedInput;
    terms?: ClassTermUncheckedUpdateManyWithoutClassStreamNestedInput;
  };

  export type classStreamUncheckedUpdateManyWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string;
    staffId?: NullableStringFieldUpdateOperationsInput | string | null;
    streamId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type AcademicYearSubjectCreateManySubjectInput = {
    id?: string;
    academicYearClassId: string;
  };

  export type GradingUpdateWithoutSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    from?: FloatFieldUpdateOperationsInput | number;
    to?: FloatFieldUpdateOperationsInput | number;
    grade?: StringFieldUpdateOperationsInput | string;
    remarks?: NullableStringFieldUpdateOperationsInput | string | null;
    academicYearSubjects?: AcademicYearSubjectUpdateManyWithoutCustomGradingNestedInput;
  };

  export type GradingUncheckedUpdateWithoutSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    from?: FloatFieldUpdateOperationsInput | number;
    to?: FloatFieldUpdateOperationsInput | number;
    grade?: StringFieldUpdateOperationsInput | string;
    remarks?: NullableStringFieldUpdateOperationsInput | string | null;
    academicYearSubjects?: AcademicYearSubjectUncheckedUpdateManyWithoutCustomGradingNestedInput;
  };

  export type GradingUncheckedUpdateManyWithoutSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    from?: FloatFieldUpdateOperationsInput | number;
    to?: FloatFieldUpdateOperationsInput | number;
    grade?: StringFieldUpdateOperationsInput | string;
    remarks?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type AcademicYearSubjectUpdateWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string;
    customGrading?: GradingUpdateManyWithoutAcademicYearSubjectsNestedInput;
    academicYearClass?: AcademicYearClassUpdateOneRequiredWithoutAcademicYearSubjectsNestedInput;
    teachers?: StaffUpdateManyWithoutAcademicYearSubjectsNestedInput;
    examSubjects?: ExamSubjectUpdateManyWithoutAcademicYearSubjectNestedInput;
  };

  export type AcademicYearSubjectUncheckedUpdateWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string;
    academicYearClassId?: StringFieldUpdateOperationsInput | string;
    customGrading?: GradingUncheckedUpdateManyWithoutAcademicYearSubjectsNestedInput;
    teachers?: StaffUncheckedUpdateManyWithoutAcademicYearSubjectsNestedInput;
    examSubjects?: ExamSubjectUncheckedUpdateManyWithoutAcademicYearSubjectNestedInput;
  };

  export type AcademicYearSubjectUncheckedUpdateManyWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string;
    academicYearClassId?: StringFieldUpdateOperationsInput | string;
  };

  export type SubjectUpdateWithoutGradingInput = {
    id?: StringFieldUpdateOperationsInput | string;
    subjectName?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    code?: StringFieldUpdateOperationsInput | string;
    academicYearSubjects?: AcademicYearSubjectUpdateManyWithoutSubjectNestedInput;
    level?: LevelUpdateOneRequiredWithoutSubjectsNestedInput;
  };

  export type SubjectUncheckedUpdateWithoutGradingInput = {
    id?: StringFieldUpdateOperationsInput | string;
    subjectName?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    code?: StringFieldUpdateOperationsInput | string;
    levelId?: StringFieldUpdateOperationsInput | string;
    academicYearSubjects?: AcademicYearSubjectUncheckedUpdateManyWithoutSubjectNestedInput;
  };

  export type SubjectUncheckedUpdateManyWithoutGradingInput = {
    id?: StringFieldUpdateOperationsInput | string;
    subjectName?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    code?: StringFieldUpdateOperationsInput | string;
    levelId?: StringFieldUpdateOperationsInput | string;
  };

  export type AcademicYearSubjectUpdateWithoutCustomGradingInput = {
    id?: StringFieldUpdateOperationsInput | string;
    academicYearClass?: AcademicYearClassUpdateOneRequiredWithoutAcademicYearSubjectsNestedInput;
    teachers?: StaffUpdateManyWithoutAcademicYearSubjectsNestedInput;
    subject?: SubjectUpdateOneRequiredWithoutAcademicYearSubjectsNestedInput;
    examSubjects?: ExamSubjectUpdateManyWithoutAcademicYearSubjectNestedInput;
  };

  export type AcademicYearSubjectUncheckedUpdateWithoutCustomGradingInput = {
    id?: StringFieldUpdateOperationsInput | string;
    academicYearClassId?: StringFieldUpdateOperationsInput | string;
    subjectId?: StringFieldUpdateOperationsInput | string;
    teachers?: StaffUncheckedUpdateManyWithoutAcademicYearSubjectsNestedInput;
    examSubjects?: ExamSubjectUncheckedUpdateManyWithoutAcademicYearSubjectNestedInput;
  };

  export type AcademicYearSubjectUncheckedUpdateManyWithoutCustomGradingInput =
    {
      id?: StringFieldUpdateOperationsInput | string;
      academicYearClassId?: StringFieldUpdateOperationsInput | string;
      subjectId?: StringFieldUpdateOperationsInput | string;
    };

  export type ExamSubjectCreateManyAcademicYearSubjectInput = {
    id?: string;
    examId: string;
    examDate: Date | string;
  };

  export type GradingUpdateWithoutAcademicYearSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    from?: FloatFieldUpdateOperationsInput | number;
    to?: FloatFieldUpdateOperationsInput | number;
    grade?: StringFieldUpdateOperationsInput | string;
    remarks?: NullableStringFieldUpdateOperationsInput | string | null;
    subjects?: SubjectUpdateManyWithoutGradingNestedInput;
  };

  export type GradingUncheckedUpdateWithoutAcademicYearSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    from?: FloatFieldUpdateOperationsInput | number;
    to?: FloatFieldUpdateOperationsInput | number;
    grade?: StringFieldUpdateOperationsInput | string;
    remarks?: NullableStringFieldUpdateOperationsInput | string | null;
    subjects?: SubjectUncheckedUpdateManyWithoutGradingNestedInput;
  };

  export type GradingUncheckedUpdateManyWithoutAcademicYearSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    from?: FloatFieldUpdateOperationsInput | number;
    to?: FloatFieldUpdateOperationsInput | number;
    grade?: StringFieldUpdateOperationsInput | string;
    remarks?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type StaffUpdateWithoutAcademicYearSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    staffType?: EnumStaffTypeFieldUpdateOperationsInput | $Enums.StaffType;
    genericPassword?: StringFieldUpdateOperationsInput | string;
    classStreams?: classStreamUpdateManyWithoutClassTeacherNestedInput;
    user?: UserUpdateOneWithoutStaffsNestedInput;
  };

  export type StaffUncheckedUpdateWithoutAcademicYearSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    staffType?: EnumStaffTypeFieldUpdateOperationsInput | $Enums.StaffType;
    userId?: NullableStringFieldUpdateOperationsInput | string | null;
    genericPassword?: StringFieldUpdateOperationsInput | string;
    classStreams?: classStreamUncheckedUpdateManyWithoutClassTeacherNestedInput;
  };

  export type StaffUncheckedUpdateManyWithoutAcademicYearSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    staffType?: EnumStaffTypeFieldUpdateOperationsInput | $Enums.StaffType;
    userId?: NullableStringFieldUpdateOperationsInput | string | null;
    genericPassword?: StringFieldUpdateOperationsInput | string;
  };

  export type ExamSubjectUpdateWithoutAcademicYearSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string;
    examDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    exam?: ExamUpdateOneRequiredWithoutExamSubjectsNestedInput;
    examScores?: ExamScoreUpdateManyWithoutExamSubjectNestedInput;
  };

  export type ExamSubjectUncheckedUpdateWithoutAcademicYearSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string;
    examId?: StringFieldUpdateOperationsInput | string;
    examDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    examScores?: ExamScoreUncheckedUpdateManyWithoutExamSubjectNestedInput;
  };

  export type ExamSubjectUncheckedUpdateManyWithoutAcademicYearSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string;
    examId?: StringFieldUpdateOperationsInput | string;
    examDate?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ClassTermCreateManyClassStreamInput = {
    id?: string;
    startAt?: Date | string;
    endAt: Date | string;
    termId?: string | null;
    feesAmount?: number | null;
  };

  export type PupilUpdateWithoutClassStreamsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    genericPassword?: StringFieldUpdateOperationsInput | string;
    examScores?: ExamScoreUpdateManyWithoutPupilNestedInput;
    fees?: FeesUpdateManyWithoutPupilNestedInput;
    user?: UserUpdateOneWithoutPupilsNestedInput;
  };

  export type PupilUncheckedUpdateWithoutClassStreamsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: NullableStringFieldUpdateOperationsInput | string | null;
    genericPassword?: StringFieldUpdateOperationsInput | string;
    examScores?: ExamScoreUncheckedUpdateManyWithoutPupilNestedInput;
    fees?: FeesUncheckedUpdateManyWithoutPupilNestedInput;
  };

  export type PupilUncheckedUpdateManyWithoutClassStreamsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: NullableStringFieldUpdateOperationsInput | string | null;
    genericPassword?: StringFieldUpdateOperationsInput | string;
  };

  export type ClassTermUpdateWithoutClassStreamInput = {
    id?: StringFieldUpdateOperationsInput | string;
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    feesAmount?: NullableIntFieldUpdateOperationsInput | number | null;
    term?: TermUpdateOneWithoutClassTermsNestedInput;
    exams?: ExamUpdateManyWithoutClassTermNestedInput;
    fees?: FeesUpdateManyWithoutTermNestedInput;
  };

  export type ClassTermUncheckedUpdateWithoutClassStreamInput = {
    id?: StringFieldUpdateOperationsInput | string;
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    termId?: NullableStringFieldUpdateOperationsInput | string | null;
    feesAmount?: NullableIntFieldUpdateOperationsInput | number | null;
    exams?: ExamUncheckedUpdateManyWithoutClassTermNestedInput;
    fees?: FeesUncheckedUpdateManyWithoutTermNestedInput;
  };

  export type ClassTermUncheckedUpdateManyWithoutClassStreamInput = {
    id?: StringFieldUpdateOperationsInput | string;
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    termId?: NullableStringFieldUpdateOperationsInput | string | null;
    feesAmount?: NullableIntFieldUpdateOperationsInput | number | null;
  };

  export type ClassTermCreateManyTermInput = {
    id?: string;
    startAt?: Date | string;
    endAt: Date | string;
    classStreamId?: string | null;
    feesAmount?: number | null;
  };

  export type ClassTermUpdateWithoutTermInput = {
    id?: StringFieldUpdateOperationsInput | string;
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    feesAmount?: NullableIntFieldUpdateOperationsInput | number | null;
    classStream?: classStreamUpdateOneWithoutTermsNestedInput;
    exams?: ExamUpdateManyWithoutClassTermNestedInput;
    fees?: FeesUpdateManyWithoutTermNestedInput;
  };

  export type ClassTermUncheckedUpdateWithoutTermInput = {
    id?: StringFieldUpdateOperationsInput | string;
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    classStreamId?: NullableStringFieldUpdateOperationsInput | string | null;
    feesAmount?: NullableIntFieldUpdateOperationsInput | number | null;
    exams?: ExamUncheckedUpdateManyWithoutClassTermNestedInput;
    fees?: FeesUncheckedUpdateManyWithoutTermNestedInput;
  };

  export type ClassTermUncheckedUpdateManyWithoutTermInput = {
    id?: StringFieldUpdateOperationsInput | string;
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    classStreamId?: NullableStringFieldUpdateOperationsInput | string | null;
    feesAmount?: NullableIntFieldUpdateOperationsInput | number | null;
  };

  export type ExamCreateManyClassTermInput = {
    id: string;
    examName: string;
    examType?: $Enums.ExamType;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type FeesCreateManyTermInput = {
    id?: string;
    pupilId: string;
    balance?: number;
    status?: $Enums.FeesStatus;
  };

  export type ExamUpdateWithoutClassTermInput = {
    id?: StringFieldUpdateOperationsInput | string;
    examName?: StringFieldUpdateOperationsInput | string;
    examType?: EnumExamTypeFieldUpdateOperationsInput | $Enums.ExamType;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    examSubjects?: ExamSubjectUpdateManyWithoutExamNestedInput;
  };

  export type ExamUncheckedUpdateWithoutClassTermInput = {
    id?: StringFieldUpdateOperationsInput | string;
    examName?: StringFieldUpdateOperationsInput | string;
    examType?: EnumExamTypeFieldUpdateOperationsInput | $Enums.ExamType;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    examSubjects?: ExamSubjectUncheckedUpdateManyWithoutExamNestedInput;
  };

  export type ExamUncheckedUpdateManyWithoutClassTermInput = {
    id?: StringFieldUpdateOperationsInput | string;
    examName?: StringFieldUpdateOperationsInput | string;
    examType?: EnumExamTypeFieldUpdateOperationsInput | $Enums.ExamType;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type FeesUpdateWithoutTermInput = {
    id?: StringFieldUpdateOperationsInput | string;
    balance?: IntFieldUpdateOperationsInput | number;
    status?: EnumFeesStatusFieldUpdateOperationsInput | $Enums.FeesStatus;
    pupil?: PupilUpdateOneRequiredWithoutFeesNestedInput;
    feesPayments?: FeesPaymentUpdateManyWithoutFeesNestedInput;
  };

  export type FeesUncheckedUpdateWithoutTermInput = {
    id?: StringFieldUpdateOperationsInput | string;
    pupilId?: StringFieldUpdateOperationsInput | string;
    balance?: IntFieldUpdateOperationsInput | number;
    status?: EnumFeesStatusFieldUpdateOperationsInput | $Enums.FeesStatus;
    feesPayments?: FeesPaymentUncheckedUpdateManyWithoutFeesNestedInput;
  };

  export type FeesUncheckedUpdateManyWithoutTermInput = {
    id?: StringFieldUpdateOperationsInput | string;
    pupilId?: StringFieldUpdateOperationsInput | string;
    balance?: IntFieldUpdateOperationsInput | number;
    status?: EnumFeesStatusFieldUpdateOperationsInput | $Enums.FeesStatus;
  };

  export type FeesPaymentCreateManyFeesInput = {
    id?: string;
    amountPaid: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    userId: string;
  };

  export type FeesPaymentUpdateWithoutFeesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    amountPaid?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    paidBy?: UserUpdateOneRequiredWithoutFeesPaymentsNestedInput;
  };

  export type FeesPaymentUncheckedUpdateWithoutFeesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    amountPaid?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    userId?: StringFieldUpdateOperationsInput | string;
  };

  export type FeesPaymentUncheckedUpdateManyWithoutFeesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    amountPaid?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    userId?: StringFieldUpdateOperationsInput | string;
  };

  export type ComputerLabItemCreateManyAssetInput = {
    id?: string;
    name: string;
    model?: string | null;
    specification?: string | null;
    quantity?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    trackQuantity?: boolean;
    unit: $Enums.AssetUnit;
  };

  export type FoodStoreItemCreateManyAssetInput = {
    id?: string;
    foodName: string;
    unit: $Enums.AssetUnit;
    quantity?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    supplierId?: string | null;
    trackQuantity?: boolean;
    status?: $Enums.AssetItemStatus;
    isConsumable?: boolean;
  };

  export type GeneralStoreItemCreateManyAssetInput = {
    id?: string;
    name: string;
    quantity?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    status?: $Enums.AssetItemStatus;
    trackQuantity?: boolean;
    unit: $Enums.AssetUnit;
  };

  export type LabItemCreateManyAssetInput = {
    id?: string;
    name: string;
    quantity?: number | null;
    unit: $Enums.AssetUnit;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    trackQuantity?: boolean;
    status?: $Enums.AssetStatus;
  };

  export type LibraryBookCreateManyAssetInput = {
    id?: string;
    title: string;
    author: string;
    libraryBookCategoryId: string;
    quantity?: number | null;
    trackQuantity?: boolean;
    unit: $Enums.AssetUnit;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ComputerLabItemUpdateWithoutAssetInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    model?: NullableStringFieldUpdateOperationsInput | string | null;
    specification?: NullableStringFieldUpdateOperationsInput | string | null;
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    trackQuantity?: BoolFieldUpdateOperationsInput | boolean;
    unit?: EnumAssetUnitFieldUpdateOperationsInput | $Enums.AssetUnit;
    individualComputerLabItems?: IndividualComputerLabItemUpdateManyWithoutComputerLabItemNestedInput;
  };

  export type ComputerLabItemUncheckedUpdateWithoutAssetInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    model?: NullableStringFieldUpdateOperationsInput | string | null;
    specification?: NullableStringFieldUpdateOperationsInput | string | null;
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    trackQuantity?: BoolFieldUpdateOperationsInput | boolean;
    unit?: EnumAssetUnitFieldUpdateOperationsInput | $Enums.AssetUnit;
    individualComputerLabItems?: IndividualComputerLabItemUncheckedUpdateManyWithoutComputerLabItemNestedInput;
  };

  export type ComputerLabItemUncheckedUpdateManyWithoutAssetInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    model?: NullableStringFieldUpdateOperationsInput | string | null;
    specification?: NullableStringFieldUpdateOperationsInput | string | null;
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    trackQuantity?: BoolFieldUpdateOperationsInput | boolean;
    unit?: EnumAssetUnitFieldUpdateOperationsInput | $Enums.AssetUnit;
  };

  export type FoodStoreItemUpdateWithoutAssetInput = {
    id?: StringFieldUpdateOperationsInput | string;
    foodName?: StringFieldUpdateOperationsInput | string;
    unit?: EnumAssetUnitFieldUpdateOperationsInput | $Enums.AssetUnit;
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    trackQuantity?: BoolFieldUpdateOperationsInput | boolean;
    status?:
      | EnumAssetItemStatusFieldUpdateOperationsInput
      | $Enums.AssetItemStatus;
    isConsumable?: BoolFieldUpdateOperationsInput | boolean;
    consumptions?: FoodConsumptionUpdateManyWithoutFoodItemNestedInput;
    supplier?: SupplierUpdateOneWithoutFoodStoreItemsNestedInput;
    individualFoodStoreItems?: IndividualFoodStoreItemUpdateManyWithoutFoodStoreItemNestedInput;
  };

  export type FoodStoreItemUncheckedUpdateWithoutAssetInput = {
    id?: StringFieldUpdateOperationsInput | string;
    foodName?: StringFieldUpdateOperationsInput | string;
    unit?: EnumAssetUnitFieldUpdateOperationsInput | $Enums.AssetUnit;
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null;
    trackQuantity?: BoolFieldUpdateOperationsInput | boolean;
    status?:
      | EnumAssetItemStatusFieldUpdateOperationsInput
      | $Enums.AssetItemStatus;
    isConsumable?: BoolFieldUpdateOperationsInput | boolean;
    consumptions?: FoodConsumptionUncheckedUpdateManyWithoutFoodItemNestedInput;
    individualFoodStoreItems?: IndividualFoodStoreItemUncheckedUpdateManyWithoutFoodStoreItemNestedInput;
  };

  export type FoodStoreItemUncheckedUpdateManyWithoutAssetInput = {
    id?: StringFieldUpdateOperationsInput | string;
    foodName?: StringFieldUpdateOperationsInput | string;
    unit?: EnumAssetUnitFieldUpdateOperationsInput | $Enums.AssetUnit;
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null;
    trackQuantity?: BoolFieldUpdateOperationsInput | boolean;
    status?:
      | EnumAssetItemStatusFieldUpdateOperationsInput
      | $Enums.AssetItemStatus;
    isConsumable?: BoolFieldUpdateOperationsInput | boolean;
  };

  export type GeneralStoreItemUpdateWithoutAssetInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    status?:
      | EnumAssetItemStatusFieldUpdateOperationsInput
      | $Enums.AssetItemStatus;
    trackQuantity?: BoolFieldUpdateOperationsInput | boolean;
    unit?: EnumAssetUnitFieldUpdateOperationsInput | $Enums.AssetUnit;
    individualGeneralStoreItems?: IndividualGeneralStoreItemUpdateManyWithoutGeneralStoreItemNestedInput;
  };

  export type GeneralStoreItemUncheckedUpdateWithoutAssetInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    status?:
      | EnumAssetItemStatusFieldUpdateOperationsInput
      | $Enums.AssetItemStatus;
    trackQuantity?: BoolFieldUpdateOperationsInput | boolean;
    unit?: EnumAssetUnitFieldUpdateOperationsInput | $Enums.AssetUnit;
    individualGeneralStoreItems?: IndividualGeneralStoreItemUncheckedUpdateManyWithoutGeneralStoreItemNestedInput;
  };

  export type GeneralStoreItemUncheckedUpdateManyWithoutAssetInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    status?:
      | EnumAssetItemStatusFieldUpdateOperationsInput
      | $Enums.AssetItemStatus;
    trackQuantity?: BoolFieldUpdateOperationsInput | boolean;
    unit?: EnumAssetUnitFieldUpdateOperationsInput | $Enums.AssetUnit;
  };

  export type LabItemUpdateWithoutAssetInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null;
    unit?: EnumAssetUnitFieldUpdateOperationsInput | $Enums.AssetUnit;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    trackQuantity?: BoolFieldUpdateOperationsInput | boolean;
    status?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus;
    individualLabItems?: IndividualLabItemUpdateManyWithoutLabItemNestedInput;
  };

  export type LabItemUncheckedUpdateWithoutAssetInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null;
    unit?: EnumAssetUnitFieldUpdateOperationsInput | $Enums.AssetUnit;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    trackQuantity?: BoolFieldUpdateOperationsInput | boolean;
    status?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus;
    individualLabItems?: IndividualLabItemUncheckedUpdateManyWithoutLabItemNestedInput;
  };

  export type LabItemUncheckedUpdateManyWithoutAssetInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null;
    unit?: EnumAssetUnitFieldUpdateOperationsInput | $Enums.AssetUnit;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    trackQuantity?: BoolFieldUpdateOperationsInput | boolean;
    status?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus;
  };

  export type LibraryBookUpdateWithoutAssetInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    author?: StringFieldUpdateOperationsInput | string;
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null;
    trackQuantity?: BoolFieldUpdateOperationsInput | boolean;
    unit?: EnumAssetUnitFieldUpdateOperationsInput | $Enums.AssetUnit;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    individualBooks?: IndividualBookUpdateManyWithoutLibraryBookNestedInput;
    category?: LibraryBookCategoryUpdateOneRequiredWithoutLibraryBooksNestedInput;
  };

  export type LibraryBookUncheckedUpdateWithoutAssetInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    author?: StringFieldUpdateOperationsInput | string;
    libraryBookCategoryId?: StringFieldUpdateOperationsInput | string;
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null;
    trackQuantity?: BoolFieldUpdateOperationsInput | boolean;
    unit?: EnumAssetUnitFieldUpdateOperationsInput | $Enums.AssetUnit;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    individualBooks?: IndividualBookUncheckedUpdateManyWithoutLibraryBookNestedInput;
  };

  export type LibraryBookUncheckedUpdateManyWithoutAssetInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    author?: StringFieldUpdateOperationsInput | string;
    libraryBookCategoryId?: StringFieldUpdateOperationsInput | string;
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null;
    trackQuantity?: BoolFieldUpdateOperationsInput | boolean;
    unit?: EnumAssetUnitFieldUpdateOperationsInput | $Enums.AssetUnit;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type FoodConsumptionCreateManyFoodItemInput = {
    id?: string;
    quantityUsed?: number | null;
    dateUsedAt?: Date | string;
    usageDetails?: string | null;
  };

  export type IndividualFoodStoreItemCreateManyFoodStoreItemInput = {
    id?: string;
    uniqueIdentifier?: string | null;
    status?: $Enums.AssetStatus;
    condition?: $Enums.AssetCondition;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type FoodConsumptionUpdateWithoutFoodItemInput = {
    id?: StringFieldUpdateOperationsInput | string;
    quantityUsed?: NullableFloatFieldUpdateOperationsInput | number | null;
    dateUsedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    usageDetails?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type FoodConsumptionUncheckedUpdateWithoutFoodItemInput = {
    id?: StringFieldUpdateOperationsInput | string;
    quantityUsed?: NullableFloatFieldUpdateOperationsInput | number | null;
    dateUsedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    usageDetails?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type FoodConsumptionUncheckedUpdateManyWithoutFoodItemInput = {
    id?: StringFieldUpdateOperationsInput | string;
    quantityUsed?: NullableFloatFieldUpdateOperationsInput | number | null;
    dateUsedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    usageDetails?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type IndividualFoodStoreItemUpdateWithoutFoodStoreItemInput = {
    id?: StringFieldUpdateOperationsInput | string;
    uniqueIdentifier?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus;
    condition?:
      | EnumAssetConditionFieldUpdateOperationsInput
      | $Enums.AssetCondition;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    assetDamages?: AssetDamageUpdateManyWithoutIndividualFoodStoreItemNestedInput;
  };

  export type IndividualFoodStoreItemUncheckedUpdateWithoutFoodStoreItemInput =
    {
      id?: StringFieldUpdateOperationsInput | string;
      uniqueIdentifier?:
        | NullableStringFieldUpdateOperationsInput
        | string
        | null;
      status?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus;
      condition?:
        | EnumAssetConditionFieldUpdateOperationsInput
        | $Enums.AssetCondition;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      assetDamages?: AssetDamageUncheckedUpdateManyWithoutIndividualFoodStoreItemNestedInput;
    };

  export type IndividualFoodStoreItemUncheckedUpdateManyWithoutFoodStoreItemInput =
    {
      id?: StringFieldUpdateOperationsInput | string;
      uniqueIdentifier?:
        | NullableStringFieldUpdateOperationsInput
        | string
        | null;
      status?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus;
      condition?:
        | EnumAssetConditionFieldUpdateOperationsInput
        | $Enums.AssetCondition;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    };

  export type AssetDamageCreateManyIndividualFoodStoreItemInput = {
    id?: string;
    damageDetails: string;
    condition: $Enums.AssetCondition;
    quantity: number;
    userId?: string | null;
    individualComputerLabItemId?: string | null;
    isRepaired?: boolean;
    repairedAt?: Date | string | null;
    createdAt?: Date | string;
    individualBookId?: string | null;
    individualLabItemId?: string | null;
    individualGeneralStoreItemId?: string | null;
    isSchoolCost?: boolean;
    repairBalance?: number;
    repairPrice?: number | null;
  };

  export type AssetDamageUpdateWithoutIndividualFoodStoreItemInput = {
    id?: StringFieldUpdateOperationsInput | string;
    damageDetails?: StringFieldUpdateOperationsInput | string;
    condition?:
      | EnumAssetConditionFieldUpdateOperationsInput
      | $Enums.AssetCondition;
    quantity?: IntFieldUpdateOperationsInput | number;
    isRepaired?: BoolFieldUpdateOperationsInput | boolean;
    repairedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    isSchoolCost?: BoolFieldUpdateOperationsInput | boolean;
    repairBalance?: FloatFieldUpdateOperationsInput | number;
    repairPrice?: NullableFloatFieldUpdateOperationsInput | number | null;
    individualBook?: IndividualBookUpdateOneWithoutBookDamagesNestedInput;
    individualComputerLabItem?: IndividualComputerLabItemUpdateOneWithoutAssetDamagesNestedInput;
    individualGeneralStoreItem?: IndividualGeneralStoreItemUpdateOneWithoutAssetDamagesNestedInput;
    individualLabItem?: IndividualLabItemUpdateOneWithoutAssetDamagesNestedInput;
    damagedBy?: UserUpdateOneWithoutAssetDamagesNestedInput;
    assetRepairPayments?: AssetRepairPaymentUpdateManyWithoutAssetDamageNestedInput;
  };

  export type AssetDamageUncheckedUpdateWithoutIndividualFoodStoreItemInput = {
    id?: StringFieldUpdateOperationsInput | string;
    damageDetails?: StringFieldUpdateOperationsInput | string;
    condition?:
      | EnumAssetConditionFieldUpdateOperationsInput
      | $Enums.AssetCondition;
    quantity?: IntFieldUpdateOperationsInput | number;
    userId?: NullableStringFieldUpdateOperationsInput | string | null;
    individualComputerLabItemId?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    isRepaired?: BoolFieldUpdateOperationsInput | boolean;
    repairedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    individualBookId?: NullableStringFieldUpdateOperationsInput | string | null;
    individualLabItemId?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    individualGeneralStoreItemId?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    isSchoolCost?: BoolFieldUpdateOperationsInput | boolean;
    repairBalance?: FloatFieldUpdateOperationsInput | number;
    repairPrice?: NullableFloatFieldUpdateOperationsInput | number | null;
    assetRepairPayments?: AssetRepairPaymentUncheckedUpdateManyWithoutAssetDamageNestedInput;
  };

  export type AssetDamageUncheckedUpdateManyWithoutIndividualFoodStoreItemInput =
    {
      id?: StringFieldUpdateOperationsInput | string;
      damageDetails?: StringFieldUpdateOperationsInput | string;
      condition?:
        | EnumAssetConditionFieldUpdateOperationsInput
        | $Enums.AssetCondition;
      quantity?: IntFieldUpdateOperationsInput | number;
      userId?: NullableStringFieldUpdateOperationsInput | string | null;
      individualComputerLabItemId?:
        | NullableStringFieldUpdateOperationsInput
        | string
        | null;
      isRepaired?: BoolFieldUpdateOperationsInput | boolean;
      repairedAt?:
        | NullableDateTimeFieldUpdateOperationsInput
        | Date
        | string
        | null;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      individualBookId?:
        | NullableStringFieldUpdateOperationsInput
        | string
        | null;
      individualLabItemId?:
        | NullableStringFieldUpdateOperationsInput
        | string
        | null;
      individualGeneralStoreItemId?:
        | NullableStringFieldUpdateOperationsInput
        | string
        | null;
      isSchoolCost?: BoolFieldUpdateOperationsInput | boolean;
      repairBalance?: FloatFieldUpdateOperationsInput | number;
      repairPrice?: NullableFloatFieldUpdateOperationsInput | number | null;
    };

  export type FoodStoreItemCreateManySupplierInput = {
    id?: string;
    assetId: string;
    foodName: string;
    unit: $Enums.AssetUnit;
    quantity?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    trackQuantity?: boolean;
    status?: $Enums.AssetItemStatus;
    isConsumable?: boolean;
  };

  export type FoodStoreItemUpdateWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string;
    foodName?: StringFieldUpdateOperationsInput | string;
    unit?: EnumAssetUnitFieldUpdateOperationsInput | $Enums.AssetUnit;
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    trackQuantity?: BoolFieldUpdateOperationsInput | boolean;
    status?:
      | EnumAssetItemStatusFieldUpdateOperationsInput
      | $Enums.AssetItemStatus;
    isConsumable?: BoolFieldUpdateOperationsInput | boolean;
    consumptions?: FoodConsumptionUpdateManyWithoutFoodItemNestedInput;
    asset?: AssetUpdateOneRequiredWithoutFoodStoreItemsNestedInput;
    individualFoodStoreItems?: IndividualFoodStoreItemUpdateManyWithoutFoodStoreItemNestedInput;
  };

  export type FoodStoreItemUncheckedUpdateWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string;
    assetId?: StringFieldUpdateOperationsInput | string;
    foodName?: StringFieldUpdateOperationsInput | string;
    unit?: EnumAssetUnitFieldUpdateOperationsInput | $Enums.AssetUnit;
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    trackQuantity?: BoolFieldUpdateOperationsInput | boolean;
    status?:
      | EnumAssetItemStatusFieldUpdateOperationsInput
      | $Enums.AssetItemStatus;
    isConsumable?: BoolFieldUpdateOperationsInput | boolean;
    consumptions?: FoodConsumptionUncheckedUpdateManyWithoutFoodItemNestedInput;
    individualFoodStoreItems?: IndividualFoodStoreItemUncheckedUpdateManyWithoutFoodStoreItemNestedInput;
  };

  export type FoodStoreItemUncheckedUpdateManyWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string;
    assetId?: StringFieldUpdateOperationsInput | string;
    foodName?: StringFieldUpdateOperationsInput | string;
    unit?: EnumAssetUnitFieldUpdateOperationsInput | $Enums.AssetUnit;
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    trackQuantity?: BoolFieldUpdateOperationsInput | boolean;
    status?:
      | EnumAssetItemStatusFieldUpdateOperationsInput
      | $Enums.AssetItemStatus;
    isConsumable?: BoolFieldUpdateOperationsInput | boolean;
  };

  export type IndividualBookCreateManyLibraryBookInput = {
    id?: string;
    isbn?: string | null;
    status?: $Enums.BookStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    condition?: $Enums.AssetCondition;
    borrowCount?: number;
  };

  export type IndividualBookUpdateWithoutLibraryBookInput = {
    id?: StringFieldUpdateOperationsInput | string;
    isbn?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumBookStatusFieldUpdateOperationsInput | $Enums.BookStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    condition?:
      | EnumAssetConditionFieldUpdateOperationsInput
      | $Enums.AssetCondition;
    borrowCount?: IntFieldUpdateOperationsInput | number;
    bookDamages?: AssetDamageUpdateManyWithoutIndividualBookNestedInput;
    borrowers?: BorrowerUpdateManyWithoutLibraryBookNestedInput;
  };

  export type IndividualBookUncheckedUpdateWithoutLibraryBookInput = {
    id?: StringFieldUpdateOperationsInput | string;
    isbn?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumBookStatusFieldUpdateOperationsInput | $Enums.BookStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    condition?:
      | EnumAssetConditionFieldUpdateOperationsInput
      | $Enums.AssetCondition;
    borrowCount?: IntFieldUpdateOperationsInput | number;
    bookDamages?: AssetDamageUncheckedUpdateManyWithoutIndividualBookNestedInput;
    borrowers?: BorrowerUncheckedUpdateManyWithoutLibraryBookNestedInput;
  };

  export type IndividualBookUncheckedUpdateManyWithoutLibraryBookInput = {
    id?: StringFieldUpdateOperationsInput | string;
    isbn?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumBookStatusFieldUpdateOperationsInput | $Enums.BookStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    condition?:
      | EnumAssetConditionFieldUpdateOperationsInput
      | $Enums.AssetCondition;
    borrowCount?: IntFieldUpdateOperationsInput | number;
  };

  export type AssetDamageCreateManyIndividualBookInput = {
    id?: string;
    damageDetails: string;
    condition: $Enums.AssetCondition;
    quantity: number;
    userId?: string | null;
    individualComputerLabItemId?: string | null;
    isRepaired?: boolean;
    repairedAt?: Date | string | null;
    createdAt?: Date | string;
    individualLabItemId?: string | null;
    individualFoodStoreItemId?: string | null;
    individualGeneralStoreItemId?: string | null;
    isSchoolCost?: boolean;
    repairBalance?: number;
    repairPrice?: number | null;
  };

  export type BorrowerCreateManyLibraryBookInput = {
    id?: string;
    borrowedAt?: Date | string;
    returnAt?: Date | string | null;
    status?: $Enums.BorrowStatus;
    userId: string;
  };

  export type AssetDamageUpdateWithoutIndividualBookInput = {
    id?: StringFieldUpdateOperationsInput | string;
    damageDetails?: StringFieldUpdateOperationsInput | string;
    condition?:
      | EnumAssetConditionFieldUpdateOperationsInput
      | $Enums.AssetCondition;
    quantity?: IntFieldUpdateOperationsInput | number;
    isRepaired?: BoolFieldUpdateOperationsInput | boolean;
    repairedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    isSchoolCost?: BoolFieldUpdateOperationsInput | boolean;
    repairBalance?: FloatFieldUpdateOperationsInput | number;
    repairPrice?: NullableFloatFieldUpdateOperationsInput | number | null;
    individualComputerLabItem?: IndividualComputerLabItemUpdateOneWithoutAssetDamagesNestedInput;
    individualFoodStoreItem?: IndividualFoodStoreItemUpdateOneWithoutAssetDamagesNestedInput;
    individualGeneralStoreItem?: IndividualGeneralStoreItemUpdateOneWithoutAssetDamagesNestedInput;
    individualLabItem?: IndividualLabItemUpdateOneWithoutAssetDamagesNestedInput;
    damagedBy?: UserUpdateOneWithoutAssetDamagesNestedInput;
    assetRepairPayments?: AssetRepairPaymentUpdateManyWithoutAssetDamageNestedInput;
  };

  export type AssetDamageUncheckedUpdateWithoutIndividualBookInput = {
    id?: StringFieldUpdateOperationsInput | string;
    damageDetails?: StringFieldUpdateOperationsInput | string;
    condition?:
      | EnumAssetConditionFieldUpdateOperationsInput
      | $Enums.AssetCondition;
    quantity?: IntFieldUpdateOperationsInput | number;
    userId?: NullableStringFieldUpdateOperationsInput | string | null;
    individualComputerLabItemId?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    isRepaired?: BoolFieldUpdateOperationsInput | boolean;
    repairedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    individualLabItemId?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    individualFoodStoreItemId?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    individualGeneralStoreItemId?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    isSchoolCost?: BoolFieldUpdateOperationsInput | boolean;
    repairBalance?: FloatFieldUpdateOperationsInput | number;
    repairPrice?: NullableFloatFieldUpdateOperationsInput | number | null;
    assetRepairPayments?: AssetRepairPaymentUncheckedUpdateManyWithoutAssetDamageNestedInput;
  };

  export type AssetDamageUncheckedUpdateManyWithoutIndividualBookInput = {
    id?: StringFieldUpdateOperationsInput | string;
    damageDetails?: StringFieldUpdateOperationsInput | string;
    condition?:
      | EnumAssetConditionFieldUpdateOperationsInput
      | $Enums.AssetCondition;
    quantity?: IntFieldUpdateOperationsInput | number;
    userId?: NullableStringFieldUpdateOperationsInput | string | null;
    individualComputerLabItemId?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    isRepaired?: BoolFieldUpdateOperationsInput | boolean;
    repairedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    individualLabItemId?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    individualFoodStoreItemId?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    individualGeneralStoreItemId?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    isSchoolCost?: BoolFieldUpdateOperationsInput | boolean;
    repairBalance?: FloatFieldUpdateOperationsInput | number;
    repairPrice?: NullableFloatFieldUpdateOperationsInput | number | null;
  };

  export type BorrowerUpdateWithoutLibraryBookInput = {
    id?: StringFieldUpdateOperationsInput | string;
    borrowedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    returnAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    status?: EnumBorrowStatusFieldUpdateOperationsInput | $Enums.BorrowStatus;
    user?: UserUpdateOneRequiredWithoutBorrowersNestedInput;
  };

  export type BorrowerUncheckedUpdateWithoutLibraryBookInput = {
    id?: StringFieldUpdateOperationsInput | string;
    borrowedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    returnAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    status?: EnumBorrowStatusFieldUpdateOperationsInput | $Enums.BorrowStatus;
    userId?: StringFieldUpdateOperationsInput | string;
  };

  export type BorrowerUncheckedUpdateManyWithoutLibraryBookInput = {
    id?: StringFieldUpdateOperationsInput | string;
    borrowedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    returnAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    status?: EnumBorrowStatusFieldUpdateOperationsInput | $Enums.BorrowStatus;
    userId?: StringFieldUpdateOperationsInput | string;
  };

  export type LibraryBookCreateManyCategoryInput = {
    id?: string;
    title: string;
    author: string;
    assetId: string;
    quantity?: number | null;
    trackQuantity?: boolean;
    unit: $Enums.AssetUnit;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type LibraryBookUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    author?: StringFieldUpdateOperationsInput | string;
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null;
    trackQuantity?: BoolFieldUpdateOperationsInput | boolean;
    unit?: EnumAssetUnitFieldUpdateOperationsInput | $Enums.AssetUnit;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    individualBooks?: IndividualBookUpdateManyWithoutLibraryBookNestedInput;
    asset?: AssetUpdateOneRequiredWithoutLibraryBooksNestedInput;
  };

  export type LibraryBookUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    author?: StringFieldUpdateOperationsInput | string;
    assetId?: StringFieldUpdateOperationsInput | string;
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null;
    trackQuantity?: BoolFieldUpdateOperationsInput | boolean;
    unit?: EnumAssetUnitFieldUpdateOperationsInput | $Enums.AssetUnit;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    individualBooks?: IndividualBookUncheckedUpdateManyWithoutLibraryBookNestedInput;
  };

  export type LibraryBookUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    author?: StringFieldUpdateOperationsInput | string;
    assetId?: StringFieldUpdateOperationsInput | string;
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null;
    trackQuantity?: BoolFieldUpdateOperationsInput | boolean;
    unit?: EnumAssetUnitFieldUpdateOperationsInput | $Enums.AssetUnit;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type IndividualLabItemCreateManyLabItemInput = {
    id?: string;
    uniqueIdentifier?: string | null;
    status?: $Enums.AssetStatus;
    condition?: $Enums.AssetCondition;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type IndividualLabItemUpdateWithoutLabItemInput = {
    id?: StringFieldUpdateOperationsInput | string;
    uniqueIdentifier?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus;
    condition?:
      | EnumAssetConditionFieldUpdateOperationsInput
      | $Enums.AssetCondition;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    assetDamages?: AssetDamageUpdateManyWithoutIndividualLabItemNestedInput;
  };

  export type IndividualLabItemUncheckedUpdateWithoutLabItemInput = {
    id?: StringFieldUpdateOperationsInput | string;
    uniqueIdentifier?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus;
    condition?:
      | EnumAssetConditionFieldUpdateOperationsInput
      | $Enums.AssetCondition;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    assetDamages?: AssetDamageUncheckedUpdateManyWithoutIndividualLabItemNestedInput;
  };

  export type IndividualLabItemUncheckedUpdateManyWithoutLabItemInput = {
    id?: StringFieldUpdateOperationsInput | string;
    uniqueIdentifier?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus;
    condition?:
      | EnumAssetConditionFieldUpdateOperationsInput
      | $Enums.AssetCondition;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AssetDamageCreateManyIndividualLabItemInput = {
    id?: string;
    damageDetails: string;
    condition: $Enums.AssetCondition;
    quantity: number;
    userId?: string | null;
    individualComputerLabItemId?: string | null;
    isRepaired?: boolean;
    repairedAt?: Date | string | null;
    createdAt?: Date | string;
    individualBookId?: string | null;
    individualFoodStoreItemId?: string | null;
    individualGeneralStoreItemId?: string | null;
    isSchoolCost?: boolean;
    repairBalance?: number;
    repairPrice?: number | null;
  };

  export type AssetDamageUpdateWithoutIndividualLabItemInput = {
    id?: StringFieldUpdateOperationsInput | string;
    damageDetails?: StringFieldUpdateOperationsInput | string;
    condition?:
      | EnumAssetConditionFieldUpdateOperationsInput
      | $Enums.AssetCondition;
    quantity?: IntFieldUpdateOperationsInput | number;
    isRepaired?: BoolFieldUpdateOperationsInput | boolean;
    repairedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    isSchoolCost?: BoolFieldUpdateOperationsInput | boolean;
    repairBalance?: FloatFieldUpdateOperationsInput | number;
    repairPrice?: NullableFloatFieldUpdateOperationsInput | number | null;
    individualBook?: IndividualBookUpdateOneWithoutBookDamagesNestedInput;
    individualComputerLabItem?: IndividualComputerLabItemUpdateOneWithoutAssetDamagesNestedInput;
    individualFoodStoreItem?: IndividualFoodStoreItemUpdateOneWithoutAssetDamagesNestedInput;
    individualGeneralStoreItem?: IndividualGeneralStoreItemUpdateOneWithoutAssetDamagesNestedInput;
    damagedBy?: UserUpdateOneWithoutAssetDamagesNestedInput;
    assetRepairPayments?: AssetRepairPaymentUpdateManyWithoutAssetDamageNestedInput;
  };

  export type AssetDamageUncheckedUpdateWithoutIndividualLabItemInput = {
    id?: StringFieldUpdateOperationsInput | string;
    damageDetails?: StringFieldUpdateOperationsInput | string;
    condition?:
      | EnumAssetConditionFieldUpdateOperationsInput
      | $Enums.AssetCondition;
    quantity?: IntFieldUpdateOperationsInput | number;
    userId?: NullableStringFieldUpdateOperationsInput | string | null;
    individualComputerLabItemId?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    isRepaired?: BoolFieldUpdateOperationsInput | boolean;
    repairedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    individualBookId?: NullableStringFieldUpdateOperationsInput | string | null;
    individualFoodStoreItemId?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    individualGeneralStoreItemId?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    isSchoolCost?: BoolFieldUpdateOperationsInput | boolean;
    repairBalance?: FloatFieldUpdateOperationsInput | number;
    repairPrice?: NullableFloatFieldUpdateOperationsInput | number | null;
    assetRepairPayments?: AssetRepairPaymentUncheckedUpdateManyWithoutAssetDamageNestedInput;
  };

  export type AssetDamageUncheckedUpdateManyWithoutIndividualLabItemInput = {
    id?: StringFieldUpdateOperationsInput | string;
    damageDetails?: StringFieldUpdateOperationsInput | string;
    condition?:
      | EnumAssetConditionFieldUpdateOperationsInput
      | $Enums.AssetCondition;
    quantity?: IntFieldUpdateOperationsInput | number;
    userId?: NullableStringFieldUpdateOperationsInput | string | null;
    individualComputerLabItemId?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    isRepaired?: BoolFieldUpdateOperationsInput | boolean;
    repairedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    individualBookId?: NullableStringFieldUpdateOperationsInput | string | null;
    individualFoodStoreItemId?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    individualGeneralStoreItemId?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    isSchoolCost?: BoolFieldUpdateOperationsInput | boolean;
    repairBalance?: FloatFieldUpdateOperationsInput | number;
    repairPrice?: NullableFloatFieldUpdateOperationsInput | number | null;
  };

  export type IndividualComputerLabItemCreateManyComputerLabItemInput = {
    id?: string;
    uniqueIdentifier?: string | null;
    status?: $Enums.AssetStatus;
    condition?: $Enums.AssetCondition;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type IndividualComputerLabItemUpdateWithoutComputerLabItemInput = {
    id?: StringFieldUpdateOperationsInput | string;
    uniqueIdentifier?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus;
    condition?:
      | EnumAssetConditionFieldUpdateOperationsInput
      | $Enums.AssetCondition;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    assetDamages?: AssetDamageUpdateManyWithoutIndividualComputerLabItemNestedInput;
  };

  export type IndividualComputerLabItemUncheckedUpdateWithoutComputerLabItemInput =
    {
      id?: StringFieldUpdateOperationsInput | string;
      uniqueIdentifier?:
        | NullableStringFieldUpdateOperationsInput
        | string
        | null;
      status?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus;
      condition?:
        | EnumAssetConditionFieldUpdateOperationsInput
        | $Enums.AssetCondition;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      assetDamages?: AssetDamageUncheckedUpdateManyWithoutIndividualComputerLabItemNestedInput;
    };

  export type IndividualComputerLabItemUncheckedUpdateManyWithoutComputerLabItemInput =
    {
      id?: StringFieldUpdateOperationsInput | string;
      uniqueIdentifier?:
        | NullableStringFieldUpdateOperationsInput
        | string
        | null;
      status?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus;
      condition?:
        | EnumAssetConditionFieldUpdateOperationsInput
        | $Enums.AssetCondition;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    };

  export type AssetDamageCreateManyIndividualComputerLabItemInput = {
    id?: string;
    damageDetails: string;
    condition: $Enums.AssetCondition;
    quantity: number;
    userId?: string | null;
    isRepaired?: boolean;
    repairedAt?: Date | string | null;
    createdAt?: Date | string;
    individualBookId?: string | null;
    individualLabItemId?: string | null;
    individualFoodStoreItemId?: string | null;
    individualGeneralStoreItemId?: string | null;
    isSchoolCost?: boolean;
    repairBalance?: number;
    repairPrice?: number | null;
  };

  export type AssetDamageUpdateWithoutIndividualComputerLabItemInput = {
    id?: StringFieldUpdateOperationsInput | string;
    damageDetails?: StringFieldUpdateOperationsInput | string;
    condition?:
      | EnumAssetConditionFieldUpdateOperationsInput
      | $Enums.AssetCondition;
    quantity?: IntFieldUpdateOperationsInput | number;
    isRepaired?: BoolFieldUpdateOperationsInput | boolean;
    repairedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    isSchoolCost?: BoolFieldUpdateOperationsInput | boolean;
    repairBalance?: FloatFieldUpdateOperationsInput | number;
    repairPrice?: NullableFloatFieldUpdateOperationsInput | number | null;
    individualBook?: IndividualBookUpdateOneWithoutBookDamagesNestedInput;
    individualFoodStoreItem?: IndividualFoodStoreItemUpdateOneWithoutAssetDamagesNestedInput;
    individualGeneralStoreItem?: IndividualGeneralStoreItemUpdateOneWithoutAssetDamagesNestedInput;
    individualLabItem?: IndividualLabItemUpdateOneWithoutAssetDamagesNestedInput;
    damagedBy?: UserUpdateOneWithoutAssetDamagesNestedInput;
    assetRepairPayments?: AssetRepairPaymentUpdateManyWithoutAssetDamageNestedInput;
  };

  export type AssetDamageUncheckedUpdateWithoutIndividualComputerLabItemInput =
    {
      id?: StringFieldUpdateOperationsInput | string;
      damageDetails?: StringFieldUpdateOperationsInput | string;
      condition?:
        | EnumAssetConditionFieldUpdateOperationsInput
        | $Enums.AssetCondition;
      quantity?: IntFieldUpdateOperationsInput | number;
      userId?: NullableStringFieldUpdateOperationsInput | string | null;
      isRepaired?: BoolFieldUpdateOperationsInput | boolean;
      repairedAt?:
        | NullableDateTimeFieldUpdateOperationsInput
        | Date
        | string
        | null;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      individualBookId?:
        | NullableStringFieldUpdateOperationsInput
        | string
        | null;
      individualLabItemId?:
        | NullableStringFieldUpdateOperationsInput
        | string
        | null;
      individualFoodStoreItemId?:
        | NullableStringFieldUpdateOperationsInput
        | string
        | null;
      individualGeneralStoreItemId?:
        | NullableStringFieldUpdateOperationsInput
        | string
        | null;
      isSchoolCost?: BoolFieldUpdateOperationsInput | boolean;
      repairBalance?: FloatFieldUpdateOperationsInput | number;
      repairPrice?: NullableFloatFieldUpdateOperationsInput | number | null;
      assetRepairPayments?: AssetRepairPaymentUncheckedUpdateManyWithoutAssetDamageNestedInput;
    };

  export type AssetDamageUncheckedUpdateManyWithoutIndividualComputerLabItemInput =
    {
      id?: StringFieldUpdateOperationsInput | string;
      damageDetails?: StringFieldUpdateOperationsInput | string;
      condition?:
        | EnumAssetConditionFieldUpdateOperationsInput
        | $Enums.AssetCondition;
      quantity?: IntFieldUpdateOperationsInput | number;
      userId?: NullableStringFieldUpdateOperationsInput | string | null;
      isRepaired?: BoolFieldUpdateOperationsInput | boolean;
      repairedAt?:
        | NullableDateTimeFieldUpdateOperationsInput
        | Date
        | string
        | null;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      individualBookId?:
        | NullableStringFieldUpdateOperationsInput
        | string
        | null;
      individualLabItemId?:
        | NullableStringFieldUpdateOperationsInput
        | string
        | null;
      individualFoodStoreItemId?:
        | NullableStringFieldUpdateOperationsInput
        | string
        | null;
      individualGeneralStoreItemId?:
        | NullableStringFieldUpdateOperationsInput
        | string
        | null;
      isSchoolCost?: BoolFieldUpdateOperationsInput | boolean;
      repairBalance?: FloatFieldUpdateOperationsInput | number;
      repairPrice?: NullableFloatFieldUpdateOperationsInput | number | null;
    };

  export type IndividualGeneralStoreItemCreateManyGeneralStoreItemInput = {
    id?: string;
    uniqueIdentifier?: string | null;
    status?: $Enums.AssetStatus;
    condition?: $Enums.AssetCondition;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type IndividualGeneralStoreItemUpdateWithoutGeneralStoreItemInput = {
    id?: StringFieldUpdateOperationsInput | string;
    uniqueIdentifier?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus;
    condition?:
      | EnumAssetConditionFieldUpdateOperationsInput
      | $Enums.AssetCondition;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    assetDamages?: AssetDamageUpdateManyWithoutIndividualGeneralStoreItemNestedInput;
  };

  export type IndividualGeneralStoreItemUncheckedUpdateWithoutGeneralStoreItemInput =
    {
      id?: StringFieldUpdateOperationsInput | string;
      uniqueIdentifier?:
        | NullableStringFieldUpdateOperationsInput
        | string
        | null;
      status?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus;
      condition?:
        | EnumAssetConditionFieldUpdateOperationsInput
        | $Enums.AssetCondition;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      assetDamages?: AssetDamageUncheckedUpdateManyWithoutIndividualGeneralStoreItemNestedInput;
    };

  export type IndividualGeneralStoreItemUncheckedUpdateManyWithoutGeneralStoreItemInput =
    {
      id?: StringFieldUpdateOperationsInput | string;
      uniqueIdentifier?:
        | NullableStringFieldUpdateOperationsInput
        | string
        | null;
      status?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus;
      condition?:
        | EnumAssetConditionFieldUpdateOperationsInput
        | $Enums.AssetCondition;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    };

  export type AssetDamageCreateManyIndividualGeneralStoreItemInput = {
    id?: string;
    damageDetails: string;
    condition: $Enums.AssetCondition;
    quantity: number;
    userId?: string | null;
    individualComputerLabItemId?: string | null;
    isRepaired?: boolean;
    repairedAt?: Date | string | null;
    createdAt?: Date | string;
    individualBookId?: string | null;
    individualLabItemId?: string | null;
    individualFoodStoreItemId?: string | null;
    isSchoolCost?: boolean;
    repairBalance?: number;
    repairPrice?: number | null;
  };

  export type AssetDamageUpdateWithoutIndividualGeneralStoreItemInput = {
    id?: StringFieldUpdateOperationsInput | string;
    damageDetails?: StringFieldUpdateOperationsInput | string;
    condition?:
      | EnumAssetConditionFieldUpdateOperationsInput
      | $Enums.AssetCondition;
    quantity?: IntFieldUpdateOperationsInput | number;
    isRepaired?: BoolFieldUpdateOperationsInput | boolean;
    repairedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    isSchoolCost?: BoolFieldUpdateOperationsInput | boolean;
    repairBalance?: FloatFieldUpdateOperationsInput | number;
    repairPrice?: NullableFloatFieldUpdateOperationsInput | number | null;
    individualBook?: IndividualBookUpdateOneWithoutBookDamagesNestedInput;
    individualComputerLabItem?: IndividualComputerLabItemUpdateOneWithoutAssetDamagesNestedInput;
    individualFoodStoreItem?: IndividualFoodStoreItemUpdateOneWithoutAssetDamagesNestedInput;
    individualLabItem?: IndividualLabItemUpdateOneWithoutAssetDamagesNestedInput;
    damagedBy?: UserUpdateOneWithoutAssetDamagesNestedInput;
    assetRepairPayments?: AssetRepairPaymentUpdateManyWithoutAssetDamageNestedInput;
  };

  export type AssetDamageUncheckedUpdateWithoutIndividualGeneralStoreItemInput =
    {
      id?: StringFieldUpdateOperationsInput | string;
      damageDetails?: StringFieldUpdateOperationsInput | string;
      condition?:
        | EnumAssetConditionFieldUpdateOperationsInput
        | $Enums.AssetCondition;
      quantity?: IntFieldUpdateOperationsInput | number;
      userId?: NullableStringFieldUpdateOperationsInput | string | null;
      individualComputerLabItemId?:
        | NullableStringFieldUpdateOperationsInput
        | string
        | null;
      isRepaired?: BoolFieldUpdateOperationsInput | boolean;
      repairedAt?:
        | NullableDateTimeFieldUpdateOperationsInput
        | Date
        | string
        | null;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      individualBookId?:
        | NullableStringFieldUpdateOperationsInput
        | string
        | null;
      individualLabItemId?:
        | NullableStringFieldUpdateOperationsInput
        | string
        | null;
      individualFoodStoreItemId?:
        | NullableStringFieldUpdateOperationsInput
        | string
        | null;
      isSchoolCost?: BoolFieldUpdateOperationsInput | boolean;
      repairBalance?: FloatFieldUpdateOperationsInput | number;
      repairPrice?: NullableFloatFieldUpdateOperationsInput | number | null;
      assetRepairPayments?: AssetRepairPaymentUncheckedUpdateManyWithoutAssetDamageNestedInput;
    };

  export type AssetDamageUncheckedUpdateManyWithoutIndividualGeneralStoreItemInput =
    {
      id?: StringFieldUpdateOperationsInput | string;
      damageDetails?: StringFieldUpdateOperationsInput | string;
      condition?:
        | EnumAssetConditionFieldUpdateOperationsInput
        | $Enums.AssetCondition;
      quantity?: IntFieldUpdateOperationsInput | number;
      userId?: NullableStringFieldUpdateOperationsInput | string | null;
      individualComputerLabItemId?:
        | NullableStringFieldUpdateOperationsInput
        | string
        | null;
      isRepaired?: BoolFieldUpdateOperationsInput | boolean;
      repairedAt?:
        | NullableDateTimeFieldUpdateOperationsInput
        | Date
        | string
        | null;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      individualBookId?:
        | NullableStringFieldUpdateOperationsInput
        | string
        | null;
      individualLabItemId?:
        | NullableStringFieldUpdateOperationsInput
        | string
        | null;
      individualFoodStoreItemId?:
        | NullableStringFieldUpdateOperationsInput
        | string
        | null;
      isSchoolCost?: BoolFieldUpdateOperationsInput | boolean;
      repairBalance?: FloatFieldUpdateOperationsInput | number;
      repairPrice?: NullableFloatFieldUpdateOperationsInput | number | null;
    };

  export type AssetRepairPaymentCreateManyAssetDamageInput = {
    id?: string;
    paidAmount: number;
    paidAt?: Date | string;
    updatedAt?: Date | string;
    userId?: string | null;
    isSchoolCost?: boolean;
  };

  export type AssetRepairPaymentUpdateWithoutAssetDamageInput = {
    id?: StringFieldUpdateOperationsInput | string;
    paidAmount?: FloatFieldUpdateOperationsInput | number;
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    isSchoolCost?: BoolFieldUpdateOperationsInput | boolean;
    receivedBy?: UserUpdateOneWithoutAssetRepairPaymentsNestedInput;
  };

  export type AssetRepairPaymentUncheckedUpdateWithoutAssetDamageInput = {
    id?: StringFieldUpdateOperationsInput | string;
    paidAmount?: FloatFieldUpdateOperationsInput | number;
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    userId?: NullableStringFieldUpdateOperationsInput | string | null;
    isSchoolCost?: BoolFieldUpdateOperationsInput | boolean;
  };

  export type AssetRepairPaymentUncheckedUpdateManyWithoutAssetDamageInput = {
    id?: StringFieldUpdateOperationsInput | string;
    paidAmount?: FloatFieldUpdateOperationsInput | number;
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    userId?: NullableStringFieldUpdateOperationsInput | string | null;
    isSchoolCost?: BoolFieldUpdateOperationsInput | boolean;
  };

  export type ExamSubjectCreateManyExamInput = {
    id?: string;
    examDate: Date | string;
    academicYearSubjectId: string;
  };

  export type ExamSubjectUpdateWithoutExamInput = {
    id?: StringFieldUpdateOperationsInput | string;
    examDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    academicYearSubject?: AcademicYearSubjectUpdateOneRequiredWithoutExamSubjectsNestedInput;
    examScores?: ExamScoreUpdateManyWithoutExamSubjectNestedInput;
  };

  export type ExamSubjectUncheckedUpdateWithoutExamInput = {
    id?: StringFieldUpdateOperationsInput | string;
    examDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    academicYearSubjectId?: StringFieldUpdateOperationsInput | string;
    examScores?: ExamScoreUncheckedUpdateManyWithoutExamSubjectNestedInput;
  };

  export type ExamSubjectUncheckedUpdateManyWithoutExamInput = {
    id?: StringFieldUpdateOperationsInput | string;
    examDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    academicYearSubjectId?: StringFieldUpdateOperationsInput | string;
  };

  export type ExamScoreCreateManyExamSubjectInput = {
    id?: string;
    score: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    pupilId: string;
  };

  export type ExamScoreUpdateWithoutExamSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string;
    score?: FloatFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    pupil?: PupilUpdateOneRequiredWithoutExamScoresNestedInput;
  };

  export type ExamScoreUncheckedUpdateWithoutExamSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string;
    score?: FloatFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    pupilId?: StringFieldUpdateOperationsInput | string;
  };

  export type ExamScoreUncheckedUpdateManyWithoutExamSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string;
    score?: FloatFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    pupilId?: StringFieldUpdateOperationsInput | string;
  };

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number;
  };

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF;
}
